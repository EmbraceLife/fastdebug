<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.1.189">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>fastdebug – core</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>


<link rel="stylesheet" href="../styles.css">
</head>

<body class="nav-sidebar floating nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">fastdebug</span>
    </a>
  </div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/EmbraceLife/fastdebug"><i class="bi bi-github" role="img">
</i> 
 </a>
  </li>  
</ul>
              <div id="quarto-search" class="" title="Search"></div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
    <div class="container-fluid d-flex justify-content-between">
      <h1 class="quarto-secondary-nav-title">(Untitled)</h1>
      <button type="button" class="quarto-btn-toggle btn" aria-label="Show secondary navigation">
        <i class="bi bi-chevron-right"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse sidebar-navigation floating overflow-auto">
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../index.html" class="sidebar-item-text sidebar-link">fastdebug</a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../core.html" class="sidebar-item-text sidebar-link">core</a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../FixSigMeta.html" class="sidebar-item-text sidebar-link">FixSigMeta</a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../utils.html" class="sidebar-item-text sidebar-link">Utils</a>
  </div>
</li>
    </ul>
    </div>
</nav>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#autogenerated-do-not-edit-file-to-edit-..00_core.ipynb." id="toc-autogenerated-do-not-edit-file-to-edit-..00_core.ipynb." class="nav-link active" data-scroll-target="#autogenerated-do-not-edit-file-to-edit-..00_core.ipynb.">AUTOGENERATED! DO NOT EDIT! File to edit: ../00_core.ipynb.</a></li>
  <li><a href="#auto-0" id="toc-auto-0" class="nav-link" data-scroll-target="#auto-0">%% auto 0</a></li>
  <li><a href="#core.ipynb-4" id="toc-core.ipynb-4" class="nav-link" data-scroll-target="#core.ipynb-4">%% ../00_core.ipynb 4</a></li>
  <li><a href="#core.ipynb-19" id="toc-core.ipynb-19" class="nav-link" data-scroll-target="#core.ipynb-19">%% ../00_core.ipynb 19</a></li>
  <li><a href="#core.ipynb-30" id="toc-core.ipynb-30" class="nav-link" data-scroll-target="#core.ipynb-30">%% ../00_core.ipynb 30</a></li>
  <li><a href="#core.ipynb-49" id="toc-core.ipynb-49" class="nav-link" data-scroll-target="#core.ipynb-49">%% ../00_core.ipynb 49</a></li>
  <li><a href="#core.ipynb-50" id="toc-core.ipynb-50" class="nav-link" data-scroll-target="#core.ipynb-50">%% ../00_core.ipynb 50</a></li>
  <li><a href="#core.ipynb-51" id="toc-core.ipynb-51" class="nav-link" data-scroll-target="#core.ipynb-51">%% ../00_core.ipynb 51</a></li>
  <li><a href="#core.ipynb-55" id="toc-core.ipynb-55" class="nav-link" data-scroll-target="#core.ipynb-55">%% ../00_core.ipynb 55</a></li>
  <li><a href="#core.ipynb-56" id="toc-core.ipynb-56" class="nav-link" data-scroll-target="#core.ipynb-56">%% ../00_core.ipynb 56</a></li>
  <li><a href="#core.ipynb-58" id="toc-core.ipynb-58" class="nav-link" data-scroll-target="#core.ipynb-58">%% ../00_core.ipynb 58</a></li>
  <li><a href="#core.ipynb-67" id="toc-core.ipynb-67" class="nav-link" data-scroll-target="#core.ipynb-67">%% ../00_core.ipynb 67</a></li>
  <li><a href="#core.ipynb-73" id="toc-core.ipynb-73" class="nav-link" data-scroll-target="#core.ipynb-73">%% ../00_core.ipynb 73</a></li>
  <li><a href="#core.ipynb-88" id="toc-core.ipynb-88" class="nav-link" data-scroll-target="#core.ipynb-88">%% ../00_core.ipynb 88</a></li>
  <li><a href="#core.ipynb-95" id="toc-core.ipynb-95" class="nav-link" data-scroll-target="#core.ipynb-95">%% ../00_core.ipynb 95</a></li>
  <li><a href="#core.ipynb-128" id="toc-core.ipynb-128" class="nav-link" data-scroll-target="#core.ipynb-128">%% ../00_core.ipynb 128</a></li>
  <li><a href="#core.ipynb-147" id="toc-core.ipynb-147" class="nav-link" data-scroll-target="#core.ipynb-147">%% ../00_core.ipynb 147</a></li>
  <li><a href="#core.ipynb-148" id="toc-core.ipynb-148" class="nav-link" data-scroll-target="#core.ipynb-148">%% ../00_core.ipynb 148</a></li>
  <li><a href="#core.ipynb-204" id="toc-core.ipynb-204" class="nav-link" data-scroll-target="#core.ipynb-204">%% ../00_core.ipynb 204</a></li>
  <li><a href="#core.ipynb-218" id="toc-core.ipynb-218" class="nav-link" data-scroll-target="#core.ipynb-218">%% ../00_core.ipynb 218</a></li>
  <li><a href="#core.ipynb-246" id="toc-core.ipynb-246" class="nav-link" data-scroll-target="#core.ipynb-246">%% ../00_core.ipynb 246</a></li>
  <li><a href="#core.ipynb-247" id="toc-core.ipynb-247" class="nav-link" data-scroll-target="#core.ipynb-247">%% ../00_core.ipynb 247</a></li>
  <li><a href="#core.ipynb-248" id="toc-core.ipynb-248" class="nav-link" data-scroll-target="#core.ipynb-248">%% ../00_core.ipynb 248</a></li>
  </ul>
<div class="toc-actions"><div><i class="bi bi-github"></i></div><div class="action-links"><p><a href="https://github.com/EmbraceLife/fastdebug/issues/new" class="toc-action">Report an issue</a></p></div></div></nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">



<section id="autogenerated-do-not-edit-file-to-edit-..00_core.ipynb." class="level1">
<h1>AUTOGENERATED! DO NOT EDIT! File to edit: ../00_core.ipynb.</h1>
</section>
<section id="auto-0" class="level1">
<h1>%% auto 0</h1>
<p><strong>all</strong> = [‘defaults’, ‘dbcolors’, ‘colorize’, ‘strip_ansi’, ‘alignright’, ‘printsrcwithidx’, ‘printsrclinewithidx’, ‘printsrc’, ‘dbprint’, ‘dbprintinsert’, ‘printrunsrclines’, ‘Fastdb’]</p>
</section>
<section id="core.ipynb-4" class="level1">
<h1>%% ../00_core.ipynb 4</h1>
<p>defaults = type(‘defaults’, (object,), {‘margin’: 157, # align to the right by 157 ‘orisrc’: None, # keep a copy of original official src code ‘outenv’: globals(), # outside global env ‘cmts’: {} # a dict to store idx and cmt # ‘eg’: None, # examples # ‘src’: None, # official src })</p>
</section>
<section id="core.ipynb-19" class="level1">
<h1>%% ../00_core.ipynb 19</h1>
<p>from pprint import pprint</p>
</section>
<section id="core.ipynb-30" class="level1">
<h1>%% ../00_core.ipynb 30</h1>
<p>import inspect</p>
</section>
<section id="core.ipynb-49" class="level1">
<h1>%% ../00_core.ipynb 49</h1>
<p>from fastcore.basics import *</p>
</section>
<section id="core.ipynb-50" class="level1">
<h1>%% ../00_core.ipynb 50</h1>
<p>class dbcolors: g = ‘\033[92m’ #GREEN y = ‘\033[93m’ #YELLOW r = ‘\033[91m’ #RED reset = ‘\033[0m’ #RESET COLOR</p>
</section>
<section id="core.ipynb-51" class="level1">
<h1>%% ../00_core.ipynb 51</h1>
<p>def colorize(cmt, color:str=None): if color == “g”: return dbcolors.g + cmt + dbcolors.reset elif color == “y”: return dbcolors.y + cmt + dbcolors.reset elif color == “r”: return dbcolors.r + cmt + dbcolors.reset else: return cmt</p>
</section>
<section id="core.ipynb-55" class="level1">
<h1>%% ../00_core.ipynb 55</h1>
<p>import re</p>
</section>
<section id="core.ipynb-56" class="level1">
<h1>%% ../00_core.ipynb 56</h1>
<p>def strip_ansi(source): return re.sub(r’\033[(;)+?m’, ’’, source)</p>
</section>
<section id="core.ipynb-58" class="level1">
<h1>%% ../00_core.ipynb 58</h1>
<p>def alignright(blocks, margin:int=157): lst = blocks.split(‘’) maxlen = max(map(lambda l : len(strip_ansi(l)) , lst )) indent = margin - maxlen for l in lst: print(’ ’*indent + format(l))</p>
</section>
<section id="core.ipynb-67" class="level1">
<h1>%% ../00_core.ipynb 67</h1>
<p>def printsrcwithidx(src, maxlines:int=33, # maximum num of lines per page part:int=0): # if the src is more than 33 lines, then divide the src by 33 into a few parts totallen = 157 lenidx = 5 lspace = 10 lstsrc = inspect.getsource(src).split(‘’) numparts = len(lstsrc) // 33 + 1 if len(lstsrc) % 33 != 0 else len(lstsrc) // 33 # cmts = {5:“this is me”, 111:“this is me”, 14:“this is you this is you this is you this is you this is you this is you this is you this is you”} cmts = defaults.cmts if part == 0: for idx, l in zip(range(len(lstsrc)), lstsrc): lenl = len(l)</p>
<pre><code>        if not bool(l.strip()):
            print(l + " "*(totallen-lenl-lenidx) + "(" + str(idx) + ")")

        elif lenl + lspace &gt;= 100:
            if bool(cmts):
                cmtidx = [cmt[0] for cmt in list(cmts.items())]
                if idx in cmtidx:
                    print(l + " # " + cmts[idx] + " "*(totallen-lenl-lenidx-len(cmts[idx])-3) + "(" + str(idx) + ")")
                else:
                    print(l + " "*(totallen-lenl-lenidx) + "(" + str(idx) + ")")
            else: 
                print(l + " "*(totallen-lenl-lenidx) + "(" + str(idx) + ")")

        else:


            if bool(cmts):
                cmtidx = [cmt[0] for cmt in list(cmts.items())]
                if idx in cmtidx:
                    print('{:&lt;100}'.format(l + "="*(100-lenl-lspace) + f"({idx})" + " # " + cmts[idx]))
                else:
                    print('{:&lt;100}'.format(l + "="*(100-lenl-lspace) + f"({idx})"))                                                      

            else:
                print('{:&lt;100}'.format(l + "="*(100-lenl-lspace) + f"({idx})"))                 

for p in range(numparts):
    for idx, l in zip(range(len(lstsrc)), lstsrc):

        if (maxlines*p &lt;= idx &lt; maxlines*(p+1) and p+1 == part):
            lenl = len(l)
            if not bool(l.strip()):
                print(l + " "*(totallen-lenl-lenidx) + "(" + str(idx) + ")")
            elif lenl + lspace &gt;= 100:
                if bool(cmts):
                    cmtidx = [cmt[0] for cmt in list(cmts.items())]
                    if idx in cmtidx:
                        print(l + " # " + cmts[idx] + " "*(totallen-lenl-lenidx-len(cmts[idx])-3) + "(" + str(idx) + ")")
                    else:
                        print(l + " "*(totallen-lenl-lenidx) + "(" + str(idx) + ")")
                else: 
                    print(l + " "*(totallen-lenl-lenidx) + "(" + str(idx) + ")")


            else:

                if bool(cmts):
                    cmtidx = [cmt[0] for cmt in list(cmts.items())]
                    if idx in cmtidx:
                        print('{:&lt;100}'.format(l + "="*(100-lenl-lspace) + f"({idx})" + " # " + cmts[idx]))
                    else:
                        print('{:&lt;100}'.format(l + "="*(100-lenl-lspace) + f"({idx})"))                                                          

                else:
                    print('{:&lt;100}'.format(l + "="*(100-lenl-lspace) + f"({idx})"))                      

        if (idx == maxlines*(p+1) or idx == len(lstsrc) - 1) and p+1 == part:
            print('{:&gt;157}'.format(f"part No.{p+1} out of {numparts} parts"))
            return</code></pre>
</section>
<section id="core.ipynb-73" class="level1">
<h1>%% ../00_core.ipynb 73</h1>
<p>import inspect</p>
</section>
<section id="core.ipynb-88" class="level1">
<h1>%% ../00_core.ipynb 88</h1>
<p>def printsrclinewithidx(idx, l, fill=” “): totallen = 157 lenidx = 5 lenl = len(l) print(l + fill*(totallen-lenl-lenidx) + “(” + str(idx) + “)”)</p>
</section>
<section id="core.ipynb-95" class="level1">
<h1>%% ../00_core.ipynb 95</h1>
<p>def printsrc(src, # name of src code such as foo, or delegates dbcode, # string of codes or int of code idx number cmt, expand:int=2): # expand the codes around the srcline under investigation</p>
<pre><code>lstsrc = inspect.getsource(src).split('\n')

dblines = ""
if type(dbcode) == int:
    dblines = lstsrc[dbcode]
else:
    dblines = dbcode
    numdblines = list(map(lambda x: bool(x.strip()), dblines.split('\n'))).count(True)


dblineidx = []
for idx, l in zip(range(len(lstsrc)), lstsrc):
    if bool(l) and l.strip() in dblines:
        dblineidx.append(idx)

for idx, l in zip(range(len(lstsrc)), lstsrc):
    
    srcidx = dbcode if type(dbcode) == int else dblineidx[0]
    
    if bool(l) and l.strip() in dblines and idx == srcidx:
        printsrclinewithidx(idx, l, fill="=")

        if bool(cmt):
            colcmt = colorize(cmt, "r")
            alignright(colcmt) # also print the comment

    if idx &gt;= srcidx - expand and idx &lt; srcidx:
        printsrclinewithidx(idx, l)
    elif idx &lt;= srcidx + expand and idx &gt; srcidx:
        printsrclinewithidx(idx, l)</code></pre>
</section>
<section id="core.ipynb-128" class="level1">
<h1>%% ../00_core.ipynb 128</h1>
<p>def dbprint(src, # the src func name, e.g., foo dbcode, # the srclines under investigation, can be either string or int cmt:str, # comment *codes, # a list of dbcodes expand:int=2, # span 2 lines of srcode up and down from the srcline investigated env={}, # out environment showdbsrc=False): # print out dbsrc or not “Insert dbcodes under srclines under investigation, and create a new dbsrc function to replace the official one”</p>
<pre><code># make sure the original official src is kept safe and used whenever dbprint is used
if defaults.orisrc == None:
    defaults.orisrc = src
else: 
    src = defaults.orisrc
    
if type(dbcode) == int: defaults.cmts.update({dbcode: cmt})

printsrc(src, dbcode, cmt, expand)

dbsrc = ""
indent = 4
onedbprint = False

lst = inspect.getsource(src).split('\n')
if not bool(lst[-1]): lst = lst[:-1]

srclines = ""
if type(dbcode) == int:
    srclines = lst[dbcode]
else:
    srclines = dbcode

for idx, l in zip(range(len(lst)), lst):
    # make sure the line with correct idx is debugged
    if bool(l.strip()) and l.strip() in srclines and idx == dbcode: 

        numindent = len(l) - len(l.strip())
        dbcodes = "dbprintinsert("
        count = 1
        for c in codes:
            if count == len(codes):
                dbcodes = dbcodes + '"' + c + '"' + "," + "env=g" + ")"
            else:
                dbcodes = dbcodes + '"' + c + '"' + ","
            count = count + 1

        dbsrc = dbsrc + " "*numindent + "g = locals()" + '\n'
        dbsrc = dbsrc + " "*numindent + dbcodes + '\n'
        dbsrc = dbsrc + l + '\n'  

    elif bool(l.strip()) and idx + 1 == len(lst):
        dbsrc = dbsrc + l

    elif bool(l.strip()): # make sure pure indentation + \n is ignored
        dbsrc = dbsrc + l + '\n'


if showdbsrc: # added to debug
    for l in dbsrc.split('\n'):
        print(l)

exec(dbsrc, globals().update(env)) # make sure b can access lst from above

env.update(locals())

return locals()[defaults.orisrc.__name__]</code></pre>
</section>
<section id="core.ipynb-147" class="level1">
<h1>%% ../00_core.ipynb 147</h1>
<p>import ast</p>
</section>
<section id="core.ipynb-148" class="level1">
<h1>%% ../00_core.ipynb 148</h1>
<p>def dbprintinsert(*codes, env={}):</p>
<pre><code># trial and error version for real code, still not quite why globals vs locals work in exec and eval
for c in codes:
    print("\n")
    
    # handle a block of code
    if "\n" in c: 
        output = f"Running your code block =&gt; "
        print('{:&lt;157}'.format(c))       
        print('{:&gt;157}'.format(output))  
        print('The code block printout =&gt; : ')
        block = ast.parse(c, mode='exec')
        exec(compile(block, '&lt;string&gt;', mode='exec'), globals().update(env))
    
    # handle assignment: 2. when = occur before if; 1. when no if only =
    elif ("=" in c and "if" not in c) or ("=" in c and c.find("=") &lt; c.find("if")): # make sure assignment and !== and == are differentiated
        
        # print('k' in locals())
        exec(c, globals().update(env)) 
        # print('k' in locals())
        variable = c.partition(" = ")[0]
        # print(f"{c} =&gt; {variable}: {eval(variable)}")
        output = f"{c} =&gt; {variable}: {eval(variable)}"
        print('{:&gt;157}'.format(output))       
        
    # handle if statement
    # Note: do insert code like this : `if abc == def: print(abc)`, print is a must
    elif "if" in c: 
        cond = re.search('if (.*?):', c).group(1)
        
        # when code in string is like 'if abc == def:'
        if c.endswith(':'):
            
            # print ... 
            # print(f"{c} =&gt; {cond}: {eval(cond)}")      
            output = f"{c} =&gt; {cond}: {eval(cond)}"
            print('{:&gt;157}'.format(output))
            
        # when code in string is like 'if abc == def: print(...)'
        else: 
            # if the cond is true, then print ...
            if eval(cond):
                
                # "if abc == def: print(abc)".split(': ', 2)[1] to get 'print(abc)'
                printc = c.split(': ', 1)[1]
                # print(f"{c} =&gt; {printc} : ")
                output = f"{c} =&gt; {printc} : "
                print('{:&gt;157}'.format(output))      
                exec(c, globals().update(env))
                
            # if cond is false, then print ...
            else: 
                # print(f"{c} =&gt; {cond}: {eval(cond)}")
                output = f"{c} =&gt; {cond}: {eval(cond)}"
                print('{:&gt;157}'.format(output))   
            
            
    # handle for in statement
    elif "for " in c and " in " in c:           
        
        # in example like 'for k, v in abc:' or `for k, v in abc: print(...)`, if abc is empty
        # step 1: access abc
        # get the substring between 'in ' and ':', which is like 'abc'
        abc = re.search('in (.*?):', c).group(1)
        # if abc is empty dict or list: print and pass
        if not bool(eval(abc)): 
            # print(f'{c} =&gt; {abc} is an emtpy {type(eval(abc))}')
            output = f'{c} =&gt; {abc} is an emtpy {type(eval(abc))}'
            print('{:&gt;157}'.format(output))   
            continue 
            # The break statement can be used if you need to break out of a for or while loop and move onto the next section of code.
            # The continue statement can be used if you need to skip the current iteration of a for or while loop and move onto the next iteration.
        
        # if the code in string is like 'for k, v in abc:', there is no more code after `:`
        if c.endswith(':'):
            
            # get the substring between 'for ' and ' in', which is like 'k, v'
            variables = re.search('for (.*?) in', c).group(1)
            
            # if variables has a substring like ', ' inside
            if (',') in variables: 
                
                # split it by ', ' into a list of substrings
                vl = variables.split(',')
                key = vl[0]
                value = vl[1]
                
                # make sure key and value will get evaluated first before exec run
                # printc is for exec to run
                printc = "print(f'{key}:{eval(key)}, {type(eval(key))} ; {value}:{eval(value)}, {type(eval(value))}')" 
                # printmsg is for reader to understand with ease
                printmsg = "print(f'key: {key}, {type(key)} ; value: {value}, {type(value)}')"
                c1 = c + " " + printc
                # print(f"{c} =&gt; {printmsg} : ")      
                output = f"{c} =&gt; {printmsg} : "
                print('{:&gt;157}'.format(output))   
                exec(c1, globals().update(env))
            
            else:
                printc = "print(f'{variables} : {eval(variables)}')"
                printmsg = "print(f'i : {variables}')"
                c1 = c + " " + printc
                # print(f"{c} =&gt; {printmsg} : ")     
                output = f"{c} =&gt; {printmsg} : "
                print('{:&gt;157}'.format(output))   
                exec(c1, globals().update(env))
                
        # if the code in string is like 'for k, v in abc: print(abc)'
        else:                 
            # "for k, v in abc: print(k)".split(': ', 1)[1] to get 'print(k)'
            printc = c.split(': ', 1)[1]
            # print(f"{c} =&gt; {printc} : ")
            output = f"{c} =&gt; {printc} : "
            print('{:&gt;157}'.format(output))   
            exec(c, globals().update(env)) # we can't use eval to run `for in` loop, but exec can.
        ### Note: we shall not use the expression like `for k, v in abc print(abc)`
        ### Note: we shall not use the expression like `for k, v in abc if k == def`
    
    
    # handle evaluation
    else: 
        # print(f"{c} =&gt; {c} : {eval(c, globals().update(env))}") 
        output = f"{c} =&gt; {c} : {eval(c, globals().update(env))}"
        print('{:&gt;157}'.format(output))   
        
    # the benefit of using global().update(env) is 
    # to ensure we don't need to include the same env fo</code></pre>
</section>
<section id="core.ipynb-204" class="level1">
<h1>%% ../00_core.ipynb 204</h1>
<p>def printrunsrclines(func, example): srclines = inspect.getsource(func).split(‘’) dbsrc = “” indent = 4</p>
<pre><code>for idx, l in zip(range(len(srclines)), srclines):
    numindent = len(l) - len(l.strip())
    addline = f"srcidx.append({idx})"

    if "if" in l or "else" in l or "for" in l or "def" in l:
        numindent = numindent + indent

    if bool(l) and not l.strip().startswith('#') and not (l.strip().startswith('"') and l.strip().endswith('"')): # ignore/remove pure quotations or docs
        dbsrc = dbsrc + l + "\n" + " "*numindent + addline + "\n"  # add srcidx.append(idx) to each line

pprint(dbsrc)
srcidx = [] 
exec(dbsrc, globals().update(locals()))    
exec(example) # now we can use foo as the new foo 
print(srcidx)

for idx, l in zip(range(len(srclines)), srclines):
    if idx in srcidx or "for" in l or "if" in l or "else" in l:
        print(l)</code></pre>
</section>
<section id="core.ipynb-218" class="level1">
<h1>%% ../00_core.ipynb 218</h1>
<p>def printrunsrclines(src, example, env): srclst = inspect.getsource(src).split(‘’) dbsrc = “” indent = 4 bracketidx = [] bracketindent = 0 ifelseidx = [] ifelseindent = 0</p>
<pre><code>for idx, l in zip(range(len(srclst)), srclst):
    numindent = len(l) - len(l.strip()) # how to strip only the left not the right?????
    addline = f"srcidx.append({idx})"

    if ("if " in l and l.strip().endswith(':')) or l.strip().endswith("else:") or ("elif " in l and l.strip().endswith(':')) \
    or  (l.strip().endswith(':') and "for " in l) or ("def " in l and l.strip().endswith(':')):
        numindent = numindent + indent



    if l.strip().startswith('"""'):
        dbsrc = dbsrc + l + '\n'
    elif srclst[idx - 1].strip().startswith('"""') and '"""' not in l.strip():
        dbsrc = dbsrc + l + '\n'
    elif idx &lt;= len(srclst) - 2 and srclst[idx + 1].strip().startswith('"""') and '"""' not in l.strip():
        dbsrc = dbsrc + l + '\n'
        
    elif "{" in l and "}" not in l:
        bracketidx.append(idx)
        bracketindent = len(l) - len(l.strip())
        dbsrc = dbsrc + l + '\n'
    elif "}" in l and "{" not in l: 
        bracketidx.append(idx)
        addup = ""
        for i in bracketidx:
            line = f"srcidx.append({i})"
            addup = addup + " "*bracketindent + line + "\n"
        dbsrc = dbsrc + l + "\n" + addup
        
    elif (l.strip().startswith("if") or l.strip().startswith("elif")) and ":" in l and not l.strip().endswith(":") and ": #" not in l \
    and ("elif" in srclst[idx + 1] or "else" in srclst[idx + 1]):
        ifelseidx.append(idx)
        ifelseindent = len(l) - len(l.strip())
        dbsrc = dbsrc + l + '\n'
    elif l.strip().startswith("else") and ":" in l and not l.strip().endswith(":") and ": #" not in l:
        ifelseidx.append(idx)
        addup = ""
        for i in ifelseidx:
            line = f"srcidx.append({i})"
            addup = addup + " "*ifelseindent + line + "\n"
        dbsrc = dbsrc + l + "\n" + addup            
        
        
    elif bool(l.strip()) and not l.strip().startswith('#') \
    and not (l.strip().startswith('"') and l.strip().endswith('"')) \
    and not (l.strip().endswith(',') or ', #' in l or '): #' in l): 
        dbsrc = dbsrc + l + "\n" + " "*numindent + addline + "\n"  # add srcidx.append(idx) to each line
    else: 
        dbsrc = dbsrc + l + '\n'            

pprint(dbsrc, width=157)
srcidx = [] 
exec(dbsrc, globals().update(env), locals())    
exec(example) # now we can use foo as the new foo 
print(srcidx)

# pprint(srclines)
for idx, l in zip(range(len(srclst)), srclst):
    if idx in srcidx or "for" in l or "if" in l or "else" in l:
        print(l)</code></pre>
</section>
<section id="core.ipynb-246" class="level1">
<h1>%% ../00_core.ipynb 246</h1>
<p>class Fastdb(): “Create a Fastdebug class which has two functionalities: dbprint and print.” def <strong>init</strong>(self, src, # name of src code you are exploring env): # env variables needed for exploring the source code, e.g., g = globals() self.orisrc = src self.margin = 157 self.outenv = env self.cmts = {}</p>
</section>
<section id="core.ipynb-247" class="level1">
<h1>%% ../00_core.ipynb 247</h1>
<p><span class="citation" data-cites="patch">@patch</span> def dbprint(self:Fastdb, dbcode:int, # a srcline under investigation, can be either string or int cmt:str, # comment added to the srcline *codes, # a list of expressions (str) you write to be evaluated above the srcline expand:int=2, # span 2 lines of srcode up and down from the srcline investigated showdbsrc:bool=False): # display dbsrc “Add comment and evaluate custom (single or multi lines) expressions to any srcline of the source code you are investigating”</p>
<pre><code>src = self.orisrc
if type(dbcode) == int: self.cmts.update({dbcode: cmt})

printsrc(src, dbcode, cmt, expand)

dbsrc = ""
indent = 4
onedbprint = False

lst = inspect.getsource(src).split('\n')
if not bool(lst[-1]): lst = lst[:-1]

newlst = []
for i in codes: # no matter whether there is "" or "  " in the front or in the middle of codes
    if bool(i.strip()): newlst.append(i)
codes = newlst

srclines = ""
if type(dbcode) == int:
    srclines = lst[dbcode]
else:
    srclines = dbcode

for idx, l in zip(range(len(lst)), lst):

    if bool(l.strip()) and l.strip() in srclines and idx == dbcode: 

        if len(codes) &gt; 0: # if the new codes is not empty
            numindent = len(l) - len(l.strip())
            dbcodes = "dbprintinsert("
            count = 1
            for c in codes:
                if count == len(codes):
                    dbcodes = dbcodes + '"' + c + '"' + "," + "env=g" + ")"
                else:
                    dbcodes = dbcodes + '"' + c + '"' + ","
                count = count + 1

            dbsrc = dbsrc + " "*numindent + "g = locals()" + '\n'
            dbsrc = dbsrc + " "*numindent + dbcodes + '\n'
            dbsrc = dbsrc + l + '\n'     
        else:
            dbsrc = dbsrc + l + '\n'                

    elif bool(l.strip()) and idx + 1 == len(lst):
        dbsrc = dbsrc + l

    elif bool(l.strip()): # make sure pure indentation + \n is ignored
        dbsrc = dbsrc + l + '\n'

if showdbsrc: # added to debug
    totallen = 157
    lenidx = 5
    dblst = dbsrc.split('\n')
    for idx, l in zip(range(len(dblst)), dblst):
        lenl = len(l)
        if "dbprintinsert" in l: 
            print(l + "="*(totallen-lenl-lenidx) + "(db)")
        else:
            print(l + " "*(totallen-lenl-lenidx) + "(" + str(idx) + ")")

exec(dbsrc, globals().update(self.outenv)) # make sure b can access lst from above

return locals()[self.orisrc.__name__]</code></pre>
</section>
<section id="core.ipynb-248" class="level1">
<h1>%% ../00_core.ipynb 248</h1>
<p><span class="citation" data-cites="patch">@patch</span> def print(self:Fastdb, maxlines:int=33, # maximum num of lines per page part:int=0): # if the src is more than 33 lines, then divide the src by 33 into a few parts “Print the source code in whole or parts with idx and comments you added with dbprint along the way.”</p>
<pre><code>totallen = 157
lenidx = 5
lspace = 10
lstsrc = inspect.getsource(self.orisrc).split('\n')
numparts = len(lstsrc) // 33 + 1 if len(lstsrc) % 33 != 0 else len(lstsrc) // 33
cmts = self.cmts
if part == 0: 
    for idx, l in zip(range(len(lstsrc)), lstsrc):
        lenl = len(l)

        if not bool(l.strip()):
            print(l + " "*(totallen-lenl-lenidx) + "(" + str(idx) + ")")

        elif lenl + lspace &gt;= 100:
            if bool(cmts):
                cmtidx = [cmt[0] for cmt in list(cmts.items())]
                if idx in cmtidx:
                    print(l + " # " + cmts[idx] + " "*(totallen-lenl-lenidx-len(cmts[idx])-3) + "(" + str(idx) + ")")
                else:
                    print(l + " "*(totallen-lenl-lenidx) + "(" + str(idx) + ")")
            else: 
                print(l + " "*(totallen-lenl-lenidx) + "(" + str(idx) + ")")

        else:


            if bool(cmts):
                cmtidx = [cmt[0] for cmt in list(cmts.items())]
                if idx in cmtidx:
                    print('{:&lt;100}'.format(l + "="*(100-lenl-lspace) + f"({idx})" + " # " + cmts[idx]))
                else:
                    print('{:&lt;100}'.format(l + "="*(100-lenl-lspace) + f"({idx})"))                                                      

            else:
                print('{:&lt;100}'.format(l + "="*(100-lenl-lspace) + f"({idx})"))                 

for p in range(numparts):
    for idx, l in zip(range(len(lstsrc)), lstsrc):

        if (maxlines*p &lt;= idx &lt; maxlines*(p+1) and p+1 == part):
            lenl = len(l)
            if not bool(l.strip()):
                print(l + " "*(totallen-lenl-lenidx) + "(" + str(idx) + ")")
            elif lenl + lspace &gt;= 100:
                if bool(cmts):
                    cmtidx = [cmt[0] for cmt in list(cmts.items())]
                    if idx in cmtidx:
                        print(l + " # " + cmts[idx] + " "*(totallen-lenl-lenidx-len(cmts[idx])-3) + "(" + str(idx) + ")")
                    else:
                        print(l + " "*(totallen-lenl-lenidx) + "(" + str(idx) + ")")
                else: 
                    print(l + " "*(totallen-lenl-lenidx) + "(" + str(idx) + ")")


            else:

                if bool(cmts):
                    cmtidx = [cmt[0] for cmt in list(cmts.items())]
                    if idx in cmtidx:
                        print('{:&lt;100}'.format(l + "="*(100-lenl-lspace) + f"({idx})" + " # " + cmts[idx]))
                    else:
                        print('{:&lt;100}'.format(l + "="*(100-lenl-lspace) + f"({idx})"))                                                          

                else:
                    print('{:&lt;100}'.format(l + "="*(100-lenl-lspace) + f"({idx})"))                      

        if (idx == maxlines*(p+1) or idx == len(lstsrc) - 1) and p+1 == part:
            print('{:&gt;157}'.format(f"part No.{p+1} out of {numparts} parts"))
            return</code></pre>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    setTimeout(function() {
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const cites = ref.parentNode.getAttribute('data-cites').split(' ');
    tippyHover(ref, function() {
      var popup = window.document.createElement('div');
      cites.forEach(function(cite) {
        var citeDiv = window.document.createElement('div');
        citeDiv.classList.add('hanging-indent');
        citeDiv.classList.add('csl-entry');
        var biblioDiv = window.document.getElementById('ref-' + cite);
        if (biblioDiv) {
          citeDiv.innerHTML = biblioDiv.innerHTML;
        }
        popup.appendChild(citeDiv);
      });
      return popup.innerHTML;
    });
  }
});
</script>
</div> <!-- /content -->



</body></html>