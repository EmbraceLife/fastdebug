<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.1.189">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>fastdebug - FixSigMeta</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" integrity="sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==" crossorigin="anonymous"></script>
<script type="application/javascript">define('jquery', [],function() {return window.jQuery;})</script>


<link rel="stylesheet" href="styles.css">
<meta property="og:title" content="fastdebug - FixSigMeta">
<meta property="og:description" content="The goal of this notebook is to explore how FixSigMeta avoid problems when Foo wants to get signature from its __init__ using inspect.signature.">
<meta property="og:site-name" content="fastdebug">
<meta name="twitter:title" content="fastdebug - FixSigMeta">
<meta name="twitter:description" content="The goal of this notebook is to explore how FixSigMeta avoid problems when Foo wants to get signature from its __init__ using inspect.signature.">
<meta name="twitter:card" content="summary">
</head>

<body class="nav-sidebar floating nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">fastdebug</span>
    </a>
  </div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/EmbraceLife/fastdebug"><i class="bi bi-github" role="img">
</i> 
 </a>
  </li>  
</ul>
              <div id="quarto-search" class="" title="Search"></div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
    <div class="container-fluid d-flex justify-content-between">
      <h1 class="quarto-secondary-nav-title">FixSigMeta</h1>
      <button type="button" class="quarto-btn-toggle btn" aria-label="Show secondary navigation">
        <i class="bi bi-chevron-right"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse sidebar-navigation floating overflow-auto">
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">fastdebug</a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./core0.html" class="sidebar-item-text sidebar-link">core</a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./core.html" class="sidebar-item-text sidebar-link">core</a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./utils.html" class="sidebar-item-text sidebar-link">Utils</a>
  </div>
</li>
    </ul>
    </div>
</nav>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#full-line-width" id="toc-full-line-width" class="nav-link active" data-scroll-target="#full-line-width">Full line width</a></li>
  <li><a href="#imports" id="toc-imports" class="nav-link" data-scroll-target="#imports">Imports</a></li>
  <li><a href="#prepare-environment-variables-for-debugging" id="toc-prepare-environment-variables-for-debugging" class="nav-link" data-scroll-target="#prepare-environment-variables-for-debugging">Prepare environment variables for debugging</a></li>
  <li><a href="#when-or-why-to-use-fixsigmeta" id="toc-when-or-why-to-use-fixsigmeta" class="nav-link" data-scroll-target="#when-or-why-to-use-fixsigmeta">When or why to use <code>FixSigMeta</code>?</a></li>
  <li><a href="#how-foo-borrow-sig-from-__init__" id="toc-how-foo-borrow-sig-from-__init__" class="nav-link" data-scroll-target="#how-foo-borrow-sig-from-__init__">How Foo borrow sig from <code>__init__</code></a>
  <ul>
  <li><a href="#how-to-debug-inspect._signature_from_callable-with-fastdb" id="toc-how-to-debug-inspect._signature_from_callable-with-fastdb" class="nav-link" data-scroll-target="#how-to-debug-inspect._signature_from_callable-with-fastdb">How to debug <code>inspect._signature_from_callable</code> with Fastdb</a></li>
  <li><a href="#how-exactly-foo-get-sig-from-__init__" id="toc-how-exactly-foo-get-sig-from-__init__" class="nav-link" data-scroll-target="#how-exactly-foo-get-sig-from-__init__">How exactly Foo get sig from <code>__init__</code></a></li>
  <li><a href="#read-commented-_signature_from_callable-from-python-3.9" id="toc-read-commented-_signature_from_callable-from-python-3.9" class="nav-link" data-scroll-target="#read-commented-_signature_from_callable-from-python-3.9">Read commented <code>_signature_from_callable</code> from python 3.9+</a></li>
  </ul></li>
  <li><a href="#foos-super-class-overriding-__new__-can-stop-foo-getting-sig-from-__init__" id="toc-foos-super-class-overriding-__new__-can-stop-foo-getting-sig-from-__init__" class="nav-link" data-scroll-target="#foos-super-class-overriding-__new__-can-stop-foo-getting-sig-from-__init__">Foo’s super class overriding <code>__new__</code> can stop Foo getting sig from <code>__init__</code></a>
  <ul>
  <li><a href="#when-foos-super-class-override-__new__-python3.7-cant-give-foo-sig-from-__init__" id="toc-when-foos-super-class-override-__new__-python3.7-cant-give-foo-sig-from-__init__" class="nav-link" data-scroll-target="#when-foos-super-class-override-__new__-python3.7-cant-give-foo-sig-from-__init__">When Foo’s super class override <code>__new__</code>, python3.7 can’t give Foo sig from <code>__init__</code></a></li>
  <li><a href="#how-python3.7-and-its-inspect-mess-it-up" id="toc-how-python3.7-and-its-inspect-mess-it-up" class="nav-link" data-scroll-target="#how-python3.7-and-its-inspect-mess-it-up">How python3.7 and its inspect mess it up</a></li>
  <li><a href="#fixsigmeta-can-fix-it-for-python-3.7-inspect" id="toc-fixsigmeta-can-fix-it-for-python-3.7-inspect" class="nav-link" data-scroll-target="#fixsigmeta-can-fix-it-for-python-3.7-inspect">FixSigMeta can fix it for python 3.7 inspect</a></li>
  <li><a href="#how-fixsigmeta-fix-it" id="toc-how-fixsigmeta-fix-it" class="nav-link" data-scroll-target="#how-fixsigmeta-fix-it">How FixSigMeta fix it?</a></li>
  <li><a href="#read-commented-_signature_from_callable-of-python-3.7" id="toc-read-commented-_signature_from_callable-of-python-3.7" class="nav-link" data-scroll-target="#read-commented-_signature_from_callable-of-python-3.7">Read commented <code>_signature_from_callable</code> of python 3.7</a></li>
  </ul></li>
  <li><a href="#foos-metaclass-defines-its-own-__call__-will-stop-foo-get-sig-from-__init__" id="toc-foos-metaclass-defines-its-own-__call__-will-stop-foo-get-sig-from-__init__" class="nav-link" data-scroll-target="#foos-metaclass-defines-its-own-__call__-will-stop-foo-get-sig-from-__init__">Foo’s metaclass defines its own <code>__call__</code> will stop Foo get sig from <code>__init__</code></a>
  <ul>
  <li><a href="#problem-demo" id="toc-problem-demo" class="nav-link" data-scroll-target="#problem-demo">Problem demo</a></li>
  <li><a href="#cause-of-the-problem" id="toc-cause-of-the-problem" class="nav-link" data-scroll-target="#cause-of-the-problem">Cause of the problem</a></li>
  <li><a href="#solution-demo" id="toc-solution-demo" class="nav-link" data-scroll-target="#solution-demo">Solution demo</a></li>
  <li><a href="#how-fixsigmeta-fix-this-problem" id="toc-how-fixsigmeta-fix-this-problem" class="nav-link" data-scroll-target="#how-fixsigmeta-fix-this-problem">How FixSigMeta fix this problem</a></li>
  <li><a href="#common-feature-of-the-solutions-above-by-fixsigmeta" id="toc-common-feature-of-the-solutions-above-by-fixsigmeta" class="nav-link" data-scroll-target="#common-feature-of-the-solutions-above-by-fixsigmeta">Common feature of the solutions above by FixSigMeta</a></li>
  </ul></li>
  </ul>
<div class="toc-actions"><div><i class="bi bi-github"></i></div><div class="action-links"><p><a href="https://github.com/EmbraceLife/fastdebug/issues/new" class="toc-action">Report an issue</a></p></div></div></nav>
    </div>
<!-- main -->
<main class="content page-columns page-full" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title d-none d-lg-block">FixSigMeta</h1>
</div>



<div class="quarto-title-meta">

    
    
  </div>
  

</header>

<!-- WARNING: THIS FILE WAS AUTOGENERATED! DO NOT EDIT! -->
<p>The goal of this notebook is to explore how <code>FixSigMeta</code> avoid problems when <code>Foo</code> wants to get signature from its <code>__init__</code> using <code>inspect.signature</code>.</p>
<p>In order to understand the problems <code>FixSigMeta</code> is fixing, please read official <a href="https://fastcore.fast.ai/meta.html#fixsigmeta">docs</a> first</p>
<p>At the beginning, I know very little of the source code of <code>inspect.signature</code> or in fact <code>inspect._signature_from_callable</code> and have no idea how <code>FixSigMeta</code> enable <code>Foo</code> to overcome the potential problems.</p>
<p><code>Fastdebug</code> library and its <a href="https://EmbraceLife.github.io/fastdebug/core.html#fastdb.dbprint"><code>Fastdb.dbprint</code></a> enables me to debug any source code and evaluate the expressions you write sitting above the source code and <a href="https://EmbraceLife.github.io/fastdebug/core.html#fastdb.print"><code>Fastdb.print</code></a> can display source code with comments I add when debugging with <code>dbprint</code>.</p>
<p>At the end of the notebook, I hope to have a nice and detailed document on the exploration and have a in-depth understanding of how both <code>_signature_from_callable</code> and <code>FixSigMeta</code> work.</p>
<p>Here is what I learnt from this notebook about how <code>FixSigMeta</code> solve the potential problems</p>
<blockquote class="blockquote">
<p>As a metaclass, <code>FixSigMeta</code> defines its <code>__new__</code> to creates a class instance <code>Foo</code> with attribute <code>__signature__</code> and store the signature of <code>__init__</code>. This way <code>inspect._signature_from_callable</code> can directly help <code>Foo</code> to get signature from <code>__signature__</code> instead of going into <code>__new__</code>, <code>__call__</code> looking for signatures where the potential problems reside.</p>
</blockquote>
<section id="full-line-width" class="level2">
<h2 class="anchored" data-anchor-id="full-line-width">Full line width</h2>
<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co"># from IPython.core.display import display, HTML # a depreciated import</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> IPython.display <span class="im">import</span> display, HTML</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>display(HTML(<span class="st">"&lt;style&gt;.container { width:100% !important; }&lt;/style&gt;"</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<style>.container { width:100% !important; }</style>
</div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> fastdebug.utils <span class="im">import</span> <span class="op">*</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> IPython</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>whatinside(IPython)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>IPython has: 
0 items in its __all__, and 
7 user defined functions, 
2 classes or class objects, 
0 builtin funcs and methods, and
9 callables.
</code></pre>
</div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>whichversion(<span class="st">"IPython"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>ipython: 8.4.0 
IPython: Productive Interactive Computing    
The IPython Development Team 
https://ipython.org     
python_version: &gt;=3.8     
/Users/Natsume/mambaforge/lib/python3.9/site-packages/IPython</code></pre>
</div>
</div>
</section>
<section id="imports" class="level2">
<h2 class="anchored" data-anchor-id="imports">Imports</h2>
<div class="cell">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> fastdebug.core <span class="im">import</span> <span class="op">*</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> inspect</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> inspect <span class="im">import</span> <span class="op">*</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> inspect <span class="im">import</span> _signature_from_callable</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> inspect <span class="im">import</span> _signature_is_functionlike, _signature_is_builtin, _signature_get_user_defined_method, _signature_from_function, _signature_bound_method</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> fastcore.meta <span class="im">as</span> fm</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>_signature_from_callableNew <span class="op">=</span> _signature_from_callable</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> _signature_from_callableOld(obj, <span class="op">*</span>,</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>                             follow_wrapper_chains<span class="op">=</span><span class="va">True</span>,</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>                             skip_bound_arg<span class="op">=</span><span class="va">True</span>,</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>                             sigcls):</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Private helper function to get signature for arbitrary</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a><span class="co">    callable objects.</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> <span class="bu">callable</span>(obj):</span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">raise</span> <span class="pp">TypeError</span>(<span class="st">'</span><span class="sc">{!r}</span><span class="st"> is not a callable object'</span>.<span class="bu">format</span>(obj))</span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">isinstance</span>(obj, types.MethodType):</span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a>        <span class="co"># In this case we skip the first parameter of the underlying</span></span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a>        <span class="co"># function (usually `self` or `cls`).</span></span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a>        sig <span class="op">=</span> _signature_from_callable(</span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true" tabindex="-1"></a>            obj.__func__,</span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true" tabindex="-1"></a>            follow_wrapper_chains<span class="op">=</span>follow_wrapper_chains,</span>
<span id="cb13-19"><a href="#cb13-19" aria-hidden="true" tabindex="-1"></a>            skip_bound_arg<span class="op">=</span>skip_bound_arg,</span>
<span id="cb13-20"><a href="#cb13-20" aria-hidden="true" tabindex="-1"></a>            sigcls<span class="op">=</span>sigcls)</span>
<span id="cb13-21"><a href="#cb13-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-22"><a href="#cb13-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> skip_bound_arg:</span>
<span id="cb13-23"><a href="#cb13-23" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> _signature_bound_method(sig)</span>
<span id="cb13-24"><a href="#cb13-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb13-25"><a href="#cb13-25" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> sig</span>
<span id="cb13-26"><a href="#cb13-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-27"><a href="#cb13-27" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Was this function wrapped by a decorator?</span></span>
<span id="cb13-28"><a href="#cb13-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> follow_wrapper_chains:</span>
<span id="cb13-29"><a href="#cb13-29" aria-hidden="true" tabindex="-1"></a>        obj <span class="op">=</span> unwrap(obj, stop<span class="op">=</span>(<span class="kw">lambda</span> f: <span class="bu">hasattr</span>(f, <span class="st">"__signature__"</span>)))</span>
<span id="cb13-30"><a href="#cb13-30" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">isinstance</span>(obj, types.MethodType):</span>
<span id="cb13-31"><a href="#cb13-31" aria-hidden="true" tabindex="-1"></a>            <span class="co"># If the unwrapped object is a *method*, we might want to</span></span>
<span id="cb13-32"><a href="#cb13-32" aria-hidden="true" tabindex="-1"></a>            <span class="co"># skip its first parameter (self).</span></span>
<span id="cb13-33"><a href="#cb13-33" aria-hidden="true" tabindex="-1"></a>            <span class="co"># See test_signature_wrapped_bound_method for details.</span></span>
<span id="cb13-34"><a href="#cb13-34" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> _signature_from_callable(</span>
<span id="cb13-35"><a href="#cb13-35" aria-hidden="true" tabindex="-1"></a>                obj,</span>
<span id="cb13-36"><a href="#cb13-36" aria-hidden="true" tabindex="-1"></a>                follow_wrapper_chains<span class="op">=</span>follow_wrapper_chains,</span>
<span id="cb13-37"><a href="#cb13-37" aria-hidden="true" tabindex="-1"></a>                skip_bound_arg<span class="op">=</span>skip_bound_arg,</span>
<span id="cb13-38"><a href="#cb13-38" aria-hidden="true" tabindex="-1"></a>                sigcls<span class="op">=</span>sigcls)</span>
<span id="cb13-39"><a href="#cb13-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-40"><a href="#cb13-40" aria-hidden="true" tabindex="-1"></a>    <span class="cf">try</span>:</span>
<span id="cb13-41"><a href="#cb13-41" aria-hidden="true" tabindex="-1"></a>        sig <span class="op">=</span> obj.__signature__</span>
<span id="cb13-42"><a href="#cb13-42" aria-hidden="true" tabindex="-1"></a>    <span class="cf">except</span> <span class="pp">AttributeError</span>:</span>
<span id="cb13-43"><a href="#cb13-43" aria-hidden="true" tabindex="-1"></a>        <span class="cf">pass</span></span>
<span id="cb13-44"><a href="#cb13-44" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb13-45"><a href="#cb13-45" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> sig <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb13-46"><a href="#cb13-46" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="kw">not</span> <span class="bu">isinstance</span>(sig, Signature):</span>
<span id="cb13-47"><a href="#cb13-47" aria-hidden="true" tabindex="-1"></a>                <span class="cf">raise</span> <span class="pp">TypeError</span>(</span>
<span id="cb13-48"><a href="#cb13-48" aria-hidden="true" tabindex="-1"></a>                    <span class="st">'unexpected object </span><span class="sc">{!r}</span><span class="st"> in __signature__ '</span></span>
<span id="cb13-49"><a href="#cb13-49" aria-hidden="true" tabindex="-1"></a>                    <span class="st">'attribute'</span>.<span class="bu">format</span>(sig))</span>
<span id="cb13-50"><a href="#cb13-50" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> sig</span>
<span id="cb13-51"><a href="#cb13-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-52"><a href="#cb13-52" aria-hidden="true" tabindex="-1"></a>    <span class="cf">try</span>:</span>
<span id="cb13-53"><a href="#cb13-53" aria-hidden="true" tabindex="-1"></a>        partialmethod <span class="op">=</span> obj._partialmethod</span>
<span id="cb13-54"><a href="#cb13-54" aria-hidden="true" tabindex="-1"></a>    <span class="cf">except</span> <span class="pp">AttributeError</span>:</span>
<span id="cb13-55"><a href="#cb13-55" aria-hidden="true" tabindex="-1"></a>        <span class="cf">pass</span></span>
<span id="cb13-56"><a href="#cb13-56" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb13-57"><a href="#cb13-57" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">isinstance</span>(partialmethod, functools.partialmethod):</span>
<span id="cb13-58"><a href="#cb13-58" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Unbound partialmethod (see functools.partialmethod)</span></span>
<span id="cb13-59"><a href="#cb13-59" aria-hidden="true" tabindex="-1"></a>            <span class="co"># This means, that we need to calculate the signature</span></span>
<span id="cb13-60"><a href="#cb13-60" aria-hidden="true" tabindex="-1"></a>            <span class="co"># as if it's a regular partial object, but taking into</span></span>
<span id="cb13-61"><a href="#cb13-61" aria-hidden="true" tabindex="-1"></a>            <span class="co"># account that the first positional argument</span></span>
<span id="cb13-62"><a href="#cb13-62" aria-hidden="true" tabindex="-1"></a>            <span class="co"># (usually `self`, or `cls`) will not be passed</span></span>
<span id="cb13-63"><a href="#cb13-63" aria-hidden="true" tabindex="-1"></a>            <span class="co"># automatically (as for boundmethods)</span></span>
<span id="cb13-64"><a href="#cb13-64" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-65"><a href="#cb13-65" aria-hidden="true" tabindex="-1"></a>            wrapped_sig <span class="op">=</span> _signature_from_callable(</span>
<span id="cb13-66"><a href="#cb13-66" aria-hidden="true" tabindex="-1"></a>                partialmethod.func,</span>
<span id="cb13-67"><a href="#cb13-67" aria-hidden="true" tabindex="-1"></a>                follow_wrapper_chains<span class="op">=</span>follow_wrapper_chains,</span>
<span id="cb13-68"><a href="#cb13-68" aria-hidden="true" tabindex="-1"></a>                skip_bound_arg<span class="op">=</span>skip_bound_arg,</span>
<span id="cb13-69"><a href="#cb13-69" aria-hidden="true" tabindex="-1"></a>                sigcls<span class="op">=</span>sigcls)</span>
<span id="cb13-70"><a href="#cb13-70" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-71"><a href="#cb13-71" aria-hidden="true" tabindex="-1"></a>            sig <span class="op">=</span> _signature_get_partial(wrapped_sig, partialmethod, (<span class="va">None</span>,))</span>
<span id="cb13-72"><a href="#cb13-72" aria-hidden="true" tabindex="-1"></a>            first_wrapped_param <span class="op">=</span> <span class="bu">tuple</span>(wrapped_sig.parameters.values())[<span class="dv">0</span>]</span>
<span id="cb13-73"><a href="#cb13-73" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> first_wrapped_param.kind <span class="kw">is</span> Parameter.VAR_POSITIONAL:</span>
<span id="cb13-74"><a href="#cb13-74" aria-hidden="true" tabindex="-1"></a>                <span class="co"># First argument of the wrapped callable is `*args`, as in</span></span>
<span id="cb13-75"><a href="#cb13-75" aria-hidden="true" tabindex="-1"></a>                <span class="co"># `partialmethod(lambda *args)`.</span></span>
<span id="cb13-76"><a href="#cb13-76" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> sig</span>
<span id="cb13-77"><a href="#cb13-77" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb13-78"><a href="#cb13-78" aria-hidden="true" tabindex="-1"></a>                sig_params <span class="op">=</span> <span class="bu">tuple</span>(sig.parameters.values())</span>
<span id="cb13-79"><a href="#cb13-79" aria-hidden="true" tabindex="-1"></a>                <span class="cf">assert</span> (<span class="kw">not</span> sig_params <span class="kw">or</span></span>
<span id="cb13-80"><a href="#cb13-80" aria-hidden="true" tabindex="-1"></a>                        first_wrapped_param <span class="kw">is</span> <span class="kw">not</span> sig_params[<span class="dv">0</span>])</span>
<span id="cb13-81"><a href="#cb13-81" aria-hidden="true" tabindex="-1"></a>                new_params <span class="op">=</span> (first_wrapped_param,) <span class="op">+</span> sig_params</span>
<span id="cb13-82"><a href="#cb13-82" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> sig.replace(parameters<span class="op">=</span>new_params)</span>
<span id="cb13-83"><a href="#cb13-83" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-84"><a href="#cb13-84" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> isfunction(obj) <span class="kw">or</span> _signature_is_functionlike(obj):</span>
<span id="cb13-85"><a href="#cb13-85" aria-hidden="true" tabindex="-1"></a>        <span class="co"># If it's a pure Python function, or an object that is duck type</span></span>
<span id="cb13-86"><a href="#cb13-86" aria-hidden="true" tabindex="-1"></a>        <span class="co"># of a Python function (Cython functions, for instance), then:</span></span>
<span id="cb13-87"><a href="#cb13-87" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> _signature_from_function(sigcls, obj)</span>
<span id="cb13-88"><a href="#cb13-88" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-89"><a href="#cb13-89" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> _signature_is_builtin(obj):</span>
<span id="cb13-90"><a href="#cb13-90" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> _signature_from_builtin(sigcls, obj,</span>
<span id="cb13-91"><a href="#cb13-91" aria-hidden="true" tabindex="-1"></a>                                       skip_bound_arg<span class="op">=</span>skip_bound_arg)</span>
<span id="cb13-92"><a href="#cb13-92" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-93"><a href="#cb13-93" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">isinstance</span>(obj, functools.partial):</span>
<span id="cb13-94"><a href="#cb13-94" aria-hidden="true" tabindex="-1"></a>        wrapped_sig <span class="op">=</span> _signature_from_callable(</span>
<span id="cb13-95"><a href="#cb13-95" aria-hidden="true" tabindex="-1"></a>            obj.func,</span>
<span id="cb13-96"><a href="#cb13-96" aria-hidden="true" tabindex="-1"></a>            follow_wrapper_chains<span class="op">=</span>follow_wrapper_chains,</span>
<span id="cb13-97"><a href="#cb13-97" aria-hidden="true" tabindex="-1"></a>            skip_bound_arg<span class="op">=</span>skip_bound_arg,</span>
<span id="cb13-98"><a href="#cb13-98" aria-hidden="true" tabindex="-1"></a>            sigcls<span class="op">=</span>sigcls)</span>
<span id="cb13-99"><a href="#cb13-99" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> _signature_get_partial(wrapped_sig, obj)</span>
<span id="cb13-100"><a href="#cb13-100" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-101"><a href="#cb13-101" aria-hidden="true" tabindex="-1"></a>    sig <span class="op">=</span> <span class="va">None</span></span>
<span id="cb13-102"><a href="#cb13-102" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">isinstance</span>(obj, <span class="bu">type</span>):</span>
<span id="cb13-103"><a href="#cb13-103" aria-hidden="true" tabindex="-1"></a>        <span class="co"># obj is a class or a metaclass</span></span>
<span id="cb13-104"><a href="#cb13-104" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-105"><a href="#cb13-105" aria-hidden="true" tabindex="-1"></a>        <span class="co"># First, let's see if it has an overloaded __call__ defined</span></span>
<span id="cb13-106"><a href="#cb13-106" aria-hidden="true" tabindex="-1"></a>        <span class="co"># in its metaclass</span></span>
<span id="cb13-107"><a href="#cb13-107" aria-hidden="true" tabindex="-1"></a>        call <span class="op">=</span> _signature_get_user_defined_method(<span class="bu">type</span>(obj), <span class="st">'__call__'</span>)</span>
<span id="cb13-108"><a href="#cb13-108" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> call <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb13-109"><a href="#cb13-109" aria-hidden="true" tabindex="-1"></a>            sig <span class="op">=</span> _signature_from_callable(</span>
<span id="cb13-110"><a href="#cb13-110" aria-hidden="true" tabindex="-1"></a>                call,</span>
<span id="cb13-111"><a href="#cb13-111" aria-hidden="true" tabindex="-1"></a>                follow_wrapper_chains<span class="op">=</span>follow_wrapper_chains,</span>
<span id="cb13-112"><a href="#cb13-112" aria-hidden="true" tabindex="-1"></a>                skip_bound_arg<span class="op">=</span>skip_bound_arg,</span>
<span id="cb13-113"><a href="#cb13-113" aria-hidden="true" tabindex="-1"></a>                sigcls<span class="op">=</span>sigcls)</span>
<span id="cb13-114"><a href="#cb13-114" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb13-115"><a href="#cb13-115" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Now we check if the 'obj' class has a '__new__' method</span></span>
<span id="cb13-116"><a href="#cb13-116" aria-hidden="true" tabindex="-1"></a>            new <span class="op">=</span> _signature_get_user_defined_method(obj, <span class="st">'__new__'</span>)</span>
<span id="cb13-117"><a href="#cb13-117" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> new <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb13-118"><a href="#cb13-118" aria-hidden="true" tabindex="-1"></a>                sig <span class="op">=</span> _signature_from_callable(</span>
<span id="cb13-119"><a href="#cb13-119" aria-hidden="true" tabindex="-1"></a>                    new,</span>
<span id="cb13-120"><a href="#cb13-120" aria-hidden="true" tabindex="-1"></a>                    follow_wrapper_chains<span class="op">=</span>follow_wrapper_chains,</span>
<span id="cb13-121"><a href="#cb13-121" aria-hidden="true" tabindex="-1"></a>                    skip_bound_arg<span class="op">=</span>skip_bound_arg,</span>
<span id="cb13-122"><a href="#cb13-122" aria-hidden="true" tabindex="-1"></a>                    sigcls<span class="op">=</span>sigcls)</span>
<span id="cb13-123"><a href="#cb13-123" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb13-124"><a href="#cb13-124" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Finally, we should have at least __init__ implemented</span></span>
<span id="cb13-125"><a href="#cb13-125" aria-hidden="true" tabindex="-1"></a>                init <span class="op">=</span> _signature_get_user_defined_method(obj, <span class="st">'__init__'</span>)</span>
<span id="cb13-126"><a href="#cb13-126" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> init <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb13-127"><a href="#cb13-127" aria-hidden="true" tabindex="-1"></a>                    sig <span class="op">=</span> _signature_from_callable(</span>
<span id="cb13-128"><a href="#cb13-128" aria-hidden="true" tabindex="-1"></a>                        init,</span>
<span id="cb13-129"><a href="#cb13-129" aria-hidden="true" tabindex="-1"></a>                        follow_wrapper_chains<span class="op">=</span>follow_wrapper_chains,</span>
<span id="cb13-130"><a href="#cb13-130" aria-hidden="true" tabindex="-1"></a>                        skip_bound_arg<span class="op">=</span>skip_bound_arg,</span>
<span id="cb13-131"><a href="#cb13-131" aria-hidden="true" tabindex="-1"></a>                        sigcls<span class="op">=</span>sigcls)</span>
<span id="cb13-132"><a href="#cb13-132" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-133"><a href="#cb13-133" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> sig <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb13-134"><a href="#cb13-134" aria-hidden="true" tabindex="-1"></a>            <span class="co"># At this point we know, that `obj` is a class, with no user-</span></span>
<span id="cb13-135"><a href="#cb13-135" aria-hidden="true" tabindex="-1"></a>            <span class="co"># defined '__init__', '__new__', or class-level '__call__'</span></span>
<span id="cb13-136"><a href="#cb13-136" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-137"><a href="#cb13-137" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> base <span class="kw">in</span> obj.__mro__[:<span class="op">-</span><span class="dv">1</span>]:</span>
<span id="cb13-138"><a href="#cb13-138" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Since '__text_signature__' is implemented as a</span></span>
<span id="cb13-139"><a href="#cb13-139" aria-hidden="true" tabindex="-1"></a>                <span class="co"># descriptor that extracts text signature from the</span></span>
<span id="cb13-140"><a href="#cb13-140" aria-hidden="true" tabindex="-1"></a>                <span class="co"># class docstring, if 'obj' is derived from a builtin</span></span>
<span id="cb13-141"><a href="#cb13-141" aria-hidden="true" tabindex="-1"></a>                <span class="co"># class, its own '__text_signature__' may be 'None'.</span></span>
<span id="cb13-142"><a href="#cb13-142" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Therefore, we go through the MRO (except the last</span></span>
<span id="cb13-143"><a href="#cb13-143" aria-hidden="true" tabindex="-1"></a>                <span class="co"># class in there, which is 'object') to find the first</span></span>
<span id="cb13-144"><a href="#cb13-144" aria-hidden="true" tabindex="-1"></a>                <span class="co"># class with non-empty text signature.</span></span>
<span id="cb13-145"><a href="#cb13-145" aria-hidden="true" tabindex="-1"></a>                <span class="cf">try</span>:</span>
<span id="cb13-146"><a href="#cb13-146" aria-hidden="true" tabindex="-1"></a>                    text_sig <span class="op">=</span> base.__text_signature__</span>
<span id="cb13-147"><a href="#cb13-147" aria-hidden="true" tabindex="-1"></a>                <span class="cf">except</span> <span class="pp">AttributeError</span>:</span>
<span id="cb13-148"><a href="#cb13-148" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">pass</span></span>
<span id="cb13-149"><a href="#cb13-149" aria-hidden="true" tabindex="-1"></a>                <span class="cf">else</span>:</span>
<span id="cb13-150"><a href="#cb13-150" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">if</span> text_sig:</span>
<span id="cb13-151"><a href="#cb13-151" aria-hidden="true" tabindex="-1"></a>                        <span class="co"># If 'obj' class has a __text_signature__ attribute:</span></span>
<span id="cb13-152"><a href="#cb13-152" aria-hidden="true" tabindex="-1"></a>                        <span class="co"># return a signature based on it</span></span>
<span id="cb13-153"><a href="#cb13-153" aria-hidden="true" tabindex="-1"></a>                        <span class="cf">return</span> _signature_fromstr(sigcls, obj, text_sig)</span>
<span id="cb13-154"><a href="#cb13-154" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-155"><a href="#cb13-155" aria-hidden="true" tabindex="-1"></a>            <span class="co"># No '__text_signature__' was found for the 'obj' class.</span></span>
<span id="cb13-156"><a href="#cb13-156" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Last option is to check if its '__init__' is</span></span>
<span id="cb13-157"><a href="#cb13-157" aria-hidden="true" tabindex="-1"></a>            <span class="co"># object.__init__ or type.__init__.</span></span>
<span id="cb13-158"><a href="#cb13-158" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="bu">type</span> <span class="kw">not</span> <span class="kw">in</span> obj.__mro__:</span>
<span id="cb13-159"><a href="#cb13-159" aria-hidden="true" tabindex="-1"></a>                <span class="co"># We have a class (not metaclass), but no user-defined</span></span>
<span id="cb13-160"><a href="#cb13-160" aria-hidden="true" tabindex="-1"></a>                <span class="co"># __init__ or __new__ for it</span></span>
<span id="cb13-161"><a href="#cb13-161" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> (obj.<span class="fu">__init__</span> <span class="kw">is</span> <span class="bu">object</span>.<span class="fu">__init__</span> <span class="kw">and</span></span>
<span id="cb13-162"><a href="#cb13-162" aria-hidden="true" tabindex="-1"></a>                    obj.<span class="fu">__new__</span> <span class="kw">is</span> <span class="bu">object</span>.<span class="fu">__new__</span>):</span>
<span id="cb13-163"><a href="#cb13-163" aria-hidden="true" tabindex="-1"></a>                    <span class="co"># Return a signature of 'object' builtin.</span></span>
<span id="cb13-164"><a href="#cb13-164" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">return</span> sigcls.from_callable(<span class="bu">object</span>)</span>
<span id="cb13-165"><a href="#cb13-165" aria-hidden="true" tabindex="-1"></a>                <span class="cf">else</span>:</span>
<span id="cb13-166"><a href="#cb13-166" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">raise</span> <span class="pp">ValueError</span>(</span>
<span id="cb13-167"><a href="#cb13-167" aria-hidden="true" tabindex="-1"></a>                        <span class="st">'no signature found for builtin type </span><span class="sc">{!r}</span><span class="st">'</span>.<span class="bu">format</span>(obj))</span>
<span id="cb13-168"><a href="#cb13-168" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-169"><a href="#cb13-169" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> <span class="kw">not</span> <span class="bu">isinstance</span>(obj, _NonUserDefinedCallables):</span>
<span id="cb13-170"><a href="#cb13-170" aria-hidden="true" tabindex="-1"></a>        <span class="co"># An object with __call__</span></span>
<span id="cb13-171"><a href="#cb13-171" aria-hidden="true" tabindex="-1"></a>        <span class="co"># We also check that the 'obj' is not an instance of</span></span>
<span id="cb13-172"><a href="#cb13-172" aria-hidden="true" tabindex="-1"></a>        <span class="co"># _WrapperDescriptor or _MethodWrapper to avoid</span></span>
<span id="cb13-173"><a href="#cb13-173" aria-hidden="true" tabindex="-1"></a>        <span class="co"># infinite recursion (and even potential segfault)</span></span>
<span id="cb13-174"><a href="#cb13-174" aria-hidden="true" tabindex="-1"></a>        call <span class="op">=</span> _signature_get_user_defined_method(<span class="bu">type</span>(obj), <span class="st">'__call__'</span>)</span>
<span id="cb13-175"><a href="#cb13-175" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> call <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb13-176"><a href="#cb13-176" aria-hidden="true" tabindex="-1"></a>            <span class="cf">try</span>:</span>
<span id="cb13-177"><a href="#cb13-177" aria-hidden="true" tabindex="-1"></a>                sig <span class="op">=</span> _signature_from_callable(</span>
<span id="cb13-178"><a href="#cb13-178" aria-hidden="true" tabindex="-1"></a>                    call,</span>
<span id="cb13-179"><a href="#cb13-179" aria-hidden="true" tabindex="-1"></a>                    follow_wrapper_chains<span class="op">=</span>follow_wrapper_chains,</span>
<span id="cb13-180"><a href="#cb13-180" aria-hidden="true" tabindex="-1"></a>                    skip_bound_arg<span class="op">=</span>skip_bound_arg,</span>
<span id="cb13-181"><a href="#cb13-181" aria-hidden="true" tabindex="-1"></a>                    sigcls<span class="op">=</span>sigcls)</span>
<span id="cb13-182"><a href="#cb13-182" aria-hidden="true" tabindex="-1"></a>            <span class="cf">except</span> <span class="pp">ValueError</span> <span class="im">as</span> ex:</span>
<span id="cb13-183"><a href="#cb13-183" aria-hidden="true" tabindex="-1"></a>                msg <span class="op">=</span> <span class="st">'no signature found for </span><span class="sc">{!r}</span><span class="st">'</span>.<span class="bu">format</span>(obj)</span>
<span id="cb13-184"><a href="#cb13-184" aria-hidden="true" tabindex="-1"></a>                <span class="cf">raise</span> <span class="pp">ValueError</span>(msg) <span class="im">from</span> ex</span>
<span id="cb13-185"><a href="#cb13-185" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-186"><a href="#cb13-186" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> sig <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb13-187"><a href="#cb13-187" aria-hidden="true" tabindex="-1"></a>        <span class="co"># For classes and objects we skip the first parameter of their</span></span>
<span id="cb13-188"><a href="#cb13-188" aria-hidden="true" tabindex="-1"></a>        <span class="co"># __call__, __new__, or __init__ methods</span></span>
<span id="cb13-189"><a href="#cb13-189" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> skip_bound_arg:</span>
<span id="cb13-190"><a href="#cb13-190" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> _signature_bound_method(sig)</span>
<span id="cb13-191"><a href="#cb13-191" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb13-192"><a href="#cb13-192" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> sig</span>
<span id="cb13-193"><a href="#cb13-193" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-194"><a href="#cb13-194" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">isinstance</span>(obj, types.BuiltinFunctionType):</span>
<span id="cb13-195"><a href="#cb13-195" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Raise a nicer error message for builtins</span></span>
<span id="cb13-196"><a href="#cb13-196" aria-hidden="true" tabindex="-1"></a>        msg <span class="op">=</span> <span class="st">'no signature found for builtin function </span><span class="sc">{!r}</span><span class="st">'</span>.<span class="bu">format</span>(obj)</span>
<span id="cb13-197"><a href="#cb13-197" aria-hidden="true" tabindex="-1"></a>        <span class="cf">raise</span> <span class="pp">ValueError</span>(msg)</span>
<span id="cb13-198"><a href="#cb13-198" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-199"><a href="#cb13-199" aria-hidden="true" tabindex="-1"></a>    <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="st">'callable </span><span class="sc">{!r}</span><span class="st"> is not supported by signature'</span>.<span class="bu">format</span>(obj))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="prepare-environment-variables-for-debugging" class="level2">
<h2 class="anchored" data-anchor-id="prepare-environment-variables-for-debugging">Prepare environment variables for debugging</h2>
<div class="cell">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="bu">len</span>(<span class="bu">dir</span>(fm))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<pre><code>103</code></pre>
</div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="bu">len</span>(inspect.__dict__)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<pre><code>167</code></pre>
</div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>g <span class="op">=</span> {}</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="co"># g.update(inspect.__dict__)</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a><span class="co"># g.update(fm.__dict__)</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>g.update(inspect._signature_from_callable.__globals__)</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>g.update(fm.delegates.__globals__)</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a><span class="bu">len</span>(g)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<pre><code>254</code></pre>
</div>
</div>
</section>
<section id="when-or-why-to-use-fixsigmeta" class="level2">
<h2 class="anchored" data-anchor-id="when-or-why-to-use-fixsigmeta">When or why to use <code>FixSigMeta</code>?</h2>
<p>When we want a class e.g., <code>Foo</code> to have signature from its <code>__init__</code> method.</p>
<p><code>FixSigMeta</code> can avoid potential problems for <code>Foo</code> to access signature from <code>__init__</code>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Foo:</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, a, b, c): <span class="cf">pass</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>    <span class="at">@classmethod</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> clsmed(): <span class="cf">pass</span></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>inspect.signature(Foo)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<pre><code>&lt;Signature (a, b, c)&gt;</code></pre>
</div>
</div>
</section>
<section id="how-foo-borrow-sig-from-__init__" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="how-foo-borrow-sig-from-__init__">How Foo borrow sig from <code>__init__</code></h2>
<div class="cell">
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="co"># g = locals()</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>sig <span class="op">=</span> Fastdb(_signature_from_callable, g)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<section id="how-to-debug-inspect._signature_from_callable-with-fastdb" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="how-to-debug-inspect._signature_from_callable-with-fastdb">How to debug <code>inspect._signature_from_callable</code> with Fastdb</h3>
<div class="cell column-screen">
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>sig.dbprint(<span class="dv">9</span>, <span class="st">"so that it can use in itself"</span>)</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>sig.<span class="bu">print</span>(part<span class="op">=</span><span class="dv">1</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>    """                                                                                                                                                 (7)
                                                                                                                                                        (8)
    _get_signature_of = functools.partial(_signature_from_callable,=====================================================================================(9)
                                                                                                                                 so that it can use in itself
                                follow_wrapper_chains=follow_wrapper_chains,                                                                            (10)
                                skip_bound_arg=skip_bound_arg,                                                                                          (11)
def _signature_from_callable(obj, *,======================================================(0)       
                             follow_wrapper_chains=True,==================================(1)       
                             skip_bound_arg=True,=========================================(2)       
                             sigcls):=====================================================(3)       
                                                                                                                                                        (4)
    """Private helper function to get signature for arbitrary=============================(5)       
    callable objects.=====================================================================(6)       
    """===================================================================================(7)       
                                                                                                                                                        (8)
    _get_signature_of = functools.partial(_signature_from_callable,=======================(9) # so that it can use in itself
                                follow_wrapper_chains=follow_wrapper_chains,==============(10)      
                                skip_bound_arg=skip_bound_arg,============================(11)      
                                sigcls=sigcls)============================================(12)      
                                                                                                                                                        (13)
    if not callable(obj):=================================================================(14)      
        raise TypeError('{!r} is not a callable object'.format(obj))======================(15)      
                                                                                                                                                        (16)
    if isinstance(obj, types.MethodType):=================================================(17)      
        # In this case we skip the first parameter of the underlying======================(18)      
        # function (usually `self` or `cls`).=============================================(19)      
        sig = _get_signature_of(obj.__func__)=============================================(20)      
                                                                                                                                                        (21)
        if skip_bound_arg:================================================================(22)      
            return _signature_bound_method(sig)===========================================(23)      
        else:=============================================================================(24)      
            return sig====================================================================(25)      
                                                                                                                                                        (26)
    # Was this function wrapped by a decorator?===========================================(27)      
    if follow_wrapper_chains:=============================================================(28)      
        obj = unwrap(obj, stop=(lambda f: hasattr(f, "__signature__")))===================(29)      
        if isinstance(obj, types.MethodType):=============================================(30)      
            # If the unwrapped object is a *method*, we might want to=====================(31)      
            # skip its first parameter (self).============================================(32)      
                                                                                                                                     part No.1 out of 6 parts</code></pre>
</div>
</div>
<div class="cell column-screen">
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>sig.dbprint(<span class="dv">14</span>, <span class="st">"obj must be callable"</span>)</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>sig.<span class="bu">print</span>(part<span class="op">=</span><span class="dv">1</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>                                sigcls=sigcls)                                                                                                          (12)
                                                                                                                                                        (13)
    if not callable(obj):===============================================================================================================================(14)
                                                                                                                                         obj must be callable
        raise TypeError('{!r} is not a callable object'.format(obj))                                                                                    (15)
                                                                                                                                                        (16)
def _signature_from_callable(obj, *,======================================================(0)       
                             follow_wrapper_chains=True,==================================(1)       
                             skip_bound_arg=True,=========================================(2)       
                             sigcls):=====================================================(3)       
                                                                                                                                                        (4)
    """Private helper function to get signature for arbitrary=============================(5)       
    callable objects.=====================================================================(6)       
    """===================================================================================(7)       
                                                                                                                                                        (8)
    _get_signature_of = functools.partial(_signature_from_callable,=======================(9) # so that it can use in itself
                                follow_wrapper_chains=follow_wrapper_chains,==============(10)      
                                skip_bound_arg=skip_bound_arg,============================(11)      
                                sigcls=sigcls)============================================(12)      
                                                                                                                                                        (13)
    if not callable(obj):=================================================================(14) # obj must be callable
        raise TypeError('{!r} is not a callable object'.format(obj))======================(15)      
                                                                                                                                                        (16)
    if isinstance(obj, types.MethodType):=================================================(17)      
        # In this case we skip the first parameter of the underlying======================(18)      
        # function (usually `self` or `cls`).=============================================(19)      
        sig = _get_signature_of(obj.__func__)=============================================(20)      
                                                                                                                                                        (21)
        if skip_bound_arg:================================================================(22)      
            return _signature_bound_method(sig)===========================================(23)      
        else:=============================================================================(24)      
            return sig====================================================================(25)      
                                                                                                                                                        (26)
    # Was this function wrapped by a decorator?===========================================(27)      
    if follow_wrapper_chains:=============================================================(28)      
        obj = unwrap(obj, stop=(lambda f: hasattr(f, "__signature__")))===================(29)      
        if isinstance(obj, types.MethodType):=============================================(30)      
            # If the unwrapped object is a *method*, we might want to=====================(31)      
            # skip its first parameter (self).============================================(32)      
                                                                                                                                     part No.1 out of 6 parts</code></pre>
</div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb27"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="bu">isinstance</span>(Foo.clsmed, types.MethodType)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<pre><code>True</code></pre>
</div>
</div>
<div class="cell column-screen">
<div class="sourceCode cell-code" id="cb29"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a>sig.dbprint(<span class="dv">17</span>, <span class="st">"obj can be a classmethod"</span>)</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>sig.<span class="bu">print</span>(part<span class="op">=</span><span class="dv">1</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>        raise TypeError('{!r} is not a callable object'.format(obj))                                                                                    (15)
                                                                                                                                                        (16)
    if isinstance(obj, types.MethodType):===============================================================================================================(17)
                                                                                                                                     obj can be a classmethod
        # In this case we skip the first parameter of the underlying                                                                                    (18)
        # function (usually `self` or `cls`).                                                                                                           (19)
def _signature_from_callable(obj, *,======================================================(0)       
                             follow_wrapper_chains=True,==================================(1)       
                             skip_bound_arg=True,=========================================(2)       
                             sigcls):=====================================================(3)       
                                                                                                                                                        (4)
    """Private helper function to get signature for arbitrary=============================(5)       
    callable objects.=====================================================================(6)       
    """===================================================================================(7)       
                                                                                                                                                        (8)
    _get_signature_of = functools.partial(_signature_from_callable,=======================(9) # so that it can use in itself
                                follow_wrapper_chains=follow_wrapper_chains,==============(10)      
                                skip_bound_arg=skip_bound_arg,============================(11)      
                                sigcls=sigcls)============================================(12)      
                                                                                                                                                        (13)
    if not callable(obj):=================================================================(14) # obj must be callable
        raise TypeError('{!r} is not a callable object'.format(obj))======================(15)      
                                                                                                                                                        (16)
    if isinstance(obj, types.MethodType):=================================================(17) # obj can be a classmethod
        # In this case we skip the first parameter of the underlying======================(18)      
        # function (usually `self` or `cls`).=============================================(19)      
        sig = _get_signature_of(obj.__func__)=============================================(20)      
                                                                                                                                                        (21)
        if skip_bound_arg:================================================================(22)      
            return _signature_bound_method(sig)===========================================(23)      
        else:=============================================================================(24)      
            return sig====================================================================(25)      
                                                                                                                                                        (26)
    # Was this function wrapped by a decorator?===========================================(27)      
    if follow_wrapper_chains:=============================================================(28)      
        obj = unwrap(obj, stop=(lambda f: hasattr(f, "__signature__")))===================(29)      
        if isinstance(obj, types.MethodType):=============================================(30)      
            # If the unwrapped object is a *method*, we might want to=====================(31)      
            # skip its first parameter (self).============================================(32)      
                                                                                                                                     part No.1 out of 6 parts</code></pre>
</div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb31"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> fastcore.meta <span class="im">import</span> delegates</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb32"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> low(a, b<span class="op">=</span><span class="dv">1</span>): <span class="cf">pass</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a><span class="at">@delegates</span>(low)</span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> mid(c, d<span class="op">=</span><span class="dv">1</span>, <span class="op">**</span>kwargs): <span class="cf">pass</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell column-screen">
<div class="sourceCode cell-code" id="cb33"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a>dbsig <span class="op">=</span> sig.dbprint(<span class="dv">28</span>, <span class="st">"does Foo has __signature__?"</span>, <span class="st">"follow_wrapper_chains"</span>, <span class="op">\</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>            <span class="st">"obj = unwrap(obj, stop=(lambda f: hasattr(f, '__signature__')))"</span>, <span class="st">"isinstance(obj, types.MethodType)"</span>)</span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a><span class="co"># inspect._signature_from_callable = _signature_from_callable</span></span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a>inspect._signature_from_callable <span class="op">=</span> dbsig</span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a><span class="co"># inspect._signature_from_callable = g['_signature_from_callable']</span></span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true" tabindex="-1"></a>inspect.signature(mid)</span>
<span id="cb33-9"><a href="#cb33-9" aria-hidden="true" tabindex="-1"></a>sig.<span class="bu">print</span>(part<span class="op">=</span><span class="dv">1</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>                                                                                                                                                        (26)
    # Was this function wrapped by a decorator?                                                                                                         (27)
    if follow_wrapper_chains:===========================================================================================================================(28)
                                                                                                                                  does Foo has __signature__?
        obj = unwrap(obj, stop=(lambda f: hasattr(f, "__signature__")))                                                                                 (29)
        if isinstance(obj, types.MethodType):                                                                                                           (30)


                                                                                                        follow_wrapper_chains =&gt; follow_wrapper_chains : True


                                                        obj = unwrap(obj, stop=(lambda f: hasattr(f, '__signature__'))) =&gt; obj: &lt;function mid at 0x1074ee550&gt;


                                                                               isinstance(obj, types.MethodType) =&gt; isinstance(obj, types.MethodType) : False
def _signature_from_callable(obj, *,======================================================(0)       
                             follow_wrapper_chains=True,==================================(1)       
                             skip_bound_arg=True,=========================================(2)       
                             sigcls):=====================================================(3)       
                                                                                                                                                        (4)
    """Private helper function to get signature for arbitrary=============================(5)       
    callable objects.=====================================================================(6)       
    """===================================================================================(7)       
                                                                                                                                                        (8)
    _get_signature_of = functools.partial(_signature_from_callable,=======================(9) # so that it can use in itself
                                follow_wrapper_chains=follow_wrapper_chains,==============(10)      
                                skip_bound_arg=skip_bound_arg,============================(11)      
                                sigcls=sigcls)============================================(12)      
                                                                                                                                                        (13)
    if not callable(obj):=================================================================(14) # obj must be callable
        raise TypeError('{!r} is not a callable object'.format(obj))======================(15)      
                                                                                                                                                        (16)
    if isinstance(obj, types.MethodType):=================================================(17) # obj can be a classmethod
        # In this case we skip the first parameter of the underlying======================(18)      
        # function (usually `self` or `cls`).=============================================(19)      
        sig = _get_signature_of(obj.__func__)=============================================(20)      
                                                                                                                                                        (21)
        if skip_bound_arg:================================================================(22)      
            return _signature_bound_method(sig)===========================================(23)      
        else:=============================================================================(24)      
            return sig====================================================================(25)      
                                                                                                                                                        (26)
    # Was this function wrapped by a decorator?===========================================(27)      
    if follow_wrapper_chains:=============================================================(28) # does Foo has __signature__?
        obj = unwrap(obj, stop=(lambda f: hasattr(f, "__signature__")))===================(29)      
        if isinstance(obj, types.MethodType):=============================================(30)      
            # If the unwrapped object is a *method*, we might want to=====================(31)      
            # skip its first parameter (self).============================================(32)      
                                                                                                                                     part No.1 out of 6 parts</code></pre>
</div>
</div>
<div class="cell column-screen">
<div class="sourceCode cell-code" id="cb35"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a>dbsig <span class="op">=</span> sig.dbprint(<span class="dv">37</span>, <span class="st">"check __signature__"</span>, <span class="st">"obj = unwrap(obj, stop=(lambda f: hasattr(f, '__signature__')))"</span>, <span class="st">"obj.__signature__"</span>)</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>inspect._signature_from_callable <span class="op">=</span> dbsig</span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>inspect.signature(mid)</span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a>sig.<span class="bu">print</span>(part<span class="op">=</span><span class="dv">2</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>                                                                                                                                                        (35)
    try:                                                                                                                                                (36)
        sig = obj.__signature__=========================================================================================================================(37)
                                                                                                                                          check __signature__
    except AttributeError:                                                                                                                              (38)
        pass                                                                                                                                            (39)


                                                        obj = unwrap(obj, stop=(lambda f: hasattr(f, '__signature__'))) =&gt; obj: &lt;function mid at 0x1074ee550&gt;


                                                                                                    obj.__signature__ =&gt; obj.__signature__ : (c, d=1, *, b=1)
            # See test_signature_wrapped_bound_method for details.========================(33)      
            return _get_signature_of(obj)=================================================(34)      
                                                                                                                                                        (35)
    try:==================================================================================(36)      
        sig = obj.__signature__===========================================================(37) # check __signature__
    except AttributeError:================================================================(38)      
        pass==============================================================================(39)      
    else:=================================================================================(40)      
        if sig is not None:===============================================================(41)      
            if not isinstance(sig, Signature):============================================(42)      
                raise TypeError(==========================================================(43)      
                    'unexpected object {!r} in __signature__ '============================(44)      
                    'attribute'.format(sig))==============================================(45)      
            return sig====================================================================(46)      
                                                                                                                                                        (47)
    try:==================================================================================(48)      
        partialmethod = obj._partialmethod================================================(49)      
    except AttributeError:================================================================(50)      
        pass==============================================================================(51)      
    else:=================================================================================(52)      
        if isinstance(partialmethod, functools.partialmethod):============================(53)      
            # Unbound partialmethod (see functools.partialmethod)=========================(54)      
            # This means, that we need to calculate the signature=========================(55)      
            # as if it's a regular partial object, but taking into========================(56)      
            # account that the first positional argument==================================(57)      
            # (usually `self`, or `cls`) will not be passed===============================(58)      
            # automatically (as for boundmethods)=========================================(59)      
                                                                                                                                                        (60)
            wrapped_sig = _get_signature_of(partialmethod.func)===========================(61)      
                                                                                                                                                        (62)
            sig = _signature_get_partial(wrapped_sig, partialmethod, (None,))=============(63)      
            first_wrapped_param = tuple(wrapped_sig.parameters.values())[0]===============(64)      
            if first_wrapped_param.kind is Parameter.VAR_POSITIONAL:======================(65)      
                                                                                                                                     part No.2 out of 6 parts</code></pre>
</div>
</div>
</section>
<section id="how-exactly-foo-get-sig-from-__init__" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="how-exactly-foo-get-sig-from-__init__">How exactly Foo get sig from <code>__init__</code></h3>
<div class="cell column-screen">
<div class="sourceCode cell-code" id="cb37"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a>dbsig <span class="op">=</span> sig.dbprint(<span class="dv">91</span>, <span class="st">"step 1: obj is a class?"</span>, <span class="st">"isinstance(obj, type)"</span>)</span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>inspect._signature_from_callable <span class="op">=</span> dbsig</span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a>inspect.signature(Foo)</span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a>sig.<span class="bu">print</span>(part<span class="op">=</span><span class="dv">3</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>                                                                                                                                                        (89)
    sig = None                                                                                                                                          (90)
    if isinstance(obj, type):===========================================================================================================================(91)
                                                                                                                                      step 1: obj is a class?
        # obj is a class or a metaclass                                                                                                                 (92)
                                                                                                                                                        (93)


                                                                                                        isinstance(obj, type) =&gt; isinstance(obj, type) : True
                # First argument of the wrapped callable is `*args`, as in================(66)      
                # `partialmethod(lambda *args)`.==========================================(67)      
                return sig================================================================(68)      
            else:=========================================================================(69)      
                sig_params = tuple(sig.parameters.values())===============================(70)      
                assert (not sig_params or=================================================(71)      
                        first_wrapped_param is not sig_params[0])=========================(72)      
                new_params = (first_wrapped_param,) + sig_params==========================(73)      
                return sig.replace(parameters=new_params)=================================(74)      
                                                                                                                                                        (75)
    if isfunction(obj) or _signature_is_functionlike(obj):================================(76)      
        # If it's a pure Python function, or an object that is duck type==================(77)      
        # of a Python function (Cython functions, for instance), then:====================(78)      
        return _signature_from_function(sigcls, obj,======================================(79)      
                                        skip_bound_arg=skip_bound_arg)====================(80)      
                                                                                                                                                        (81)
    if _signature_is_builtin(obj):========================================================(82)      
        return _signature_from_builtin(sigcls, obj,=======================================(83)      
                                       skip_bound_arg=skip_bound_arg)=====================(84)      
                                                                                                                                                        (85)
    if isinstance(obj, functools.partial):================================================(86)      
        wrapped_sig = _get_signature_of(obj.func)=========================================(87)      
        return _signature_get_partial(wrapped_sig, obj)===================================(88)      
                                                                                                                                                        (89)
    sig = None============================================================================(90)      
    if isinstance(obj, type):=============================================================(91) # step 1: obj is a class?
        # obj is a class or a metaclass===================================================(92)      
                                                                                                                                                        (93)
        # First, let's see if it has an overloaded __call__ defined=======================(94)      
        # in its metaclass================================================================(95)      
        call = _signature_get_user_defined_method(type(obj), '__call__')==================(96)      
        if call is not None:==============================================================(97)      
            sig = _get_signature_of(call)=================================================(98)      
                                                                                                                                     part No.3 out of 6 parts</code></pre>
</div>
</div>
<div class="cell column-screen">
<div class="sourceCode cell-code" id="cb39"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a>dbsig <span class="op">=</span> sig.dbprint(<span class="dv">96</span>, <span class="st">"step 2: define its own __call__?"</span>, <span class="st">"call = _signature_get_user_defined_method(type(obj), '__call__')"</span>)</span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>inspect._signature_from_callable <span class="op">=</span> dbsig</span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a>inspect.signature(Foo)</span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a>sig.<span class="bu">print</span>(part<span class="op">=</span><span class="dv">3</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>        # First, let's see if it has an overloaded __call__ defined                                                                                     (94)
        # in its metaclass                                                                                                                              (95)
        call = _signature_get_user_defined_method(type(obj), '__call__')================================================================================(96)
                                                                                                                             step 2: define its own __call__?
        if call is not None:                                                                                                                            (97)
            sig = _get_signature_of(call)                                                                                                               (98)


                                                                               call = _signature_get_user_defined_method(type(obj), '__call__') =&gt; call: None
                # First argument of the wrapped callable is `*args`, as in================(66)      
                # `partialmethod(lambda *args)`.==========================================(67)      
                return sig================================================================(68)      
            else:=========================================================================(69)      
                sig_params = tuple(sig.parameters.values())===============================(70)      
                assert (not sig_params or=================================================(71)      
                        first_wrapped_param is not sig_params[0])=========================(72)      
                new_params = (first_wrapped_param,) + sig_params==========================(73)      
                return sig.replace(parameters=new_params)=================================(74)      
                                                                                                                                                        (75)
    if isfunction(obj) or _signature_is_functionlike(obj):================================(76)      
        # If it's a pure Python function, or an object that is duck type==================(77)      
        # of a Python function (Cython functions, for instance), then:====================(78)      
        return _signature_from_function(sigcls, obj,======================================(79)      
                                        skip_bound_arg=skip_bound_arg)====================(80)      
                                                                                                                                                        (81)
    if _signature_is_builtin(obj):========================================================(82)      
        return _signature_from_builtin(sigcls, obj,=======================================(83)      
                                       skip_bound_arg=skip_bound_arg)=====================(84)      
                                                                                                                                                        (85)
    if isinstance(obj, functools.partial):================================================(86)      
        wrapped_sig = _get_signature_of(obj.func)=========================================(87)      
        return _signature_get_partial(wrapped_sig, obj)===================================(88)      
                                                                                                                                                        (89)
    sig = None============================================================================(90)      
    if isinstance(obj, type):=============================================================(91) # step 1: obj is a class?
        # obj is a class or a metaclass===================================================(92)      
                                                                                                                                                        (93)
        # First, let's see if it has an overloaded __call__ defined=======================(94)      
        # in its metaclass================================================================(95)      
        call = _signature_get_user_defined_method(type(obj), '__call__')==================(96) # step 2: define its own __call__?
        if call is not None:==============================================================(97)      
            sig = _get_signature_of(call)=================================================(98)      
                                                                                                                                     part No.3 out of 6 parts</code></pre>
</div>
</div>
<div class="cell column-screen">
<div class="sourceCode cell-code" id="cb41"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a>dbsig <span class="op">=</span> sig.dbprint(<span class="dv">101</span>, <span class="st">"step 3: define its own __new__?"</span>, <span class="st">"new = _signature_get_user_defined_method(obj, '__new__')"</span>)</span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a>inspect._signature_from_callable <span class="op">=</span> dbsig</span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a>inspect.signature(Foo)</span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a>sig.<span class="bu">print</span>(part<span class="op">=</span><span class="dv">4</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>        else:                                                                                                                                           (99)
            factory_method = None                                                                                                                       (100)
            new = _signature_get_user_defined_method(obj, '__new__')====================================================================================(101)
                                                                                                                              step 3: define its own __new__?
            init = _signature_get_user_defined_method(obj, '__init__')                                                                                  (102)
            # Now we check if the 'obj' class has an own '__new__' method                                                                               (103)


                                                                                        new = _signature_get_user_defined_method(obj, '__new__') =&gt; new: None
        else:=============================================================================(99)      
            factory_method = None=========================================================(100)     
            new = _signature_get_user_defined_method(obj, '__new__')======================(101) # step 3: define its own __new__?
            init = _signature_get_user_defined_method(obj, '__init__')====================(102)     
            # Now we check if the 'obj' class has an own '__new__' method=================(103)     
            if '__new__' in obj.__dict__:=================================================(104)     
                factory_method = new======================================================(105)     
            # or an own '__init__' method=================================================(106)     
            elif '__init__' in obj.__dict__:==============================================(107)     
                factory_method = init=====================================================(108)     
            # If not, we take inherited '__new__' or '__init__', if present===============(109)     
            elif new is not None:=========================================================(110)     
                factory_method = new======================================================(111)     
            elif init is not None:========================================================(112)     
                factory_method = init=====================================================(113)     
                                                                                                                                                        (114)
            if factory_method is not None:================================================(115)     
                sig = _get_signature_of(factory_method)===================================(116)     
                                                                                                                                                        (117)
        if sig is None:===================================================================(118)     
            # At this point we know, that `obj` is a class, with no user-=================(119)     
            # defined '__init__', '__new__', or class-level '__call__'====================(120)     
                                                                                                                                                        (121)
            for base in obj.__mro__[:-1]:=================================================(122)     
                # Since '__text_signature__' is implemented as a==========================(123)     
                # descriptor that extracts text signature from the========================(124)     
                # class docstring, if 'obj' is derived from a builtin=====================(125)     
                # class, its own '__text_signature__' may be 'None'.======================(126)     
                # Therefore, we go through the MRO (except the last=======================(127)     
                # class in there, which is 'object') to find the first====================(128)     
                # class with non-empty text signature.====================================(129)     
                try:======================================================================(130)     
                    text_sig = base.__text_signature__====================================(131)     
                                                                                                                                     part No.4 out of 6 parts</code></pre>
</div>
</div>
<div class="cell column-screen">
<div class="sourceCode cell-code" id="cb43"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a>sig.dbprint(<span class="dv">102</span>, <span class="st">"step 4: define its own __init__?"</span>, <span class="st">"init = _signature_get_user_defined_method(obj, '__init__')"</span>)</span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a>inspect._signature_from_callable <span class="op">=</span> dbsig</span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a>inspect.signature(Foo)</span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a>sig.<span class="bu">print</span>(part<span class="op">=</span><span class="dv">4</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>            factory_method = None                                                                                                                       (100)
            new = _signature_get_user_defined_method(obj, '__new__')                                                                                    (101)
            init = _signature_get_user_defined_method(obj, '__init__')==================================================================================(102)
                                                                                                                             step 4: define its own __init__?
            # Now we check if the 'obj' class has an own '__new__' method                                                                               (103)
            if '__new__' in obj.__dict__:                                                                                                               (104)


                                                                                        new = _signature_get_user_defined_method(obj, '__new__') =&gt; new: None
        else:=============================================================================(99)      
            factory_method = None=========================================================(100)     
            new = _signature_get_user_defined_method(obj, '__new__')======================(101) # step 3: define its own __new__?
            init = _signature_get_user_defined_method(obj, '__init__')====================(102) # step 4: define its own __init__?
            # Now we check if the 'obj' class has an own '__new__' method=================(103)     
            if '__new__' in obj.__dict__:=================================================(104)     
                factory_method = new======================================================(105)     
            # or an own '__init__' method=================================================(106)     
            elif '__init__' in obj.__dict__:==============================================(107)     
                factory_method = init=====================================================(108)     
            # If not, we take inherited '__new__' or '__init__', if present===============(109)     
            elif new is not None:=========================================================(110)     
                factory_method = new======================================================(111)     
            elif init is not None:========================================================(112)     
                factory_method = init=====================================================(113)     
                                                                                                                                                        (114)
            if factory_method is not None:================================================(115)     
                sig = _get_signature_of(factory_method)===================================(116)     
                                                                                                                                                        (117)
        if sig is None:===================================================================(118)     
            # At this point we know, that `obj` is a class, with no user-=================(119)     
            # defined '__init__', '__new__', or class-level '__call__'====================(120)     
                                                                                                                                                        (121)
            for base in obj.__mro__[:-1]:=================================================(122)     
                # Since '__text_signature__' is implemented as a==========================(123)     
                # descriptor that extracts text signature from the========================(124)     
                # class docstring, if 'obj' is derived from a builtin=====================(125)     
                # class, its own '__text_signature__' may be 'None'.======================(126)     
                # Therefore, we go through the MRO (except the last=======================(127)     
                # class in there, which is 'object') to find the first====================(128)     
                # class with non-empty text signature.====================================(129)     
                try:======================================================================(130)     
                    text_sig = base.__text_signature__====================================(131)     
                                                                                                                                     part No.4 out of 6 parts</code></pre>
</div>
</div>
<div class="cell column-screen">
<div class="sourceCode cell-code" id="cb45"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a>sig.dbprint(<span class="dv">108</span>, <span class="st">"step 5: __init__ is inside obj.__dict__?"</span>, <span class="st">"'__init__' in obj.__dict__"</span>)</span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a>inspect._signature_from_callable <span class="op">=</span> dbsig</span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a>inspect.signature(Foo)</span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a>sig.<span class="bu">print</span>(part<span class="op">=</span><span class="dv">4</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>            # or an own '__init__' method                                                                                                               (106)
            elif '__init__' in obj.__dict__:                                                                                                            (107)
                factory_method = init===================================================================================================================(108)
                                                                                                                     step 5: __init__ is inside obj.__dict__?
            # If not, we take inherited '__new__' or '__init__', if present                                                                             (109)
            elif new is not None:                                                                                                                       (110)


                                                                                        new = _signature_get_user_defined_method(obj, '__new__') =&gt; new: None
        else:=============================================================================(99)      
            factory_method = None=========================================================(100)     
            new = _signature_get_user_defined_method(obj, '__new__')======================(101) # step 3: define its own __new__?
            init = _signature_get_user_defined_method(obj, '__init__')====================(102) # step 4: define its own __init__?
            # Now we check if the 'obj' class has an own '__new__' method=================(103)     
            if '__new__' in obj.__dict__:=================================================(104)     
                factory_method = new======================================================(105)     
            # or an own '__init__' method=================================================(106)     
            elif '__init__' in obj.__dict__:==============================================(107)     
                factory_method = init=====================================================(108) # step 5: __init__ is inside obj.__dict__?
            # If not, we take inherited '__new__' or '__init__', if present===============(109)     
            elif new is not None:=========================================================(110)     
                factory_method = new======================================================(111)     
            elif init is not None:========================================================(112)     
                factory_method = init=====================================================(113)     
                                                                                                                                                        (114)
            if factory_method is not None:================================================(115)     
                sig = _get_signature_of(factory_method)===================================(116)     
                                                                                                                                                        (117)
        if sig is None:===================================================================(118)     
            # At this point we know, that `obj` is a class, with no user-=================(119)     
            # defined '__init__', '__new__', or class-level '__call__'====================(120)     
                                                                                                                                                        (121)
            for base in obj.__mro__[:-1]:=================================================(122)     
                # Since '__text_signature__' is implemented as a==========================(123)     
                # descriptor that extracts text signature from the========================(124)     
                # class docstring, if 'obj' is derived from a builtin=====================(125)     
                # class, its own '__text_signature__' may be 'None'.======================(126)     
                # Therefore, we go through the MRO (except the last=======================(127)     
                # class in there, which is 'object') to find the first====================(128)     
                # class with non-empty text signature.====================================(129)     
                try:======================================================================(130)     
                    text_sig = base.__text_signature__====================================(131)     
                                                                                                                                     part No.4 out of 6 parts</code></pre>
</div>
</div>
<div class="cell page-columns page-full">
<div class="sourceCode cell-code" id="cb47"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a>dbsig <span class="op">=</span> sig.dbprint(<span class="dv">116</span>, <span class="st">"step 6: run on itself using functools.partial"</span>, <span class="st">"sig = _get_signature_of(factory_method)"</span>)</span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a>inspect._signature_from_callable <span class="op">=</span> dbsig</span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a>inspect.signature(Foo)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>                                                                                                                                                        (114)
            if factory_method is not None:                                                                                                              (115)
                sig = _get_signature_of(factory_method)=================================================================================================(116)
                                                                                                                step 6: run on itself using functools.partial
                                                                                                                                                        (117)
        if sig is None:                                                                                                                                 (118)


                                                                                              sig = _get_signature_of(factory_method) =&gt; sig: (self, a, b, c)</code></pre>
</div>
<div class="cell-output cell-output-display column-screen">
<pre><code>&lt;Signature (a, b, c)&gt;</code></pre>
</div>
</div>
<div class="cell page-columns page-full">
<div class="sourceCode cell-code" id="cb50"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a>dbsig <span class="op">=</span> sig.dbprint(<span class="dv">76</span>, <span class="st">"step 7: run on itself will run here"</span>, <span class="st">"isfunction(obj)"</span>, <span class="st">"_signature_is_functionlike(obj)"</span>)</span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a>inspect._signature_from_callable <span class="op">=</span> dbsig</span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a>inspect.signature(Foo.<span class="fu">__init__</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>                return sig.replace(parameters=new_params)                                                                                               (74)
                                                                                                                                                        (75)
    if isfunction(obj) or _signature_is_functionlike(obj):==============================================================================================(76)
                                                                                                                          step 7: run on itself will run here
        # If it's a pure Python function, or an object that is duck type                                                                                (77)
        # of a Python function (Cython functions, for instance), then:                                                                                  (78)


                                                                                                                    isfunction(obj) =&gt; isfunction(obj) : True


                                                                                    _signature_is_functionlike(obj) =&gt; _signature_is_functionlike(obj) : True</code></pre>
</div>
<div class="cell-output cell-output-display column-screen">
<pre><code>&lt;Signature (self, a, b, c)&gt;</code></pre>
</div>
</div>
<div class="cell page-columns page-full">
<div class="sourceCode cell-code" id="cb53"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a>dbsig <span class="op">=</span> sig.dbprint(<span class="dv">79</span>, <span class="st">"step 8: get sig with a different func"</span>, <span class="st">"env"</span>)</span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a>inspect._signature_from_callable <span class="op">=</span> dbsig</span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true" tabindex="-1"></a>inspect.signature(Foo)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>        # If it's a pure Python function, or an object that is duck type                                                                                (77)
        # of a Python function (Cython functions, for instance), then:                                                                                  (78)
        return _signature_from_function(sigcls, obj,====================================================================================================(79)
                                                                                                                        step 8: get sig with a different func
                                        skip_bound_arg=skip_bound_arg)                                                                                  (80)
                                                                                                                                                        (81)</code></pre>
</div>
<div class="cell-output cell-output-display column-screen">
<pre><code>&lt;Signature (a, b, c)&gt;</code></pre>
</div>
</div>
</section>
<section id="read-commented-_signature_from_callable-from-python-3.9" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="read-commented-_signature_from_callable-from-python-3.9">Read commented <code>_signature_from_callable</code> from python 3.9+</h3>
<div class="cell column-screen">
<div class="sourceCode cell-code" id="cb56"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a>sig.<span class="bu">print</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>def _signature_from_callable(obj, *,======================================================(0)       
                             follow_wrapper_chains=True,==================================(1)       
                             skip_bound_arg=True,=========================================(2)       
                             sigcls):=====================================================(3)       
                                                                                                                                                        (4)
    """Private helper function to get signature for arbitrary=============================(5)       
    callable objects.=====================================================================(6)       
    """===================================================================================(7)       
                                                                                                                                                        (8)
    _get_signature_of = functools.partial(_signature_from_callable,=======================(9) # so that it can use in itself
                                follow_wrapper_chains=follow_wrapper_chains,==============(10)      
                                skip_bound_arg=skip_bound_arg,============================(11)      
                                sigcls=sigcls)============================================(12)      
                                                                                                                                                        (13)
    if not callable(obj):=================================================================(14) # obj must be callable
        raise TypeError('{!r} is not a callable object'.format(obj))======================(15)      
                                                                                                                                                        (16)
    if isinstance(obj, types.MethodType):=================================================(17) # obj can be a classmethod
        # In this case we skip the first parameter of the underlying======================(18)      
        # function (usually `self` or `cls`).=============================================(19)      
        sig = _get_signature_of(obj.__func__)=============================================(20)      
                                                                                                                                                        (21)
        if skip_bound_arg:================================================================(22)      
            return _signature_bound_method(sig)===========================================(23)      
        else:=============================================================================(24)      
            return sig====================================================================(25)      
                                                                                                                                                        (26)
    # Was this function wrapped by a decorator?===========================================(27)      
    if follow_wrapper_chains:=============================================================(28) # does Foo has __signature__?
        obj = unwrap(obj, stop=(lambda f: hasattr(f, "__signature__")))===================(29)      
        if isinstance(obj, types.MethodType):=============================================(30)      
            # If the unwrapped object is a *method*, we might want to=====================(31)      
            # skip its first parameter (self).============================================(32)      
            # See test_signature_wrapped_bound_method for details.========================(33)      
            return _get_signature_of(obj)=================================================(34)      
                                                                                                                                                        (35)
    try:==================================================================================(36)      
        sig = obj.__signature__===========================================================(37) # check __signature__
    except AttributeError:================================================================(38)      
        pass==============================================================================(39)      
    else:=================================================================================(40)      
        if sig is not None:===============================================================(41)      
            if not isinstance(sig, Signature):============================================(42)      
                raise TypeError(==========================================================(43)      
                    'unexpected object {!r} in __signature__ '============================(44)      
                    'attribute'.format(sig))==============================================(45)      
            return sig====================================================================(46)      
                                                                                                                                                        (47)
    try:==================================================================================(48)      
        partialmethod = obj._partialmethod================================================(49)      
    except AttributeError:================================================================(50)      
        pass==============================================================================(51)      
    else:=================================================================================(52)      
        if isinstance(partialmethod, functools.partialmethod):============================(53)      
            # Unbound partialmethod (see functools.partialmethod)=========================(54)      
            # This means, that we need to calculate the signature=========================(55)      
            # as if it's a regular partial object, but taking into========================(56)      
            # account that the first positional argument==================================(57)      
            # (usually `self`, or `cls`) will not be passed===============================(58)      
            # automatically (as for boundmethods)=========================================(59)      
                                                                                                                                                        (60)
            wrapped_sig = _get_signature_of(partialmethod.func)===========================(61)      
                                                                                                                                                        (62)
            sig = _signature_get_partial(wrapped_sig, partialmethod, (None,))=============(63)      
            first_wrapped_param = tuple(wrapped_sig.parameters.values())[0]===============(64)      
            if first_wrapped_param.kind is Parameter.VAR_POSITIONAL:======================(65)      
                # First argument of the wrapped callable is `*args`, as in================(66)      
                # `partialmethod(lambda *args)`.==========================================(67)      
                return sig================================================================(68)      
            else:=========================================================================(69)      
                sig_params = tuple(sig.parameters.values())===============================(70)      
                assert (not sig_params or=================================================(71)      
                        first_wrapped_param is not sig_params[0])=========================(72)      
                new_params = (first_wrapped_param,) + sig_params==========================(73)      
                return sig.replace(parameters=new_params)=================================(74)      
                                                                                                                                                        (75)
    if isfunction(obj) or _signature_is_functionlike(obj):================================(76) # step 7: run on itself will run here
        # If it's a pure Python function, or an object that is duck type==================(77)      
        # of a Python function (Cython functions, for instance), then:====================(78)      
        return _signature_from_function(sigcls, obj,======================================(79) # step 8: get sig with a different func
                                        skip_bound_arg=skip_bound_arg)====================(80)      
                                                                                                                                                        (81)
    if _signature_is_builtin(obj):========================================================(82)      
        return _signature_from_builtin(sigcls, obj,=======================================(83)      
                                       skip_bound_arg=skip_bound_arg)=====================(84)      
                                                                                                                                                        (85)
    if isinstance(obj, functools.partial):================================================(86)      
        wrapped_sig = _get_signature_of(obj.func)=========================================(87)      
        return _signature_get_partial(wrapped_sig, obj)===================================(88)      
                                                                                                                                                        (89)
    sig = None============================================================================(90)      
    if isinstance(obj, type):=============================================================(91) # step 1: obj is a class?
        # obj is a class or a metaclass===================================================(92)      
                                                                                                                                                        (93)
        # First, let's see if it has an overloaded __call__ defined=======================(94)      
        # in its metaclass================================================================(95)      
        call = _signature_get_user_defined_method(type(obj), '__call__')==================(96) # step 2: define its own __call__?
        if call is not None:==============================================================(97)      
            sig = _get_signature_of(call)=================================================(98)      
        else:=============================================================================(99)      
            factory_method = None=========================================================(100)     
            new = _signature_get_user_defined_method(obj, '__new__')======================(101) # step 3: define its own __new__?
            init = _signature_get_user_defined_method(obj, '__init__')====================(102) # step 4: define its own __init__?
            # Now we check if the 'obj' class has an own '__new__' method=================(103)     
            if '__new__' in obj.__dict__:=================================================(104)     
                factory_method = new======================================================(105)     
            # or an own '__init__' method=================================================(106)     
            elif '__init__' in obj.__dict__:==============================================(107)     
                factory_method = init=====================================================(108) # step 5: __init__ is inside obj.__dict__?
            # If not, we take inherited '__new__' or '__init__', if present===============(109)     
            elif new is not None:=========================================================(110)     
                factory_method = new======================================================(111)     
            elif init is not None:========================================================(112)     
                factory_method = init=====================================================(113)     
                                                                                                                                                        (114)
            if factory_method is not None:================================================(115)     
                sig = _get_signature_of(factory_method)===================================(116) # step 6: run on itself using functools.partial
                                                                                                                                                        (117)
        if sig is None:===================================================================(118)     
            # At this point we know, that `obj` is a class, with no user-=================(119)     
            # defined '__init__', '__new__', or class-level '__call__'====================(120)     
                                                                                                                                                        (121)
            for base in obj.__mro__[:-1]:=================================================(122)     
                # Since '__text_signature__' is implemented as a==========================(123)     
                # descriptor that extracts text signature from the========================(124)     
                # class docstring, if 'obj' is derived from a builtin=====================(125)     
                # class, its own '__text_signature__' may be 'None'.======================(126)     
                # Therefore, we go through the MRO (except the last=======================(127)     
                # class in there, which is 'object') to find the first====================(128)     
                # class with non-empty text signature.====================================(129)     
                try:======================================================================(130)     
                    text_sig = base.__text_signature__====================================(131)     
                except AttributeError:====================================================(132)     
                    pass==================================================================(133)     
                else:=====================================================================(134)     
                    if text_sig:==========================================================(135)     
                        # If 'base' class has a __text_signature__ attribute:=============(136)     
                        # return a signature based on it==================================(137)     
                        return _signature_fromstr(sigcls, base, text_sig)=================(138)     
                                                                                                                                                        (139)
            # No '__text_signature__' was found for the 'obj' class.======================(140)     
            # Last option is to check if its '__init__' is================================(141)     
            # object.__init__ or type.__init__.===========================================(142)     
            if type not in obj.__mro__:===================================================(143)     
                # We have a class (not metaclass), but no user-defined====================(144)     
                # __init__ or __new__ for it==============================================(145)     
                if (obj.__init__ is object.__init__ and===================================(146)     
                    obj.__new__ is object.__new__):=======================================(147)     
                    # Return a signature of 'object' builtin.=============================(148)     
                    return sigcls.from_callable(object)===================================(149)     
                else:=====================================================================(150)     
                    raise ValueError(=====================================================(151)     
                        'no signature found for builtin type {!r}'.format(obj))===========(152)     
                                                                                                                                                        (153)
    elif not isinstance(obj, _NonUserDefinedCallables):===================================(154)     
        # An object with __call__=========================================================(155)     
        # We also check that the 'obj' is not an instance of==============================(156)     
        # _WrapperDescriptor or _MethodWrapper to avoid===================================(157)     
        # infinite recursion (and even potential segfault)================================(158)     
        call = _signature_get_user_defined_method(type(obj), '__call__')==================(159)     
        if call is not None:==============================================================(160)     
            try:==========================================================================(161)     
                sig = _get_signature_of(call)=============================================(162)     
            except ValueError as ex:======================================================(163)     
                msg = 'no signature found for {!r}'.format(obj)===========================(164)     
                raise ValueError(msg) from ex=============================================(165)     
                                                                                                                                                        (166)
    if sig is not None:===================================================================(167)     
        # For classes and objects we skip the first parameter of their====================(168)     
        # __call__, __new__, or __init__ methods==========================================(169)     
        if skip_bound_arg:================================================================(170)     
            return _signature_bound_method(sig)===========================================(171)     
        else:=============================================================================(172)     
            return sig====================================================================(173)     
                                                                                                                                                        (174)
    if isinstance(obj, types.BuiltinFunctionType):========================================(175)     
        # Raise a nicer error message for builtins========================================(176)     
        msg = 'no signature found for builtin function {!r}'.format(obj)==================(177)     
        raise ValueError(msg)=============================================================(178)     
                                                                                                                                                        (179)
    raise ValueError('callable {!r} is not supported by signature'.format(obj))===========(180)     
                                                                                                                                                        (181)</code></pre>
</div>
</div>
</section>
</section>
<section id="foos-super-class-overriding-__new__-can-stop-foo-getting-sig-from-__init__" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="foos-super-class-overriding-__new__-can-stop-foo-getting-sig-from-__init__">Foo’s super class overriding <code>__new__</code> can stop Foo getting sig from <code>__init__</code></h2>
<p>Many things can go wrong to prevent a class to use the signature from <code>__init__</code>.</p>
<p>FixSigMeta is a metaclass, which helps us to get our classes’ signature right.</p>
<p>Then what types of the signature problems can FixSigMeta fix?</p>
<section id="when-foos-super-class-override-__new__-python3.7-cant-give-foo-sig-from-__init__" class="level3">
<h3 class="anchored" data-anchor-id="when-foos-super-class-override-__new__-python3.7-cant-give-foo-sig-from-__init__">When Foo’s super class override <code>__new__</code>, python3.7 can’t give Foo sig from <code>__init__</code></h3>
<ol type="1">
<li>when your class Foo inherits from class Base, if Base defines its <code>__new__</code>, then Foo can’t get signature from <code>__init__</code>. (True for python 3.7 see <a href="https://www.kaggle.com/code/danielliao/notebook3edc928f49?scriptVersionId=104385507&amp;cellId=1">demos</a>, no more for 3.9+)</li>
</ol>
<div class="cell">
<div class="sourceCode cell-code" id="cb58"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Base: <span class="co"># pass</span></span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__new__</span>(<span class="va">self</span>, <span class="op">**</span>args): <span class="cf">pass</span>  <span class="co"># defines a __new__ </span></span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-4"><a href="#cb58-4" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Foo(Base):</span>
<span id="cb58-5"><a href="#cb58-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, d, e, f): <span class="cf">pass</span></span>
<span id="cb58-6"><a href="#cb58-6" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb58-7"><a href="#cb58-7" aria-hidden="true" tabindex="-1"></a>inspect._signature_from_callable <span class="op">=</span> sig.orisrc</span>
<span id="cb58-8"><a href="#cb58-8" aria-hidden="true" tabindex="-1"></a>inspect.signature(Foo) <span class="co"># no more problem for python 3.9+,</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<pre><code>&lt;Signature (d, e, f)&gt;</code></pre>
</div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb60"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a><span class="co"># from IPython.display import IFrame</span></span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-3"><a href="#cb60-3" aria-hidden="true" tabindex="-1"></a><span class="co"># IFrame(src="https://www.kaggle.com/embed/danielliao/notebook3edc928f49?cellIds=2&amp;kernelSessionId=104407182", width = "1200", height="300", \</span></span>
<span id="cb60-4"><a href="#cb60-4" aria-hidden="true" tabindex="-1"></a><span class="co">#        style="margin: 0 auto; width: 100%; max-width: 950px;", frameborder="0", scrolling="auto", title="notebook3edc928f49")</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb61"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a>inspect._signature_from_callable <span class="op">=</span> _signature_from_callableOld</span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a>inspect.signature(Foo) <span class="co"># it is a problem for python 3.7,</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<pre><code>&lt;Signature (**args)&gt;</code></pre>
</div>
</div>
</section>
<section id="how-python3.7-and-its-inspect-mess-it-up" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="how-python3.7-and-its-inspect-mess-it-up">How python3.7 and its inspect mess it up</h3>
<div class="cell">
<div class="sourceCode cell-code" id="cb63"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a><span class="co"># g = locals()</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb64"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a>sigOld <span class="op">=</span> Fastdb(_signature_from_callableOld, g)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell column-screen">
<div class="sourceCode cell-code" id="cb65"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a>dbsigOld <span class="op">=</span> sigOld.dbprint(<span class="dv">115</span>, <span class="st">"messup step 1: overriding __new__ is detected"</span>, <span class="st">"new = _signature_get_user_defined_method(obj, '__new__')"</span>)</span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true" tabindex="-1"></a>inspect._signature_from_callable <span class="op">=</span> dbsigOld </span>
<span id="cb65-3"><a href="#cb65-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(inspect.signature(Foo)) <span class="co"># it is a problem for python 3.7, </span></span>
<span id="cb65-4"><a href="#cb65-4" aria-hidden="true" tabindex="-1"></a>sigOld.<span class="bu">print</span>(part<span class="op">=</span><span class="dv">4</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>        else:                                                                                                                                           (113)
            # Now we check if the 'obj' class has a '__new__' method                                                                                    (114)
            new = _signature_get_user_defined_method(obj, '__new__')====================================================================================(115)
                                                                                                                messup step 1: overriding __new__ is detected
            if new is not None:                                                                                                                         (116)
                sig = _signature_from_callable(                                                                                                         (117)


                                                      new = _signature_get_user_defined_method(obj, '__new__') =&gt; new: &lt;function Base.__new__ at 0x1074eee50&gt;
(**args)
                                                                                                                                                        (99)
    sig = None============================================================================(100)     
    if isinstance(obj, type):=============================================================(101)     
        # obj is a class or a metaclass===================================================(102)     
                                                                                                                                                        (103)
        # First, let's see if it has an overloaded __call__ defined=======================(104)     
        # in its metaclass================================================================(105)     
        call = _signature_get_user_defined_method(type(obj), '__call__')==================(106)     
        if call is not None:==============================================================(107)     
            sig = _signature_from_callable(===============================================(108)     
                call,=====================================================================(109)     
                follow_wrapper_chains=follow_wrapper_chains,==============================(110)     
                skip_bound_arg=skip_bound_arg,============================================(111)     
                sigcls=sigcls)============================================================(112)     
        else:=============================================================================(113)     
            # Now we check if the 'obj' class has a '__new__' method======================(114)     
            new = _signature_get_user_defined_method(obj, '__new__')======================(115) # messup step 1: overriding __new__ is detected
            if new is not None:===========================================================(116)     
                sig = _signature_from_callable(===========================================(117)     
                    new,==================================================================(118)     
                    follow_wrapper_chains=follow_wrapper_chains,==========================(119)     
                    skip_bound_arg=skip_bound_arg,========================================(120)     
                    sigcls=sigcls)========================================================(121)     
            else:=========================================================================(122)     
                # Finally, we should have at least __init__ implemented===================(123)     
                init = _signature_get_user_defined_method(obj, '__init__')================(124)     
                if init is not None:======================================================(125)     
                    sig = _signature_from_callable(=======================================(126)     
                        init,=============================================================(127)     
                        follow_wrapper_chains=follow_wrapper_chains,======================(128)     
                        skip_bound_arg=skip_bound_arg,====================================(129)     
                        sigcls=sigcls)====================================================(130)     
                                                                                                                                                        (131)
                                                                                                                                     part No.4 out of 7 parts</code></pre>
</div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb67"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pprint <span class="im">import</span> pprint</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell column-screen">
<div class="sourceCode cell-code" id="cb68"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true" tabindex="-1"></a>dbsigOld <span class="op">=</span> sigOld.dbprint(<span class="dv">117</span>, <span class="st">"messup step 2: only __new__ sig is extracted"</span>, <span class="st">"env"</span>)</span>
<span id="cb68-2"><a href="#cb68-2" aria-hidden="true" tabindex="-1"></a>inspect._signature_from_callable <span class="op">=</span> dbsigOld </span>
<span id="cb68-3"><a href="#cb68-3" aria-hidden="true" tabindex="-1"></a>pprint(inspect.signature(Foo)) <span class="co"># it is a problem for python 3.7, </span></span>
<span id="cb68-4"><a href="#cb68-4" aria-hidden="true" tabindex="-1"></a>sigOld.<span class="bu">print</span>(part<span class="op">=</span><span class="dv">4</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>            new = _signature_get_user_defined_method(obj, '__new__')                                                                                    (115)
            if new is not None:                                                                                                                         (116)
                sig = _signature_from_callable(=========================================================================================================(117)
                                                                                                                 messup step 2: only __new__ sig is extracted
                    new,                                                                                                                                (118)
                    follow_wrapper_chains=follow_wrapper_chains,                                                                                        (119)


env =&gt; env : {'obj': &lt;class '__main__.Foo'&gt;, 'follow_wrapper_chains': True, 'skip_bound_arg': True, 'sigcls': &lt;class 'inspect.Signature'&gt;, 'sig': None, 'call': None, 'new': &lt;function Base.__new__ at 0x1074eee50&gt;}
&lt;Signature (**args)&gt;
                                                                                                                                                        (99)
    sig = None============================================================================(100)     
    if isinstance(obj, type):=============================================================(101)     
        # obj is a class or a metaclass===================================================(102)     
                                                                                                                                                        (103)
        # First, let's see if it has an overloaded __call__ defined=======================(104)     
        # in its metaclass================================================================(105)     
        call = _signature_get_user_defined_method(type(obj), '__call__')==================(106)     
        if call is not None:==============================================================(107)     
            sig = _signature_from_callable(===============================================(108)     
                call,=====================================================================(109)     
                follow_wrapper_chains=follow_wrapper_chains,==============================(110)     
                skip_bound_arg=skip_bound_arg,============================================(111)     
                sigcls=sigcls)============================================================(112)     
        else:=============================================================================(113)     
            # Now we check if the 'obj' class has a '__new__' method======================(114)     
            new = _signature_get_user_defined_method(obj, '__new__')======================(115) # messup step 1: overriding __new__ is detected
            if new is not None:===========================================================(116)     
                sig = _signature_from_callable(===========================================(117) # messup step 2: only __new__ sig is extracted
                    new,==================================================================(118)     
                    follow_wrapper_chains=follow_wrapper_chains,==========================(119)     
                    skip_bound_arg=skip_bound_arg,========================================(120)     
                    sigcls=sigcls)========================================================(121)     
            else:=========================================================================(122)     
                # Finally, we should have at least __init__ implemented===================(123)     
                init = _signature_get_user_defined_method(obj, '__init__')================(124)     
                if init is not None:======================================================(125)     
                    sig = _signature_from_callable(=======================================(126)     
                        init,=============================================================(127)     
                        follow_wrapper_chains=follow_wrapper_chains,======================(128)     
                        skip_bound_arg=skip_bound_arg,====================================(129)     
                        sigcls=sigcls)====================================================(130)     
                                                                                                                                                        (131)
                                                                                                                                     part No.4 out of 7 parts</code></pre>
</div>
</div>
<div class="cell column-screen">
<div class="sourceCode cell-code" id="cb70"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb70-1"><a href="#cb70-1" aria-hidden="true" tabindex="-1"></a>dbsigOld <span class="op">=</span> sigOld.dbprint(<span class="dv">124</span>, <span class="st">"messup step 3: __init__ don't even get accessed"</span>)</span>
<span id="cb70-2"><a href="#cb70-2" aria-hidden="true" tabindex="-1"></a>inspect._signature_from_callable <span class="op">=</span> dbsigOld </span>
<span id="cb70-3"><a href="#cb70-3" aria-hidden="true" tabindex="-1"></a>pprint(inspect.signature(Foo))</span>
<span id="cb70-4"><a href="#cb70-4" aria-hidden="true" tabindex="-1"></a>sigOld.<span class="bu">print</span>(part<span class="op">=</span><span class="dv">4</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>            else:                                                                                                                                       (122)
                # Finally, we should have at least __init__ implemented                                                                                 (123)
                init = _signature_get_user_defined_method(obj, '__init__')==============================================================================(124)
                                                                                                              messup step 3: __init__ don't even get accessed
                if init is not None:                                                                                                                    (125)
                    sig = _signature_from_callable(                                                                                                     (126)
&lt;Signature (**args)&gt;
                                                                                                                                                        (99)
    sig = None============================================================================(100)     
    if isinstance(obj, type):=============================================================(101)     
        # obj is a class or a metaclass===================================================(102)     
                                                                                                                                                        (103)
        # First, let's see if it has an overloaded __call__ defined=======================(104)     
        # in its metaclass================================================================(105)     
        call = _signature_get_user_defined_method(type(obj), '__call__')==================(106)     
        if call is not None:==============================================================(107)     
            sig = _signature_from_callable(===============================================(108)     
                call,=====================================================================(109)     
                follow_wrapper_chains=follow_wrapper_chains,==============================(110)     
                skip_bound_arg=skip_bound_arg,============================================(111)     
                sigcls=sigcls)============================================================(112)     
        else:=============================================================================(113)     
            # Now we check if the 'obj' class has a '__new__' method======================(114)     
            new = _signature_get_user_defined_method(obj, '__new__')======================(115) # messup step 1: overriding __new__ is detected
            if new is not None:===========================================================(116)     
                sig = _signature_from_callable(===========================================(117) # messup step 2: only __new__ sig is extracted
                    new,==================================================================(118)     
                    follow_wrapper_chains=follow_wrapper_chains,==========================(119)     
                    skip_bound_arg=skip_bound_arg,========================================(120)     
                    sigcls=sigcls)========================================================(121)     
            else:=========================================================================(122)     
                # Finally, we should have at least __init__ implemented===================(123)     
                init = _signature_get_user_defined_method(obj, '__init__')================(124) # messup step 3: __init__ don't even get accessed
                if init is not None:======================================================(125)     
                    sig = _signature_from_callable(=======================================(126)     
                        init,=============================================================(127)     
                        follow_wrapper_chains=follow_wrapper_chains,======================(128)     
                        skip_bound_arg=skip_bound_arg,====================================(129)     
                        sigcls=sigcls)====================================================(130)     
                                                                                                                                                        (131)
                                                                                                                                     part No.4 out of 7 parts</code></pre>
</div>
</div>
</section>
<section id="fixsigmeta-can-fix-it-for-python-3.7-inspect" class="level3">
<h3 class="anchored" data-anchor-id="fixsigmeta-can-fix-it-for-python-3.7-inspect">FixSigMeta can fix it for python 3.7 inspect</h3>
<p>Solution to 1: By also inheriting from the metaclass FixSigMeta can solve the signature problem for Foo (for python 3.7)</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb72"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb72-1"><a href="#cb72-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> fastcore.meta <span class="im">import</span> FixSigMeta, test_sig</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb73"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb73-1"><a href="#cb73-1" aria-hidden="true" tabindex="-1"></a>inspect._signature_from_callable <span class="op">=</span> _signature_from_callableNew</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb74"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb74-1"><a href="#cb74-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Base: <span class="co"># pass</span></span>
<span id="cb74-2"><a href="#cb74-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__new__</span>(<span class="va">self</span>, <span class="op">**</span>args): <span class="cf">pass</span>  <span class="co"># defines a __new__ </span></span>
<span id="cb74-3"><a href="#cb74-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb74-4"><a href="#cb74-4" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Foo(Base, metaclass<span class="op">=</span>FixSigMeta):</span>
<span id="cb74-5"><a href="#cb74-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, d, e, f): <span class="cf">pass</span></span>
<span id="cb74-6"><a href="#cb74-6" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb74-7"><a href="#cb74-7" aria-hidden="true" tabindex="-1"></a>test_sig(Foo, <span class="st">'(d, e, f)'</span>)</span>
<span id="cb74-8"><a href="#cb74-8" aria-hidden="true" tabindex="-1"></a>inspect.signature(Foo)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<pre><code>&lt;Signature (d, e, f)&gt;</code></pre>
</div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb76"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb76-1"><a href="#cb76-1" aria-hidden="true" tabindex="-1"></a>inspect._signature_from_callable <span class="op">=</span> dbsigOld</span>
<span id="cb76-2"><a href="#cb76-2" aria-hidden="true" tabindex="-1"></a>inspect.signature(Foo) <span class="co"># No more a problem for python 3.7</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<pre><code>&lt;Signature (d, e, f)&gt;</code></pre>
</div>
</div>
</section>
<section id="how-fixsigmeta-fix-it" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="how-fixsigmeta-fix-it">How FixSigMeta fix it?</h3>
<div class="cell">
<div class="sourceCode cell-code" id="cb78"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb78-1"><a href="#cb78-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Base: <span class="co"># pass</span></span>
<span id="cb78-2"><a href="#cb78-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__new__</span>(<span class="va">self</span>, <span class="op">**</span>args): <span class="cf">pass</span>  <span class="co"># defines a __new__ </span></span>
<span id="cb78-3"><a href="#cb78-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-4"><a href="#cb78-4" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Foo(Base):</span>
<span id="cb78-5"><a href="#cb78-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, d, e, f): <span class="cf">pass</span></span>
<span id="cb78-6"><a href="#cb78-6" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb78-7"><a href="#cb78-7" aria-hidden="true" tabindex="-1"></a>inspect._signature_from_callable <span class="op">=</span> sigOld.orisrc</span>
<span id="cb78-8"><a href="#cb78-8" aria-hidden="true" tabindex="-1"></a>inspect.signature(Foo)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<pre><code>&lt;Signature (**args)&gt;</code></pre>
</div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb80"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb80-1"><a href="#cb80-1" aria-hidden="true" tabindex="-1"></a><span class="bu">hasattr</span>(Foo, <span class="st">'__signature__'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<pre><code>False</code></pre>
</div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb82"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb82-1"><a href="#cb82-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Base: <span class="co"># pass</span></span>
<span id="cb82-2"><a href="#cb82-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__new__</span>(<span class="va">self</span>, <span class="op">**</span>args): <span class="cf">pass</span>  <span class="co"># defines a __new__ </span></span>
<span id="cb82-3"><a href="#cb82-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-4"><a href="#cb82-4" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Foo(Base, metaclass<span class="op">=</span>FixSigMeta):</span>
<span id="cb82-5"><a href="#cb82-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, d, e, f): <span class="cf">pass</span></span>
<span id="cb82-6"><a href="#cb82-6" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb82-7"><a href="#cb82-7" aria-hidden="true" tabindex="-1"></a>test_sig(Foo, <span class="st">'(d, e, f)'</span>)</span>
<span id="cb82-8"><a href="#cb82-8" aria-hidden="true" tabindex="-1"></a>inspect.signature(Foo)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<pre><code>&lt;Signature (d, e, f)&gt;</code></pre>
</div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb84"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb84-1"><a href="#cb84-1" aria-hidden="true" tabindex="-1"></a>Foo.__signature__</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<pre><code>&lt;Signature (d, e, f)&gt;</code></pre>
</div>
</div>
<div class="cell column-screen">
<div class="sourceCode cell-code" id="cb86"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb86-1"><a href="#cb86-1" aria-hidden="true" tabindex="-1"></a>dbsigOld <span class="op">=</span> sigOld.dbprint(<span class="dv">27</span>, <span class="st">"FixSigMeta step 1: does it have __signature__"</span>, <span class="st">"env"</span>, <span class="st">"hasattr(obj, '__signature__')"</span>, <span class="op">\</span></span>
<span id="cb86-2"><a href="#cb86-2" aria-hidden="true" tabindex="-1"></a>               <span class="st">"obj = unwrap(obj, stop=(lambda f: hasattr(f, '__signature__')))"</span>, <span class="st">"inspect.getdoc(unwrap)"</span>)</span>
<span id="cb86-3"><a href="#cb86-3" aria-hidden="true" tabindex="-1"></a>inspect._signature_from_callable <span class="op">=</span> dbsigOld</span>
<span id="cb86-4"><a href="#cb86-4" aria-hidden="true" tabindex="-1"></a>pprint(inspect.signature(Foo)) </span>
<span id="cb86-5"><a href="#cb86-5" aria-hidden="true" tabindex="-1"></a>sigOld.<span class="bu">print</span>(part<span class="op">=</span><span class="dv">1</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>                                                                                                                                                        (25)
    # Was this function wrapped by a decorator?                                                                                                         (26)
    if follow_wrapper_chains:===========================================================================================================================(27)
                                                                                                                FixSigMeta step 1: does it have __signature__
        obj = unwrap(obj, stop=(lambda f: hasattr(f, "__signature__")))                                                                                 (28)
        if isinstance(obj, types.MethodType):                                                                                                           (29)


                   env =&gt; env : {'obj': &lt;class '__main__.Foo'&gt;, 'follow_wrapper_chains': True, 'skip_bound_arg': True, 'sigcls': &lt;class 'inspect.Signature'&gt;}


                                                                                        hasattr(obj, '__signature__') =&gt; hasattr(obj, '__signature__') : True


                                                               obj = unwrap(obj, stop=(lambda f: hasattr(f, '__signature__'))) =&gt; obj: &lt;class '__main__.Foo'&gt;


inspect.getdoc(unwrap) =&gt; inspect.getdoc(unwrap) : Get the object wrapped by *func*.

Follows the chain of :attr:`__wrapped__` attributes returning the last
object in the chain.

*stop* is an optional callback accepting an object in the wrapper chain
as its sole argument that allows the unwrapping to be terminated early if
the callback returns a true value. If the callback never returns a true
value, the last object in the chain is returned as usual. For example,
:func:`signature` uses this to stop unwrapping if any object in the
chain has a ``__signature__`` attribute defined.

:exc:`ValueError` is raised if a cycle is encountered.

 
&lt;Signature (d, e, f)&gt;
def _signature_from_callableOld(obj, *,===================================================(0)       
                             follow_wrapper_chains=True,==================================(1)       
                             skip_bound_arg=True,=========================================(2)       
                             sigcls):=====================================================(3)       
                                                                                                                                                        (4)
    """Private helper function to get signature for arbitrary=============================(5)       
    callable objects.=====================================================================(6)       
    """===================================================================================(7)       
                                                                                                                                                        (8)
    if not callable(obj):=================================================================(9)       
        raise TypeError('{!r} is not a callable object'.format(obj))======================(10)      
                                                                                                                                                        (11)
    if isinstance(obj, types.MethodType):=================================================(12)      
        # In this case we skip the first parameter of the underlying======================(13)      
        # function (usually `self` or `cls`).=============================================(14)      
        sig = _signature_from_callable(===================================================(15)      
            obj.__func__,=================================================================(16)      
            follow_wrapper_chains=follow_wrapper_chains,==================================(17)      
            skip_bound_arg=skip_bound_arg,================================================(18)      
            sigcls=sigcls)================================================================(19)      
                                                                                                                                                        (20)
        if skip_bound_arg:================================================================(21)      
            return _signature_bound_method(sig)===========================================(22)      
        else:=============================================================================(23)      
            return sig====================================================================(24)      
                                                                                                                                                        (25)
    # Was this function wrapped by a decorator?===========================================(26)      
    if follow_wrapper_chains:=============================================================(27) # FixSigMeta step 1: does it have __signature__
        obj = unwrap(obj, stop=(lambda f: hasattr(f, "__signature__")))===================(28)      
        if isinstance(obj, types.MethodType):=============================================(29)      
            # If the unwrapped object is a *method*, we might want to=====================(30)      
            # skip its first parameter (self).============================================(31)      
            # See test_signature_wrapped_bound_method for details.========================(32)      
                                                                                                                                     part No.1 out of 7 parts</code></pre>
</div>
</div>
<div class="cell column-screen">
<div class="sourceCode cell-code" id="cb88"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb88-1"><a href="#cb88-1" aria-hidden="true" tabindex="-1"></a>dbsigOld <span class="op">=</span> sigOld.dbprint(<span class="dv">44</span>, <span class="st">"FixSigMeta step 2: use __signature__ as Foo's sig"</span>, <span class="st">"env"</span>, <span class="st">"sig = obj.__signature__"</span>, <span class="st">"isinstance(sig, Signature)"</span>)</span>
<span id="cb88-2"><a href="#cb88-2" aria-hidden="true" tabindex="-1"></a>inspect._signature_from_callable <span class="op">=</span> dbsigOld</span>
<span id="cb88-3"><a href="#cb88-3" aria-hidden="true" tabindex="-1"></a>pprint(inspect.signature(Foo)) </span>
<span id="cb88-4"><a href="#cb88-4" aria-hidden="true" tabindex="-1"></a>sigOld.<span class="bu">print</span>(part<span class="op">=</span><span class="dv">2</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>        pass                                                                                                                                            (42)
    else:                                                                                                                                               (43)
        if sig is not None:=============================================================================================================================(44)
                                                                                                            FixSigMeta step 2: use __signature__ as Foo's sig
            if not isinstance(sig, Signature):                                                                                                          (45)
                raise TypeError(                                                                                                                        (46)


env =&gt; env : {'obj': &lt;class '__main__.Foo'&gt;, 'follow_wrapper_chains': True, 'skip_bound_arg': True, 'sigcls': &lt;class 'inspect.Signature'&gt;, 'sig': &lt;Signature (d, e, f)&gt;}


                                                                                                                    sig = obj.__signature__ =&gt; sig: (d, e, f)


                                                                                              isinstance(sig, Signature) =&gt; isinstance(sig, Signature) : True
&lt;Signature (d, e, f)&gt;
            return _signature_from_callable(==============================================(33)      
                obj,======================================================================(34)      
                follow_wrapper_chains=follow_wrapper_chains,==============================(35)      
                skip_bound_arg=skip_bound_arg,============================================(36)      
                sigcls=sigcls)============================================================(37)      
                                                                                                                                                        (38)
    try:==================================================================================(39)      
        sig = obj.__signature__===========================================================(40)      
    except AttributeError:================================================================(41)      
        pass==============================================================================(42)      
    else:=================================================================================(43)      
        if sig is not None:===============================================================(44) # FixSigMeta step 2: use __signature__ as Foo's sig
            if not isinstance(sig, Signature):============================================(45)      
                raise TypeError(==========================================================(46)      
                    'unexpected object {!r} in __signature__ '============================(47)      
                    'attribute'.format(sig))==============================================(48)      
            return sig====================================================================(49)      
                                                                                                                                                        (50)
    try:==================================================================================(51)      
        partialmethod = obj._partialmethod================================================(52)      
    except AttributeError:================================================================(53)      
        pass==============================================================================(54)      
    else:=================================================================================(55)      
        if isinstance(partialmethod, functools.partialmethod):============================(56)      
            # Unbound partialmethod (see functools.partialmethod)=========================(57)      
            # This means, that we need to calculate the signature=========================(58)      
            # as if it's a regular partial object, but taking into========================(59)      
            # account that the first positional argument==================================(60)      
            # (usually `self`, or `cls`) will not be passed===============================(61)      
            # automatically (as for boundmethods)=========================================(62)      
                                                                                                                                                        (63)
            wrapped_sig = _signature_from_callable(=======================================(64)      
                partialmethod.func,=======================================================(65)      
                                                                                                                                     part No.2 out of 7 parts</code></pre>
</div>
</div>
<p>Note: new and old <code>_signature_from_callable</code> have the same code for getting signature for object with <code>__signature__</code>.</p>
</section>
<section id="read-commented-_signature_from_callable-of-python-3.7" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="read-commented-_signature_from_callable-of-python-3.7">Read commented <code>_signature_from_callable</code> of python 3.7</h3>
<div class="cell column-screen">
<div class="sourceCode cell-code" id="cb90"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb90-1"><a href="#cb90-1" aria-hidden="true" tabindex="-1"></a>sigOld.<span class="bu">print</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>def _signature_from_callableOld(obj, *,===================================================(0)       
                             follow_wrapper_chains=True,==================================(1)       
                             skip_bound_arg=True,=========================================(2)       
                             sigcls):=====================================================(3)       
                                                                                                                                                        (4)
    """Private helper function to get signature for arbitrary=============================(5)       
    callable objects.=====================================================================(6)       
    """===================================================================================(7)       
                                                                                                                                                        (8)
    if not callable(obj):=================================================================(9)       
        raise TypeError('{!r} is not a callable object'.format(obj))======================(10)      
                                                                                                                                                        (11)
    if isinstance(obj, types.MethodType):=================================================(12)      
        # In this case we skip the first parameter of the underlying======================(13)      
        # function (usually `self` or `cls`).=============================================(14)      
        sig = _signature_from_callable(===================================================(15)      
            obj.__func__,=================================================================(16)      
            follow_wrapper_chains=follow_wrapper_chains,==================================(17)      
            skip_bound_arg=skip_bound_arg,================================================(18)      
            sigcls=sigcls)================================================================(19)      
                                                                                                                                                        (20)
        if skip_bound_arg:================================================================(21)      
            return _signature_bound_method(sig)===========================================(22)      
        else:=============================================================================(23)      
            return sig====================================================================(24)      
                                                                                                                                                        (25)
    # Was this function wrapped by a decorator?===========================================(26)      
    if follow_wrapper_chains:=============================================================(27) # FixSigMeta step 1: does it have __signature__
        obj = unwrap(obj, stop=(lambda f: hasattr(f, "__signature__")))===================(28)      
        if isinstance(obj, types.MethodType):=============================================(29)      
            # If the unwrapped object is a *method*, we might want to=====================(30)      
            # skip its first parameter (self).============================================(31)      
            # See test_signature_wrapped_bound_method for details.========================(32)      
            return _signature_from_callable(==============================================(33)      
                obj,======================================================================(34)      
                follow_wrapper_chains=follow_wrapper_chains,==============================(35)      
                skip_bound_arg=skip_bound_arg,============================================(36)      
                sigcls=sigcls)============================================================(37)      
                                                                                                                                                        (38)
    try:==================================================================================(39)      
        sig = obj.__signature__===========================================================(40)      
    except AttributeError:================================================================(41)      
        pass==============================================================================(42)      
    else:=================================================================================(43)      
        if sig is not None:===============================================================(44) # FixSigMeta step 2: use __signature__ as Foo's sig
            if not isinstance(sig, Signature):============================================(45)      
                raise TypeError(==========================================================(46)      
                    'unexpected object {!r} in __signature__ '============================(47)      
                    'attribute'.format(sig))==============================================(48)      
            return sig====================================================================(49)      
                                                                                                                                                        (50)
    try:==================================================================================(51)      
        partialmethod = obj._partialmethod================================================(52)      
    except AttributeError:================================================================(53)      
        pass==============================================================================(54)      
    else:=================================================================================(55)      
        if isinstance(partialmethod, functools.partialmethod):============================(56)      
            # Unbound partialmethod (see functools.partialmethod)=========================(57)      
            # This means, that we need to calculate the signature=========================(58)      
            # as if it's a regular partial object, but taking into========================(59)      
            # account that the first positional argument==================================(60)      
            # (usually `self`, or `cls`) will not be passed===============================(61)      
            # automatically (as for boundmethods)=========================================(62)      
                                                                                                                                                        (63)
            wrapped_sig = _signature_from_callable(=======================================(64)      
                partialmethod.func,=======================================================(65)      
                follow_wrapper_chains=follow_wrapper_chains,==============================(66)      
                skip_bound_arg=skip_bound_arg,============================================(67)      
                sigcls=sigcls)============================================================(68)      
                                                                                                                                                        (69)
            sig = _signature_get_partial(wrapped_sig, partialmethod, (None,))=============(70)      
            first_wrapped_param = tuple(wrapped_sig.parameters.values())[0]===============(71)      
            if first_wrapped_param.kind is Parameter.VAR_POSITIONAL:======================(72)      
                # First argument of the wrapped callable is `*args`, as in================(73)      
                # `partialmethod(lambda *args)`.==========================================(74)      
                return sig================================================================(75)      
            else:=========================================================================(76)      
                sig_params = tuple(sig.parameters.values())===============================(77)      
                assert (not sig_params or=================================================(78)      
                        first_wrapped_param is not sig_params[0])=========================(79)      
                new_params = (first_wrapped_param,) + sig_params==========================(80)      
                return sig.replace(parameters=new_params)=================================(81)      
                                                                                                                                                        (82)
    if isfunction(obj) or _signature_is_functionlike(obj):================================(83)      
        # If it's a pure Python function, or an object that is duck type==================(84)      
        # of a Python function (Cython functions, for instance), then:====================(85)      
        return _signature_from_function(sigcls, obj)======================================(86)      
                                                                                                                                                        (87)
    if _signature_is_builtin(obj):========================================================(88)      
        return _signature_from_builtin(sigcls, obj,=======================================(89)      
                                       skip_bound_arg=skip_bound_arg)=====================(90)      
                                                                                                                                                        (91)
    if isinstance(obj, functools.partial):================================================(92)      
        wrapped_sig = _signature_from_callable(===========================================(93)      
            obj.func,=====================================================================(94)      
            follow_wrapper_chains=follow_wrapper_chains,==================================(95)      
            skip_bound_arg=skip_bound_arg,================================================(96)      
            sigcls=sigcls)================================================================(97)      
        return _signature_get_partial(wrapped_sig, obj)===================================(98)      
                                                                                                                                                        (99)
    sig = None============================================================================(100)     
    if isinstance(obj, type):=============================================================(101)     
        # obj is a class or a metaclass===================================================(102)     
                                                                                                                                                        (103)
        # First, let's see if it has an overloaded __call__ defined=======================(104)     
        # in its metaclass================================================================(105)     
        call = _signature_get_user_defined_method(type(obj), '__call__')==================(106)     
        if call is not None:==============================================================(107)     
            sig = _signature_from_callable(===============================================(108)     
                call,=====================================================================(109)     
                follow_wrapper_chains=follow_wrapper_chains,==============================(110)     
                skip_bound_arg=skip_bound_arg,============================================(111)     
                sigcls=sigcls)============================================================(112)     
        else:=============================================================================(113)     
            # Now we check if the 'obj' class has a '__new__' method======================(114)     
            new = _signature_get_user_defined_method(obj, '__new__')======================(115) # messup step 1: overriding __new__ is detected
            if new is not None:===========================================================(116)     
                sig = _signature_from_callable(===========================================(117) # messup step 2: only __new__ sig is extracted
                    new,==================================================================(118)     
                    follow_wrapper_chains=follow_wrapper_chains,==========================(119)     
                    skip_bound_arg=skip_bound_arg,========================================(120)     
                    sigcls=sigcls)========================================================(121)     
            else:=========================================================================(122)     
                # Finally, we should have at least __init__ implemented===================(123)     
                init = _signature_get_user_defined_method(obj, '__init__')================(124) # messup step 3: __init__ don't even get accessed
                if init is not None:======================================================(125)     
                    sig = _signature_from_callable(=======================================(126)     
                        init,=============================================================(127)     
                        follow_wrapper_chains=follow_wrapper_chains,======================(128)     
                        skip_bound_arg=skip_bound_arg,====================================(129)     
                        sigcls=sigcls)====================================================(130)     
                                                                                                                                                        (131)
        if sig is None:===================================================================(132)     
            # At this point we know, that `obj` is a class, with no user-=================(133)     
            # defined '__init__', '__new__', or class-level '__call__'====================(134)     
                                                                                                                                                        (135)
            for base in obj.__mro__[:-1]:=================================================(136)     
                # Since '__text_signature__' is implemented as a==========================(137)     
                # descriptor that extracts text signature from the========================(138)     
                # class docstring, if 'obj' is derived from a builtin=====================(139)     
                # class, its own '__text_signature__' may be 'None'.======================(140)     
                # Therefore, we go through the MRO (except the last=======================(141)     
                # class in there, which is 'object') to find the first====================(142)     
                # class with non-empty text signature.====================================(143)     
                try:======================================================================(144)     
                    text_sig = base.__text_signature__====================================(145)     
                except AttributeError:====================================================(146)     
                    pass==================================================================(147)     
                else:=====================================================================(148)     
                    if text_sig:==========================================================(149)     
                        # If 'obj' class has a __text_signature__ attribute:==============(150)     
                        # return a signature based on it==================================(151)     
                        return _signature_fromstr(sigcls, obj, text_sig)==================(152)     
                                                                                                                                                        (153)
            # No '__text_signature__' was found for the 'obj' class.======================(154)     
            # Last option is to check if its '__init__' is================================(155)     
            # object.__init__ or type.__init__.===========================================(156)     
            if type not in obj.__mro__:===================================================(157)     
                # We have a class (not metaclass), but no user-defined====================(158)     
                # __init__ or __new__ for it==============================================(159)     
                if (obj.__init__ is object.__init__ and===================================(160)     
                    obj.__new__ is object.__new__):=======================================(161)     
                    # Return a signature of 'object' builtin.=============================(162)     
                    return sigcls.from_callable(object)===================================(163)     
                else:=====================================================================(164)     
                    raise ValueError(=====================================================(165)     
                        'no signature found for builtin type {!r}'.format(obj))===========(166)     
                                                                                                                                                        (167)
    elif not isinstance(obj, _NonUserDefinedCallables):===================================(168)     
        # An object with __call__=========================================================(169)     
        # We also check that the 'obj' is not an instance of==============================(170)     
        # _WrapperDescriptor or _MethodWrapper to avoid===================================(171)     
        # infinite recursion (and even potential segfault)================================(172)     
        call = _signature_get_user_defined_method(type(obj), '__call__')==================(173)     
        if call is not None:==============================================================(174)     
            try:==========================================================================(175)     
                sig = _signature_from_callable(===========================================(176)     
                    call,=================================================================(177)     
                    follow_wrapper_chains=follow_wrapper_chains,==========================(178)     
                    skip_bound_arg=skip_bound_arg,========================================(179)     
                    sigcls=sigcls)========================================================(180)     
            except ValueError as ex:======================================================(181)     
                msg = 'no signature found for {!r}'.format(obj)===========================(182)     
                raise ValueError(msg) from ex=============================================(183)     
                                                                                                                                                        (184)
    if sig is not None:===================================================================(185)     
        # For classes and objects we skip the first parameter of their====================(186)     
        # __call__, __new__, or __init__ methods==========================================(187)     
        if skip_bound_arg:================================================================(188)     
            return _signature_bound_method(sig)===========================================(189)     
        else:=============================================================================(190)     
            return sig====================================================================(191)     
                                                                                                                                                        (192)
    if isinstance(obj, types.BuiltinFunctionType):========================================(193)     
        # Raise a nicer error message for builtins========================================(194)     
        msg = 'no signature found for builtin function {!r}'.format(obj)==================(195)     
        raise ValueError(msg)=============================================================(196)     
                                                                                                                                                        (197)
    raise ValueError('callable {!r} is not supported by signature'.format(obj))===========(198)     
                                                                                                                                                        (199)</code></pre>
</div>
</div>
</section>
</section>
<section id="foos-metaclass-defines-its-own-__call__-will-stop-foo-get-sig-from-__init__" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="foos-metaclass-defines-its-own-__call__-will-stop-foo-get-sig-from-__init__">Foo’s metaclass defines its own <code>__call__</code> will stop Foo get sig from <code>__init__</code></h2>
<section id="problem-demo" class="level3">
<h3 class="anchored" data-anchor-id="problem-demo">Problem demo</h3>
<div class="cell">
<div class="sourceCode cell-code" id="cb92"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb92-1"><a href="#cb92-1" aria-hidden="true" tabindex="-1"></a>inspect._signature_from_callable <span class="op">=</span> _signature_from_callableNew</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<ol start="2" type="1">
<li>when your Foo has a metaclass BaseMeta, if BaseMeta need to define its <code>__call__</code>, then Foo can’t get signature from <code>__init__</code>.</li>
</ol>
<div class="cell">
<div class="sourceCode cell-code" id="cb93"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb93-1"><a href="#cb93-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> BaseMeta(<span class="bu">type</span>): </span>
<span id="cb93-2"><a href="#cb93-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># using __new__ from type</span></span>
<span id="cb93-3"><a href="#cb93-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__call__</span>(cls, <span class="op">*</span>args, <span class="op">**</span>kwargs): <span class="cf">pass</span></span>
<span id="cb93-4"><a href="#cb93-4" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Foo(metaclass<span class="op">=</span>BaseMeta): </span>
<span id="cb93-5"><a href="#cb93-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, d, e, f): <span class="cf">pass</span></span>
<span id="cb93-6"><a href="#cb93-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb93-7"><a href="#cb93-7" aria-hidden="true" tabindex="-1"></a>test_sig(Foo, <span class="st">'(*args, **kwargs)'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb94"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb94-1"><a href="#cb94-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> BaseMeta(<span class="bu">type</span>): </span>
<span id="cb94-2"><a href="#cb94-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__new__</span>(cls, name, bases, <span class="bu">dict</span>):</span>
<span id="cb94-3"><a href="#cb94-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">super</span>().<span class="fu">__new__</span>(cls, name, bases, <span class="bu">dict</span>) <span class="co"># using __new__ from type</span></span>
<span id="cb94-4"><a href="#cb94-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__call__</span>(cls, <span class="op">*</span>args, <span class="op">**</span>kwargs): <span class="cf">pass</span></span>
<span id="cb94-5"><a href="#cb94-5" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Foo(metaclass<span class="op">=</span>BaseMeta): </span>
<span id="cb94-6"><a href="#cb94-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, d, e, f): <span class="cf">pass</span></span>
<span id="cb94-7"><a href="#cb94-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb94-8"><a href="#cb94-8" aria-hidden="true" tabindex="-1"></a>test_sig(Foo, <span class="st">'(*args, **kwargs)'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="cause-of-the-problem" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="cause-of-the-problem">Cause of the problem</h3>
<p>Now I have a better understanding of the source codes, I have 2 places to investigate, they are roughly at line 96 and line 37.</p>
<div class="cell column-screen">
<div class="sourceCode cell-code" id="cb95"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb95-1"><a href="#cb95-1" aria-hidden="true" tabindex="-1"></a>dbsig <span class="op">=</span> sig.dbprint(<span class="dv">37</span>, <span class="st">"does Foo store sig inside __signature__"</span>, <span class="st">"hasattr(obj, '__signature__')"</span>)</span>
<span id="cb95-2"><a href="#cb95-2" aria-hidden="true" tabindex="-1"></a>inspect._signature_from_callable <span class="op">=</span> dbsig</span>
<span id="cb95-3"><a href="#cb95-3" aria-hidden="true" tabindex="-1"></a>pprint(inspect.signature(Foo))</span>
<span id="cb95-4"><a href="#cb95-4" aria-hidden="true" tabindex="-1"></a>sig.<span class="bu">print</span>(part<span class="op">=</span><span class="dv">2</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>                                                                                                                                                        (35)
    try:                                                                                                                                                (36)
        sig = obj.__signature__=========================================================================================================================(37)
                                                                                                                      does Foo store sig inside __signature__
    except AttributeError:                                                                                                                              (38)
        pass                                                                                                                                            (39)


                                                                                       hasattr(obj, '__signature__') =&gt; hasattr(obj, '__signature__') : False
&lt;Signature (*args, **kwargs)&gt;
            # See test_signature_wrapped_bound_method for details.========================(33)      
            return _get_signature_of(obj)=================================================(34)      
                                                                                                                                                        (35)
    try:==================================================================================(36)      
        sig = obj.__signature__===========================================================(37) # does Foo store sig inside __signature__
    except AttributeError:================================================================(38)      
        pass==============================================================================(39)      
    else:=================================================================================(40)      
        if sig is not None:===============================================================(41)      
            if not isinstance(sig, Signature):============================================(42)      
                raise TypeError(==========================================================(43)      
                    'unexpected object {!r} in __signature__ '============================(44)      
                    'attribute'.format(sig))==============================================(45)      
            return sig====================================================================(46)      
                                                                                                                                                        (47)
    try:==================================================================================(48)      
        partialmethod = obj._partialmethod================================================(49)      
    except AttributeError:================================================================(50)      
        pass==============================================================================(51)      
    else:=================================================================================(52)      
        if isinstance(partialmethod, functools.partialmethod):============================(53)      
            # Unbound partialmethod (see functools.partialmethod)=========================(54)      
            # This means, that we need to calculate the signature=========================(55)      
            # as if it's a regular partial object, but taking into========================(56)      
            # account that the first positional argument==================================(57)      
            # (usually `self`, or `cls`) will not be passed===============================(58)      
            # automatically (as for boundmethods)=========================================(59)      
                                                                                                                                                        (60)
            wrapped_sig = _get_signature_of(partialmethod.func)===========================(61)      
                                                                                                                                                        (62)
            sig = _signature_get_partial(wrapped_sig, partialmethod, (None,))=============(63)      
            first_wrapped_param = tuple(wrapped_sig.parameters.values())[0]===============(64)      
            if first_wrapped_param.kind is Parameter.VAR_POSITIONAL:======================(65)      
                                                                                                                                     part No.2 out of 6 parts</code></pre>
</div>
</div>
<div class="cell column-screen">
<div class="sourceCode cell-code" id="cb97"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb97-1"><a href="#cb97-1" aria-hidden="true" tabindex="-1"></a>dbsig <span class="op">=</span> sig.dbprint(<span class="dv">98</span>, <span class="st">"__call__ is defined"</span>, <span class="st">"sig = _get_signature_of(call)"</span>)</span>
<span id="cb97-2"><a href="#cb97-2" aria-hidden="true" tabindex="-1"></a>inspect._signature_from_callable <span class="op">=</span> dbsig</span>
<span id="cb97-3"><a href="#cb97-3" aria-hidden="true" tabindex="-1"></a>pprint(inspect.signature(Foo))</span>
<span id="cb97-4"><a href="#cb97-4" aria-hidden="true" tabindex="-1"></a>sig.<span class="bu">print</span>(part<span class="op">=</span><span class="dv">3</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>        call = _signature_get_user_defined_method(type(obj), '__call__')                                                                                (96)
        if call is not None:                                                                                                                            (97)
            sig = _get_signature_of(call)===============================================================================================================(98)
                                                                                                                                          __call__ is defined
        else:                                                                                                                                           (99)
            factory_method = None                                                                                                                       (100)


                                                                                                 sig = _get_signature_of(call) =&gt; sig: (cls, *args, **kwargs)
&lt;Signature (*args, **kwargs)&gt;
                # First argument of the wrapped callable is `*args`, as in================(66)      
                # `partialmethod(lambda *args)`.==========================================(67)      
                return sig================================================================(68)      
            else:=========================================================================(69)      
                sig_params = tuple(sig.parameters.values())===============================(70)      
                assert (not sig_params or=================================================(71)      
                        first_wrapped_param is not sig_params[0])=========================(72)      
                new_params = (first_wrapped_param,) + sig_params==========================(73)      
                return sig.replace(parameters=new_params)=================================(74)      
                                                                                                                                                        (75)
    if isfunction(obj) or _signature_is_functionlike(obj):================================(76) # step 7: run on itself will run here
        # If it's a pure Python function, or an object that is duck type==================(77)      
        # of a Python function (Cython functions, for instance), then:====================(78)      
        return _signature_from_function(sigcls, obj,======================================(79) # step 8: get sig with a different func
                                        skip_bound_arg=skip_bound_arg)====================(80)      
                                                                                                                                                        (81)
    if _signature_is_builtin(obj):========================================================(82)      
        return _signature_from_builtin(sigcls, obj,=======================================(83)      
                                       skip_bound_arg=skip_bound_arg)=====================(84)      
                                                                                                                                                        (85)
    if isinstance(obj, functools.partial):================================================(86)      
        wrapped_sig = _get_signature_of(obj.func)=========================================(87)      
        return _signature_get_partial(wrapped_sig, obj)===================================(88)      
                                                                                                                                                        (89)
    sig = None============================================================================(90)      
    if isinstance(obj, type):=============================================================(91) # step 1: obj is a class?
        # obj is a class or a metaclass===================================================(92)      
                                                                                                                                                        (93)
        # First, let's see if it has an overloaded __call__ defined=======================(94)      
        # in its metaclass================================================================(95)      
        call = _signature_get_user_defined_method(type(obj), '__call__')==================(96) # step 2: define its own __call__?
        if call is not None:==============================================================(97)      
            sig = _get_signature_of(call)=================================================(98) # __call__ is defined
                                                                                                                                     part No.3 out of 6 parts</code></pre>
</div>
</div>
</section>
<section id="solution-demo" class="level3">
<h3 class="anchored" data-anchor-id="solution-demo">Solution demo</h3>
<p>Solution to problem 2: you need to inherit from FixSigMeta instead of type when constructing the metaclass to preserve the signature in <code>__init__</code>. Be careful not to override <code>__new__</code> when doing this:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb99"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb99-1"><a href="#cb99-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> BaseMeta(FixSigMeta): </span>
<span id="cb99-2"><a href="#cb99-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># using __new__ of  FixSigMeta instead of type</span></span>
<span id="cb99-3"><a href="#cb99-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__call__</span>(cls, <span class="op">*</span>args, <span class="op">**</span>kwargs): <span class="cf">pass</span></span>
<span id="cb99-4"><a href="#cb99-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb99-5"><a href="#cb99-5" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Foo(metaclass<span class="op">=</span>BaseMeta): <span class="co"># Base</span></span>
<span id="cb99-6"><a href="#cb99-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, d, e, f): <span class="cf">pass</span></span>
<span id="cb99-7"><a href="#cb99-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb99-8"><a href="#cb99-8" aria-hidden="true" tabindex="-1"></a>test_sig(Foo, <span class="st">'(d, e, f)'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb100"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb100-1"><a href="#cb100-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> BaseMeta(FixSigMeta): </span>
<span id="cb100-2"><a href="#cb100-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__new__</span>(cls, name, bases, <span class="bu">dict</span>): <span class="co"># not really overriding __new__, still using FixSigMeta.__new__ actually</span></span>
<span id="cb100-3"><a href="#cb100-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">super</span>().<span class="fu">__new__</span>(cls, name, bases, <span class="bu">dict</span>)</span>
<span id="cb100-4"><a href="#cb100-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__call__</span>(cls, <span class="op">*</span>args, <span class="op">**</span>kwargs): <span class="cf">pass</span></span>
<span id="cb100-5"><a href="#cb100-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb100-6"><a href="#cb100-6" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Foo(metaclass<span class="op">=</span>BaseMeta): <span class="co"># Base</span></span>
<span id="cb100-7"><a href="#cb100-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, d, e, f): <span class="cf">pass</span></span>
<span id="cb100-8"><a href="#cb100-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb100-9"><a href="#cb100-9" aria-hidden="true" tabindex="-1"></a>test_sig(Foo, <span class="st">'(d, e, f)'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Note: if Base also defines <code>__new__</code>, then FixSigMeta can’t help.</p>
</section>
<section id="how-fixsigmeta-fix-this-problem" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="how-fixsigmeta-fix-this-problem">How FixSigMeta fix this problem</h3>
<div class="cell column-screen">
<div class="sourceCode cell-code" id="cb101"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb101-1"><a href="#cb101-1" aria-hidden="true" tabindex="-1"></a>dbsig <span class="op">=</span> sig.dbprint(<span class="dv">29</span>, <span class="st">"why has to unwrap?"</span>, <span class="st">"hasattr(obj, '__signature__')"</span>)</span>
<span id="cb101-2"><a href="#cb101-2" aria-hidden="true" tabindex="-1"></a>inspect._signature_from_callable <span class="op">=</span> dbsig</span>
<span id="cb101-3"><a href="#cb101-3" aria-hidden="true" tabindex="-1"></a>pprint(inspect.signature(Foo))</span>
<span id="cb101-4"><a href="#cb101-4" aria-hidden="true" tabindex="-1"></a>sig.<span class="bu">print</span>(part<span class="op">=</span><span class="dv">1</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>    # Was this function wrapped by a decorator?                                                                                                         (27)
    if follow_wrapper_chains:                                                                                                                           (28)
        obj = unwrap(obj, stop=(lambda f: hasattr(f, "__signature__")))=================================================================================(29)
                                                                                                                                           why has to unwrap?
        if isinstance(obj, types.MethodType):                                                                                                           (30)
            # If the unwrapped object is a *method*, we might want to                                                                                   (31)


                                                                                        hasattr(obj, '__signature__') =&gt; hasattr(obj, '__signature__') : True
&lt;Signature (d, e, f)&gt;
def _signature_from_callable(obj, *,======================================================(0)       
                             follow_wrapper_chains=True,==================================(1)       
                             skip_bound_arg=True,=========================================(2)       
                             sigcls):=====================================================(3)       
                                                                                                                                                        (4)
    """Private helper function to get signature for arbitrary=============================(5)       
    callable objects.=====================================================================(6)       
    """===================================================================================(7)       
                                                                                                                                                        (8)
    _get_signature_of = functools.partial(_signature_from_callable,=======================(9) # so that it can use in itself
                                follow_wrapper_chains=follow_wrapper_chains,==============(10)      
                                skip_bound_arg=skip_bound_arg,============================(11)      
                                sigcls=sigcls)============================================(12)      
                                                                                                                                                        (13)
    if not callable(obj):=================================================================(14) # obj must be callable
        raise TypeError('{!r} is not a callable object'.format(obj))======================(15)      
                                                                                                                                                        (16)
    if isinstance(obj, types.MethodType):=================================================(17) # obj can be a classmethod
        # In this case we skip the first parameter of the underlying======================(18)      
        # function (usually `self` or `cls`).=============================================(19)      
        sig = _get_signature_of(obj.__func__)=============================================(20)      
                                                                                                                                                        (21)
        if skip_bound_arg:================================================================(22)      
            return _signature_bound_method(sig)===========================================(23)      
        else:=============================================================================(24)      
            return sig====================================================================(25)      
                                                                                                                                                        (26)
    # Was this function wrapped by a decorator?===========================================(27)      
    if follow_wrapper_chains:=============================================================(28) # does Foo has __signature__?
        obj = unwrap(obj, stop=(lambda f: hasattr(f, "__signature__")))===================(29) # why has to unwrap?
        if isinstance(obj, types.MethodType):=============================================(30)      
            # If the unwrapped object is a *method*, we might want to=====================(31)      
            # skip its first parameter (self).============================================(32)      
                                                                                                                                     part No.1 out of 6 parts</code></pre>
</div>
</div>
<div class="cell column-screen">
<div class="sourceCode cell-code" id="cb103"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb103-1"><a href="#cb103-1" aria-hidden="true" tabindex="-1"></a>dbsig <span class="op">=</span> sig.dbprint(<span class="dv">30</span>, <span class="st">"what is wrapped by Foo?"</span>, <span class="st">"isinstance(obj, types.MethodType)"</span>, <span class="st">"obj"</span>, <span class="st">"type(obj)"</span>)</span>
<span id="cb103-2"><a href="#cb103-2" aria-hidden="true" tabindex="-1"></a>inspect._signature_from_callable <span class="op">=</span> dbsig</span>
<span id="cb103-3"><a href="#cb103-3" aria-hidden="true" tabindex="-1"></a>pprint(inspect.signature(Foo))</span>
<span id="cb103-4"><a href="#cb103-4" aria-hidden="true" tabindex="-1"></a>sig.<span class="bu">print</span>(part<span class="op">=</span><span class="dv">2</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>    if follow_wrapper_chains:                                                                                                                           (28)
        obj = unwrap(obj, stop=(lambda f: hasattr(f, "__signature__")))                                                                                 (29)
        if isinstance(obj, types.MethodType):===========================================================================================================(30)
                                                                                                                                      what is wrapped by Foo?
            # If the unwrapped object is a *method*, we might want to                                                                                   (31)
            # skip its first parameter (self).                                                                                                          (32)


                                                                               isinstance(obj, types.MethodType) =&gt; isinstance(obj, types.MethodType) : False


                                                                                                                          obj =&gt; obj : &lt;class '__main__.Foo'&gt;


                                                                                                         type(obj) =&gt; type(obj) : &lt;class '__main__.BaseMeta'&gt;
&lt;Signature (d, e, f)&gt;
            # See test_signature_wrapped_bound_method for details.========================(33)      
            return _get_signature_of(obj)=================================================(34)      
                                                                                                                                                        (35)
    try:==================================================================================(36)      
        sig = obj.__signature__===========================================================(37) # does Foo store sig inside __signature__
    except AttributeError:================================================================(38)      
        pass==============================================================================(39)      
    else:=================================================================================(40)      
        if sig is not None:===============================================================(41)      
            if not isinstance(sig, Signature):============================================(42)      
                raise TypeError(==========================================================(43)      
                    'unexpected object {!r} in __signature__ '============================(44)      
                    'attribute'.format(sig))==============================================(45)      
            return sig====================================================================(46)      
                                                                                                                                                        (47)
    try:==================================================================================(48)      
        partialmethod = obj._partialmethod================================================(49)      
    except AttributeError:================================================================(50)      
        pass==============================================================================(51)      
    else:=================================================================================(52)      
        if isinstance(partialmethod, functools.partialmethod):============================(53)      
            # Unbound partialmethod (see functools.partialmethod)=========================(54)      
            # This means, that we need to calculate the signature=========================(55)      
            # as if it's a regular partial object, but taking into========================(56)      
            # account that the first positional argument==================================(57)      
            # (usually `self`, or `cls`) will not be passed===============================(58)      
            # automatically (as for boundmethods)=========================================(59)      
                                                                                                                                                        (60)
            wrapped_sig = _get_signature_of(partialmethod.func)===========================(61)      
                                                                                                                                                        (62)
            sig = _signature_get_partial(wrapped_sig, partialmethod, (None,))=============(63)      
            first_wrapped_param = tuple(wrapped_sig.parameters.values())[0]===============(64)      
            if first_wrapped_param.kind is Parameter.VAR_POSITIONAL:======================(65)      
                                                                                                                                     part No.2 out of 6 parts</code></pre>
</div>
</div>
</section>
<section id="common-feature-of-the-solutions-above-by-fixsigmeta" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="common-feature-of-the-solutions-above-by-fixsigmeta">Common feature of the solutions above by FixSigMeta</h3>
<p>The key is to create <code>__signature__</code> for Foo, so that <code>inspect.signature</code> will get sig from <code>__signature__</code>, instead of <code>__new__</code> or <code>__call__</code></p>
<div class="cell">
<div class="sourceCode cell-code" id="cb105"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb105-1"><a href="#cb105-1" aria-hidden="true" tabindex="-1"></a><span class="co"># g = locals()</span></span>
<span id="cb105-2"><a href="#cb105-2" aria-hidden="true" tabindex="-1"></a>fsm <span class="op">=</span> Fastdb(FixSigMeta, g)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb106"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb106-1"><a href="#cb106-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> fastcore.meta <span class="im">import</span> _rm_self</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell column-screen">
<div class="sourceCode cell-code" id="cb107"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb107-1"><a href="#cb107-1" aria-hidden="true" tabindex="-1"></a>dbfsm <span class="op">=</span> fsm.dbprint(<span class="dv">4</span>, <span class="st">"FixSigMeta create Foo with its __new__"</span>, <span class="st">"res"</span>, <span class="st">"inspect.signature(res.__init__)"</span>, <span class="st">"_rm_self(inspect.signature(res.__init__))"</span>)</span>
<span id="cb107-2"><a href="#cb107-2" aria-hidden="true" tabindex="-1"></a>FixSigMeta <span class="op">=</span> dbfsm</span>
<span id="cb107-3"><a href="#cb107-3" aria-hidden="true" tabindex="-1"></a>inspect._signature_from_callable <span class="op">=</span> sig.orisrc <span class="co"># deactivate it</span></span>
<span id="cb107-4"><a href="#cb107-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-5"><a href="#cb107-5" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> BaseMeta(FixSigMeta): </span>
<span id="cb107-6"><a href="#cb107-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__new__</span>(cls, name, bases, <span class="bu">dict</span>): <span class="co"># not really overriding __new__, still using FixSigMeta.__new__ actually</span></span>
<span id="cb107-7"><a href="#cb107-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">super</span>().<span class="fu">__new__</span>(cls, name, bases, <span class="bu">dict</span>)</span>
<span id="cb107-8"><a href="#cb107-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__call__</span>(cls, <span class="op">*</span>args, <span class="op">**</span>kwargs): <span class="cf">pass</span></span>
<span id="cb107-9"><a href="#cb107-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-10"><a href="#cb107-10" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Foo(metaclass<span class="op">=</span>BaseMeta): <span class="co"># Base</span></span>
<span id="cb107-11"><a href="#cb107-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, d, e, f): <span class="cf">pass</span></span>
<span id="cb107-12"><a href="#cb107-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-13"><a href="#cb107-13" aria-hidden="true" tabindex="-1"></a>test_sig(Foo, <span class="st">'(d, e, f)'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>    def __new__(cls, name, bases, dict):                                                                                                                (2)
        res = super().__new__(cls, name, bases, dict)                                                                                                   (3)
        if res.__init__ is not object.__init__: res.__signature__ = _rm_self(inspect.signature(res.__init__))===========================================(4)
                                                                                                                       FixSigMeta create Foo with its __new__
        return res                                                                                                                                      (5)
                                                                                                                                                        (6)


                                                                                                                          res =&gt; res : &lt;class '__main__.Foo'&gt;


                                                                         inspect.signature(res.__init__) =&gt; inspect.signature(res.__init__) : (self, d, e, f)


                                                           _rm_self(inspect.signature(res.__init__)) =&gt; _rm_self(inspect.signature(res.__init__)) : (d, e, f)</code></pre>
</div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb109"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb109-1"><a href="#cb109-1" aria-hidden="true" tabindex="-1"></a>fsm.<span class="bu">print</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>class FixSigMeta(type):===================================================================(0)       
    "A metaclass that fixes the signature on classes that override `__new__`"=============(1)       
    def __new__(cls, name, bases, dict):==================================================(2)       
        res = super().__new__(cls, name, bases, dict)=====================================(3)       
        if res.__init__ is not object.__init__: res.__signature__ = _rm_self(inspect.signature(res.__init__)) # FixSigMeta create Foo with its __new__  (4)
        return res========================================================================(5)       
                                                                                                                                                        (6)</code></pre>
</div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb111"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb111-1"><a href="#cb111-1" aria-hidden="true" tabindex="-1"></a>FixSigMeta <span class="op">=</span> fsm.orisrc</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb112"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb112-1"><a href="#cb112-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> fastcore.meta <span class="im">import</span> test_eq</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb113"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb113-1"><a href="#cb113-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> BaseMeta(FixSigMeta): </span>
<span id="cb113-2"><a href="#cb113-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># __new__ comes from FixSigMeta</span></span>
<span id="cb113-3"><a href="#cb113-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__new__</span>(cls, <span class="op">*</span>args, <span class="op">**</span>kwargs): <span class="cf">pass</span> <span class="co"># as it create None for Foo, there is no signature neither</span></span>
<span id="cb113-4"><a href="#cb113-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__call__</span>(cls, <span class="op">*</span>args, <span class="op">**</span>kwargs): <span class="cf">pass</span></span>
<span id="cb113-5"><a href="#cb113-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb113-6"><a href="#cb113-6" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Foo(metaclass<span class="op">=</span>BaseMeta): <span class="co"># Base</span></span>
<span id="cb113-7"><a href="#cb113-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, d, e, f): <span class="cf">pass</span></span>
<span id="cb113-8"><a href="#cb113-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb113-9"><a href="#cb113-9" aria-hidden="true" tabindex="-1"></a>test_eq(<span class="bu">type</span>(Foo), <span class="bu">type</span>(<span class="va">None</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Note: if Base also defines <code>__init__</code>, then FixSigMeta can still help.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb114"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb114-1"><a href="#cb114-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> BaseMeta(FixSigMeta): </span>
<span id="cb114-2"><a href="#cb114-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># __new__ comes from FixSigMeta</span></span>
<span id="cb114-3"><a href="#cb114-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(cls, <span class="op">*</span>args, <span class="op">**</span>kwargs): <span class="cf">pass</span> <span class="co"># this __init__ is not used by Foo</span></span>
<span id="cb114-4"><a href="#cb114-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__call__</span>(cls, <span class="op">*</span>args, <span class="op">**</span>kwargs): <span class="cf">pass</span></span>
<span id="cb114-5"><a href="#cb114-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-6"><a href="#cb114-6" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Foo(metaclass<span class="op">=</span>BaseMeta): <span class="co"># Base</span></span>
<span id="cb114-7"><a href="#cb114-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, d, e, f): <span class="cf">pass</span> <span class="co"># override the __init__ above</span></span>
<span id="cb114-8"><a href="#cb114-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-9"><a href="#cb114-9" aria-hidden="true" tabindex="-1"></a>test_sig(Foo, <span class="st">'(d, e, f)'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    setTimeout(function() {
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const cites = ref.parentNode.getAttribute('data-cites').split(' ');
    tippyHover(ref, function() {
      var popup = window.document.createElement('div');
      cites.forEach(function(cite) {
        var citeDiv = window.document.createElement('div');
        citeDiv.classList.add('hanging-indent');
        citeDiv.classList.add('csl-entry');
        var biblioDiv = window.document.getElementById('ref-' + cite);
        if (biblioDiv) {
          citeDiv.innerHTML = biblioDiv.innerHTML;
        }
        popup.appendChild(citeDiv);
      });
      return popup.innerHTML;
    });
  }
});
</script>
</div> <!-- /content -->



</body></html>