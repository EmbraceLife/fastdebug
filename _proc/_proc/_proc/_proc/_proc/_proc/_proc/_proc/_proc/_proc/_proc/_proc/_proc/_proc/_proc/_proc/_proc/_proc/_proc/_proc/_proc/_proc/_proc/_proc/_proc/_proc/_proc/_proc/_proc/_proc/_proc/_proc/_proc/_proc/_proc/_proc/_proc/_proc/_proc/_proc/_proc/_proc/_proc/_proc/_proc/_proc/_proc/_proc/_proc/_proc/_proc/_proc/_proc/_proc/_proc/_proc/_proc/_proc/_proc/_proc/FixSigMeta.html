<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">

<head>

<meta charset="utf-8" />
<meta name="generator" content="quarto-1.1.189" />

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />


<title>fastdebug – FixSigMeta</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>

<!-- htmldependencies:E3FAD763 -->
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" integrity="sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==" crossorigin="anonymous"></script>
<script type="application/javascript">define('jquery', [],function() {return window.jQuery;})</script>


<link rel="stylesheet" href="styles.css" />
</head>

<body>

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="/index.html">
    <span class="navbar-title">fastdebug</span>
    </a>
  </div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse"
  aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation"
  onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/EmbraceLife/fastdebug"><i 
  class="bi bi-github" 
  role="img" 
>
</i> 
 </a>
  </li>  
</ul>
              <div id="quarto-search" class="" title="Search"></div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav" 
        data-bs-toggle="collapse" data-bs-target="#quarto-sidebar" 
        aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation"
        onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }"
  >
    <div class="container-fluid d-flex justify-content-between">
      <h1 class="quarto-secondary-nav-title"></h1>
      <button type="button" 
        class="quarto-btn-toggle btn" aria-label="Show secondary navigation">
        <i class="bi bi-chevron-right"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse sidebar-navigation floating overflow-auto">
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="/index.html" class="sidebar-item-text sidebar-link">fastdebug</a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="/core.html" class="sidebar-item-text sidebar-link">core</a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="/FixSigMeta.html" class="sidebar-item-text sidebar-link active">FixSigMeta</a>
  </div>
</li>
        <li class="sidebar-item">
  utils.html
  </li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="/utils.html" class="sidebar-item-text sidebar-link">Utils</a>
  </div>
</li>
    </ul>
    </div>
</nav>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <div id="quarto-toc-target"></div>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">FixSigMeta</h1>
</div>



<div class="quarto-title-meta">

    
    
  </div>
  

</header>
<nav id="TOC" role="doc-toc">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#full-line-width" id="toc-full-line-width">Full line width</a></li>
  <li><a href="#imports" id="toc-imports">Imports</a></li>
  <li><a href="#prepare-environment-variables-for-debugging" id="toc-prepare-environment-variables-for-debugging">Prepare environment variables for debugging</a></li>
  <li><a href="#when-or-why-to-use-fixsigmeta" id="toc-when-or-why-to-use-fixsigmeta">When or why to use <code>FixSigMeta</code>?</a></li>
  <li><a href="#how-foo-borrow-sig-from-__init__" id="toc-how-foo-borrow-sig-from-__init__">How Foo borrow sig from <code>__init__</code></a>
  <ul>
  <li><a href="#how-to-debug-inspect._signature_from_callable-with-fastdb" id="toc-how-to-debug-inspect._signature_from_callable-with-fastdb">How to debug <code>inspect._signature_from_callable</code> with Fastdb</a></li>
  <li><a href="#how-exactly-foo-get-sig-from-__init__" id="toc-how-exactly-foo-get-sig-from-__init__">How exactly Foo get sig from <code>__init__</code></a></li>
  <li><a href="#read-commented-_signature_from_callable-from-python-3.9" id="toc-read-commented-_signature_from_callable-from-python-3.9">Read commented <code>_signature_from_callable</code> from python 3.9+</a></li>
  </ul></li>
  <li><a href="#foos-super-class-overriding-__new__-can-stop-foo-getting-sig-from-__init__" id="toc-foos-super-class-overriding-__new__-can-stop-foo-getting-sig-from-__init__">Foo’s super class overriding <code>__new__</code> can stop Foo getting sig from <code>__init__</code></a>
  <ul>
  <li><a href="#when-foos-super-class-override-__new__-python3.7-cant-give-foo-sig-from-__init__" id="toc-when-foos-super-class-override-__new__-python3.7-cant-give-foo-sig-from-__init__">When Foo’s super class override <code>__new__</code>, python3.7 can’t give Foo sig from <code>__init__</code></a></li>
  <li><a href="#how-python3.7-and-its-inspect-mess-it-up" id="toc-how-python3.7-and-its-inspect-mess-it-up">How python3.7 and its inspect mess it up</a></li>
  <li><a href="#fixsigmeta-can-fix-it-for-python-3.7-inspect" id="toc-fixsigmeta-can-fix-it-for-python-3.7-inspect">FixSigMeta can fix it for python 3.7 inspect</a></li>
  <li><a href="#how-fixsigmeta-fix-it" id="toc-how-fixsigmeta-fix-it">How FixSigMeta fix it?</a></li>
  <li><a href="#read-commented-_signature_from_callable-of-python-3.7" id="toc-read-commented-_signature_from_callable-of-python-3.7">Read commented <code>_signature_from_callable</code> of python 3.7</a></li>
  </ul></li>
  <li><a href="#foos-metaclass-defines-its-own-__call__-will-stop-foo-get-sig-from-__init__" id="toc-foos-metaclass-defines-its-own-__call__-will-stop-foo-get-sig-from-__init__">Foo’s metaclass defines its own <code>__call__</code> will stop Foo get sig from <code>__init__</code></a>
  <ul>
  <li><a href="#problem-demo" id="toc-problem-demo">Problem demo</a></li>
  <li><a href="#cause-of-the-problem" id="toc-cause-of-the-problem">Cause of the problem</a></li>
  <li><a href="#solution-demo" id="toc-solution-demo">Solution demo</a></li>
  <li><a href="#how-fixsigmeta-fix-this-problem" id="toc-how-fixsigmeta-fix-this-problem">How FixSigMeta fix this problem</a></li>
  <li><a href="#common-feature-of-the-solutions-above-by-fixsigmeta" id="toc-common-feature-of-the-solutions-above-by-fixsigmeta">Common feature of the solutions above by FixSigMeta</a></li>
  </ul></li>
  </ul>
</nav>
<!-- WARNING: THIS FILE WAS AUTOGENERATED! DO NOT EDIT! -->
<p>The goal of this notebook is to explore how <code>FixSigMeta</code> avoid problems when <code>Foo</code> wants to get signature from its <code>__init__</code> using <code>inspect.signature</code>.</p>
<p>In order to understand the problems <code>FixSigMeta</code> is fixing, please read official <a href="https://fastcore.fast.ai/meta.html#fixsigmeta">docs</a> first</p>
<p>At the beginning, I know very little of the source code of <code>inspect.signature</code> or in fact <code>inspect._signature_from_callable</code> and have no idea how <code>FixSigMeta</code> enable <code>Foo</code> to overcome the potential problems.</p>
<p><code>Fastdebug</code> library and its <a href="https://EmbraceLife.github.io/fastdebug/core.html#fastdb.dbprint"><code>Fastdb.dbprint</code></a> enables me to debug any source code and evaluate the expressions you write sitting above the source code and <a href="https://EmbraceLife.github.io/fastdebug/core.html#fastdb.print"><code>Fastdb.print</code></a> can display source code with comments I add when debugging with <a href="https://EmbraceLife.github.io/fastdebug/core.html#dbprint"><code>dbprint</code></a>.</p>
<p>At the end of the notebook, I hope to have a nice and detailed document on the exploration and have a in-depth understanding of how both <code>_signature_from_callable</code> and <code>FixSigMeta</code> work.</p>
<p>Here is what I learnt from this notebook about how <code>FixSigMeta</code> solve the potential problems</p>
<blockquote>
<p>As a metaclass, <code>FixSigMeta</code> defines its <code>__new__</code> to creates a class instance <code>Foo</code> with attribute <code>__signature__</code> and store the signature of <code>__init__</code>. This way <code>inspect._signature_from_callable</code> can directly help <code>Foo</code> to get signature from <code>__signature__</code> instead of going into <code>__new__</code>, <code>__call__</code> looking for signatures where the potential problems reside.</p>
</blockquote>
<section id="full-line-width" class="level2">
<h2>Full line width</h2>
<div class="cell">
<div class="sourceCode" id="cb1"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co"># from IPython.core.display import display, HTML # a depreciated import</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> IPython.display <span class="im">import</span> display, HTML </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>display(HTML(<span class="st">&quot;&lt;style&gt;.container { width:100% !important; }&lt;/style&gt;&quot;</span>))</span></code></pre></div>
<div class="cell-output cell-output-display">
<style>.container { width:100% !important; }</style>
</div>
</div>
<div class="cell">
<div class="sourceCode" id="cb2"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> fastdebug.utils <span class="im">import</span> <span class="op">*</span></span></code></pre></div>
</div>
<div class="cell">
<div class="sourceCode" id="cb3"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> IPython</span></code></pre></div>
</div>
<div class="cell">
<div class="sourceCode" id="cb4"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>whatinside(IPython)</span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>IPython has: 
0 items in its __all__, and 
7 user defined functions, 
2 classes or class objects, 
0 builtin funcs and methods, and
9 callables.
</code></pre>
</div>
</div>
<div class="cell">
<div class="sourceCode" id="cb6"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>whichversion(<span class="st">&quot;IPython&quot;</span>)</span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>ipython: 8.4.0 
IPython: Productive Interactive Computing    
The IPython Development Team 
https://ipython.org     
python_version: &gt;=3.8     
/Users/Natsume/mambaforge/lib/python3.9/site-packages/IPython</code></pre>
</div>
</div>
</section>
<section id="imports" class="level2">
<h2>Imports</h2>
<div class="cell">
<div class="sourceCode" id="cb8"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> fastdebug.core <span class="im">import</span> <span class="op">*</span></span></code></pre></div>
</div>
<div class="cell">
<div class="sourceCode" id="cb9"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> inspect</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> inspect <span class="im">import</span> <span class="op">*</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> inspect <span class="im">import</span> _signature_from_callable</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> inspect <span class="im">import</span> _signature_is_functionlike, _signature_is_builtin, _signature_get_user_defined_method, _signature_from_function, _signature_bound_method</span></code></pre></div>
</div>
<div class="cell">
<div class="sourceCode" id="cb10"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> fastcore.meta <span class="im">as</span> fm</span></code></pre></div>
</div>
<div class="cell">
<div class="sourceCode" id="cb11"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>_signature_from_callableNew <span class="op">=</span> _signature_from_callable</span></code></pre></div>
</div>
<div class="cell">
<div class="sourceCode" id="cb12"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> _signature_from_callableOld(obj, <span class="op">*</span>,</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>                             follow_wrapper_chains<span class="op">=</span><span class="va">True</span>,</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>                             skip_bound_arg<span class="op">=</span><span class="va">True</span>,</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>                             sigcls):</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">&quot;&quot;&quot;Private helper function to get signature for arbitrary</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a><span class="co">    callable objects.</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a><span class="co">    &quot;&quot;&quot;</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> <span class="bu">callable</span>(obj):</span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">raise</span> <span class="pp">TypeError</span>(<span class="st">&#39;</span><span class="sc">{!r}</span><span class="st"> is not a callable object&#39;</span>.<span class="bu">format</span>(obj))</span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">isinstance</span>(obj, types.MethodType):</span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>        <span class="co"># In this case we skip the first parameter of the underlying</span></span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>        <span class="co"># function (usually `self` or `cls`).</span></span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a>        sig <span class="op">=</span> _signature_from_callable(</span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a>            obj.__func__,</span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a>            follow_wrapper_chains<span class="op">=</span>follow_wrapper_chains,</span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true" tabindex="-1"></a>            skip_bound_arg<span class="op">=</span>skip_bound_arg,</span>
<span id="cb12-20"><a href="#cb12-20" aria-hidden="true" tabindex="-1"></a>            sigcls<span class="op">=</span>sigcls)</span>
<span id="cb12-21"><a href="#cb12-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-22"><a href="#cb12-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> skip_bound_arg:</span>
<span id="cb12-23"><a href="#cb12-23" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> _signature_bound_method(sig)</span>
<span id="cb12-24"><a href="#cb12-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb12-25"><a href="#cb12-25" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> sig</span>
<span id="cb12-26"><a href="#cb12-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-27"><a href="#cb12-27" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Was this function wrapped by a decorator?</span></span>
<span id="cb12-28"><a href="#cb12-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> follow_wrapper_chains:</span>
<span id="cb12-29"><a href="#cb12-29" aria-hidden="true" tabindex="-1"></a>        obj <span class="op">=</span> unwrap(obj, stop<span class="op">=</span>(<span class="kw">lambda</span> f: <span class="bu">hasattr</span>(f, <span class="st">&quot;__signature__&quot;</span>)))</span>
<span id="cb12-30"><a href="#cb12-30" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">isinstance</span>(obj, types.MethodType):</span>
<span id="cb12-31"><a href="#cb12-31" aria-hidden="true" tabindex="-1"></a>            <span class="co"># If the unwrapped object is a *method*, we might want to</span></span>
<span id="cb12-32"><a href="#cb12-32" aria-hidden="true" tabindex="-1"></a>            <span class="co"># skip its first parameter (self).</span></span>
<span id="cb12-33"><a href="#cb12-33" aria-hidden="true" tabindex="-1"></a>            <span class="co"># See test_signature_wrapped_bound_method for details.</span></span>
<span id="cb12-34"><a href="#cb12-34" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> _signature_from_callable(</span>
<span id="cb12-35"><a href="#cb12-35" aria-hidden="true" tabindex="-1"></a>                obj,</span>
<span id="cb12-36"><a href="#cb12-36" aria-hidden="true" tabindex="-1"></a>                follow_wrapper_chains<span class="op">=</span>follow_wrapper_chains,</span>
<span id="cb12-37"><a href="#cb12-37" aria-hidden="true" tabindex="-1"></a>                skip_bound_arg<span class="op">=</span>skip_bound_arg,</span>
<span id="cb12-38"><a href="#cb12-38" aria-hidden="true" tabindex="-1"></a>                sigcls<span class="op">=</span>sigcls)</span>
<span id="cb12-39"><a href="#cb12-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-40"><a href="#cb12-40" aria-hidden="true" tabindex="-1"></a>    <span class="cf">try</span>:</span>
<span id="cb12-41"><a href="#cb12-41" aria-hidden="true" tabindex="-1"></a>        sig <span class="op">=</span> obj.__signature__</span>
<span id="cb12-42"><a href="#cb12-42" aria-hidden="true" tabindex="-1"></a>    <span class="cf">except</span> <span class="pp">AttributeError</span>:</span>
<span id="cb12-43"><a href="#cb12-43" aria-hidden="true" tabindex="-1"></a>        <span class="cf">pass</span></span>
<span id="cb12-44"><a href="#cb12-44" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb12-45"><a href="#cb12-45" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> sig <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb12-46"><a href="#cb12-46" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="kw">not</span> <span class="bu">isinstance</span>(sig, Signature):</span>
<span id="cb12-47"><a href="#cb12-47" aria-hidden="true" tabindex="-1"></a>                <span class="cf">raise</span> <span class="pp">TypeError</span>(</span>
<span id="cb12-48"><a href="#cb12-48" aria-hidden="true" tabindex="-1"></a>                    <span class="st">&#39;unexpected object </span><span class="sc">{!r}</span><span class="st"> in __signature__ &#39;</span></span>
<span id="cb12-49"><a href="#cb12-49" aria-hidden="true" tabindex="-1"></a>                    <span class="st">&#39;attribute&#39;</span>.<span class="bu">format</span>(sig))</span>
<span id="cb12-50"><a href="#cb12-50" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> sig</span>
<span id="cb12-51"><a href="#cb12-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-52"><a href="#cb12-52" aria-hidden="true" tabindex="-1"></a>    <span class="cf">try</span>:</span>
<span id="cb12-53"><a href="#cb12-53" aria-hidden="true" tabindex="-1"></a>        partialmethod <span class="op">=</span> obj._partialmethod</span>
<span id="cb12-54"><a href="#cb12-54" aria-hidden="true" tabindex="-1"></a>    <span class="cf">except</span> <span class="pp">AttributeError</span>:</span>
<span id="cb12-55"><a href="#cb12-55" aria-hidden="true" tabindex="-1"></a>        <span class="cf">pass</span></span>
<span id="cb12-56"><a href="#cb12-56" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb12-57"><a href="#cb12-57" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">isinstance</span>(partialmethod, functools.partialmethod):</span>
<span id="cb12-58"><a href="#cb12-58" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Unbound partialmethod (see functools.partialmethod)</span></span>
<span id="cb12-59"><a href="#cb12-59" aria-hidden="true" tabindex="-1"></a>            <span class="co"># This means, that we need to calculate the signature</span></span>
<span id="cb12-60"><a href="#cb12-60" aria-hidden="true" tabindex="-1"></a>            <span class="co"># as if it&#39;s a regular partial object, but taking into</span></span>
<span id="cb12-61"><a href="#cb12-61" aria-hidden="true" tabindex="-1"></a>            <span class="co"># account that the first positional argument</span></span>
<span id="cb12-62"><a href="#cb12-62" aria-hidden="true" tabindex="-1"></a>            <span class="co"># (usually `self`, or `cls`) will not be passed</span></span>
<span id="cb12-63"><a href="#cb12-63" aria-hidden="true" tabindex="-1"></a>            <span class="co"># automatically (as for boundmethods)</span></span>
<span id="cb12-64"><a href="#cb12-64" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-65"><a href="#cb12-65" aria-hidden="true" tabindex="-1"></a>            wrapped_sig <span class="op">=</span> _signature_from_callable(</span>
<span id="cb12-66"><a href="#cb12-66" aria-hidden="true" tabindex="-1"></a>                partialmethod.func,</span>
<span id="cb12-67"><a href="#cb12-67" aria-hidden="true" tabindex="-1"></a>                follow_wrapper_chains<span class="op">=</span>follow_wrapper_chains,</span>
<span id="cb12-68"><a href="#cb12-68" aria-hidden="true" tabindex="-1"></a>                skip_bound_arg<span class="op">=</span>skip_bound_arg,</span>
<span id="cb12-69"><a href="#cb12-69" aria-hidden="true" tabindex="-1"></a>                sigcls<span class="op">=</span>sigcls)</span>
<span id="cb12-70"><a href="#cb12-70" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-71"><a href="#cb12-71" aria-hidden="true" tabindex="-1"></a>            sig <span class="op">=</span> _signature_get_partial(wrapped_sig, partialmethod, (<span class="va">None</span>,))</span>
<span id="cb12-72"><a href="#cb12-72" aria-hidden="true" tabindex="-1"></a>            first_wrapped_param <span class="op">=</span> <span class="bu">tuple</span>(wrapped_sig.parameters.values())[<span class="dv">0</span>]</span>
<span id="cb12-73"><a href="#cb12-73" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> first_wrapped_param.kind <span class="kw">is</span> Parameter.VAR_POSITIONAL:</span>
<span id="cb12-74"><a href="#cb12-74" aria-hidden="true" tabindex="-1"></a>                <span class="co"># First argument of the wrapped callable is `*args`, as in</span></span>
<span id="cb12-75"><a href="#cb12-75" aria-hidden="true" tabindex="-1"></a>                <span class="co"># `partialmethod(lambda *args)`.</span></span>
<span id="cb12-76"><a href="#cb12-76" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> sig</span>
<span id="cb12-77"><a href="#cb12-77" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb12-78"><a href="#cb12-78" aria-hidden="true" tabindex="-1"></a>                sig_params <span class="op">=</span> <span class="bu">tuple</span>(sig.parameters.values())</span>
<span id="cb12-79"><a href="#cb12-79" aria-hidden="true" tabindex="-1"></a>                <span class="cf">assert</span> (<span class="kw">not</span> sig_params <span class="kw">or</span></span>
<span id="cb12-80"><a href="#cb12-80" aria-hidden="true" tabindex="-1"></a>                        first_wrapped_param <span class="kw">is</span> <span class="kw">not</span> sig_params[<span class="dv">0</span>])</span>
<span id="cb12-81"><a href="#cb12-81" aria-hidden="true" tabindex="-1"></a>                new_params <span class="op">=</span> (first_wrapped_param,) <span class="op">+</span> sig_params</span>
<span id="cb12-82"><a href="#cb12-82" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> sig.replace(parameters<span class="op">=</span>new_params)</span>
<span id="cb12-83"><a href="#cb12-83" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-84"><a href="#cb12-84" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> isfunction(obj) <span class="kw">or</span> _signature_is_functionlike(obj):</span>
<span id="cb12-85"><a href="#cb12-85" aria-hidden="true" tabindex="-1"></a>        <span class="co"># If it&#39;s a pure Python function, or an object that is duck type</span></span>
<span id="cb12-86"><a href="#cb12-86" aria-hidden="true" tabindex="-1"></a>        <span class="co"># of a Python function (Cython functions, for instance), then:</span></span>
<span id="cb12-87"><a href="#cb12-87" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> _signature_from_function(sigcls, obj)</span>
<span id="cb12-88"><a href="#cb12-88" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-89"><a href="#cb12-89" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> _signature_is_builtin(obj):</span>
<span id="cb12-90"><a href="#cb12-90" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> _signature_from_builtin(sigcls, obj,</span>
<span id="cb12-91"><a href="#cb12-91" aria-hidden="true" tabindex="-1"></a>                                       skip_bound_arg<span class="op">=</span>skip_bound_arg)</span>
<span id="cb12-92"><a href="#cb12-92" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-93"><a href="#cb12-93" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">isinstance</span>(obj, functools.partial):</span>
<span id="cb12-94"><a href="#cb12-94" aria-hidden="true" tabindex="-1"></a>        wrapped_sig <span class="op">=</span> _signature_from_callable(</span>
<span id="cb12-95"><a href="#cb12-95" aria-hidden="true" tabindex="-1"></a>            obj.func,</span>
<span id="cb12-96"><a href="#cb12-96" aria-hidden="true" tabindex="-1"></a>            follow_wrapper_chains<span class="op">=</span>follow_wrapper_chains,</span>
<span id="cb12-97"><a href="#cb12-97" aria-hidden="true" tabindex="-1"></a>            skip_bound_arg<span class="op">=</span>skip_bound_arg,</span>
<span id="cb12-98"><a href="#cb12-98" aria-hidden="true" tabindex="-1"></a>            sigcls<span class="op">=</span>sigcls)</span>
<span id="cb12-99"><a href="#cb12-99" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> _signature_get_partial(wrapped_sig, obj)</span>
<span id="cb12-100"><a href="#cb12-100" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-101"><a href="#cb12-101" aria-hidden="true" tabindex="-1"></a>    sig <span class="op">=</span> <span class="va">None</span></span>
<span id="cb12-102"><a href="#cb12-102" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">isinstance</span>(obj, <span class="bu">type</span>):</span>
<span id="cb12-103"><a href="#cb12-103" aria-hidden="true" tabindex="-1"></a>        <span class="co"># obj is a class or a metaclass</span></span>
<span id="cb12-104"><a href="#cb12-104" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-105"><a href="#cb12-105" aria-hidden="true" tabindex="-1"></a>        <span class="co"># First, let&#39;s see if it has an overloaded __call__ defined</span></span>
<span id="cb12-106"><a href="#cb12-106" aria-hidden="true" tabindex="-1"></a>        <span class="co"># in its metaclass</span></span>
<span id="cb12-107"><a href="#cb12-107" aria-hidden="true" tabindex="-1"></a>        call <span class="op">=</span> _signature_get_user_defined_method(<span class="bu">type</span>(obj), <span class="st">&#39;__call__&#39;</span>)</span>
<span id="cb12-108"><a href="#cb12-108" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> call <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb12-109"><a href="#cb12-109" aria-hidden="true" tabindex="-1"></a>            sig <span class="op">=</span> _signature_from_callable(</span>
<span id="cb12-110"><a href="#cb12-110" aria-hidden="true" tabindex="-1"></a>                call,</span>
<span id="cb12-111"><a href="#cb12-111" aria-hidden="true" tabindex="-1"></a>                follow_wrapper_chains<span class="op">=</span>follow_wrapper_chains,</span>
<span id="cb12-112"><a href="#cb12-112" aria-hidden="true" tabindex="-1"></a>                skip_bound_arg<span class="op">=</span>skip_bound_arg,</span>
<span id="cb12-113"><a href="#cb12-113" aria-hidden="true" tabindex="-1"></a>                sigcls<span class="op">=</span>sigcls)</span>
<span id="cb12-114"><a href="#cb12-114" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb12-115"><a href="#cb12-115" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Now we check if the &#39;obj&#39; class has a &#39;__new__&#39; method</span></span>
<span id="cb12-116"><a href="#cb12-116" aria-hidden="true" tabindex="-1"></a>            new <span class="op">=</span> _signature_get_user_defined_method(obj, <span class="st">&#39;__new__&#39;</span>)</span>
<span id="cb12-117"><a href="#cb12-117" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> new <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb12-118"><a href="#cb12-118" aria-hidden="true" tabindex="-1"></a>                sig <span class="op">=</span> _signature_from_callable(</span>
<span id="cb12-119"><a href="#cb12-119" aria-hidden="true" tabindex="-1"></a>                    new,</span>
<span id="cb12-120"><a href="#cb12-120" aria-hidden="true" tabindex="-1"></a>                    follow_wrapper_chains<span class="op">=</span>follow_wrapper_chains,</span>
<span id="cb12-121"><a href="#cb12-121" aria-hidden="true" tabindex="-1"></a>                    skip_bound_arg<span class="op">=</span>skip_bound_arg,</span>
<span id="cb12-122"><a href="#cb12-122" aria-hidden="true" tabindex="-1"></a>                    sigcls<span class="op">=</span>sigcls)</span>
<span id="cb12-123"><a href="#cb12-123" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb12-124"><a href="#cb12-124" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Finally, we should have at least __init__ implemented</span></span>
<span id="cb12-125"><a href="#cb12-125" aria-hidden="true" tabindex="-1"></a>                init <span class="op">=</span> _signature_get_user_defined_method(obj, <span class="st">&#39;__init__&#39;</span>)</span>
<span id="cb12-126"><a href="#cb12-126" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> init <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb12-127"><a href="#cb12-127" aria-hidden="true" tabindex="-1"></a>                    sig <span class="op">=</span> _signature_from_callable(</span>
<span id="cb12-128"><a href="#cb12-128" aria-hidden="true" tabindex="-1"></a>                        init,</span>
<span id="cb12-129"><a href="#cb12-129" aria-hidden="true" tabindex="-1"></a>                        follow_wrapper_chains<span class="op">=</span>follow_wrapper_chains,</span>
<span id="cb12-130"><a href="#cb12-130" aria-hidden="true" tabindex="-1"></a>                        skip_bound_arg<span class="op">=</span>skip_bound_arg,</span>
<span id="cb12-131"><a href="#cb12-131" aria-hidden="true" tabindex="-1"></a>                        sigcls<span class="op">=</span>sigcls)</span>
<span id="cb12-132"><a href="#cb12-132" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-133"><a href="#cb12-133" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> sig <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb12-134"><a href="#cb12-134" aria-hidden="true" tabindex="-1"></a>            <span class="co"># At this point we know, that `obj` is a class, with no user-</span></span>
<span id="cb12-135"><a href="#cb12-135" aria-hidden="true" tabindex="-1"></a>            <span class="co"># defined &#39;__init__&#39;, &#39;__new__&#39;, or class-level &#39;__call__&#39;</span></span>
<span id="cb12-136"><a href="#cb12-136" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-137"><a href="#cb12-137" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> base <span class="kw">in</span> obj.__mro__[:<span class="op">-</span><span class="dv">1</span>]:</span>
<span id="cb12-138"><a href="#cb12-138" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Since &#39;__text_signature__&#39; is implemented as a</span></span>
<span id="cb12-139"><a href="#cb12-139" aria-hidden="true" tabindex="-1"></a>                <span class="co"># descriptor that extracts text signature from the</span></span>
<span id="cb12-140"><a href="#cb12-140" aria-hidden="true" tabindex="-1"></a>                <span class="co"># class docstring, if &#39;obj&#39; is derived from a builtin</span></span>
<span id="cb12-141"><a href="#cb12-141" aria-hidden="true" tabindex="-1"></a>                <span class="co"># class, its own &#39;__text_signature__&#39; may be &#39;None&#39;.</span></span>
<span id="cb12-142"><a href="#cb12-142" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Therefore, we go through the MRO (except the last</span></span>
<span id="cb12-143"><a href="#cb12-143" aria-hidden="true" tabindex="-1"></a>                <span class="co"># class in there, which is &#39;object&#39;) to find the first</span></span>
<span id="cb12-144"><a href="#cb12-144" aria-hidden="true" tabindex="-1"></a>                <span class="co"># class with non-empty text signature.</span></span>
<span id="cb12-145"><a href="#cb12-145" aria-hidden="true" tabindex="-1"></a>                <span class="cf">try</span>:</span>
<span id="cb12-146"><a href="#cb12-146" aria-hidden="true" tabindex="-1"></a>                    text_sig <span class="op">=</span> base.__text_signature__</span>
<span id="cb12-147"><a href="#cb12-147" aria-hidden="true" tabindex="-1"></a>                <span class="cf">except</span> <span class="pp">AttributeError</span>:</span>
<span id="cb12-148"><a href="#cb12-148" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">pass</span></span>
<span id="cb12-149"><a href="#cb12-149" aria-hidden="true" tabindex="-1"></a>                <span class="cf">else</span>:</span>
<span id="cb12-150"><a href="#cb12-150" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">if</span> text_sig:</span>
<span id="cb12-151"><a href="#cb12-151" aria-hidden="true" tabindex="-1"></a>                        <span class="co"># If &#39;obj&#39; class has a __text_signature__ attribute:</span></span>
<span id="cb12-152"><a href="#cb12-152" aria-hidden="true" tabindex="-1"></a>                        <span class="co"># return a signature based on it</span></span>
<span id="cb12-153"><a href="#cb12-153" aria-hidden="true" tabindex="-1"></a>                        <span class="cf">return</span> _signature_fromstr(sigcls, obj, text_sig)</span>
<span id="cb12-154"><a href="#cb12-154" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-155"><a href="#cb12-155" aria-hidden="true" tabindex="-1"></a>            <span class="co"># No &#39;__text_signature__&#39; was found for the &#39;obj&#39; class.</span></span>
<span id="cb12-156"><a href="#cb12-156" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Last option is to check if its &#39;__init__&#39; is</span></span>
<span id="cb12-157"><a href="#cb12-157" aria-hidden="true" tabindex="-1"></a>            <span class="co"># object.__init__ or type.__init__.</span></span>
<span id="cb12-158"><a href="#cb12-158" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="bu">type</span> <span class="kw">not</span> <span class="kw">in</span> obj.__mro__:</span>
<span id="cb12-159"><a href="#cb12-159" aria-hidden="true" tabindex="-1"></a>                <span class="co"># We have a class (not metaclass), but no user-defined</span></span>
<span id="cb12-160"><a href="#cb12-160" aria-hidden="true" tabindex="-1"></a>                <span class="co"># __init__ or __new__ for it</span></span>
<span id="cb12-161"><a href="#cb12-161" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> (obj.<span class="fu">__init__</span> <span class="kw">is</span> <span class="bu">object</span>.<span class="fu">__init__</span> <span class="kw">and</span></span>
<span id="cb12-162"><a href="#cb12-162" aria-hidden="true" tabindex="-1"></a>                    obj.<span class="fu">__new__</span> <span class="kw">is</span> <span class="bu">object</span>.<span class="fu">__new__</span>):</span>
<span id="cb12-163"><a href="#cb12-163" aria-hidden="true" tabindex="-1"></a>                    <span class="co"># Return a signature of &#39;object&#39; builtin.</span></span>
<span id="cb12-164"><a href="#cb12-164" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">return</span> sigcls.from_callable(<span class="bu">object</span>)</span>
<span id="cb12-165"><a href="#cb12-165" aria-hidden="true" tabindex="-1"></a>                <span class="cf">else</span>:</span>
<span id="cb12-166"><a href="#cb12-166" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">raise</span> <span class="pp">ValueError</span>(</span>
<span id="cb12-167"><a href="#cb12-167" aria-hidden="true" tabindex="-1"></a>                        <span class="st">&#39;no signature found for builtin type </span><span class="sc">{!r}</span><span class="st">&#39;</span>.<span class="bu">format</span>(obj))</span>
<span id="cb12-168"><a href="#cb12-168" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-169"><a href="#cb12-169" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> <span class="kw">not</span> <span class="bu">isinstance</span>(obj, _NonUserDefinedCallables):</span>
<span id="cb12-170"><a href="#cb12-170" aria-hidden="true" tabindex="-1"></a>        <span class="co"># An object with __call__</span></span>
<span id="cb12-171"><a href="#cb12-171" aria-hidden="true" tabindex="-1"></a>        <span class="co"># We also check that the &#39;obj&#39; is not an instance of</span></span>
<span id="cb12-172"><a href="#cb12-172" aria-hidden="true" tabindex="-1"></a>        <span class="co"># _WrapperDescriptor or _MethodWrapper to avoid</span></span>
<span id="cb12-173"><a href="#cb12-173" aria-hidden="true" tabindex="-1"></a>        <span class="co"># infinite recursion (and even potential segfault)</span></span>
<span id="cb12-174"><a href="#cb12-174" aria-hidden="true" tabindex="-1"></a>        call <span class="op">=</span> _signature_get_user_defined_method(<span class="bu">type</span>(obj), <span class="st">&#39;__call__&#39;</span>)</span>
<span id="cb12-175"><a href="#cb12-175" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> call <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb12-176"><a href="#cb12-176" aria-hidden="true" tabindex="-1"></a>            <span class="cf">try</span>:</span>
<span id="cb12-177"><a href="#cb12-177" aria-hidden="true" tabindex="-1"></a>                sig <span class="op">=</span> _signature_from_callable(</span>
<span id="cb12-178"><a href="#cb12-178" aria-hidden="true" tabindex="-1"></a>                    call,</span>
<span id="cb12-179"><a href="#cb12-179" aria-hidden="true" tabindex="-1"></a>                    follow_wrapper_chains<span class="op">=</span>follow_wrapper_chains,</span>
<span id="cb12-180"><a href="#cb12-180" aria-hidden="true" tabindex="-1"></a>                    skip_bound_arg<span class="op">=</span>skip_bound_arg,</span>
<span id="cb12-181"><a href="#cb12-181" aria-hidden="true" tabindex="-1"></a>                    sigcls<span class="op">=</span>sigcls)</span>
<span id="cb12-182"><a href="#cb12-182" aria-hidden="true" tabindex="-1"></a>            <span class="cf">except</span> <span class="pp">ValueError</span> <span class="im">as</span> ex:</span>
<span id="cb12-183"><a href="#cb12-183" aria-hidden="true" tabindex="-1"></a>                msg <span class="op">=</span> <span class="st">&#39;no signature found for </span><span class="sc">{!r}</span><span class="st">&#39;</span>.<span class="bu">format</span>(obj)</span>
<span id="cb12-184"><a href="#cb12-184" aria-hidden="true" tabindex="-1"></a>                <span class="cf">raise</span> <span class="pp">ValueError</span>(msg) <span class="im">from</span> ex</span>
<span id="cb12-185"><a href="#cb12-185" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-186"><a href="#cb12-186" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> sig <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb12-187"><a href="#cb12-187" aria-hidden="true" tabindex="-1"></a>        <span class="co"># For classes and objects we skip the first parameter of their</span></span>
<span id="cb12-188"><a href="#cb12-188" aria-hidden="true" tabindex="-1"></a>        <span class="co"># __call__, __new__, or __init__ methods</span></span>
<span id="cb12-189"><a href="#cb12-189" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> skip_bound_arg:</span>
<span id="cb12-190"><a href="#cb12-190" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> _signature_bound_method(sig)</span>
<span id="cb12-191"><a href="#cb12-191" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb12-192"><a href="#cb12-192" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> sig</span>
<span id="cb12-193"><a href="#cb12-193" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-194"><a href="#cb12-194" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">isinstance</span>(obj, types.BuiltinFunctionType):</span>
<span id="cb12-195"><a href="#cb12-195" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Raise a nicer error message for builtins</span></span>
<span id="cb12-196"><a href="#cb12-196" aria-hidden="true" tabindex="-1"></a>        msg <span class="op">=</span> <span class="st">&#39;no signature found for builtin function </span><span class="sc">{!r}</span><span class="st">&#39;</span>.<span class="bu">format</span>(obj)</span>
<span id="cb12-197"><a href="#cb12-197" aria-hidden="true" tabindex="-1"></a>        <span class="cf">raise</span> <span class="pp">ValueError</span>(msg)</span>
<span id="cb12-198"><a href="#cb12-198" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-199"><a href="#cb12-199" aria-hidden="true" tabindex="-1"></a>    <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="st">&#39;callable </span><span class="sc">{!r}</span><span class="st"> is not supported by signature&#39;</span>.<span class="bu">format</span>(obj))</span></code></pre></div>
</div>
</section>
<section id="prepare-environment-variables-for-debugging" class="level2">
<h2>Prepare environment variables for debugging</h2>
<div class="cell">
<div class="sourceCode" id="cb13"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="bu">len</span>(<span class="bu">dir</span>(fm))</span></code></pre></div>
<div class="cell-output cell-output-display">
<pre><code>103</code></pre>
</div>
</div>
<div class="cell">
<div class="sourceCode" id="cb15"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="bu">len</span>(inspect.__dict__)</span></code></pre></div>
<div class="cell-output cell-output-display">
<pre><code>167</code></pre>
</div>
</div>
<div class="cell">
<div class="sourceCode" id="cb17"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>g <span class="op">=</span> {}</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>g.update(inspect.__dict__)</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>g.update(fm.__dict__)</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a><span class="bu">len</span>(g)</span></code></pre></div>
<div class="cell-output cell-output-display">
<pre><code>254</code></pre>
</div>
</div>
</section>
<section id="when-or-why-to-use-fixsigmeta" class="level2">
<h2>When or why to use <code>FixSigMeta</code>?</h2>
<p>When we want a class e.g., <code>Foo</code> to have signature from its <code>__init__</code> method.</p>
<p><code>FixSigMeta</code> can avoid potential problems for <code>Foo</code> to access signature from <code>__init__</code>.</p>
<div class="cell">
<div class="sourceCode" id="cb19"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Foo:</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, a, b, c): <span class="cf">pass</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>    <span class="at">@classmethod</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> clsmed(): <span class="cf">pass</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>inspect.signature(Foo)</span></code></pre></div>
<div class="cell-output cell-output-display">
<pre><code>&lt;Signature (a, b, c)&gt;</code></pre>
</div>
</div>
</section>
<section id="how-foo-borrow-sig-from-__init__" class="level2">
<h2>How Foo borrow sig from <code>__init__</code></h2>
<div class="cell">
<div class="sourceCode" id="cb21"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="co"># g = locals()</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>sig <span class="op">=</span> Fastdb(_signature_from_callable, g)</span></code></pre></div>
</div>
<section id="how-to-debug-inspect._signature_from_callable-with-fastdb" class="level3">
<h3>How to debug <code>inspect._signature_from_callable</code> with Fastdb</h3>
<div class="cell column-screen">
<div class="sourceCode" id="cb22"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>sig.dbprint(<span class="dv">9</span>, <span class="st">&quot;so that it can use in itself&quot;</span>)</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>sig.<span class="bu">print</span>(part<span class="op">=</span><span class="dv">1</span>)</span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>    &quot;&quot;&quot;                                                                                                                                                 (7)
                                                                                                                                                        (8)
    _get_signature_of = functools.partial(_signature_from_callable,=====================================================================================(9)
                                                                                                                                 so that it can use in itself
                                follow_wrapper_chains=follow_wrapper_chains,                                                                            (10)
                                skip_bound_arg=skip_bound_arg,                                                                                          (11)
def _signature_from_callable(obj, *,======================================================(0)       
                             follow_wrapper_chains=True,==================================(1)       
                             skip_bound_arg=True,=========================================(2)       
                             sigcls):=====================================================(3)       
                                                                                                                                                        (4)
    &quot;&quot;&quot;Private helper function to get signature for arbitrary=============================(5)       
    callable objects.=====================================================================(6)       
    &quot;&quot;&quot;===================================================================================(7)       
                                                                                                                                                        (8)
    _get_signature_of = functools.partial(_signature_from_callable,=======================(9) # so that it can use in itself
                                follow_wrapper_chains=follow_wrapper_chains,==============(10)      
                                skip_bound_arg=skip_bound_arg,============================(11)      
                                sigcls=sigcls)============================================(12)      
                                                                                                                                                        (13)
    if not callable(obj):=================================================================(14)      
        raise TypeError(&#39;{!r} is not a callable object&#39;.format(obj))======================(15)      
                                                                                                                                                        (16)
    if isinstance(obj, types.MethodType):=================================================(17)      
        # In this case we skip the first parameter of the underlying======================(18)      
        # function (usually `self` or `cls`).=============================================(19)      
        sig = _get_signature_of(obj.__func__)=============================================(20)      
                                                                                                                                                        (21)
        if skip_bound_arg:================================================================(22)      
            return _signature_bound_method(sig)===========================================(23)      
        else:=============================================================================(24)      
            return sig====================================================================(25)      
                                                                                                                                                        (26)
    # Was this function wrapped by a decorator?===========================================(27)      
    if follow_wrapper_chains:=============================================================(28)      
        obj = unwrap(obj, stop=(lambda f: hasattr(f, &quot;__signature__&quot;)))===================(29)      
        if isinstance(obj, types.MethodType):=============================================(30)      
            # If the unwrapped object is a *method*, we might want to=====================(31)      
            # skip its first parameter (self).============================================(32)      
                                                                                                                                     part No.1 out of 6 parts</code></pre>
</div>
</div>
<div class="cell column-screen">
<div class="sourceCode" id="cb24"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>sig.dbprint(<span class="dv">14</span>, <span class="st">&quot;obj must be callable&quot;</span>)</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>sig.<span class="bu">print</span>(part<span class="op">=</span><span class="dv">1</span>)</span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>                                sigcls=sigcls)                                                                                                          (12)
                                                                                                                                                        (13)
    if not callable(obj):===============================================================================================================================(14)
                                                                                                                                         obj must be callable
        raise TypeError(&#39;{!r} is not a callable object&#39;.format(obj))                                                                                    (15)
                                                                                                                                                        (16)
def _signature_from_callable(obj, *,======================================================(0)       
                             follow_wrapper_chains=True,==================================(1)       
                             skip_bound_arg=True,=========================================(2)       
                             sigcls):=====================================================(3)       
                                                                                                                                                        (4)
    &quot;&quot;&quot;Private helper function to get signature for arbitrary=============================(5)       
    callable objects.=====================================================================(6)       
    &quot;&quot;&quot;===================================================================================(7)       
                                                                                                                                                        (8)
    _get_signature_of = functools.partial(_signature_from_callable,=======================(9) # so that it can use in itself
                                follow_wrapper_chains=follow_wrapper_chains,==============(10)      
                                skip_bound_arg=skip_bound_arg,============================(11)      
                                sigcls=sigcls)============================================(12)      
                                                                                                                                                        (13)
    if not callable(obj):=================================================================(14) # obj must be callable
        raise TypeError(&#39;{!r} is not a callable object&#39;.format(obj))======================(15)      
                                                                                                                                                        (16)
    if isinstance(obj, types.MethodType):=================================================(17)      
        # In this case we skip the first parameter of the underlying======================(18)      
        # function (usually `self` or `cls`).=============================================(19)      
        sig = _get_signature_of(obj.__func__)=============================================(20)      
                                                                                                                                                        (21)
        if skip_bound_arg:================================================================(22)      
            return _signature_bound_method(sig)===========================================(23)      
        else:=============================================================================(24)      
            return sig====================================================================(25)      
                                                                                                                                                        (26)
    # Was this function wrapped by a decorator?===========================================(27)      
    if follow_wrapper_chains:=============================================================(28)      
        obj = unwrap(obj, stop=(lambda f: hasattr(f, &quot;__signature__&quot;)))===================(29)      
        if isinstance(obj, types.MethodType):=============================================(30)      
            # If the unwrapped object is a *method*, we might want to=====================(31)      
            # skip its first parameter (self).============================================(32)      
                                                                                                                                     part No.1 out of 6 parts</code></pre>
</div>
</div>
<div class="cell">
<div class="sourceCode" id="cb26"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="bu">isinstance</span>(Foo.clsmed, types.MethodType)</span></code></pre></div>
<div class="cell-output cell-output-display">
<pre><code>True</code></pre>
</div>
</div>
<div class="cell column-screen">
<div class="sourceCode" id="cb28"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>sig.dbprint(<span class="dv">17</span>, <span class="st">&quot;obj can be a classmethod&quot;</span>)</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>sig.<span class="bu">print</span>(part<span class="op">=</span><span class="dv">1</span>)</span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>        raise TypeError(&#39;{!r} is not a callable object&#39;.format(obj))                                                                                    (15)
                                                                                                                                                        (16)
    if isinstance(obj, types.MethodType):===============================================================================================================(17)
                                                                                                                                     obj can be a classmethod
        # In this case we skip the first parameter of the underlying                                                                                    (18)
        # function (usually `self` or `cls`).                                                                                                           (19)
def _signature_from_callable(obj, *,======================================================(0)       
                             follow_wrapper_chains=True,==================================(1)       
                             skip_bound_arg=True,=========================================(2)       
                             sigcls):=====================================================(3)       
                                                                                                                                                        (4)
    &quot;&quot;&quot;Private helper function to get signature for arbitrary=============================(5)       
    callable objects.=====================================================================(6)       
    &quot;&quot;&quot;===================================================================================(7)       
                                                                                                                                                        (8)
    _get_signature_of = functools.partial(_signature_from_callable,=======================(9) # so that it can use in itself
                                follow_wrapper_chains=follow_wrapper_chains,==============(10)      
                                skip_bound_arg=skip_bound_arg,============================(11)      
                                sigcls=sigcls)============================================(12)      
                                                                                                                                                        (13)
    if not callable(obj):=================================================================(14) # obj must be callable
        raise TypeError(&#39;{!r} is not a callable object&#39;.format(obj))======================(15)      
                                                                                                                                                        (16)
    if isinstance(obj, types.MethodType):=================================================(17) # obj can be a classmethod
        # In this case we skip the first parameter of the underlying======================(18)      
        # function (usually `self` or `cls`).=============================================(19)      
        sig = _get_signature_of(obj.__func__)=============================================(20)      
                                                                                                                                                        (21)
        if skip_bound_arg:================================================================(22)      
            return _signature_bound_method(sig)===========================================(23)      
        else:=============================================================================(24)      
            return sig====================================================================(25)      
                                                                                                                                                        (26)
    # Was this function wrapped by a decorator?===========================================(27)      
    if follow_wrapper_chains:=============================================================(28)      
        obj = unwrap(obj, stop=(lambda f: hasattr(f, &quot;__signature__&quot;)))===================(29)      
        if isinstance(obj, types.MethodType):=============================================(30)      
            # If the unwrapped object is a *method*, we might want to=====================(31)      
            # skip its first parameter (self).============================================(32)      
                                                                                                                                     part No.1 out of 6 parts</code></pre>
</div>
</div>
<div class="cell">
<div class="sourceCode" id="cb30"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> fastcore.meta <span class="im">import</span> delegates</span></code></pre></div>
</div>
<div class="cell">
<div class="sourceCode" id="cb31"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> low(a, b<span class="op">=</span><span class="dv">1</span>): <span class="cf">pass</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a><span class="at">@delegates</span>(low)</span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> mid(c, d<span class="op">=</span><span class="dv">1</span>, <span class="op">**</span>kwargs): <span class="cf">pass</span></span></code></pre></div>
</div>
<div class="cell column-screen">
<div class="sourceCode" id="cb32"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a>dbsig <span class="op">=</span> sig.dbprint(<span class="dv">28</span>, <span class="st">&quot;does Foo has __signature__?&quot;</span>, <span class="st">&quot;follow_wrapper_chains&quot;</span>, <span class="op">\</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>            <span class="st">&quot;obj = unwrap(obj, stop=(lambda f: hasattr(f, &#39;__signature__&#39;)))&quot;</span>, <span class="st">&quot;isinstance(obj, types.MethodType)&quot;</span>)</span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a><span class="co"># inspect._signature_from_callable = _signature_from_callable</span></span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a>inspect._signature_from_callable <span class="op">=</span> dbsig</span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a><span class="co"># inspect._signature_from_callable = g[&#39;_signature_from_callable&#39;]</span></span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true" tabindex="-1"></a>inspect.signature(mid)</span>
<span id="cb32-9"><a href="#cb32-9" aria-hidden="true" tabindex="-1"></a>sig.<span class="bu">print</span>(part<span class="op">=</span><span class="dv">1</span>)</span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>                                                                                                                                                        (26)
    # Was this function wrapped by a decorator?                                                                                                         (27)
    if follow_wrapper_chains:===========================================================================================================================(28)
                                                                                                                                  does Foo has __signature__?
        obj = unwrap(obj, stop=(lambda f: hasattr(f, &quot;__signature__&quot;)))                                                                                 (29)
        if isinstance(obj, types.MethodType):                                                                                                           (30)


                                                                                                        follow_wrapper_chains =&gt; follow_wrapper_chains : True


                                                        obj = unwrap(obj, stop=(lambda f: hasattr(f, &#39;__signature__&#39;))) =&gt; obj: &lt;function mid at 0x111cfdee0&gt;


                                                                               isinstance(obj, types.MethodType) =&gt; isinstance(obj, types.MethodType) : False
def _signature_from_callable(obj, *,======================================================(0)       
                             follow_wrapper_chains=True,==================================(1)       
                             skip_bound_arg=True,=========================================(2)       
                             sigcls):=====================================================(3)       
                                                                                                                                                        (4)
    &quot;&quot;&quot;Private helper function to get signature for arbitrary=============================(5)       
    callable objects.=====================================================================(6)       
    &quot;&quot;&quot;===================================================================================(7)       
                                                                                                                                                        (8)
    _get_signature_of = functools.partial(_signature_from_callable,=======================(9) # so that it can use in itself
                                follow_wrapper_chains=follow_wrapper_chains,==============(10)      
                                skip_bound_arg=skip_bound_arg,============================(11)      
                                sigcls=sigcls)============================================(12)      
                                                                                                                                                        (13)
    if not callable(obj):=================================================================(14) # obj must be callable
        raise TypeError(&#39;{!r} is not a callable object&#39;.format(obj))======================(15)      
                                                                                                                                                        (16)
    if isinstance(obj, types.MethodType):=================================================(17) # obj can be a classmethod
        # In this case we skip the first parameter of the underlying======================(18)      
        # function (usually `self` or `cls`).=============================================(19)      
        sig = _get_signature_of(obj.__func__)=============================================(20)      
                                                                                                                                                        (21)
        if skip_bound_arg:================================================================(22)      
            return _signature_bound_method(sig)===========================================(23)      
        else:=============================================================================(24)      
            return sig====================================================================(25)      
                                                                                                                                                        (26)
    # Was this function wrapped by a decorator?===========================================(27)      
    if follow_wrapper_chains:=============================================================(28) # does Foo has __signature__?
        obj = unwrap(obj, stop=(lambda f: hasattr(f, &quot;__signature__&quot;)))===================(29)      
        if isinstance(obj, types.MethodType):=============================================(30)      
            # If the unwrapped object is a *method*, we might want to=====================(31)      
            # skip its first parameter (self).============================================(32)      
                                                                                                                                     part No.1 out of 6 parts</code></pre>
</div>
</div>
<div class="cell column-screen">
<div class="sourceCode" id="cb34"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a>dbsig <span class="op">=</span> sig.dbprint(<span class="dv">37</span>, <span class="st">&quot;check __signature__&quot;</span>, <span class="st">&quot;obj = unwrap(obj, stop=(lambda f: hasattr(f, &#39;__signature__&#39;)))&quot;</span>, <span class="st">&quot;obj.__signature__&quot;</span>)</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>inspect._signature_from_callable <span class="op">=</span> dbsig</span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>inspect.signature(mid)</span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a>sig.<span class="bu">print</span>(part<span class="op">=</span><span class="dv">2</span>)</span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>                                                                                                                                                        (35)
    try:                                                                                                                                                (36)
        sig = obj.__signature__=========================================================================================================================(37)
                                                                                                                                          check __signature__
    except AttributeError:                                                                                                                              (38)
        pass                                                                                                                                            (39)


                                                        obj = unwrap(obj, stop=(lambda f: hasattr(f, &#39;__signature__&#39;))) =&gt; obj: &lt;function mid at 0x111cfdee0&gt;


                                                                                                    obj.__signature__ =&gt; obj.__signature__ : (c, d=1, *, b=1)
            # See test_signature_wrapped_bound_method for details.========================(33)      
            return _get_signature_of(obj)=================================================(34)      
                                                                                                                                                        (35)
    try:==================================================================================(36)      
        sig = obj.__signature__===========================================================(37) # check __signature__
    except AttributeError:================================================================(38)      
        pass==============================================================================(39)      
    else:=================================================================================(40)      
        if sig is not None:===============================================================(41)      
            if not isinstance(sig, Signature):============================================(42)      
                raise TypeError(==========================================================(43)      
                    &#39;unexpected object {!r} in __signature__ &#39;============================(44)      
                    &#39;attribute&#39;.format(sig))==============================================(45)      
            return sig====================================================================(46)      
                                                                                                                                                        (47)
    try:==================================================================================(48)      
        partialmethod = obj._partialmethod================================================(49)      
    except AttributeError:================================================================(50)      
        pass==============================================================================(51)      
    else:=================================================================================(52)      
        if isinstance(partialmethod, functools.partialmethod):============================(53)      
            # Unbound partialmethod (see functools.partialmethod)=========================(54)      
            # This means, that we need to calculate the signature=========================(55)      
            # as if it&#39;s a regular partial object, but taking into========================(56)      
            # account that the first positional argument==================================(57)      
            # (usually `self`, or `cls`) will not be passed===============================(58)      
            # automatically (as for boundmethods)=========================================(59)      
                                                                                                                                                        (60)
            wrapped_sig = _get_signature_of(partialmethod.func)===========================(61)      
                                                                                                                                                        (62)
            sig = _signature_get_partial(wrapped_sig, partialmethod, (None,))=============(63)      
            first_wrapped_param = tuple(wrapped_sig.parameters.values())[0]===============(64)      
            if first_wrapped_param.kind is Parameter.VAR_POSITIONAL:======================(65)      
                                                                                                                                     part No.2 out of 6 parts</code></pre>
</div>
</div>
</section>
<section id="how-exactly-foo-get-sig-from-__init__" class="level3">
<h3>How exactly Foo get sig from <code>__init__</code></h3>
<div class="cell column-screen">
<div class="sourceCode" id="cb36"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a>dbsig <span class="op">=</span> sig.dbprint(<span class="dv">91</span>, <span class="st">&quot;step 1: obj is a class?&quot;</span>, <span class="st">&quot;isinstance(obj, type)&quot;</span>)</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a>inspect._signature_from_callable <span class="op">=</span> dbsig</span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a>inspect.signature(Foo)</span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a>sig.<span class="bu">print</span>(part<span class="op">=</span><span class="dv">3</span>)</span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>                                                                                                                                                        (89)
    sig = None                                                                                                                                          (90)
    if isinstance(obj, type):===========================================================================================================================(91)
                                                                                                                                      step 1: obj is a class?
        # obj is a class or a metaclass                                                                                                                 (92)
                                                                                                                                                        (93)


                                                                                                        isinstance(obj, type) =&gt; isinstance(obj, type) : True
                # First argument of the wrapped callable is `*args`, as in================(66)      
                # `partialmethod(lambda *args)`.==========================================(67)      
                return sig================================================================(68)      
            else:=========================================================================(69)      
                sig_params = tuple(sig.parameters.values())===============================(70)      
                assert (not sig_params or=================================================(71)      
                        first_wrapped_param is not sig_params[0])=========================(72)      
                new_params = (first_wrapped_param,) + sig_params==========================(73)      
                return sig.replace(parameters=new_params)=================================(74)      
                                                                                                                                                        (75)
    if isfunction(obj) or _signature_is_functionlike(obj):================================(76)      
        # If it&#39;s a pure Python function, or an object that is duck type==================(77)      
        # of a Python function (Cython functions, for instance), then:====================(78)      
        return _signature_from_function(sigcls, obj,======================================(79)      
                                        skip_bound_arg=skip_bound_arg)====================(80)      
                                                                                                                                                        (81)
    if _signature_is_builtin(obj):========================================================(82)      
        return _signature_from_builtin(sigcls, obj,=======================================(83)      
                                       skip_bound_arg=skip_bound_arg)=====================(84)      
                                                                                                                                                        (85)
    if isinstance(obj, functools.partial):================================================(86)      
        wrapped_sig = _get_signature_of(obj.func)=========================================(87)      
        return _signature_get_partial(wrapped_sig, obj)===================================(88)      
                                                                                                                                                        (89)
    sig = None============================================================================(90)      
    if isinstance(obj, type):=============================================================(91) # step 1: obj is a class?
        # obj is a class or a metaclass===================================================(92)      
                                                                                                                                                        (93)
        # First, let&#39;s see if it has an overloaded __call__ defined=======================(94)      
        # in its metaclass================================================================(95)      
        call = _signature_get_user_defined_method(type(obj), &#39;__call__&#39;)==================(96)      
        if call is not None:==============================================================(97)      
            sig = _get_signature_of(call)=================================================(98)      
                                                                                                                                     part No.3 out of 6 parts</code></pre>
</div>
</div>
<div class="cell column-screen">
<div class="sourceCode" id="cb38"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a>dbsig <span class="op">=</span> sig.dbprint(<span class="dv">96</span>, <span class="st">&quot;step 2: define its own __call__?&quot;</span>, <span class="st">&quot;call = _signature_get_user_defined_method(type(obj), &#39;__call__&#39;)&quot;</span>)</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a>inspect._signature_from_callable <span class="op">=</span> dbsig</span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a>inspect.signature(Foo)</span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a>sig.<span class="bu">print</span>(part<span class="op">=</span><span class="dv">3</span>)</span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>        # First, let&#39;s see if it has an overloaded __call__ defined                                                                                     (94)
        # in its metaclass                                                                                                                              (95)
        call = _signature_get_user_defined_method(type(obj), &#39;__call__&#39;)================================================================================(96)
                                                                                                                             step 2: define its own __call__?
        if call is not None:                                                                                                                            (97)
            sig = _get_signature_of(call)                                                                                                               (98)


                                                                               call = _signature_get_user_defined_method(type(obj), &#39;__call__&#39;) =&gt; call: None
                # First argument of the wrapped callable is `*args`, as in================(66)      
                # `partialmethod(lambda *args)`.==========================================(67)      
                return sig================================================================(68)      
            else:=========================================================================(69)      
                sig_params = tuple(sig.parameters.values())===============================(70)      
                assert (not sig_params or=================================================(71)      
                        first_wrapped_param is not sig_params[0])=========================(72)      
                new_params = (first_wrapped_param,) + sig_params==========================(73)      
                return sig.replace(parameters=new_params)=================================(74)      
                                                                                                                                                        (75)
    if isfunction(obj) or _signature_is_functionlike(obj):================================(76)      
        # If it&#39;s a pure Python function, or an object that is duck type==================(77)      
        # of a Python function (Cython functions, for instance), then:====================(78)      
        return _signature_from_function(sigcls, obj,======================================(79)      
                                        skip_bound_arg=skip_bound_arg)====================(80)      
                                                                                                                                                        (81)
    if _signature_is_builtin(obj):========================================================(82)      
        return _signature_from_builtin(sigcls, obj,=======================================(83)      
                                       skip_bound_arg=skip_bound_arg)=====================(84)      
                                                                                                                                                        (85)
    if isinstance(obj, functools.partial):================================================(86)      
        wrapped_sig = _get_signature_of(obj.func)=========================================(87)      
        return _signature_get_partial(wrapped_sig, obj)===================================(88)      
                                                                                                                                                        (89)
    sig = None============================================================================(90)      
    if isinstance(obj, type):=============================================================(91) # step 1: obj is a class?
        # obj is a class or a metaclass===================================================(92)      
                                                                                                                                                        (93)
        # First, let&#39;s see if it has an overloaded __call__ defined=======================(94)      
        # in its metaclass================================================================(95)      
        call = _signature_get_user_defined_method(type(obj), &#39;__call__&#39;)==================(96) # step 2: define its own __call__?
        if call is not None:==============================================================(97)      
            sig = _get_signature_of(call)=================================================(98)      
                                                                                                                                     part No.3 out of 6 parts</code></pre>
</div>
</div>
<div class="cell column-screen">
<div class="sourceCode" id="cb40"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a>dbsig <span class="op">=</span> sig.dbprint(<span class="dv">101</span>, <span class="st">&quot;step 3: define its own __new__?&quot;</span>, <span class="st">&quot;new = _signature_get_user_defined_method(obj, &#39;__new__&#39;)&quot;</span>)</span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a>inspect._signature_from_callable <span class="op">=</span> dbsig</span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a>inspect.signature(Foo)</span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a>sig.<span class="bu">print</span>(part<span class="op">=</span><span class="dv">4</span>)</span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>        else:                                                                                                                                           (99)
            factory_method = None                                                                                                                       (100)
            new = _signature_get_user_defined_method(obj, &#39;__new__&#39;)====================================================================================(101)
                                                                                                                              step 3: define its own __new__?
            init = _signature_get_user_defined_method(obj, &#39;__init__&#39;)                                                                                  (102)
            # Now we check if the &#39;obj&#39; class has an own &#39;__new__&#39; method                                                                               (103)


                                                                                        new = _signature_get_user_defined_method(obj, &#39;__new__&#39;) =&gt; new: None
        else:=============================================================================(99)      
            factory_method = None=========================================================(100)     
            new = _signature_get_user_defined_method(obj, &#39;__new__&#39;)======================(101) # step 3: define its own __new__?
            init = _signature_get_user_defined_method(obj, &#39;__init__&#39;)====================(102)     
            # Now we check if the &#39;obj&#39; class has an own &#39;__new__&#39; method=================(103)     
            if &#39;__new__&#39; in obj.__dict__:=================================================(104)     
                factory_method = new======================================================(105)     
            # or an own &#39;__init__&#39; method=================================================(106)     
            elif &#39;__init__&#39; in obj.__dict__:==============================================(107)     
                factory_method = init=====================================================(108)     
            # If not, we take inherited &#39;__new__&#39; or &#39;__init__&#39;, if present===============(109)     
            elif new is not None:=========================================================(110)     
                factory_method = new======================================================(111)     
            elif init is not None:========================================================(112)     
                factory_method = init=====================================================(113)     
                                                                                                                                                        (114)
            if factory_method is not None:================================================(115)     
                sig = _get_signature_of(factory_method)===================================(116)     
                                                                                                                                                        (117)
        if sig is None:===================================================================(118)     
            # At this point we know, that `obj` is a class, with no user-=================(119)     
            # defined &#39;__init__&#39;, &#39;__new__&#39;, or class-level &#39;__call__&#39;====================(120)     
                                                                                                                                                        (121)
            for base in obj.__mro__[:-1]:=================================================(122)     
                # Since &#39;__text_signature__&#39; is implemented as a==========================(123)     
                # descriptor that extracts text signature from the========================(124)     
                # class docstring, if &#39;obj&#39; is derived from a builtin=====================(125)     
                # class, its own &#39;__text_signature__&#39; may be &#39;None&#39;.======================(126)     
                # Therefore, we go through the MRO (except the last=======================(127)     
                # class in there, which is &#39;object&#39;) to find the first====================(128)     
                # class with non-empty text signature.====================================(129)     
                try:======================================================================(130)     
                    text_sig = base.__text_signature__====================================(131)     
                                                                                                                                     part No.4 out of 6 parts</code></pre>
</div>
</div>
<div class="cell column-screen">
<div class="sourceCode" id="cb42"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a>sig.dbprint(<span class="dv">102</span>, <span class="st">&quot;step 4: define its own __init__?&quot;</span>, <span class="st">&quot;init = _signature_get_user_defined_method(obj, &#39;__init__&#39;)&quot;</span>)</span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a>inspect._signature_from_callable <span class="op">=</span> dbsig</span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a>inspect.signature(Foo)</span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a>sig.<span class="bu">print</span>(part<span class="op">=</span><span class="dv">4</span>)</span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>            factory_method = None                                                                                                                       (100)
            new = _signature_get_user_defined_method(obj, &#39;__new__&#39;)                                                                                    (101)
            init = _signature_get_user_defined_method(obj, &#39;__init__&#39;)==================================================================================(102)
                                                                                                                             step 4: define its own __init__?
            # Now we check if the &#39;obj&#39; class has an own &#39;__new__&#39; method                                                                               (103)
            if &#39;__new__&#39; in obj.__dict__:                                                                                                               (104)


                                                                                        new = _signature_get_user_defined_method(obj, &#39;__new__&#39;) =&gt; new: None
        else:=============================================================================(99)      
            factory_method = None=========================================================(100)     
            new = _signature_get_user_defined_method(obj, &#39;__new__&#39;)======================(101) # step 3: define its own __new__?
            init = _signature_get_user_defined_method(obj, &#39;__init__&#39;)====================(102) # step 4: define its own __init__?
            # Now we check if the &#39;obj&#39; class has an own &#39;__new__&#39; method=================(103)     
            if &#39;__new__&#39; in obj.__dict__:=================================================(104)     
                factory_method = new======================================================(105)     
            # or an own &#39;__init__&#39; method=================================================(106)     
            elif &#39;__init__&#39; in obj.__dict__:==============================================(107)     
                factory_method = init=====================================================(108)     
            # If not, we take inherited &#39;__new__&#39; or &#39;__init__&#39;, if present===============(109)     
            elif new is not None:=========================================================(110)     
                factory_method = new======================================================(111)     
            elif init is not None:========================================================(112)     
                factory_method = init=====================================================(113)     
                                                                                                                                                        (114)
            if factory_method is not None:================================================(115)     
                sig = _get_signature_of(factory_method)===================================(116)     
                                                                                                                                                        (117)
        if sig is None:===================================================================(118)     
            # At this point we know, that `obj` is a class, with no user-=================(119)     
            # defined &#39;__init__&#39;, &#39;__new__&#39;, or class-level &#39;__call__&#39;====================(120)     
                                                                                                                                                        (121)
            for base in obj.__mro__[:-1]:=================================================(122)     
                # Since &#39;__text_signature__&#39; is implemented as a==========================(123)     
                # descriptor that extracts text signature from the========================(124)     
                # class docstring, if &#39;obj&#39; is derived from a builtin=====================(125)     
                # class, its own &#39;__text_signature__&#39; may be &#39;None&#39;.======================(126)     
                # Therefore, we go through the MRO (except the last=======================(127)     
                # class in there, which is &#39;object&#39;) to find the first====================(128)     
                # class with non-empty text signature.====================================(129)     
                try:======================================================================(130)     
                    text_sig = base.__text_signature__====================================(131)     
                                                                                                                                     part No.4 out of 6 parts</code></pre>
</div>
</div>
<div class="cell column-screen">
<div class="sourceCode" id="cb44"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a>sig.dbprint(<span class="dv">108</span>, <span class="st">&quot;step 5: __init__ is inside obj.__dict__?&quot;</span>, <span class="st">&quot;&#39;__init__&#39; in obj.__dict__&quot;</span>)</span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a>inspect._signature_from_callable <span class="op">=</span> dbsig</span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a>inspect.signature(Foo)</span>
<span id="cb44-4"><a href="#cb44-4" aria-hidden="true" tabindex="-1"></a>sig.<span class="bu">print</span>(part<span class="op">=</span><span class="dv">4</span>)</span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>            # or an own &#39;__init__&#39; method                                                                                                               (106)
            elif &#39;__init__&#39; in obj.__dict__:                                                                                                            (107)
                factory_method = init===================================================================================================================(108)
                                                                                                                     step 5: __init__ is inside obj.__dict__?
            # If not, we take inherited &#39;__new__&#39; or &#39;__init__&#39;, if present                                                                             (109)
            elif new is not None:                                                                                                                       (110)


                                                                                        new = _signature_get_user_defined_method(obj, &#39;__new__&#39;) =&gt; new: None
        else:=============================================================================(99)      
            factory_method = None=========================================================(100)     
            new = _signature_get_user_defined_method(obj, &#39;__new__&#39;)======================(101) # step 3: define its own __new__?
            init = _signature_get_user_defined_method(obj, &#39;__init__&#39;)====================(102) # step 4: define its own __init__?
            # Now we check if the &#39;obj&#39; class has an own &#39;__new__&#39; method=================(103)     
            if &#39;__new__&#39; in obj.__dict__:=================================================(104)     
                factory_method = new======================================================(105)     
            # or an own &#39;__init__&#39; method=================================================(106)     
            elif &#39;__init__&#39; in obj.__dict__:==============================================(107)     
                factory_method = init=====================================================(108) # step 5: __init__ is inside obj.__dict__?
            # If not, we take inherited &#39;__new__&#39; or &#39;__init__&#39;, if present===============(109)     
            elif new is not None:=========================================================(110)     
                factory_method = new======================================================(111)     
            elif init is not None:========================================================(112)     
                factory_method = init=====================================================(113)     
                                                                                                                                                        (114)
            if factory_method is not None:================================================(115)     
                sig = _get_signature_of(factory_method)===================================(116)     
                                                                                                                                                        (117)
        if sig is None:===================================================================(118)     
            # At this point we know, that `obj` is a class, with no user-=================(119)     
            # defined &#39;__init__&#39;, &#39;__new__&#39;, or class-level &#39;__call__&#39;====================(120)     
                                                                                                                                                        (121)
            for base in obj.__mro__[:-1]:=================================================(122)     
                # Since &#39;__text_signature__&#39; is implemented as a==========================(123)     
                # descriptor that extracts text signature from the========================(124)     
                # class docstring, if &#39;obj&#39; is derived from a builtin=====================(125)     
                # class, its own &#39;__text_signature__&#39; may be &#39;None&#39;.======================(126)     
                # Therefore, we go through the MRO (except the last=======================(127)     
                # class in there, which is &#39;object&#39;) to find the first====================(128)     
                # class with non-empty text signature.====================================(129)     
                try:======================================================================(130)     
                    text_sig = base.__text_signature__====================================(131)     
                                                                                                                                     part No.4 out of 6 parts</code></pre>
</div>
</div>
<div class="cell">
<div class="sourceCode" id="cb46"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a>dbsig <span class="op">=</span> sig.dbprint(<span class="dv">116</span>, <span class="st">&quot;step 6: run on itself using functools.partial&quot;</span>, <span class="st">&quot;sig = _get_signature_of(factory_method)&quot;</span>)</span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a>inspect._signature_from_callable <span class="op">=</span> dbsig</span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a>inspect.signature(Foo)</span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>                                                                                                                                                        (114)
            if factory_method is not None:                                                                                                              (115)
                sig = _get_signature_of(factory_method)=================================================================================================(116)
                                                                                                                step 6: run on itself using functools.partial
                                                                                                                                                        (117)
        if sig is None:                                                                                                                                 (118)


                                                                                              sig = _get_signature_of(factory_method) =&gt; sig: (self, a, b, c)</code></pre>
</div>
<div class="cell-output cell-output-display column-screen">
<pre><code>&lt;Signature (a, b, c)&gt;</code></pre>
</div>
</div>
<div class="cell">
<div class="sourceCode" id="cb49"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a>dbsig <span class="op">=</span> sig.dbprint(<span class="dv">76</span>, <span class="st">&quot;step 7: run on itself will run here&quot;</span>, <span class="st">&quot;isfunction(obj)&quot;</span>, <span class="st">&quot;_signature_is_functionlike(obj)&quot;</span>)</span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a>inspect._signature_from_callable <span class="op">=</span> dbsig</span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a>inspect.signature(Foo.<span class="fu">__init__</span>)</span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>                return sig.replace(parameters=new_params)                                                                                               (74)
                                                                                                                                                        (75)
    if isfunction(obj) or _signature_is_functionlike(obj):==============================================================================================(76)
                                                                                                                          step 7: run on itself will run here
        # If it&#39;s a pure Python function, or an object that is duck type                                                                                (77)
        # of a Python function (Cython functions, for instance), then:                                                                                  (78)


                                                                                                                    isfunction(obj) =&gt; isfunction(obj) : True


                                                                                    _signature_is_functionlike(obj) =&gt; _signature_is_functionlike(obj) : True</code></pre>
</div>
<div class="cell-output cell-output-display column-screen">
<pre><code>&lt;Signature (self, a, b, c)&gt;</code></pre>
</div>
</div>
<div class="cell">
<div class="sourceCode" id="cb52"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a>dbsig <span class="op">=</span> sig.dbprint(<span class="dv">79</span>, <span class="st">&quot;step 8: get sig with a different func&quot;</span>, <span class="st">&quot;env&quot;</span>)</span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a>inspect._signature_from_callable <span class="op">=</span> dbsig</span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true" tabindex="-1"></a>inspect.signature(Foo)</span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>        # If it&#39;s a pure Python function, or an object that is duck type                                                                                (77)
        # of a Python function (Cython functions, for instance), then:                                                                                  (78)
        return _signature_from_function(sigcls, obj,====================================================================================================(79)
                                                                                                                        step 8: get sig with a different func
                                        skip_bound_arg=skip_bound_arg)                                                                                  (80)
                                                                                                                                                        (81)</code></pre>
</div>
<div class="cell-output cell-output-display column-screen">
<pre><code>&lt;Signature (a, b, c)&gt;</code></pre>
</div>
</div>
</section>
<section id="read-commented-_signature_from_callable-from-python-3.9" class="level3">
<h3>Read commented <code>_signature_from_callable</code> from python 3.9+</h3>
<div class="cell column-screen">
<div class="sourceCode" id="cb55"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a>sig.<span class="bu">print</span>()</span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>def _signature_from_callable(obj, *,======================================================(0)       
                             follow_wrapper_chains=True,==================================(1)       
                             skip_bound_arg=True,=========================================(2)       
                             sigcls):=====================================================(3)       
                                                                                                                                                        (4)
    &quot;&quot;&quot;Private helper function to get signature for arbitrary=============================(5)       
    callable objects.=====================================================================(6)       
    &quot;&quot;&quot;===================================================================================(7)       
                                                                                                                                                        (8)
    _get_signature_of = functools.partial(_signature_from_callable,=======================(9) # so that it can use in itself
                                follow_wrapper_chains=follow_wrapper_chains,==============(10)      
                                skip_bound_arg=skip_bound_arg,============================(11)      
                                sigcls=sigcls)============================================(12)      
                                                                                                                                                        (13)
    if not callable(obj):=================================================================(14) # obj must be callable
        raise TypeError(&#39;{!r} is not a callable object&#39;.format(obj))======================(15)      
                                                                                                                                                        (16)
    if isinstance(obj, types.MethodType):=================================================(17) # obj can be a classmethod
        # In this case we skip the first parameter of the underlying======================(18)      
        # function (usually `self` or `cls`).=============================================(19)      
        sig = _get_signature_of(obj.__func__)=============================================(20)      
                                                                                                                                                        (21)
        if skip_bound_arg:================================================================(22)      
            return _signature_bound_method(sig)===========================================(23)      
        else:=============================================================================(24)      
            return sig====================================================================(25)      
                                                                                                                                                        (26)
    # Was this function wrapped by a decorator?===========================================(27)      
    if follow_wrapper_chains:=============================================================(28) # does Foo has __signature__?
        obj = unwrap(obj, stop=(lambda f: hasattr(f, &quot;__signature__&quot;)))===================(29)      
        if isinstance(obj, types.MethodType):=============================================(30)      
            # If the unwrapped object is a *method*, we might want to=====================(31)      
            # skip its first parameter (self).============================================(32)      
            # See test_signature_wrapped_bound_method for details.========================(33)      
            return _get_signature_of(obj)=================================================(34)      
                                                                                                                                                        (35)
    try:==================================================================================(36)      
        sig = obj.__signature__===========================================================(37) # check __signature__
    except AttributeError:================================================================(38)      
        pass==============================================================================(39)      
    else:=================================================================================(40)      
        if sig is not None:===============================================================(41)      
            if not isinstance(sig, Signature):============================================(42)      
                raise TypeError(==========================================================(43)      
                    &#39;unexpected object {!r} in __signature__ &#39;============================(44)      
                    &#39;attribute&#39;.format(sig))==============================================(45)      
            return sig====================================================================(46)      
                                                                                                                                                        (47)
    try:==================================================================================(48)      
        partialmethod = obj._partialmethod================================================(49)      
    except AttributeError:================================================================(50)      
        pass==============================================================================(51)      
    else:=================================================================================(52)      
        if isinstance(partialmethod, functools.partialmethod):============================(53)      
            # Unbound partialmethod (see functools.partialmethod)=========================(54)      
            # This means, that we need to calculate the signature=========================(55)      
            # as if it&#39;s a regular partial object, but taking into========================(56)      
            # account that the first positional argument==================================(57)      
            # (usually `self`, or `cls`) will not be passed===============================(58)      
            # automatically (as for boundmethods)=========================================(59)      
                                                                                                                                                        (60)
            wrapped_sig = _get_signature_of(partialmethod.func)===========================(61)      
                                                                                                                                                        (62)
            sig = _signature_get_partial(wrapped_sig, partialmethod, (None,))=============(63)      
            first_wrapped_param = tuple(wrapped_sig.parameters.values())[0]===============(64)      
            if first_wrapped_param.kind is Parameter.VAR_POSITIONAL:======================(65)      
                # First argument of the wrapped callable is `*args`, as in================(66)      
                # `partialmethod(lambda *args)`.==========================================(67)      
                return sig================================================================(68)      
            else:=========================================================================(69)      
                sig_params = tuple(sig.parameters.values())===============================(70)      
                assert (not sig_params or=================================================(71)      
                        first_wrapped_param is not sig_params[0])=========================(72)      
                new_params = (first_wrapped_param,) + sig_params==========================(73)      
                return sig.replace(parameters=new_params)=================================(74)      
                                                                                                                                                        (75)
    if isfunction(obj) or _signature_is_functionlike(obj):================================(76) # step 7: run on itself will run here
        # If it&#39;s a pure Python function, or an object that is duck type==================(77)      
        # of a Python function (Cython functions, for instance), then:====================(78)      
        return _signature_from_function(sigcls, obj,======================================(79) # step 8: get sig with a different func
                                        skip_bound_arg=skip_bound_arg)====================(80)      
                                                                                                                                                        (81)
    if _signature_is_builtin(obj):========================================================(82)      
        return _signature_from_builtin(sigcls, obj,=======================================(83)      
                                       skip_bound_arg=skip_bound_arg)=====================(84)      
                                                                                                                                                        (85)
    if isinstance(obj, functools.partial):================================================(86)      
        wrapped_sig = _get_signature_of(obj.func)=========================================(87)      
        return _signature_get_partial(wrapped_sig, obj)===================================(88)      
                                                                                                                                                        (89)
    sig = None============================================================================(90)      
    if isinstance(obj, type):=============================================================(91) # step 1: obj is a class?
        # obj is a class or a metaclass===================================================(92)      
                                                                                                                                                        (93)
        # First, let&#39;s see if it has an overloaded __call__ defined=======================(94)      
        # in its metaclass================================================================(95)      
        call = _signature_get_user_defined_method(type(obj), &#39;__call__&#39;)==================(96) # step 2: define its own __call__?
        if call is not None:==============================================================(97)      
            sig = _get_signature_of(call)=================================================(98)      
        else:=============================================================================(99)      
            factory_method = None=========================================================(100)     
            new = _signature_get_user_defined_method(obj, &#39;__new__&#39;)======================(101) # step 3: define its own __new__?
            init = _signature_get_user_defined_method(obj, &#39;__init__&#39;)====================(102) # step 4: define its own __init__?
            # Now we check if the &#39;obj&#39; class has an own &#39;__new__&#39; method=================(103)     
            if &#39;__new__&#39; in obj.__dict__:=================================================(104)     
                factory_method = new======================================================(105)     
            # or an own &#39;__init__&#39; method=================================================(106)     
            elif &#39;__init__&#39; in obj.__dict__:==============================================(107)     
                factory_method = init=====================================================(108) # step 5: __init__ is inside obj.__dict__?
            # If not, we take inherited &#39;__new__&#39; or &#39;__init__&#39;, if present===============(109)     
            elif new is not None:=========================================================(110)     
                factory_method = new======================================================(111)     
            elif init is not None:========================================================(112)     
                factory_method = init=====================================================(113)     
                                                                                                                                                        (114)
            if factory_method is not None:================================================(115)     
                sig = _get_signature_of(factory_method)===================================(116) # step 6: run on itself using functools.partial
                                                                                                                                                        (117)
        if sig is None:===================================================================(118)     
            # At this point we know, that `obj` is a class, with no user-=================(119)     
            # defined &#39;__init__&#39;, &#39;__new__&#39;, or class-level &#39;__call__&#39;====================(120)     
                                                                                                                                                        (121)
            for base in obj.__mro__[:-1]:=================================================(122)     
                # Since &#39;__text_signature__&#39; is implemented as a==========================(123)     
                # descriptor that extracts text signature from the========================(124)     
                # class docstring, if &#39;obj&#39; is derived from a builtin=====================(125)     
                # class, its own &#39;__text_signature__&#39; may be &#39;None&#39;.======================(126)     
                # Therefore, we go through the MRO (except the last=======================(127)     
                # class in there, which is &#39;object&#39;) to find the first====================(128)     
                # class with non-empty text signature.====================================(129)     
                try:======================================================================(130)     
                    text_sig = base.__text_signature__====================================(131)     
                except AttributeError:====================================================(132)     
                    pass==================================================================(133)     
                else:=====================================================================(134)     
                    if text_sig:==========================================================(135)     
                        # If &#39;base&#39; class has a __text_signature__ attribute:=============(136)     
                        # return a signature based on it==================================(137)     
                        return _signature_fromstr(sigcls, base, text_sig)=================(138)     
                                                                                                                                                        (139)
            # No &#39;__text_signature__&#39; was found for the &#39;obj&#39; class.======================(140)     
            # Last option is to check if its &#39;__init__&#39; is================================(141)     
            # object.__init__ or type.__init__.===========================================(142)     
            if type not in obj.__mro__:===================================================(143)     
                # We have a class (not metaclass), but no user-defined====================(144)     
                # __init__ or __new__ for it==============================================(145)     
                if (obj.__init__ is object.__init__ and===================================(146)     
                    obj.__new__ is object.__new__):=======================================(147)     
                    # Return a signature of &#39;object&#39; builtin.=============================(148)     
                    return sigcls.from_callable(object)===================================(149)     
                else:=====================================================================(150)     
                    raise ValueError(=====================================================(151)     
                        &#39;no signature found for builtin type {!r}&#39;.format(obj))===========(152)     
                                                                                                                                                        (153)
    elif not isinstance(obj, _NonUserDefinedCallables):===================================(154)     
        # An object with __call__=========================================================(155)     
        # We also check that the &#39;obj&#39; is not an instance of==============================(156)     
        # _WrapperDescriptor or _MethodWrapper to avoid===================================(157)     
        # infinite recursion (and even potential segfault)================================(158)     
        call = _signature_get_user_defined_method(type(obj), &#39;__call__&#39;)==================(159)     
        if call is not None:==============================================================(160)     
            try:==========================================================================(161)     
                sig = _get_signature_of(call)=============================================(162)     
            except ValueError as ex:======================================================(163)     
                msg = &#39;no signature found for {!r}&#39;.format(obj)===========================(164)     
                raise ValueError(msg) from ex=============================================(165)     
                                                                                                                                                        (166)
    if sig is not None:===================================================================(167)     
        # For classes and objects we skip the first parameter of their====================(168)     
        # __call__, __new__, or __init__ methods==========================================(169)     
        if skip_bound_arg:================================================================(170)     
            return _signature_bound_method(sig)===========================================(171)     
        else:=============================================================================(172)     
            return sig====================================================================(173)     
                                                                                                                                                        (174)
    if isinstance(obj, types.BuiltinFunctionType):========================================(175)     
        # Raise a nicer error message for builtins========================================(176)     
        msg = &#39;no signature found for builtin function {!r}&#39;.format(obj)==================(177)     
        raise ValueError(msg)=============================================================(178)     
                                                                                                                                                        (179)
    raise ValueError(&#39;callable {!r} is not supported by signature&#39;.format(obj))===========(180)     
                                                                                                                                                        (181)</code></pre>
</div>
</div>
</section>
</section>
<section id="foos-super-class-overriding-__new__-can-stop-foo-getting-sig-from-__init__" class="level2">
<h2>Foo’s super class overriding <code>__new__</code> can stop Foo getting sig from <code>__init__</code></h2>
<p>Many things can go wrong to prevent a class to use the signature from <code>__init__</code>.</p>
<p>FixSigMeta is a metaclass, which helps us to get our classes’ signature right.</p>
<p>Then what types of the signature problems can FixSigMeta fix?</p>
<section id="when-foos-super-class-override-__new__-python3.7-cant-give-foo-sig-from-__init__" class="level3">
<h3>When Foo’s super class override <code>__new__</code>, python3.7 can’t give Foo sig from <code>__init__</code></h3>
<ol type="1">
<li>when your class Foo inherits from class Base, if Base defines its <code>__new__</code>, then Foo can’t get signature from <code>__init__</code>. (True for python 3.7 see <a href="https://www.kaggle.com/code/danielliao/notebook3edc928f49?scriptVersionId=104385507&amp;cellId=1">demos</a>, no more for 3.9+)</li>
</ol>
<div class="cell">
<div class="sourceCode" id="cb57"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Base: <span class="co"># pass</span></span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__new__</span>(<span class="va">self</span>, <span class="op">**</span>args): <span class="cf">pass</span>  <span class="co"># defines a __new__ </span></span>
<span id="cb57-3"><a href="#cb57-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-4"><a href="#cb57-4" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Foo(Base):</span>
<span id="cb57-5"><a href="#cb57-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, d, e, f): <span class="cf">pass</span></span>
<span id="cb57-6"><a href="#cb57-6" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb57-7"><a href="#cb57-7" aria-hidden="true" tabindex="-1"></a>inspect._signature_from_callable <span class="op">=</span> sig.orisrc</span>
<span id="cb57-8"><a href="#cb57-8" aria-hidden="true" tabindex="-1"></a>inspect.signature(Foo) <span class="co"># no more problem for python 3.9+,</span></span></code></pre></div>
<div class="cell-output cell-output-display">
<pre><code>&lt;Signature (d, e, f)&gt;</code></pre>
</div>
</div>
<div class="cell">
<div class="sourceCode" id="cb59"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a><span class="co"># from IPython.display import IFrame</span></span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-3"><a href="#cb59-3" aria-hidden="true" tabindex="-1"></a><span class="co"># IFrame(src=&quot;https://www.kaggle.com/embed/danielliao/notebook3edc928f49?cellIds=2&amp;kernelSessionId=104407182&quot;, width = &quot;1200&quot;, height=&quot;300&quot;, \</span></span>
<span id="cb59-4"><a href="#cb59-4" aria-hidden="true" tabindex="-1"></a><span class="co">#        style=&quot;margin: 0 auto; width: 100%; max-width: 950px;&quot;, frameborder=&quot;0&quot;, scrolling=&quot;auto&quot;, title=&quot;notebook3edc928f49&quot;)</span></span></code></pre></div>
</div>
<div class="cell">
<div class="sourceCode" id="cb60"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a>inspect._signature_from_callable <span class="op">=</span> _signature_from_callableOld</span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true" tabindex="-1"></a>inspect.signature(Foo) <span class="co"># it is a problem for python 3.7,</span></span></code></pre></div>
<div class="cell-output cell-output-display">
<pre><code>&lt;Signature (**args)&gt;</code></pre>
</div>
</div>
</section>
<section id="how-python3.7-and-its-inspect-mess-it-up" class="level3">
<h3>How python3.7 and its inspect mess it up</h3>
<div class="cell">
<div class="sourceCode" id="cb62"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a><span class="co"># g = locals()</span></span></code></pre></div>
</div>
<div class="cell">
<div class="sourceCode" id="cb63"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a>sigOld <span class="op">=</span> Fastdb(_signature_from_callableOld, g)</span></code></pre></div>
</div>
<div class="cell column-screen">
<div class="sourceCode" id="cb64"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a>dbsigOld <span class="op">=</span> sigOld.dbprint(<span class="dv">115</span>, <span class="st">&quot;messup step 1: overriding __new__ is detected&quot;</span>, <span class="st">&quot;new = _signature_get_user_defined_method(obj, &#39;__new__&#39;)&quot;</span>)</span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true" tabindex="-1"></a>inspect._signature_from_callable <span class="op">=</span> dbsigOld </span>
<span id="cb64-3"><a href="#cb64-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(inspect.signature(Foo)) <span class="co"># it is a problem for python 3.7, </span></span>
<span id="cb64-4"><a href="#cb64-4" aria-hidden="true" tabindex="-1"></a>sigOld.<span class="bu">print</span>(part<span class="op">=</span><span class="dv">4</span>)</span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>        else:                                                                                                                                           (113)
            # Now we check if the &#39;obj&#39; class has a &#39;__new__&#39; method                                                                                    (114)
            new = _signature_get_user_defined_method(obj, &#39;__new__&#39;)====================================================================================(115)
                                                                                                                messup step 1: overriding __new__ is detected
            if new is not None:                                                                                                                         (116)
                sig = _signature_from_callable(                                                                                                         (117)


                                                      new = _signature_get_user_defined_method(obj, &#39;__new__&#39;) =&gt; new: &lt;function Base.__new__ at 0x111d13d30&gt;
(**args)
                                                                                                                                                        (99)
    sig = None============================================================================(100)     
    if isinstance(obj, type):=============================================================(101)     
        # obj is a class or a metaclass===================================================(102)     
                                                                                                                                                        (103)
        # First, let&#39;s see if it has an overloaded __call__ defined=======================(104)     
        # in its metaclass================================================================(105)     
        call = _signature_get_user_defined_method(type(obj), &#39;__call__&#39;)==================(106)     
        if call is not None:==============================================================(107)     
            sig = _signature_from_callable(===============================================(108)     
                call,=====================================================================(109)     
                follow_wrapper_chains=follow_wrapper_chains,==============================(110)     
                skip_bound_arg=skip_bound_arg,============================================(111)     
                sigcls=sigcls)============================================================(112)     
        else:=============================================================================(113)     
            # Now we check if the &#39;obj&#39; class has a &#39;__new__&#39; method======================(114)     
            new = _signature_get_user_defined_method(obj, &#39;__new__&#39;)======================(115) # messup step 1: overriding __new__ is detected
            if new is not None:===========================================================(116)     
                sig = _signature_from_callable(===========================================(117)     
                    new,==================================================================(118)     
                    follow_wrapper_chains=follow_wrapper_chains,==========================(119)     
                    skip_bound_arg=skip_bound_arg,========================================(120)     
                    sigcls=sigcls)========================================================(121)     
            else:=========================================================================(122)     
                # Finally, we should have at least __init__ implemented===================(123)     
                init = _signature_get_user_defined_method(obj, &#39;__init__&#39;)================(124)     
                if init is not None:======================================================(125)     
                    sig = _signature_from_callable(=======================================(126)     
                        init,=============================================================(127)     
                        follow_wrapper_chains=follow_wrapper_chains,======================(128)     
                        skip_bound_arg=skip_bound_arg,====================================(129)     
                        sigcls=sigcls)====================================================(130)     
                                                                                                                                                        (131)
                                                                                                                                     part No.4 out of 7 parts</code></pre>
</div>
</div>
<div class="cell">
<div class="sourceCode" id="cb66"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pprint <span class="im">import</span> pprint</span></code></pre></div>
</div>
<div class="cell column-screen">
<div class="sourceCode" id="cb67"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a>dbsigOld <span class="op">=</span> sigOld.dbprint(<span class="dv">117</span>, <span class="st">&quot;messup step 2: only __new__ sig is extracted&quot;</span>, <span class="st">&quot;env&quot;</span>)</span>
<span id="cb67-2"><a href="#cb67-2" aria-hidden="true" tabindex="-1"></a>inspect._signature_from_callable <span class="op">=</span> dbsigOld </span>
<span id="cb67-3"><a href="#cb67-3" aria-hidden="true" tabindex="-1"></a>pprint(inspect.signature(Foo)) <span class="co"># it is a problem for python 3.7, </span></span>
<span id="cb67-4"><a href="#cb67-4" aria-hidden="true" tabindex="-1"></a>sigOld.<span class="bu">print</span>(part<span class="op">=</span><span class="dv">4</span>)</span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>            new = _signature_get_user_defined_method(obj, &#39;__new__&#39;)                                                                                    (115)
            if new is not None:                                                                                                                         (116)
                sig = _signature_from_callable(=========================================================================================================(117)
                                                                                                                 messup step 2: only __new__ sig is extracted
                    new,                                                                                                                                (118)
                    follow_wrapper_chains=follow_wrapper_chains,                                                                                        (119)


env =&gt; env : {&#39;obj&#39;: &lt;class &#39;__main__.Foo&#39;&gt;, &#39;follow_wrapper_chains&#39;: True, &#39;skip_bound_arg&#39;: True, &#39;sigcls&#39;: &lt;class &#39;inspect.Signature&#39;&gt;, &#39;sig&#39;: None, &#39;call&#39;: None, &#39;new&#39;: &lt;function Base.__new__ at 0x111d13d30&gt;}
&lt;Signature (**args)&gt;
                                                                                                                                                        (99)
    sig = None============================================================================(100)     
    if isinstance(obj, type):=============================================================(101)     
        # obj is a class or a metaclass===================================================(102)     
                                                                                                                                                        (103)
        # First, let&#39;s see if it has an overloaded __call__ defined=======================(104)     
        # in its metaclass================================================================(105)     
        call = _signature_get_user_defined_method(type(obj), &#39;__call__&#39;)==================(106)     
        if call is not None:==============================================================(107)     
            sig = _signature_from_callable(===============================================(108)     
                call,=====================================================================(109)     
                follow_wrapper_chains=follow_wrapper_chains,==============================(110)     
                skip_bound_arg=skip_bound_arg,============================================(111)     
                sigcls=sigcls)============================================================(112)     
        else:=============================================================================(113)     
            # Now we check if the &#39;obj&#39; class has a &#39;__new__&#39; method======================(114)     
            new = _signature_get_user_defined_method(obj, &#39;__new__&#39;)======================(115) # messup step 1: overriding __new__ is detected
            if new is not None:===========================================================(116)     
                sig = _signature_from_callable(===========================================(117) # messup step 2: only __new__ sig is extracted
                    new,==================================================================(118)     
                    follow_wrapper_chains=follow_wrapper_chains,==========================(119)     
                    skip_bound_arg=skip_bound_arg,========================================(120)     
                    sigcls=sigcls)========================================================(121)     
            else:=========================================================================(122)     
                # Finally, we should have at least __init__ implemented===================(123)     
                init = _signature_get_user_defined_method(obj, &#39;__init__&#39;)================(124)     
                if init is not None:======================================================(125)     
                    sig = _signature_from_callable(=======================================(126)     
                        init,=============================================================(127)     
                        follow_wrapper_chains=follow_wrapper_chains,======================(128)     
                        skip_bound_arg=skip_bound_arg,====================================(129)     
                        sigcls=sigcls)====================================================(130)     
                                                                                                                                                        (131)
                                                                                                                                     part No.4 out of 7 parts</code></pre>
</div>
</div>
<div class="cell column-screen">
<div class="sourceCode" id="cb69"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a>dbsigOld <span class="op">=</span> sigOld.dbprint(<span class="dv">124</span>, <span class="st">&quot;messup step 3: __init__ don&#39;t even get accessed&quot;</span>)</span>
<span id="cb69-2"><a href="#cb69-2" aria-hidden="true" tabindex="-1"></a>inspect._signature_from_callable <span class="op">=</span> dbsigOld </span>
<span id="cb69-3"><a href="#cb69-3" aria-hidden="true" tabindex="-1"></a>pprint(inspect.signature(Foo))</span>
<span id="cb69-4"><a href="#cb69-4" aria-hidden="true" tabindex="-1"></a>sigOld.<span class="bu">print</span>(part<span class="op">=</span><span class="dv">4</span>)</span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>            else:                                                                                                                                       (122)
                # Finally, we should have at least __init__ implemented                                                                                 (123)
                init = _signature_get_user_defined_method(obj, &#39;__init__&#39;)==============================================================================(124)
                                                                                                              messup step 3: __init__ don&#39;t even get accessed
                if init is not None:                                                                                                                    (125)
                    sig = _signature_from_callable(                                                                                                     (126)
&lt;Signature (**args)&gt;
                                                                                                                                                        (99)
    sig = None============================================================================(100)     
    if isinstance(obj, type):=============================================================(101)     
        # obj is a class or a metaclass===================================================(102)     
                                                                                                                                                        (103)
        # First, let&#39;s see if it has an overloaded __call__ defined=======================(104)     
        # in its metaclass================================================================(105)     
        call = _signature_get_user_defined_method(type(obj), &#39;__call__&#39;)==================(106)     
        if call is not None:==============================================================(107)     
            sig = _signature_from_callable(===============================================(108)     
                call,=====================================================================(109)     
                follow_wrapper_chains=follow_wrapper_chains,==============================(110)     
                skip_bound_arg=skip_bound_arg,============================================(111)     
                sigcls=sigcls)============================================================(112)     
        else:=============================================================================(113)     
            # Now we check if the &#39;obj&#39; class has a &#39;__new__&#39; method======================(114)     
            new = _signature_get_user_defined_method(obj, &#39;__new__&#39;)======================(115) # messup step 1: overriding __new__ is detected
            if new is not None:===========================================================(116)     
                sig = _signature_from_callable(===========================================(117) # messup step 2: only __new__ sig is extracted
                    new,==================================================================(118)     
                    follow_wrapper_chains=follow_wrapper_chains,==========================(119)     
                    skip_bound_arg=skip_bound_arg,========================================(120)     
                    sigcls=sigcls)========================================================(121)     
            else:=========================================================================(122)     
                # Finally, we should have at least __init__ implemented===================(123)     
                init = _signature_get_user_defined_method(obj, &#39;__init__&#39;)================(124) # messup step 3: __init__ don&#39;t even get accessed
                if init is not None:======================================================(125)     
                    sig = _signature_from_callable(=======================================(126)     
                        init,=============================================================(127)     
                        follow_wrapper_chains=follow_wrapper_chains,======================(128)     
                        skip_bound_arg=skip_bound_arg,====================================(129)     
                        sigcls=sigcls)====================================================(130)     
                                                                                                                                                        (131)
                                                                                                                                     part No.4 out of 7 parts</code></pre>
</div>
</div>
</section>
<section id="fixsigmeta-can-fix-it-for-python-3.7-inspect" class="level3">
<h3>FixSigMeta can fix it for python 3.7 inspect</h3>
<p>Solution to 1: By also inheriting from the metaclass FixSigMeta can solve the signature problem for Foo (for python 3.7)</p>
<div class="cell">
<div class="sourceCode" id="cb71"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> fastcore.meta <span class="im">import</span> FixSigMeta, test_sig</span></code></pre></div>
</div>
<div class="cell">
<div class="sourceCode" id="cb72"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb72-1"><a href="#cb72-1" aria-hidden="true" tabindex="-1"></a>inspect._signature_from_callable <span class="op">=</span> _signature_from_callableNew</span></code></pre></div>
</div>
<div class="cell">
<div class="sourceCode" id="cb73"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb73-1"><a href="#cb73-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Base: <span class="co"># pass</span></span>
<span id="cb73-2"><a href="#cb73-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__new__</span>(<span class="va">self</span>, <span class="op">**</span>args): <span class="cf">pass</span>  <span class="co"># defines a __new__ </span></span>
<span id="cb73-3"><a href="#cb73-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-4"><a href="#cb73-4" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Foo(Base, metaclass<span class="op">=</span>FixSigMeta):</span>
<span id="cb73-5"><a href="#cb73-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, d, e, f): <span class="cf">pass</span></span>
<span id="cb73-6"><a href="#cb73-6" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb73-7"><a href="#cb73-7" aria-hidden="true" tabindex="-1"></a>test_sig(Foo, <span class="st">&#39;(d, e, f)&#39;</span>)</span>
<span id="cb73-8"><a href="#cb73-8" aria-hidden="true" tabindex="-1"></a>inspect.signature(Foo)</span></code></pre></div>
<div class="cell-output cell-output-display">
<pre><code>&lt;Signature (d, e, f)&gt;</code></pre>
</div>
</div>
<div class="cell">
<div class="sourceCode" id="cb75"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb75-1"><a href="#cb75-1" aria-hidden="true" tabindex="-1"></a>inspect._signature_from_callable <span class="op">=</span> dbsigOld</span>
<span id="cb75-2"><a href="#cb75-2" aria-hidden="true" tabindex="-1"></a>inspect.signature(Foo) <span class="co"># No more a problem for python 3.7</span></span></code></pre></div>
<div class="cell-output cell-output-display">
<pre><code>&lt;Signature (d, e, f)&gt;</code></pre>
</div>
</div>
</section>
<section id="how-fixsigmeta-fix-it" class="level3">
<h3>How FixSigMeta fix it?</h3>
<div class="cell">
<div class="sourceCode" id="cb77"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb77-1"><a href="#cb77-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Base: <span class="co"># pass</span></span>
<span id="cb77-2"><a href="#cb77-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__new__</span>(<span class="va">self</span>, <span class="op">**</span>args): <span class="cf">pass</span>  <span class="co"># defines a __new__ </span></span>
<span id="cb77-3"><a href="#cb77-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb77-4"><a href="#cb77-4" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Foo(Base):</span>
<span id="cb77-5"><a href="#cb77-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, d, e, f): <span class="cf">pass</span></span>
<span id="cb77-6"><a href="#cb77-6" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb77-7"><a href="#cb77-7" aria-hidden="true" tabindex="-1"></a>inspect._signature_from_callable <span class="op">=</span> sigOld.orisrc</span>
<span id="cb77-8"><a href="#cb77-8" aria-hidden="true" tabindex="-1"></a>inspect.signature(Foo)</span></code></pre></div>
<div class="cell-output cell-output-display">
<pre><code>&lt;Signature (**args)&gt;</code></pre>
</div>
</div>
<div class="cell">
<div class="sourceCode" id="cb79"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb79-1"><a href="#cb79-1" aria-hidden="true" tabindex="-1"></a><span class="bu">hasattr</span>(Foo, <span class="st">&#39;__signature__&#39;</span>)</span></code></pre></div>
<div class="cell-output cell-output-display">
<pre><code>False</code></pre>
</div>
</div>
<div class="cell">
<div class="sourceCode" id="cb81"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb81-1"><a href="#cb81-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Base: <span class="co"># pass</span></span>
<span id="cb81-2"><a href="#cb81-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__new__</span>(<span class="va">self</span>, <span class="op">**</span>args): <span class="cf">pass</span>  <span class="co"># defines a __new__ </span></span>
<span id="cb81-3"><a href="#cb81-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb81-4"><a href="#cb81-4" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Foo(Base, metaclass<span class="op">=</span>FixSigMeta):</span>
<span id="cb81-5"><a href="#cb81-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, d, e, f): <span class="cf">pass</span></span>
<span id="cb81-6"><a href="#cb81-6" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb81-7"><a href="#cb81-7" aria-hidden="true" tabindex="-1"></a>test_sig(Foo, <span class="st">&#39;(d, e, f)&#39;</span>)</span>
<span id="cb81-8"><a href="#cb81-8" aria-hidden="true" tabindex="-1"></a>inspect.signature(Foo)</span></code></pre></div>
<div class="cell-output cell-output-display">
<pre><code>&lt;Signature (d, e, f)&gt;</code></pre>
</div>
</div>
<div class="cell">
<div class="sourceCode" id="cb83"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb83-1"><a href="#cb83-1" aria-hidden="true" tabindex="-1"></a>Foo.__signature__</span></code></pre></div>
<div class="cell-output cell-output-display">
<pre><code>&lt;Signature (d, e, f)&gt;</code></pre>
</div>
</div>
<div class="cell column-screen">
<div class="sourceCode" id="cb85"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb85-1"><a href="#cb85-1" aria-hidden="true" tabindex="-1"></a>dbsigOld <span class="op">=</span> sigOld.dbprint(<span class="dv">27</span>, <span class="st">&quot;FixSigMeta step 1: does it have __signature__&quot;</span>, <span class="st">&quot;env&quot;</span>, <span class="st">&quot;hasattr(obj, &#39;__signature__&#39;)&quot;</span>, <span class="op">\</span></span>
<span id="cb85-2"><a href="#cb85-2" aria-hidden="true" tabindex="-1"></a>               <span class="st">&quot;obj = unwrap(obj, stop=(lambda f: hasattr(f, &#39;__signature__&#39;)))&quot;</span>, <span class="st">&quot;inspect.getdoc(unwrap)&quot;</span>)</span>
<span id="cb85-3"><a href="#cb85-3" aria-hidden="true" tabindex="-1"></a>inspect._signature_from_callable <span class="op">=</span> dbsigOld</span>
<span id="cb85-4"><a href="#cb85-4" aria-hidden="true" tabindex="-1"></a>pprint(inspect.signature(Foo)) </span>
<span id="cb85-5"><a href="#cb85-5" aria-hidden="true" tabindex="-1"></a>sigOld.<span class="bu">print</span>(part<span class="op">=</span><span class="dv">1</span>)</span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>                                                                                                                                                        (25)
    # Was this function wrapped by a decorator?                                                                                                         (26)
    if follow_wrapper_chains:===========================================================================================================================(27)
                                                                                                                FixSigMeta step 1: does it have __signature__
        obj = unwrap(obj, stop=(lambda f: hasattr(f, &quot;__signature__&quot;)))                                                                                 (28)
        if isinstance(obj, types.MethodType):                                                                                                           (29)


                   env =&gt; env : {&#39;obj&#39;: &lt;class &#39;__main__.Foo&#39;&gt;, &#39;follow_wrapper_chains&#39;: True, &#39;skip_bound_arg&#39;: True, &#39;sigcls&#39;: &lt;class &#39;inspect.Signature&#39;&gt;}


                                                                                        hasattr(obj, &#39;__signature__&#39;) =&gt; hasattr(obj, &#39;__signature__&#39;) : True


                                                               obj = unwrap(obj, stop=(lambda f: hasattr(f, &#39;__signature__&#39;))) =&gt; obj: &lt;class &#39;__main__.Foo&#39;&gt;


inspect.getdoc(unwrap) =&gt; inspect.getdoc(unwrap) : Get the object wrapped by *func*.

Follows the chain of :attr:`__wrapped__` attributes returning the last
object in the chain.

*stop* is an optional callback accepting an object in the wrapper chain
as its sole argument that allows the unwrapping to be terminated early if
the callback returns a true value. If the callback never returns a true
value, the last object in the chain is returned as usual. For example,
:func:`signature` uses this to stop unwrapping if any object in the
chain has a ``__signature__`` attribute defined.

:exc:`ValueError` is raised if a cycle is encountered.

 
&lt;Signature (d, e, f)&gt;
def _signature_from_callableOld(obj, *,===================================================(0)       
                             follow_wrapper_chains=True,==================================(1)       
                             skip_bound_arg=True,=========================================(2)       
                             sigcls):=====================================================(3)       
                                                                                                                                                        (4)
    &quot;&quot;&quot;Private helper function to get signature for arbitrary=============================(5)       
    callable objects.=====================================================================(6)       
    &quot;&quot;&quot;===================================================================================(7)       
                                                                                                                                                        (8)
    if not callable(obj):=================================================================(9)       
        raise TypeError(&#39;{!r} is not a callable object&#39;.format(obj))======================(10)      
                                                                                                                                                        (11)
    if isinstance(obj, types.MethodType):=================================================(12)      
        # In this case we skip the first parameter of the underlying======================(13)      
        # function (usually `self` or `cls`).=============================================(14)      
        sig = _signature_from_callable(===================================================(15)      
            obj.__func__,=================================================================(16)      
            follow_wrapper_chains=follow_wrapper_chains,==================================(17)      
            skip_bound_arg=skip_bound_arg,================================================(18)      
            sigcls=sigcls)================================================================(19)      
                                                                                                                                                        (20)
        if skip_bound_arg:================================================================(21)      
            return _signature_bound_method(sig)===========================================(22)      
        else:=============================================================================(23)      
            return sig====================================================================(24)      
                                                                                                                                                        (25)
    # Was this function wrapped by a decorator?===========================================(26)      
    if follow_wrapper_chains:=============================================================(27) # FixSigMeta step 1: does it have __signature__
        obj = unwrap(obj, stop=(lambda f: hasattr(f, &quot;__signature__&quot;)))===================(28)      
        if isinstance(obj, types.MethodType):=============================================(29)      
            # If the unwrapped object is a *method*, we might want to=====================(30)      
            # skip its first parameter (self).============================================(31)      
            # See test_signature_wrapped_bound_method for details.========================(32)      
                                                                                                                                     part No.1 out of 7 parts</code></pre>
</div>
</div>
<div class="cell column-screen">
<div class="sourceCode" id="cb87"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb87-1"><a href="#cb87-1" aria-hidden="true" tabindex="-1"></a>dbsigOld <span class="op">=</span> sigOld.dbprint(<span class="dv">44</span>, <span class="st">&quot;FixSigMeta step 2: use __signature__ as Foo&#39;s sig&quot;</span>, <span class="st">&quot;env&quot;</span>, <span class="st">&quot;sig = obj.__signature__&quot;</span>, <span class="st">&quot;isinstance(sig, Signature)&quot;</span>)</span>
<span id="cb87-2"><a href="#cb87-2" aria-hidden="true" tabindex="-1"></a>inspect._signature_from_callable <span class="op">=</span> dbsigOld</span>
<span id="cb87-3"><a href="#cb87-3" aria-hidden="true" tabindex="-1"></a>pprint(inspect.signature(Foo)) </span>
<span id="cb87-4"><a href="#cb87-4" aria-hidden="true" tabindex="-1"></a>sigOld.<span class="bu">print</span>(part<span class="op">=</span><span class="dv">2</span>)</span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>        pass                                                                                                                                            (42)
    else:                                                                                                                                               (43)
        if sig is not None:=============================================================================================================================(44)
                                                                                                            FixSigMeta step 2: use __signature__ as Foo&#39;s sig
            if not isinstance(sig, Signature):                                                                                                          (45)
                raise TypeError(                                                                                                                        (46)


env =&gt; env : {&#39;obj&#39;: &lt;class &#39;__main__.Foo&#39;&gt;, &#39;follow_wrapper_chains&#39;: True, &#39;skip_bound_arg&#39;: True, &#39;sigcls&#39;: &lt;class &#39;inspect.Signature&#39;&gt;, &#39;sig&#39;: &lt;Signature (d, e, f)&gt;}


                                                                                                                    sig = obj.__signature__ =&gt; sig: (d, e, f)


                                                                                              isinstance(sig, Signature) =&gt; isinstance(sig, Signature) : True
&lt;Signature (d, e, f)&gt;
            return _signature_from_callable(==============================================(33)      
                obj,======================================================================(34)      
                follow_wrapper_chains=follow_wrapper_chains,==============================(35)      
                skip_bound_arg=skip_bound_arg,============================================(36)      
                sigcls=sigcls)============================================================(37)      
                                                                                                                                                        (38)
    try:==================================================================================(39)      
        sig = obj.__signature__===========================================================(40)      
    except AttributeError:================================================================(41)      
        pass==============================================================================(42)      
    else:=================================================================================(43)      
        if sig is not None:===============================================================(44) # FixSigMeta step 2: use __signature__ as Foo&#39;s sig
            if not isinstance(sig, Signature):============================================(45)      
                raise TypeError(==========================================================(46)      
                    &#39;unexpected object {!r} in __signature__ &#39;============================(47)      
                    &#39;attribute&#39;.format(sig))==============================================(48)      
            return sig====================================================================(49)      
                                                                                                                                                        (50)
    try:==================================================================================(51)      
        partialmethod = obj._partialmethod================================================(52)      
    except AttributeError:================================================================(53)      
        pass==============================================================================(54)      
    else:=================================================================================(55)      
        if isinstance(partialmethod, functools.partialmethod):============================(56)      
            # Unbound partialmethod (see functools.partialmethod)=========================(57)      
            # This means, that we need to calculate the signature=========================(58)      
            # as if it&#39;s a regular partial object, but taking into========================(59)      
            # account that the first positional argument==================================(60)      
            # (usually `self`, or `cls`) will not be passed===============================(61)      
            # automatically (as for boundmethods)=========================================(62)      
                                                                                                                                                        (63)
            wrapped_sig = _signature_from_callable(=======================================(64)      
                partialmethod.func,=======================================================(65)      
                                                                                                                                     part No.2 out of 7 parts</code></pre>
</div>
</div>
<p>Note: new and old <code>_signature_from_callable</code> have the same code for getting signature for object with <code>__signature__</code>.</p>
</section>
<section id="read-commented-_signature_from_callable-of-python-3.7" class="level3">
<h3>Read commented <code>_signature_from_callable</code> of python 3.7</h3>
<div class="cell column-screen">
<div class="sourceCode" id="cb89"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb89-1"><a href="#cb89-1" aria-hidden="true" tabindex="-1"></a>sigOld.<span class="bu">print</span>()</span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>def _signature_from_callableOld(obj, *,===================================================(0)       
                             follow_wrapper_chains=True,==================================(1)       
                             skip_bound_arg=True,=========================================(2)       
                             sigcls):=====================================================(3)       
                                                                                                                                                        (4)
    &quot;&quot;&quot;Private helper function to get signature for arbitrary=============================(5)       
    callable objects.=====================================================================(6)       
    &quot;&quot;&quot;===================================================================================(7)       
                                                                                                                                                        (8)
    if not callable(obj):=================================================================(9)       
        raise TypeError(&#39;{!r} is not a callable object&#39;.format(obj))======================(10)      
                                                                                                                                                        (11)
    if isinstance(obj, types.MethodType):=================================================(12)      
        # In this case we skip the first parameter of the underlying======================(13)      
        # function (usually `self` or `cls`).=============================================(14)      
        sig = _signature_from_callable(===================================================(15)      
            obj.__func__,=================================================================(16)      
            follow_wrapper_chains=follow_wrapper_chains,==================================(17)      
            skip_bound_arg=skip_bound_arg,================================================(18)      
            sigcls=sigcls)================================================================(19)      
                                                                                                                                                        (20)
        if skip_bound_arg:================================================================(21)      
            return _signature_bound_method(sig)===========================================(22)      
        else:=============================================================================(23)      
            return sig====================================================================(24)      
                                                                                                                                                        (25)
    # Was this function wrapped by a decorator?===========================================(26)      
    if follow_wrapper_chains:=============================================================(27) # FixSigMeta step 1: does it have __signature__
        obj = unwrap(obj, stop=(lambda f: hasattr(f, &quot;__signature__&quot;)))===================(28)      
        if isinstance(obj, types.MethodType):=============================================(29)      
            # If the unwrapped object is a *method*, we might want to=====================(30)      
            # skip its first parameter (self).============================================(31)      
            # See test_signature_wrapped_bound_method for details.========================(32)      
            return _signature_from_callable(==============================================(33)      
                obj,======================================================================(34)      
                follow_wrapper_chains=follow_wrapper_chains,==============================(35)      
                skip_bound_arg=skip_bound_arg,============================================(36)      
                sigcls=sigcls)============================================================(37)      
                                                                                                                                                        (38)
    try:==================================================================================(39)      
        sig = obj.__signature__===========================================================(40)      
    except AttributeError:================================================================(41)      
        pass==============================================================================(42)      
    else:=================================================================================(43)      
        if sig is not None:===============================================================(44) # FixSigMeta step 2: use __signature__ as Foo&#39;s sig
            if not isinstance(sig, Signature):============================================(45)      
                raise TypeError(==========================================================(46)      
                    &#39;unexpected object {!r} in __signature__ &#39;============================(47)      
                    &#39;attribute&#39;.format(sig))==============================================(48)      
            return sig====================================================================(49)      
                                                                                                                                                        (50)
    try:==================================================================================(51)      
        partialmethod = obj._partialmethod================================================(52)      
    except AttributeError:================================================================(53)      
        pass==============================================================================(54)      
    else:=================================================================================(55)      
        if isinstance(partialmethod, functools.partialmethod):============================(56)      
            # Unbound partialmethod (see functools.partialmethod)=========================(57)      
            # This means, that we need to calculate the signature=========================(58)      
            # as if it&#39;s a regular partial object, but taking into========================(59)      
            # account that the first positional argument==================================(60)      
            # (usually `self`, or `cls`) will not be passed===============================(61)      
            # automatically (as for boundmethods)=========================================(62)      
                                                                                                                                                        (63)
            wrapped_sig = _signature_from_callable(=======================================(64)      
                partialmethod.func,=======================================================(65)      
                follow_wrapper_chains=follow_wrapper_chains,==============================(66)      
                skip_bound_arg=skip_bound_arg,============================================(67)      
                sigcls=sigcls)============================================================(68)      
                                                                                                                                                        (69)
            sig = _signature_get_partial(wrapped_sig, partialmethod, (None,))=============(70)      
            first_wrapped_param = tuple(wrapped_sig.parameters.values())[0]===============(71)      
            if first_wrapped_param.kind is Parameter.VAR_POSITIONAL:======================(72)      
                # First argument of the wrapped callable is `*args`, as in================(73)      
                # `partialmethod(lambda *args)`.==========================================(74)      
                return sig================================================================(75)      
            else:=========================================================================(76)      
                sig_params = tuple(sig.parameters.values())===============================(77)      
                assert (not sig_params or=================================================(78)      
                        first_wrapped_param is not sig_params[0])=========================(79)      
                new_params = (first_wrapped_param,) + sig_params==========================(80)      
                return sig.replace(parameters=new_params)=================================(81)      
                                                                                                                                                        (82)
    if isfunction(obj) or _signature_is_functionlike(obj):================================(83)      
        # If it&#39;s a pure Python function, or an object that is duck type==================(84)      
        # of a Python function (Cython functions, for instance), then:====================(85)      
        return _signature_from_function(sigcls, obj)======================================(86)      
                                                                                                                                                        (87)
    if _signature_is_builtin(obj):========================================================(88)      
        return _signature_from_builtin(sigcls, obj,=======================================(89)      
                                       skip_bound_arg=skip_bound_arg)=====================(90)      
                                                                                                                                                        (91)
    if isinstance(obj, functools.partial):================================================(92)      
        wrapped_sig = _signature_from_callable(===========================================(93)      
            obj.func,=====================================================================(94)      
            follow_wrapper_chains=follow_wrapper_chains,==================================(95)      
            skip_bound_arg=skip_bound_arg,================================================(96)      
            sigcls=sigcls)================================================================(97)      
        return _signature_get_partial(wrapped_sig, obj)===================================(98)      
                                                                                                                                                        (99)
    sig = None============================================================================(100)     
    if isinstance(obj, type):=============================================================(101)     
        # obj is a class or a metaclass===================================================(102)     
                                                                                                                                                        (103)
        # First, let&#39;s see if it has an overloaded __call__ defined=======================(104)     
        # in its metaclass================================================================(105)     
        call = _signature_get_user_defined_method(type(obj), &#39;__call__&#39;)==================(106)     
        if call is not None:==============================================================(107)     
            sig = _signature_from_callable(===============================================(108)     
                call,=====================================================================(109)     
                follow_wrapper_chains=follow_wrapper_chains,==============================(110)     
                skip_bound_arg=skip_bound_arg,============================================(111)     
                sigcls=sigcls)============================================================(112)     
        else:=============================================================================(113)     
            # Now we check if the &#39;obj&#39; class has a &#39;__new__&#39; method======================(114)     
            new = _signature_get_user_defined_method(obj, &#39;__new__&#39;)======================(115) # messup step 1: overriding __new__ is detected
            if new is not None:===========================================================(116)     
                sig = _signature_from_callable(===========================================(117) # messup step 2: only __new__ sig is extracted
                    new,==================================================================(118)     
                    follow_wrapper_chains=follow_wrapper_chains,==========================(119)     
                    skip_bound_arg=skip_bound_arg,========================================(120)     
                    sigcls=sigcls)========================================================(121)     
            else:=========================================================================(122)     
                # Finally, we should have at least __init__ implemented===================(123)     
                init = _signature_get_user_defined_method(obj, &#39;__init__&#39;)================(124) # messup step 3: __init__ don&#39;t even get accessed
                if init is not None:======================================================(125)     
                    sig = _signature_from_callable(=======================================(126)     
                        init,=============================================================(127)     
                        follow_wrapper_chains=follow_wrapper_chains,======================(128)     
                        skip_bound_arg=skip_bound_arg,====================================(129)     
                        sigcls=sigcls)====================================================(130)     
                                                                                                                                                        (131)
        if sig is None:===================================================================(132)     
            # At this point we know, that `obj` is a class, with no user-=================(133)     
            # defined &#39;__init__&#39;, &#39;__new__&#39;, or class-level &#39;__call__&#39;====================(134)     
                                                                                                                                                        (135)
            for base in obj.__mro__[:-1]:=================================================(136)     
                # Since &#39;__text_signature__&#39; is implemented as a==========================(137)     
                # descriptor that extracts text signature from the========================(138)     
                # class docstring, if &#39;obj&#39; is derived from a builtin=====================(139)     
                # class, its own &#39;__text_signature__&#39; may be &#39;None&#39;.======================(140)     
                # Therefore, we go through the MRO (except the last=======================(141)     
                # class in there, which is &#39;object&#39;) to find the first====================(142)     
                # class with non-empty text signature.====================================(143)     
                try:======================================================================(144)     
                    text_sig = base.__text_signature__====================================(145)     
                except AttributeError:====================================================(146)     
                    pass==================================================================(147)     
                else:=====================================================================(148)     
                    if text_sig:==========================================================(149)     
                        # If &#39;obj&#39; class has a __text_signature__ attribute:==============(150)     
                        # return a signature based on it==================================(151)     
                        return _signature_fromstr(sigcls, obj, text_sig)==================(152)     
                                                                                                                                                        (153)
            # No &#39;__text_signature__&#39; was found for the &#39;obj&#39; class.======================(154)     
            # Last option is to check if its &#39;__init__&#39; is================================(155)     
            # object.__init__ or type.__init__.===========================================(156)     
            if type not in obj.__mro__:===================================================(157)     
                # We have a class (not metaclass), but no user-defined====================(158)     
                # __init__ or __new__ for it==============================================(159)     
                if (obj.__init__ is object.__init__ and===================================(160)     
                    obj.__new__ is object.__new__):=======================================(161)     
                    # Return a signature of &#39;object&#39; builtin.=============================(162)     
                    return sigcls.from_callable(object)===================================(163)     
                else:=====================================================================(164)     
                    raise ValueError(=====================================================(165)     
                        &#39;no signature found for builtin type {!r}&#39;.format(obj))===========(166)     
                                                                                                                                                        (167)
    elif not isinstance(obj, _NonUserDefinedCallables):===================================(168)     
        # An object with __call__=========================================================(169)     
        # We also check that the &#39;obj&#39; is not an instance of==============================(170)     
        # _WrapperDescriptor or _MethodWrapper to avoid===================================(171)     
        # infinite recursion (and even potential segfault)================================(172)     
        call = _signature_get_user_defined_method(type(obj), &#39;__call__&#39;)==================(173)     
        if call is not None:==============================================================(174)     
            try:==========================================================================(175)     
                sig = _signature_from_callable(===========================================(176)     
                    call,=================================================================(177)     
                    follow_wrapper_chains=follow_wrapper_chains,==========================(178)     
                    skip_bound_arg=skip_bound_arg,========================================(179)     
                    sigcls=sigcls)========================================================(180)     
            except ValueError as ex:======================================================(181)     
                msg = &#39;no signature found for {!r}&#39;.format(obj)===========================(182)     
                raise ValueError(msg) from ex=============================================(183)     
                                                                                                                                                        (184)
    if sig is not None:===================================================================(185)     
        # For classes and objects we skip the first parameter of their====================(186)     
        # __call__, __new__, or __init__ methods==========================================(187)     
        if skip_bound_arg:================================================================(188)     
            return _signature_bound_method(sig)===========================================(189)     
        else:=============================================================================(190)     
            return sig====================================================================(191)     
                                                                                                                                                        (192)
    if isinstance(obj, types.BuiltinFunctionType):========================================(193)     
        # Raise a nicer error message for builtins========================================(194)     
        msg = &#39;no signature found for builtin function {!r}&#39;.format(obj)==================(195)     
        raise ValueError(msg)=============================================================(196)     
                                                                                                                                                        (197)
    raise ValueError(&#39;callable {!r} is not supported by signature&#39;.format(obj))===========(198)     
                                                                                                                                                        (199)</code></pre>
</div>
</div>
</section>
</section>
<section id="foos-metaclass-defines-its-own-__call__-will-stop-foo-get-sig-from-__init__" class="level2">
<h2>Foo’s metaclass defines its own <code>__call__</code> will stop Foo get sig from <code>__init__</code></h2>
<section id="problem-demo" class="level3">
<h3>Problem demo</h3>
<div class="cell">
<div class="sourceCode" id="cb91"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb91-1"><a href="#cb91-1" aria-hidden="true" tabindex="-1"></a>inspect._signature_from_callable <span class="op">=</span> _signature_from_callableNew</span></code></pre></div>
</div>
<ol start="2" type="1">
<li>when your Foo has a metaclass BaseMeta, if BaseMeta need to define its <code>__call__</code>, then Foo can’t get signature from <code>__init__</code>.</li>
</ol>
<div class="cell">
<div class="sourceCode" id="cb92"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb92-1"><a href="#cb92-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> BaseMeta(<span class="bu">type</span>): </span>
<span id="cb92-2"><a href="#cb92-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># using __new__ from type</span></span>
<span id="cb92-3"><a href="#cb92-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__call__</span>(cls, <span class="op">*</span>args, <span class="op">**</span>kwargs): <span class="cf">pass</span></span>
<span id="cb92-4"><a href="#cb92-4" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Foo(metaclass<span class="op">=</span>BaseMeta): </span>
<span id="cb92-5"><a href="#cb92-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, d, e, f): <span class="cf">pass</span></span>
<span id="cb92-6"><a href="#cb92-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb92-7"><a href="#cb92-7" aria-hidden="true" tabindex="-1"></a>test_sig(Foo, <span class="st">&#39;(*args, **kwargs)&#39;</span>)</span></code></pre></div>
</div>
<div class="cell">
<div class="sourceCode" id="cb93"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb93-1"><a href="#cb93-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> BaseMeta(<span class="bu">type</span>): </span>
<span id="cb93-2"><a href="#cb93-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__new__</span>(cls, name, bases, <span class="bu">dict</span>):</span>
<span id="cb93-3"><a href="#cb93-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">super</span>().<span class="fu">__new__</span>(cls, name, bases, <span class="bu">dict</span>) <span class="co"># using __new__ from type</span></span>
<span id="cb93-4"><a href="#cb93-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__call__</span>(cls, <span class="op">*</span>args, <span class="op">**</span>kwargs): <span class="cf">pass</span></span>
<span id="cb93-5"><a href="#cb93-5" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Foo(metaclass<span class="op">=</span>BaseMeta): </span>
<span id="cb93-6"><a href="#cb93-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, d, e, f): <span class="cf">pass</span></span>
<span id="cb93-7"><a href="#cb93-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb93-8"><a href="#cb93-8" aria-hidden="true" tabindex="-1"></a>test_sig(Foo, <span class="st">&#39;(*args, **kwargs)&#39;</span>)</span></code></pre></div>
</div>
</section>
<section id="cause-of-the-problem" class="level3">
<h3>Cause of the problem</h3>
<p>Now I have a better understanding of the source codes, I have 2 places to investigate, they are roughly at line 96 and line 37.</p>
<div class="cell column-screen">
<div class="sourceCode" id="cb94"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb94-1"><a href="#cb94-1" aria-hidden="true" tabindex="-1"></a>dbsig <span class="op">=</span> sig.dbprint(<span class="dv">37</span>, <span class="st">&quot;does Foo store sig inside __signature__&quot;</span>, <span class="st">&quot;hasattr(obj, &#39;__signature__&#39;)&quot;</span>)</span>
<span id="cb94-2"><a href="#cb94-2" aria-hidden="true" tabindex="-1"></a>inspect._signature_from_callable <span class="op">=</span> dbsig</span>
<span id="cb94-3"><a href="#cb94-3" aria-hidden="true" tabindex="-1"></a>pprint(inspect.signature(Foo))</span>
<span id="cb94-4"><a href="#cb94-4" aria-hidden="true" tabindex="-1"></a>sig.<span class="bu">print</span>(part<span class="op">=</span><span class="dv">2</span>)</span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>                                                                                                                                                        (35)
    try:                                                                                                                                                (36)
        sig = obj.__signature__=========================================================================================================================(37)
                                                                                                                      does Foo store sig inside __signature__
    except AttributeError:                                                                                                                              (38)
        pass                                                                                                                                            (39)


                                                                                       hasattr(obj, &#39;__signature__&#39;) =&gt; hasattr(obj, &#39;__signature__&#39;) : False
&lt;Signature (*args, **kwargs)&gt;
            # See test_signature_wrapped_bound_method for details.========================(33)      
            return _get_signature_of(obj)=================================================(34)      
                                                                                                                                                        (35)
    try:==================================================================================(36)      
        sig = obj.__signature__===========================================================(37) # does Foo store sig inside __signature__
    except AttributeError:================================================================(38)      
        pass==============================================================================(39)      
    else:=================================================================================(40)      
        if sig is not None:===============================================================(41)      
            if not isinstance(sig, Signature):============================================(42)      
                raise TypeError(==========================================================(43)      
                    &#39;unexpected object {!r} in __signature__ &#39;============================(44)      
                    &#39;attribute&#39;.format(sig))==============================================(45)      
            return sig====================================================================(46)      
                                                                                                                                                        (47)
    try:==================================================================================(48)      
        partialmethod = obj._partialmethod================================================(49)      
    except AttributeError:================================================================(50)      
        pass==============================================================================(51)      
    else:=================================================================================(52)      
        if isinstance(partialmethod, functools.partialmethod):============================(53)      
            # Unbound partialmethod (see functools.partialmethod)=========================(54)      
            # This means, that we need to calculate the signature=========================(55)      
            # as if it&#39;s a regular partial object, but taking into========================(56)      
            # account that the first positional argument==================================(57)      
            # (usually `self`, or `cls`) will not be passed===============================(58)      
            # automatically (as for boundmethods)=========================================(59)      
                                                                                                                                                        (60)
            wrapped_sig = _get_signature_of(partialmethod.func)===========================(61)      
                                                                                                                                                        (62)
            sig = _signature_get_partial(wrapped_sig, partialmethod, (None,))=============(63)      
            first_wrapped_param = tuple(wrapped_sig.parameters.values())[0]===============(64)      
            if first_wrapped_param.kind is Parameter.VAR_POSITIONAL:======================(65)      
                                                                                                                                     part No.2 out of 6 parts</code></pre>
</div>
</div>
<div class="cell column-screen">
<div class="sourceCode" id="cb96"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb96-1"><a href="#cb96-1" aria-hidden="true" tabindex="-1"></a>dbsig <span class="op">=</span> sig.dbprint(<span class="dv">98</span>, <span class="st">&quot;__call__ is defined&quot;</span>, <span class="st">&quot;sig = _get_signature_of(call)&quot;</span>)</span>
<span id="cb96-2"><a href="#cb96-2" aria-hidden="true" tabindex="-1"></a>inspect._signature_from_callable <span class="op">=</span> dbsig</span>
<span id="cb96-3"><a href="#cb96-3" aria-hidden="true" tabindex="-1"></a>pprint(inspect.signature(Foo))</span>
<span id="cb96-4"><a href="#cb96-4" aria-hidden="true" tabindex="-1"></a>sig.<span class="bu">print</span>(part<span class="op">=</span><span class="dv">3</span>)</span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>        call = _signature_get_user_defined_method(type(obj), &#39;__call__&#39;)                                                                                (96)
        if call is not None:                                                                                                                            (97)
            sig = _get_signature_of(call)===============================================================================================================(98)
                                                                                                                                          __call__ is defined
        else:                                                                                                                                           (99)
            factory_method = None                                                                                                                       (100)


                                                                                                 sig = _get_signature_of(call) =&gt; sig: (cls, *args, **kwargs)
&lt;Signature (*args, **kwargs)&gt;
                # First argument of the wrapped callable is `*args`, as in================(66)      
                # `partialmethod(lambda *args)`.==========================================(67)      
                return sig================================================================(68)      
            else:=========================================================================(69)      
                sig_params = tuple(sig.parameters.values())===============================(70)      
                assert (not sig_params or=================================================(71)      
                        first_wrapped_param is not sig_params[0])=========================(72)      
                new_params = (first_wrapped_param,) + sig_params==========================(73)      
                return sig.replace(parameters=new_params)=================================(74)      
                                                                                                                                                        (75)
    if isfunction(obj) or _signature_is_functionlike(obj):================================(76) # step 7: run on itself will run here
        # If it&#39;s a pure Python function, or an object that is duck type==================(77)      
        # of a Python function (Cython functions, for instance), then:====================(78)      
        return _signature_from_function(sigcls, obj,======================================(79) # step 8: get sig with a different func
                                        skip_bound_arg=skip_bound_arg)====================(80)      
                                                                                                                                                        (81)
    if _signature_is_builtin(obj):========================================================(82)      
        return _signature_from_builtin(sigcls, obj,=======================================(83)      
                                       skip_bound_arg=skip_bound_arg)=====================(84)      
                                                                                                                                                        (85)
    if isinstance(obj, functools.partial):================================================(86)      
        wrapped_sig = _get_signature_of(obj.func)=========================================(87)      
        return _signature_get_partial(wrapped_sig, obj)===================================(88)      
                                                                                                                                                        (89)
    sig = None============================================================================(90)      
    if isinstance(obj, type):=============================================================(91) # step 1: obj is a class?
        # obj is a class or a metaclass===================================================(92)      
                                                                                                                                                        (93)
        # First, let&#39;s see if it has an overloaded __call__ defined=======================(94)      
        # in its metaclass================================================================(95)      
        call = _signature_get_user_defined_method(type(obj), &#39;__call__&#39;)==================(96) # step 2: define its own __call__?
        if call is not None:==============================================================(97)      
            sig = _get_signature_of(call)=================================================(98) # __call__ is defined
                                                                                                                                     part No.3 out of 6 parts</code></pre>
</div>
</div>
</section>
<section id="solution-demo" class="level3">
<h3>Solution demo</h3>
<p>Solution to problem 2: you need to inherit from FixSigMeta instead of type when constructing the metaclass to preserve the signature in <code>__init__</code>. Be careful not to override <code>__new__</code> when doing this:</p>
<div class="cell">
<div class="sourceCode" id="cb98"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb98-1"><a href="#cb98-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> BaseMeta(FixSigMeta): </span>
<span id="cb98-2"><a href="#cb98-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># using __new__ of  FixSigMeta instead of type</span></span>
<span id="cb98-3"><a href="#cb98-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__call__</span>(cls, <span class="op">*</span>args, <span class="op">**</span>kwargs): <span class="cf">pass</span></span>
<span id="cb98-4"><a href="#cb98-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb98-5"><a href="#cb98-5" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Foo(metaclass<span class="op">=</span>BaseMeta): <span class="co"># Base</span></span>
<span id="cb98-6"><a href="#cb98-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, d, e, f): <span class="cf">pass</span></span>
<span id="cb98-7"><a href="#cb98-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb98-8"><a href="#cb98-8" aria-hidden="true" tabindex="-1"></a>test_sig(Foo, <span class="st">&#39;(d, e, f)&#39;</span>)</span></code></pre></div>
</div>
<div class="cell">
<div class="sourceCode" id="cb99"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb99-1"><a href="#cb99-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> BaseMeta(FixSigMeta): </span>
<span id="cb99-2"><a href="#cb99-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__new__</span>(cls, name, bases, <span class="bu">dict</span>): <span class="co"># not really overriding __new__, still using FixSigMeta.__new__ actually</span></span>
<span id="cb99-3"><a href="#cb99-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">super</span>().<span class="fu">__new__</span>(cls, name, bases, <span class="bu">dict</span>)</span>
<span id="cb99-4"><a href="#cb99-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__call__</span>(cls, <span class="op">*</span>args, <span class="op">**</span>kwargs): <span class="cf">pass</span></span>
<span id="cb99-5"><a href="#cb99-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb99-6"><a href="#cb99-6" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Foo(metaclass<span class="op">=</span>BaseMeta): <span class="co"># Base</span></span>
<span id="cb99-7"><a href="#cb99-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, d, e, f): <span class="cf">pass</span></span>
<span id="cb99-8"><a href="#cb99-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb99-9"><a href="#cb99-9" aria-hidden="true" tabindex="-1"></a>test_sig(Foo, <span class="st">&#39;(d, e, f)&#39;</span>)</span></code></pre></div>
</div>
<p>Note: if Base also defines <code>__new__</code>, then FixSigMeta can’t help.</p>
</section>
<section id="how-fixsigmeta-fix-this-problem" class="level3">
<h3>How FixSigMeta fix this problem</h3>
<div class="cell column-screen">
<div class="sourceCode" id="cb100"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb100-1"><a href="#cb100-1" aria-hidden="true" tabindex="-1"></a>dbsig <span class="op">=</span> sig.dbprint(<span class="dv">29</span>, <span class="st">&quot;why has to unwrap?&quot;</span>, <span class="st">&quot;hasattr(obj, &#39;__signature__&#39;)&quot;</span>)</span>
<span id="cb100-2"><a href="#cb100-2" aria-hidden="true" tabindex="-1"></a>inspect._signature_from_callable <span class="op">=</span> dbsig</span>
<span id="cb100-3"><a href="#cb100-3" aria-hidden="true" tabindex="-1"></a>pprint(inspect.signature(Foo))</span>
<span id="cb100-4"><a href="#cb100-4" aria-hidden="true" tabindex="-1"></a>sig.<span class="bu">print</span>(part<span class="op">=</span><span class="dv">1</span>)</span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>    # Was this function wrapped by a decorator?                                                                                                         (27)
    if follow_wrapper_chains:                                                                                                                           (28)
        obj = unwrap(obj, stop=(lambda f: hasattr(f, &quot;__signature__&quot;)))=================================================================================(29)
                                                                                                                                           why has to unwrap?
        if isinstance(obj, types.MethodType):                                                                                                           (30)
            # If the unwrapped object is a *method*, we might want to                                                                                   (31)


                                                                                        hasattr(obj, &#39;__signature__&#39;) =&gt; hasattr(obj, &#39;__signature__&#39;) : True
&lt;Signature (d, e, f)&gt;
def _signature_from_callable(obj, *,======================================================(0)       
                             follow_wrapper_chains=True,==================================(1)       
                             skip_bound_arg=True,=========================================(2)       
                             sigcls):=====================================================(3)       
                                                                                                                                                        (4)
    &quot;&quot;&quot;Private helper function to get signature for arbitrary=============================(5)       
    callable objects.=====================================================================(6)       
    &quot;&quot;&quot;===================================================================================(7)       
                                                                                                                                                        (8)
    _get_signature_of = functools.partial(_signature_from_callable,=======================(9) # so that it can use in itself
                                follow_wrapper_chains=follow_wrapper_chains,==============(10)      
                                skip_bound_arg=skip_bound_arg,============================(11)      
                                sigcls=sigcls)============================================(12)      
                                                                                                                                                        (13)
    if not callable(obj):=================================================================(14) # obj must be callable
        raise TypeError(&#39;{!r} is not a callable object&#39;.format(obj))======================(15)      
                                                                                                                                                        (16)
    if isinstance(obj, types.MethodType):=================================================(17) # obj can be a classmethod
        # In this case we skip the first parameter of the underlying======================(18)      
        # function (usually `self` or `cls`).=============================================(19)      
        sig = _get_signature_of(obj.__func__)=============================================(20)      
                                                                                                                                                        (21)
        if skip_bound_arg:================================================================(22)      
            return _signature_bound_method(sig)===========================================(23)      
        else:=============================================================================(24)      
            return sig====================================================================(25)      
                                                                                                                                                        (26)
    # Was this function wrapped by a decorator?===========================================(27)      
    if follow_wrapper_chains:=============================================================(28) # does Foo has __signature__?
        obj = unwrap(obj, stop=(lambda f: hasattr(f, &quot;__signature__&quot;)))===================(29) # why has to unwrap?
        if isinstance(obj, types.MethodType):=============================================(30)      
            # If the unwrapped object is a *method*, we might want to=====================(31)      
            # skip its first parameter (self).============================================(32)      
                                                                                                                                     part No.1 out of 6 parts</code></pre>
</div>
</div>
<div class="cell column-screen">
<div class="sourceCode" id="cb102"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb102-1"><a href="#cb102-1" aria-hidden="true" tabindex="-1"></a>dbsig <span class="op">=</span> sig.dbprint(<span class="dv">30</span>, <span class="st">&quot;what is wrapped by Foo?&quot;</span>, <span class="st">&quot;isinstance(obj, types.MethodType)&quot;</span>, <span class="st">&quot;obj&quot;</span>, <span class="st">&quot;type(obj)&quot;</span>)</span>
<span id="cb102-2"><a href="#cb102-2" aria-hidden="true" tabindex="-1"></a>inspect._signature_from_callable <span class="op">=</span> dbsig</span>
<span id="cb102-3"><a href="#cb102-3" aria-hidden="true" tabindex="-1"></a>pprint(inspect.signature(Foo))</span>
<span id="cb102-4"><a href="#cb102-4" aria-hidden="true" tabindex="-1"></a>sig.<span class="bu">print</span>(part<span class="op">=</span><span class="dv">2</span>)</span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>    if follow_wrapper_chains:                                                                                                                           (28)
        obj = unwrap(obj, stop=(lambda f: hasattr(f, &quot;__signature__&quot;)))                                                                                 (29)
        if isinstance(obj, types.MethodType):===========================================================================================================(30)
                                                                                                                                      what is wrapped by Foo?
            # If the unwrapped object is a *method*, we might want to                                                                                   (31)
            # skip its first parameter (self).                                                                                                          (32)


                                                                               isinstance(obj, types.MethodType) =&gt; isinstance(obj, types.MethodType) : False


                                                                                                                          obj =&gt; obj : &lt;class &#39;__main__.Foo&#39;&gt;


                                                                                                         type(obj) =&gt; type(obj) : &lt;class &#39;__main__.BaseMeta&#39;&gt;
&lt;Signature (d, e, f)&gt;
            # See test_signature_wrapped_bound_method for details.========================(33)      
            return _get_signature_of(obj)=================================================(34)      
                                                                                                                                                        (35)
    try:==================================================================================(36)      
        sig = obj.__signature__===========================================================(37) # does Foo store sig inside __signature__
    except AttributeError:================================================================(38)      
        pass==============================================================================(39)      
    else:=================================================================================(40)      
        if sig is not None:===============================================================(41)      
            if not isinstance(sig, Signature):============================================(42)      
                raise TypeError(==========================================================(43)      
                    &#39;unexpected object {!r} in __signature__ &#39;============================(44)      
                    &#39;attribute&#39;.format(sig))==============================================(45)      
            return sig====================================================================(46)      
                                                                                                                                                        (47)
    try:==================================================================================(48)      
        partialmethod = obj._partialmethod================================================(49)      
    except AttributeError:================================================================(50)      
        pass==============================================================================(51)      
    else:=================================================================================(52)      
        if isinstance(partialmethod, functools.partialmethod):============================(53)      
            # Unbound partialmethod (see functools.partialmethod)=========================(54)      
            # This means, that we need to calculate the signature=========================(55)      
            # as if it&#39;s a regular partial object, but taking into========================(56)      
            # account that the first positional argument==================================(57)      
            # (usually `self`, or `cls`) will not be passed===============================(58)      
            # automatically (as for boundmethods)=========================================(59)      
                                                                                                                                                        (60)
            wrapped_sig = _get_signature_of(partialmethod.func)===========================(61)      
                                                                                                                                                        (62)
            sig = _signature_get_partial(wrapped_sig, partialmethod, (None,))=============(63)      
            first_wrapped_param = tuple(wrapped_sig.parameters.values())[0]===============(64)      
            if first_wrapped_param.kind is Parameter.VAR_POSITIONAL:======================(65)      
                                                                                                                                     part No.2 out of 6 parts</code></pre>
</div>
</div>
</section>
<section id="common-feature-of-the-solutions-above-by-fixsigmeta" class="level3">
<h3>Common feature of the solutions above by FixSigMeta</h3>
<p>The key is to create <code>__signature__</code> for Foo, so that <code>inspect.signature</code> will get sig from <code>__signature__</code>, instead of <code>__new__</code> or <code>__call__</code></p>
<div class="cell">
<div class="sourceCode" id="cb104"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb104-1"><a href="#cb104-1" aria-hidden="true" tabindex="-1"></a><span class="co"># g = locals()</span></span>
<span id="cb104-2"><a href="#cb104-2" aria-hidden="true" tabindex="-1"></a>fsm <span class="op">=</span> Fastdb(FixSigMeta, g)</span></code></pre></div>
</div>
<div class="cell">
<div class="sourceCode" id="cb105"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb105-1"><a href="#cb105-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> fastcore.meta <span class="im">import</span> _rm_self</span></code></pre></div>
</div>
<div class="cell column-screen">
<div class="sourceCode" id="cb106"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb106-1"><a href="#cb106-1" aria-hidden="true" tabindex="-1"></a>dbfsm <span class="op">=</span> fsm.dbprint(<span class="dv">4</span>, <span class="st">&quot;FixSigMeta create Foo with its __new__&quot;</span>, <span class="st">&quot;res&quot;</span>, <span class="st">&quot;inspect.signature(res.__init__)&quot;</span>, <span class="st">&quot;_rm_self(inspect.signature(res.__init__))&quot;</span>)</span>
<span id="cb106-2"><a href="#cb106-2" aria-hidden="true" tabindex="-1"></a>FixSigMeta <span class="op">=</span> dbfsm</span>
<span id="cb106-3"><a href="#cb106-3" aria-hidden="true" tabindex="-1"></a>inspect._signature_from_callable <span class="op">=</span> sig.orisrc <span class="co"># deactivate it</span></span>
<span id="cb106-4"><a href="#cb106-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb106-5"><a href="#cb106-5" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> BaseMeta(FixSigMeta): </span>
<span id="cb106-6"><a href="#cb106-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__new__</span>(cls, name, bases, <span class="bu">dict</span>): <span class="co"># not really overriding __new__, still using FixSigMeta.__new__ actually</span></span>
<span id="cb106-7"><a href="#cb106-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">super</span>().<span class="fu">__new__</span>(cls, name, bases, <span class="bu">dict</span>)</span>
<span id="cb106-8"><a href="#cb106-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__call__</span>(cls, <span class="op">*</span>args, <span class="op">**</span>kwargs): <span class="cf">pass</span></span>
<span id="cb106-9"><a href="#cb106-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb106-10"><a href="#cb106-10" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Foo(metaclass<span class="op">=</span>BaseMeta): <span class="co"># Base</span></span>
<span id="cb106-11"><a href="#cb106-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, d, e, f): <span class="cf">pass</span></span>
<span id="cb106-12"><a href="#cb106-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb106-13"><a href="#cb106-13" aria-hidden="true" tabindex="-1"></a>test_sig(Foo, <span class="st">&#39;(d, e, f)&#39;</span>)</span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>    def __new__(cls, name, bases, dict):                                                                                                                (2)
        res = super().__new__(cls, name, bases, dict)                                                                                                   (3)
        if res.__init__ is not object.__init__: res.__signature__ = _rm_self(inspect.signature(res.__init__))===========================================(4)
                                                                                                                       FixSigMeta create Foo with its __new__
        return res                                                                                                                                      (5)
                                                                                                                                                        (6)


                                                                                                                          res =&gt; res : &lt;class &#39;__main__.Foo&#39;&gt;


                                                                         inspect.signature(res.__init__) =&gt; inspect.signature(res.__init__) : (self, d, e, f)


                                                           _rm_self(inspect.signature(res.__init__)) =&gt; _rm_self(inspect.signature(res.__init__)) : (d, e, f)</code></pre>
</div>
</div>
<div class="cell">
<div class="sourceCode" id="cb108"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb108-1"><a href="#cb108-1" aria-hidden="true" tabindex="-1"></a>fsm.<span class="bu">print</span>()</span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>class FixSigMeta(type):===================================================================(0)       
    &quot;A metaclass that fixes the signature on classes that override `__new__`&quot;=============(1)       
    def __new__(cls, name, bases, dict):==================================================(2)       
        res = super().__new__(cls, name, bases, dict)=====================================(3)       
        if res.__init__ is not object.__init__: res.__signature__ = _rm_self(inspect.signature(res.__init__)) # FixSigMeta create Foo with its __new__  (4)
        return res========================================================================(5)       
                                                                                                                                                        (6)</code></pre>
</div>
</div>
<div class="cell">
<div class="sourceCode" id="cb110"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb110-1"><a href="#cb110-1" aria-hidden="true" tabindex="-1"></a>FixSigMeta <span class="op">=</span> fsm.orisrc</span></code></pre></div>
</div>
<div class="cell">
<div class="sourceCode" id="cb111"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb111-1"><a href="#cb111-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> fastcore.meta <span class="im">import</span> test_eq</span></code></pre></div>
</div>
<div class="cell">
<div class="sourceCode" id="cb112"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb112-1"><a href="#cb112-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> BaseMeta(FixSigMeta): </span>
<span id="cb112-2"><a href="#cb112-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># __new__ comes from FixSigMeta</span></span>
<span id="cb112-3"><a href="#cb112-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__new__</span>(cls, <span class="op">*</span>args, <span class="op">**</span>kwargs): <span class="cf">pass</span> <span class="co"># as it create None for Foo, there is no signature neither</span></span>
<span id="cb112-4"><a href="#cb112-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__call__</span>(cls, <span class="op">*</span>args, <span class="op">**</span>kwargs): <span class="cf">pass</span></span>
<span id="cb112-5"><a href="#cb112-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb112-6"><a href="#cb112-6" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Foo(metaclass<span class="op">=</span>BaseMeta): <span class="co"># Base</span></span>
<span id="cb112-7"><a href="#cb112-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, d, e, f): <span class="cf">pass</span></span>
<span id="cb112-8"><a href="#cb112-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb112-9"><a href="#cb112-9" aria-hidden="true" tabindex="-1"></a>test_eq(<span class="bu">type</span>(Foo), <span class="bu">type</span>(<span class="va">None</span>))</span></code></pre></div>
</div>
<p>Note: if Base also defines <code>__init__</code>, then FixSigMeta can still help.</p>
<div class="cell">
<div class="sourceCode" id="cb113"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb113-1"><a href="#cb113-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> BaseMeta(FixSigMeta): </span>
<span id="cb113-2"><a href="#cb113-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># __new__ comes from FixSigMeta</span></span>
<span id="cb113-3"><a href="#cb113-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(cls, <span class="op">*</span>args, <span class="op">**</span>kwargs): <span class="cf">pass</span> <span class="co"># this __init__ is not used by Foo</span></span>
<span id="cb113-4"><a href="#cb113-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__call__</span>(cls, <span class="op">*</span>args, <span class="op">**</span>kwargs): <span class="cf">pass</span></span>
<span id="cb113-5"><a href="#cb113-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb113-6"><a href="#cb113-6" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Foo(metaclass<span class="op">=</span>BaseMeta): <span class="co"># Base</span></span>
<span id="cb113-7"><a href="#cb113-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, d, e, f): <span class="cf">pass</span> <span class="co"># override the __init__ above</span></span>
<span id="cb113-8"><a href="#cb113-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb113-9"><a href="#cb113-9" aria-hidden="true" tabindex="-1"></a>test_sig(Foo, <span class="st">&#39;(d, e, f)&#39;</span>)</span></code></pre></div>
</div>
<div id="quarto-navigation-envelope" class="hidden">
<p><span class="hidden" data-render-id="quarto-int-sidebar-title">fastdebug</span> <span class="hidden" data-render-id="quarto-int-navbar-title">fastdebug</span> <span class="hidden" data-render-id="quarto-int-next">Utils</span> <span class="hidden" data-render-id="quarto-int-prev">core</span> <span class="hidden" data-render-id="quarto-int-sidebar:/index.html">fastdebug</span> <span class="hidden" data-render-id="quarto-int-sidebar:/core.html">core</span> <span class="hidden" data-render-id="quarto-int-sidebar:/FixSigMeta.html">FixSigMeta</span> <span class="hidden" data-render-id="quarto-int-sidebar:undefined">utils.html</span> <span class="hidden" data-render-id="quarto-int-sidebar:/utils.html">Utils</span></p>
</div>
<div id="quarto-meta-markdown" class="hidden">
<p><span class="hidden" data-render-id="quarto-metatitle">fastdebug - FixSigMeta</span> <span class="hidden" data-render-id="quarto-twittercardtitle">fastdebug - FixSigMeta</span> <span class="hidden" data-render-id="quarto-ogcardtitle">fastdebug - FixSigMeta</span> <span class="hidden" data-render-id="quarto-metasitename">fastdebug</span></p>
</div>
</section>
</section>

</main> <!-- /main -->
<script id = "quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    setTimeout(function() {
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const cites = ref.parentNode.getAttribute('data-cites').split(' ');
    tippyHover(ref, function() {
      var popup = window.document.createElement('div');
      cites.forEach(function(cite) {
        var citeDiv = window.document.createElement('div');
        citeDiv.classList.add('hanging-indent');
        citeDiv.classList.add('csl-entry');
        var biblioDiv = window.document.getElementById('ref-' + cite);
        if (biblioDiv) {
          citeDiv.innerHTML = biblioDiv.innerHTML;
        }
        popup.appendChild(citeDiv);
      });
      return popup.innerHTML;
    });
  }
});
</script>
</div> <!-- /content -->

</body>

</html>