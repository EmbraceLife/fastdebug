<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.1.189">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>fastdebug - FixSigMeta</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" integrity="sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==" crossorigin="anonymous"></script>
<script type="application/javascript">define('jquery', [],function() {return window.jQuery;})</script>


<link rel="stylesheet" href="styles.css">
<meta property="og:title" content="fastdebug - FixSigMeta">
<meta property="og:description" content="When we want a class to use signature of __init__ to be its class signature.">
<meta property="og:site-name" content="fastdebug">
<meta name="twitter:title" content="fastdebug - FixSigMeta">
<meta name="twitter:description" content="When we want a class to use signature of __init__ to be its class signature.">
<meta name="twitter:card" content="summary">
</head>

<body class="nav-sidebar floating nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">fastdebug</span>
    </a>
  </div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/EmbraceLife/fastdebug"><i class="bi bi-github" role="img">
</i> 
 </a>
  </li>  
</ul>
              <div id="quarto-search" class="" title="Search"></div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
    <div class="container-fluid d-flex justify-content-between">
      <h1 class="quarto-secondary-nav-title">FixSigMeta</h1>
      <button type="button" class="quarto-btn-toggle btn" aria-label="Show secondary navigation">
        <i class="bi bi-chevron-right"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse sidebar-navigation floating overflow-auto">
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">fastdebug</a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./core.html" class="sidebar-item-text sidebar-link">core</a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./FixSigMeta.html" class="sidebar-item-text sidebar-link active">FixSigMeta</a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./utils.html" class="sidebar-item-text sidebar-link">Utils</a>
  </div>
</li>
    </ul>
    </div>
</nav>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#imports" id="toc-imports" class="nav-link active" data-scroll-target="#imports">Imports</a></li>
  <li><a href="#when-or-why-to-use-fixsigmeta" id="toc-when-or-why-to-use-fixsigmeta" class="nav-link" data-scroll-target="#when-or-why-to-use-fixsigmeta">When or why to use <code>FixSigMeta</code>?</a></li>
  <li><a href="#how-foo-borrow-sig-from-__init__" id="toc-how-foo-borrow-sig-from-__init__" class="nav-link" data-scroll-target="#how-foo-borrow-sig-from-__init__">How Foo borrow sig from <code>__init__</code></a>
  <ul>
  <li><a href="#how-to-debug-inspect._signature_from_callable-with-fastdb" id="toc-how-to-debug-inspect._signature_from_callable-with-fastdb" class="nav-link" data-scroll-target="#how-to-debug-inspect._signature_from_callable-with-fastdb">How to debug <code>inspect._signature_from_callable</code> with Fastdb</a></li>
  <li><a href="#how-exactly-foo-get-sig-from-__init__" id="toc-how-exactly-foo-get-sig-from-__init__" class="nav-link" data-scroll-target="#how-exactly-foo-get-sig-from-__init__">How exactly Foo get sig from <code>__init__</code></a></li>
  <li><a href="#read-commented-_signature_from_callable-from-python-3.9" id="toc-read-commented-_signature_from_callable-from-python-3.9" class="nav-link" data-scroll-target="#read-commented-_signature_from_callable-from-python-3.9">Read commented <code>_signature_from_callable</code> from python 3.9+</a></li>
  </ul></li>
  <li><a href="#foos-super-class-overriding-__new__-can-stop-foo-getting-sig-from-__init__" id="toc-foos-super-class-overriding-__new__-can-stop-foo-getting-sig-from-__init__" class="nav-link" data-scroll-target="#foos-super-class-overriding-__new__-can-stop-foo-getting-sig-from-__init__">Foo’s super class overriding <code>__new__</code> can stop Foo getting sig from <code>__init__</code></a>
  <ul>
  <li><a href="#when-foos-super-class-override-__new__-python3.7-cant-give-foo-sig-from-__init__" id="toc-when-foos-super-class-override-__new__-python3.7-cant-give-foo-sig-from-__init__" class="nav-link" data-scroll-target="#when-foos-super-class-override-__new__-python3.7-cant-give-foo-sig-from-__init__">When Foo’s super class override <code>__new__</code>, python3.7 can’t give Foo sig from <code>__init__</code></a></li>
  <li><a href="#how-python3.7-and-its-inspect-mess-it-up" id="toc-how-python3.7-and-its-inspect-mess-it-up" class="nav-link" data-scroll-target="#how-python3.7-and-its-inspect-mess-it-up">How python3.7 and its inspect mess it up</a></li>
  <li><a href="#fixsigmeta-can-fix-it-for-python-3.7-inspect" id="toc-fixsigmeta-can-fix-it-for-python-3.7-inspect" class="nav-link" data-scroll-target="#fixsigmeta-can-fix-it-for-python-3.7-inspect">FixSigMeta can fix it for python 3.7 inspect</a></li>
  <li><a href="#how-fixsigmeta-fix-it" id="toc-how-fixsigmeta-fix-it" class="nav-link" data-scroll-target="#how-fixsigmeta-fix-it">How FixSigMeta fix it?</a></li>
  <li><a href="#read-commented-_signature_from_callable-of-python-3.7" id="toc-read-commented-_signature_from_callable-of-python-3.7" class="nav-link" data-scroll-target="#read-commented-_signature_from_callable-of-python-3.7">Read commented <code>_signature_from_callable</code> of python 3.7</a></li>
  </ul></li>
  <li><a href="#foos-metaclass-defines-its-own-__call__-will-stop-foo-get-sig-from-__init__" id="toc-foos-metaclass-defines-its-own-__call__-will-stop-foo-get-sig-from-__init__" class="nav-link" data-scroll-target="#foos-metaclass-defines-its-own-__call__-will-stop-foo-get-sig-from-__init__">Foo’s metaclass defines its own <code>__call__</code> will stop Foo get sig from <code>__init__</code></a>
  <ul>
  <li><a href="#problem-demo" id="toc-problem-demo" class="nav-link" data-scroll-target="#problem-demo">Problem demo</a></li>
  <li><a href="#cause-of-the-problem" id="toc-cause-of-the-problem" class="nav-link" data-scroll-target="#cause-of-the-problem">Cause of the problem</a></li>
  <li><a href="#solution-demo" id="toc-solution-demo" class="nav-link" data-scroll-target="#solution-demo">Solution demo</a></li>
  <li><a href="#how-fixsigmeta-fix-this-problem" id="toc-how-fixsigmeta-fix-this-problem" class="nav-link" data-scroll-target="#how-fixsigmeta-fix-this-problem">How FixSigMeta fix this problem</a></li>
  <li><a href="#common-feature-of-the-solutions-above-by-fixsigmeta" id="toc-common-feature-of-the-solutions-above-by-fixsigmeta" class="nav-link" data-scroll-target="#common-feature-of-the-solutions-above-by-fixsigmeta">Common feature of the solutions above by FixSigMeta</a></li>
  </ul></li>
  </ul>
<div class="toc-actions"><div><i class="bi bi-github"></i></div><div class="action-links"><p><a href="https://github.com/EmbraceLife/fastdebug/issues/new" class="toc-action">Report an issue</a></p></div></div></nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title d-none d-lg-block">FixSigMeta</h1>
</div>



<div class="quarto-title-meta">

    
    
  </div>
  

</header>

<!-- WARNING: THIS FILE WAS AUTOGENERATED! DO NOT EDIT! -->
<section id="imports" class="level2">
<h2 class="anchored" data-anchor-id="imports">Imports</h2>
<div class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> fastdebug.core <span class="im">import</span> <span class="op">*</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> inspect</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> inspect <span class="im">import</span> <span class="op">*</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> inspect <span class="im">import</span> _signature_from_callable</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> inspect <span class="im">import</span> _signature_is_functionlike, _signature_is_builtin, _signature_get_user_defined_method, _signature_from_function, _signature_bound_method</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> inspect <span class="im">import</span> _signature_from_callable</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>_signature_from_callableNew <span class="op">=</span> _signature_from_callable</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="5">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> _signature_from_callableOld(obj, <span class="op">*</span>,</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>                             follow_wrapper_chains<span class="op">=</span><span class="va">True</span>,</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>                             skip_bound_arg<span class="op">=</span><span class="va">True</span>,</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>                             sigcls):</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Private helper function to get signature for arbitrary</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a><span class="co">    callable objects.</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> <span class="bu">callable</span>(obj):</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">raise</span> <span class="pp">TypeError</span>(<span class="st">'</span><span class="sc">{!r}</span><span class="st"> is not a callable object'</span>.<span class="bu">format</span>(obj))</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">isinstance</span>(obj, types.MethodType):</span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>        <span class="co"># In this case we skip the first parameter of the underlying</span></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>        <span class="co"># function (usually `self` or `cls`).</span></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>        sig <span class="op">=</span> _signature_from_callable(</span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>            obj.__func__,</span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>            follow_wrapper_chains<span class="op">=</span>follow_wrapper_chains,</span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>            skip_bound_arg<span class="op">=</span>skip_bound_arg,</span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>            sigcls<span class="op">=</span>sigcls)</span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> skip_bound_arg:</span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> _signature_bound_method(sig)</span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> sig</span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-27"><a href="#cb5-27" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Was this function wrapped by a decorator?</span></span>
<span id="cb5-28"><a href="#cb5-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> follow_wrapper_chains:</span>
<span id="cb5-29"><a href="#cb5-29" aria-hidden="true" tabindex="-1"></a>        obj <span class="op">=</span> unwrap(obj, stop<span class="op">=</span>(<span class="kw">lambda</span> f: <span class="bu">hasattr</span>(f, <span class="st">"__signature__"</span>)))</span>
<span id="cb5-30"><a href="#cb5-30" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">isinstance</span>(obj, types.MethodType):</span>
<span id="cb5-31"><a href="#cb5-31" aria-hidden="true" tabindex="-1"></a>            <span class="co"># If the unwrapped object is a *method*, we might want to</span></span>
<span id="cb5-32"><a href="#cb5-32" aria-hidden="true" tabindex="-1"></a>            <span class="co"># skip its first parameter (self).</span></span>
<span id="cb5-33"><a href="#cb5-33" aria-hidden="true" tabindex="-1"></a>            <span class="co"># See test_signature_wrapped_bound_method for details.</span></span>
<span id="cb5-34"><a href="#cb5-34" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> _signature_from_callable(</span>
<span id="cb5-35"><a href="#cb5-35" aria-hidden="true" tabindex="-1"></a>                obj,</span>
<span id="cb5-36"><a href="#cb5-36" aria-hidden="true" tabindex="-1"></a>                follow_wrapper_chains<span class="op">=</span>follow_wrapper_chains,</span>
<span id="cb5-37"><a href="#cb5-37" aria-hidden="true" tabindex="-1"></a>                skip_bound_arg<span class="op">=</span>skip_bound_arg,</span>
<span id="cb5-38"><a href="#cb5-38" aria-hidden="true" tabindex="-1"></a>                sigcls<span class="op">=</span>sigcls)</span>
<span id="cb5-39"><a href="#cb5-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-40"><a href="#cb5-40" aria-hidden="true" tabindex="-1"></a>    <span class="cf">try</span>:</span>
<span id="cb5-41"><a href="#cb5-41" aria-hidden="true" tabindex="-1"></a>        sig <span class="op">=</span> obj.__signature__</span>
<span id="cb5-42"><a href="#cb5-42" aria-hidden="true" tabindex="-1"></a>    <span class="cf">except</span> <span class="pp">AttributeError</span>:</span>
<span id="cb5-43"><a href="#cb5-43" aria-hidden="true" tabindex="-1"></a>        <span class="cf">pass</span></span>
<span id="cb5-44"><a href="#cb5-44" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb5-45"><a href="#cb5-45" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> sig <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb5-46"><a href="#cb5-46" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="kw">not</span> <span class="bu">isinstance</span>(sig, Signature):</span>
<span id="cb5-47"><a href="#cb5-47" aria-hidden="true" tabindex="-1"></a>                <span class="cf">raise</span> <span class="pp">TypeError</span>(</span>
<span id="cb5-48"><a href="#cb5-48" aria-hidden="true" tabindex="-1"></a>                    <span class="st">'unexpected object </span><span class="sc">{!r}</span><span class="st"> in __signature__ '</span></span>
<span id="cb5-49"><a href="#cb5-49" aria-hidden="true" tabindex="-1"></a>                    <span class="st">'attribute'</span>.<span class="bu">format</span>(sig))</span>
<span id="cb5-50"><a href="#cb5-50" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> sig</span>
<span id="cb5-51"><a href="#cb5-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-52"><a href="#cb5-52" aria-hidden="true" tabindex="-1"></a>    <span class="cf">try</span>:</span>
<span id="cb5-53"><a href="#cb5-53" aria-hidden="true" tabindex="-1"></a>        partialmethod <span class="op">=</span> obj._partialmethod</span>
<span id="cb5-54"><a href="#cb5-54" aria-hidden="true" tabindex="-1"></a>    <span class="cf">except</span> <span class="pp">AttributeError</span>:</span>
<span id="cb5-55"><a href="#cb5-55" aria-hidden="true" tabindex="-1"></a>        <span class="cf">pass</span></span>
<span id="cb5-56"><a href="#cb5-56" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb5-57"><a href="#cb5-57" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">isinstance</span>(partialmethod, functools.partialmethod):</span>
<span id="cb5-58"><a href="#cb5-58" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Unbound partialmethod (see functools.partialmethod)</span></span>
<span id="cb5-59"><a href="#cb5-59" aria-hidden="true" tabindex="-1"></a>            <span class="co"># This means, that we need to calculate the signature</span></span>
<span id="cb5-60"><a href="#cb5-60" aria-hidden="true" tabindex="-1"></a>            <span class="co"># as if it's a regular partial object, but taking into</span></span>
<span id="cb5-61"><a href="#cb5-61" aria-hidden="true" tabindex="-1"></a>            <span class="co"># account that the first positional argument</span></span>
<span id="cb5-62"><a href="#cb5-62" aria-hidden="true" tabindex="-1"></a>            <span class="co"># (usually `self`, or `cls`) will not be passed</span></span>
<span id="cb5-63"><a href="#cb5-63" aria-hidden="true" tabindex="-1"></a>            <span class="co"># automatically (as for boundmethods)</span></span>
<span id="cb5-64"><a href="#cb5-64" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-65"><a href="#cb5-65" aria-hidden="true" tabindex="-1"></a>            wrapped_sig <span class="op">=</span> _signature_from_callable(</span>
<span id="cb5-66"><a href="#cb5-66" aria-hidden="true" tabindex="-1"></a>                partialmethod.func,</span>
<span id="cb5-67"><a href="#cb5-67" aria-hidden="true" tabindex="-1"></a>                follow_wrapper_chains<span class="op">=</span>follow_wrapper_chains,</span>
<span id="cb5-68"><a href="#cb5-68" aria-hidden="true" tabindex="-1"></a>                skip_bound_arg<span class="op">=</span>skip_bound_arg,</span>
<span id="cb5-69"><a href="#cb5-69" aria-hidden="true" tabindex="-1"></a>                sigcls<span class="op">=</span>sigcls)</span>
<span id="cb5-70"><a href="#cb5-70" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-71"><a href="#cb5-71" aria-hidden="true" tabindex="-1"></a>            sig <span class="op">=</span> _signature_get_partial(wrapped_sig, partialmethod, (<span class="va">None</span>,))</span>
<span id="cb5-72"><a href="#cb5-72" aria-hidden="true" tabindex="-1"></a>            first_wrapped_param <span class="op">=</span> <span class="bu">tuple</span>(wrapped_sig.parameters.values())[<span class="dv">0</span>]</span>
<span id="cb5-73"><a href="#cb5-73" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> first_wrapped_param.kind <span class="kw">is</span> Parameter.VAR_POSITIONAL:</span>
<span id="cb5-74"><a href="#cb5-74" aria-hidden="true" tabindex="-1"></a>                <span class="co"># First argument of the wrapped callable is `*args`, as in</span></span>
<span id="cb5-75"><a href="#cb5-75" aria-hidden="true" tabindex="-1"></a>                <span class="co"># `partialmethod(lambda *args)`.</span></span>
<span id="cb5-76"><a href="#cb5-76" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> sig</span>
<span id="cb5-77"><a href="#cb5-77" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb5-78"><a href="#cb5-78" aria-hidden="true" tabindex="-1"></a>                sig_params <span class="op">=</span> <span class="bu">tuple</span>(sig.parameters.values())</span>
<span id="cb5-79"><a href="#cb5-79" aria-hidden="true" tabindex="-1"></a>                <span class="cf">assert</span> (<span class="kw">not</span> sig_params <span class="kw">or</span></span>
<span id="cb5-80"><a href="#cb5-80" aria-hidden="true" tabindex="-1"></a>                        first_wrapped_param <span class="kw">is</span> <span class="kw">not</span> sig_params[<span class="dv">0</span>])</span>
<span id="cb5-81"><a href="#cb5-81" aria-hidden="true" tabindex="-1"></a>                new_params <span class="op">=</span> (first_wrapped_param,) <span class="op">+</span> sig_params</span>
<span id="cb5-82"><a href="#cb5-82" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> sig.replace(parameters<span class="op">=</span>new_params)</span>
<span id="cb5-83"><a href="#cb5-83" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-84"><a href="#cb5-84" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> isfunction(obj) <span class="kw">or</span> _signature_is_functionlike(obj):</span>
<span id="cb5-85"><a href="#cb5-85" aria-hidden="true" tabindex="-1"></a>        <span class="co"># If it's a pure Python function, or an object that is duck type</span></span>
<span id="cb5-86"><a href="#cb5-86" aria-hidden="true" tabindex="-1"></a>        <span class="co"># of a Python function (Cython functions, for instance), then:</span></span>
<span id="cb5-87"><a href="#cb5-87" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> _signature_from_function(sigcls, obj)</span>
<span id="cb5-88"><a href="#cb5-88" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-89"><a href="#cb5-89" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> _signature_is_builtin(obj):</span>
<span id="cb5-90"><a href="#cb5-90" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> _signature_from_builtin(sigcls, obj,</span>
<span id="cb5-91"><a href="#cb5-91" aria-hidden="true" tabindex="-1"></a>                                       skip_bound_arg<span class="op">=</span>skip_bound_arg)</span>
<span id="cb5-92"><a href="#cb5-92" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-93"><a href="#cb5-93" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">isinstance</span>(obj, functools.partial):</span>
<span id="cb5-94"><a href="#cb5-94" aria-hidden="true" tabindex="-1"></a>        wrapped_sig <span class="op">=</span> _signature_from_callable(</span>
<span id="cb5-95"><a href="#cb5-95" aria-hidden="true" tabindex="-1"></a>            obj.func,</span>
<span id="cb5-96"><a href="#cb5-96" aria-hidden="true" tabindex="-1"></a>            follow_wrapper_chains<span class="op">=</span>follow_wrapper_chains,</span>
<span id="cb5-97"><a href="#cb5-97" aria-hidden="true" tabindex="-1"></a>            skip_bound_arg<span class="op">=</span>skip_bound_arg,</span>
<span id="cb5-98"><a href="#cb5-98" aria-hidden="true" tabindex="-1"></a>            sigcls<span class="op">=</span>sigcls)</span>
<span id="cb5-99"><a href="#cb5-99" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> _signature_get_partial(wrapped_sig, obj)</span>
<span id="cb5-100"><a href="#cb5-100" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-101"><a href="#cb5-101" aria-hidden="true" tabindex="-1"></a>    sig <span class="op">=</span> <span class="va">None</span></span>
<span id="cb5-102"><a href="#cb5-102" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">isinstance</span>(obj, <span class="bu">type</span>):</span>
<span id="cb5-103"><a href="#cb5-103" aria-hidden="true" tabindex="-1"></a>        <span class="co"># obj is a class or a metaclass</span></span>
<span id="cb5-104"><a href="#cb5-104" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-105"><a href="#cb5-105" aria-hidden="true" tabindex="-1"></a>        <span class="co"># First, let's see if it has an overloaded __call__ defined</span></span>
<span id="cb5-106"><a href="#cb5-106" aria-hidden="true" tabindex="-1"></a>        <span class="co"># in its metaclass</span></span>
<span id="cb5-107"><a href="#cb5-107" aria-hidden="true" tabindex="-1"></a>        call <span class="op">=</span> _signature_get_user_defined_method(<span class="bu">type</span>(obj), <span class="st">'__call__'</span>)</span>
<span id="cb5-108"><a href="#cb5-108" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> call <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb5-109"><a href="#cb5-109" aria-hidden="true" tabindex="-1"></a>            sig <span class="op">=</span> _signature_from_callable(</span>
<span id="cb5-110"><a href="#cb5-110" aria-hidden="true" tabindex="-1"></a>                call,</span>
<span id="cb5-111"><a href="#cb5-111" aria-hidden="true" tabindex="-1"></a>                follow_wrapper_chains<span class="op">=</span>follow_wrapper_chains,</span>
<span id="cb5-112"><a href="#cb5-112" aria-hidden="true" tabindex="-1"></a>                skip_bound_arg<span class="op">=</span>skip_bound_arg,</span>
<span id="cb5-113"><a href="#cb5-113" aria-hidden="true" tabindex="-1"></a>                sigcls<span class="op">=</span>sigcls)</span>
<span id="cb5-114"><a href="#cb5-114" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb5-115"><a href="#cb5-115" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Now we check if the 'obj' class has a '__new__' method</span></span>
<span id="cb5-116"><a href="#cb5-116" aria-hidden="true" tabindex="-1"></a>            new <span class="op">=</span> _signature_get_user_defined_method(obj, <span class="st">'__new__'</span>)</span>
<span id="cb5-117"><a href="#cb5-117" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> new <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb5-118"><a href="#cb5-118" aria-hidden="true" tabindex="-1"></a>                sig <span class="op">=</span> _signature_from_callable(</span>
<span id="cb5-119"><a href="#cb5-119" aria-hidden="true" tabindex="-1"></a>                    new,</span>
<span id="cb5-120"><a href="#cb5-120" aria-hidden="true" tabindex="-1"></a>                    follow_wrapper_chains<span class="op">=</span>follow_wrapper_chains,</span>
<span id="cb5-121"><a href="#cb5-121" aria-hidden="true" tabindex="-1"></a>                    skip_bound_arg<span class="op">=</span>skip_bound_arg,</span>
<span id="cb5-122"><a href="#cb5-122" aria-hidden="true" tabindex="-1"></a>                    sigcls<span class="op">=</span>sigcls)</span>
<span id="cb5-123"><a href="#cb5-123" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb5-124"><a href="#cb5-124" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Finally, we should have at least __init__ implemented</span></span>
<span id="cb5-125"><a href="#cb5-125" aria-hidden="true" tabindex="-1"></a>                init <span class="op">=</span> _signature_get_user_defined_method(obj, <span class="st">'__init__'</span>)</span>
<span id="cb5-126"><a href="#cb5-126" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> init <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb5-127"><a href="#cb5-127" aria-hidden="true" tabindex="-1"></a>                    sig <span class="op">=</span> _signature_from_callable(</span>
<span id="cb5-128"><a href="#cb5-128" aria-hidden="true" tabindex="-1"></a>                        init,</span>
<span id="cb5-129"><a href="#cb5-129" aria-hidden="true" tabindex="-1"></a>                        follow_wrapper_chains<span class="op">=</span>follow_wrapper_chains,</span>
<span id="cb5-130"><a href="#cb5-130" aria-hidden="true" tabindex="-1"></a>                        skip_bound_arg<span class="op">=</span>skip_bound_arg,</span>
<span id="cb5-131"><a href="#cb5-131" aria-hidden="true" tabindex="-1"></a>                        sigcls<span class="op">=</span>sigcls)</span>
<span id="cb5-132"><a href="#cb5-132" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-133"><a href="#cb5-133" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> sig <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb5-134"><a href="#cb5-134" aria-hidden="true" tabindex="-1"></a>            <span class="co"># At this point we know, that `obj` is a class, with no user-</span></span>
<span id="cb5-135"><a href="#cb5-135" aria-hidden="true" tabindex="-1"></a>            <span class="co"># defined '__init__', '__new__', or class-level '__call__'</span></span>
<span id="cb5-136"><a href="#cb5-136" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-137"><a href="#cb5-137" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> base <span class="kw">in</span> obj.__mro__[:<span class="op">-</span><span class="dv">1</span>]:</span>
<span id="cb5-138"><a href="#cb5-138" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Since '__text_signature__' is implemented as a</span></span>
<span id="cb5-139"><a href="#cb5-139" aria-hidden="true" tabindex="-1"></a>                <span class="co"># descriptor that extracts text signature from the</span></span>
<span id="cb5-140"><a href="#cb5-140" aria-hidden="true" tabindex="-1"></a>                <span class="co"># class docstring, if 'obj' is derived from a builtin</span></span>
<span id="cb5-141"><a href="#cb5-141" aria-hidden="true" tabindex="-1"></a>                <span class="co"># class, its own '__text_signature__' may be 'None'.</span></span>
<span id="cb5-142"><a href="#cb5-142" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Therefore, we go through the MRO (except the last</span></span>
<span id="cb5-143"><a href="#cb5-143" aria-hidden="true" tabindex="-1"></a>                <span class="co"># class in there, which is 'object') to find the first</span></span>
<span id="cb5-144"><a href="#cb5-144" aria-hidden="true" tabindex="-1"></a>                <span class="co"># class with non-empty text signature.</span></span>
<span id="cb5-145"><a href="#cb5-145" aria-hidden="true" tabindex="-1"></a>                <span class="cf">try</span>:</span>
<span id="cb5-146"><a href="#cb5-146" aria-hidden="true" tabindex="-1"></a>                    text_sig <span class="op">=</span> base.__text_signature__</span>
<span id="cb5-147"><a href="#cb5-147" aria-hidden="true" tabindex="-1"></a>                <span class="cf">except</span> <span class="pp">AttributeError</span>:</span>
<span id="cb5-148"><a href="#cb5-148" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">pass</span></span>
<span id="cb5-149"><a href="#cb5-149" aria-hidden="true" tabindex="-1"></a>                <span class="cf">else</span>:</span>
<span id="cb5-150"><a href="#cb5-150" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">if</span> text_sig:</span>
<span id="cb5-151"><a href="#cb5-151" aria-hidden="true" tabindex="-1"></a>                        <span class="co"># If 'obj' class has a __text_signature__ attribute:</span></span>
<span id="cb5-152"><a href="#cb5-152" aria-hidden="true" tabindex="-1"></a>                        <span class="co"># return a signature based on it</span></span>
<span id="cb5-153"><a href="#cb5-153" aria-hidden="true" tabindex="-1"></a>                        <span class="cf">return</span> _signature_fromstr(sigcls, obj, text_sig)</span>
<span id="cb5-154"><a href="#cb5-154" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-155"><a href="#cb5-155" aria-hidden="true" tabindex="-1"></a>            <span class="co"># No '__text_signature__' was found for the 'obj' class.</span></span>
<span id="cb5-156"><a href="#cb5-156" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Last option is to check if its '__init__' is</span></span>
<span id="cb5-157"><a href="#cb5-157" aria-hidden="true" tabindex="-1"></a>            <span class="co"># object.__init__ or type.__init__.</span></span>
<span id="cb5-158"><a href="#cb5-158" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="bu">type</span> <span class="kw">not</span> <span class="kw">in</span> obj.__mro__:</span>
<span id="cb5-159"><a href="#cb5-159" aria-hidden="true" tabindex="-1"></a>                <span class="co"># We have a class (not metaclass), but no user-defined</span></span>
<span id="cb5-160"><a href="#cb5-160" aria-hidden="true" tabindex="-1"></a>                <span class="co"># __init__ or __new__ for it</span></span>
<span id="cb5-161"><a href="#cb5-161" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> (obj.<span class="fu">__init__</span> <span class="kw">is</span> <span class="bu">object</span>.<span class="fu">__init__</span> <span class="kw">and</span></span>
<span id="cb5-162"><a href="#cb5-162" aria-hidden="true" tabindex="-1"></a>                    obj.<span class="fu">__new__</span> <span class="kw">is</span> <span class="bu">object</span>.<span class="fu">__new__</span>):</span>
<span id="cb5-163"><a href="#cb5-163" aria-hidden="true" tabindex="-1"></a>                    <span class="co"># Return a signature of 'object' builtin.</span></span>
<span id="cb5-164"><a href="#cb5-164" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">return</span> sigcls.from_callable(<span class="bu">object</span>)</span>
<span id="cb5-165"><a href="#cb5-165" aria-hidden="true" tabindex="-1"></a>                <span class="cf">else</span>:</span>
<span id="cb5-166"><a href="#cb5-166" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">raise</span> <span class="pp">ValueError</span>(</span>
<span id="cb5-167"><a href="#cb5-167" aria-hidden="true" tabindex="-1"></a>                        <span class="st">'no signature found for builtin type </span><span class="sc">{!r}</span><span class="st">'</span>.<span class="bu">format</span>(obj))</span>
<span id="cb5-168"><a href="#cb5-168" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-169"><a href="#cb5-169" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> <span class="kw">not</span> <span class="bu">isinstance</span>(obj, _NonUserDefinedCallables):</span>
<span id="cb5-170"><a href="#cb5-170" aria-hidden="true" tabindex="-1"></a>        <span class="co"># An object with __call__</span></span>
<span id="cb5-171"><a href="#cb5-171" aria-hidden="true" tabindex="-1"></a>        <span class="co"># We also check that the 'obj' is not an instance of</span></span>
<span id="cb5-172"><a href="#cb5-172" aria-hidden="true" tabindex="-1"></a>        <span class="co"># _WrapperDescriptor or _MethodWrapper to avoid</span></span>
<span id="cb5-173"><a href="#cb5-173" aria-hidden="true" tabindex="-1"></a>        <span class="co"># infinite recursion (and even potential segfault)</span></span>
<span id="cb5-174"><a href="#cb5-174" aria-hidden="true" tabindex="-1"></a>        call <span class="op">=</span> _signature_get_user_defined_method(<span class="bu">type</span>(obj), <span class="st">'__call__'</span>)</span>
<span id="cb5-175"><a href="#cb5-175" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> call <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb5-176"><a href="#cb5-176" aria-hidden="true" tabindex="-1"></a>            <span class="cf">try</span>:</span>
<span id="cb5-177"><a href="#cb5-177" aria-hidden="true" tabindex="-1"></a>                sig <span class="op">=</span> _signature_from_callable(</span>
<span id="cb5-178"><a href="#cb5-178" aria-hidden="true" tabindex="-1"></a>                    call,</span>
<span id="cb5-179"><a href="#cb5-179" aria-hidden="true" tabindex="-1"></a>                    follow_wrapper_chains<span class="op">=</span>follow_wrapper_chains,</span>
<span id="cb5-180"><a href="#cb5-180" aria-hidden="true" tabindex="-1"></a>                    skip_bound_arg<span class="op">=</span>skip_bound_arg,</span>
<span id="cb5-181"><a href="#cb5-181" aria-hidden="true" tabindex="-1"></a>                    sigcls<span class="op">=</span>sigcls)</span>
<span id="cb5-182"><a href="#cb5-182" aria-hidden="true" tabindex="-1"></a>            <span class="cf">except</span> <span class="pp">ValueError</span> <span class="im">as</span> ex:</span>
<span id="cb5-183"><a href="#cb5-183" aria-hidden="true" tabindex="-1"></a>                msg <span class="op">=</span> <span class="st">'no signature found for </span><span class="sc">{!r}</span><span class="st">'</span>.<span class="bu">format</span>(obj)</span>
<span id="cb5-184"><a href="#cb5-184" aria-hidden="true" tabindex="-1"></a>                <span class="cf">raise</span> <span class="pp">ValueError</span>(msg) <span class="im">from</span> ex</span>
<span id="cb5-185"><a href="#cb5-185" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-186"><a href="#cb5-186" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> sig <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb5-187"><a href="#cb5-187" aria-hidden="true" tabindex="-1"></a>        <span class="co"># For classes and objects we skip the first parameter of their</span></span>
<span id="cb5-188"><a href="#cb5-188" aria-hidden="true" tabindex="-1"></a>        <span class="co"># __call__, __new__, or __init__ methods</span></span>
<span id="cb5-189"><a href="#cb5-189" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> skip_bound_arg:</span>
<span id="cb5-190"><a href="#cb5-190" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> _signature_bound_method(sig)</span>
<span id="cb5-191"><a href="#cb5-191" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb5-192"><a href="#cb5-192" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> sig</span>
<span id="cb5-193"><a href="#cb5-193" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-194"><a href="#cb5-194" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">isinstance</span>(obj, types.BuiltinFunctionType):</span>
<span id="cb5-195"><a href="#cb5-195" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Raise a nicer error message for builtins</span></span>
<span id="cb5-196"><a href="#cb5-196" aria-hidden="true" tabindex="-1"></a>        msg <span class="op">=</span> <span class="st">'no signature found for builtin function </span><span class="sc">{!r}</span><span class="st">'</span>.<span class="bu">format</span>(obj)</span>
<span id="cb5-197"><a href="#cb5-197" aria-hidden="true" tabindex="-1"></a>        <span class="cf">raise</span> <span class="pp">ValueError</span>(msg)</span>
<span id="cb5-198"><a href="#cb5-198" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-199"><a href="#cb5-199" aria-hidden="true" tabindex="-1"></a>    <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="st">'callable </span><span class="sc">{!r}</span><span class="st"> is not supported by signature'</span>.<span class="bu">format</span>(obj))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="when-or-why-to-use-fixsigmeta" class="level2">
<h2 class="anchored" data-anchor-id="when-or-why-to-use-fixsigmeta">When or why to use <code>FixSigMeta</code>?</h2>
<p>When we want a class to use signature of <code>__init__</code> to be its class signature.</p>
<div class="cell" data-execution_count="6">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Foo:</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, a, b, c): <span class="cf">pass</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    <span class="at">@classmethod</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> clsmed(): <span class="cf">pass</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>inspect.signature(Foo)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="6">
<pre><code>&lt;Signature (a, b, c)&gt;</code></pre>
</div>
</div>
</section>
<section id="how-foo-borrow-sig-from-__init__" class="level2">
<h2 class="anchored" data-anchor-id="how-foo-borrow-sig-from-__init__">How Foo borrow sig from <code>__init__</code></h2>
<div class="cell" data-execution_count="7">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>g <span class="op">=</span> <span class="bu">globals</span>()</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>sig <span class="op">=</span> Fastdb(_signature_from_callable, g)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<section id="how-to-debug-inspect._signature_from_callable-with-fastdb" class="level3">
<h3 class="anchored" data-anchor-id="how-to-debug-inspect._signature_from_callable-with-fastdb">How to debug <code>inspect._signature_from_callable</code> with Fastdb</h3>
<div class="cell" data-execution_count="8">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>sig.dbprint(<span class="dv">9</span>, <span class="st">"so that it can use in itself"</span>)</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>sig.<span class="bu">print</span>(part<span class="op">=</span><span class="dv">1</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>    """                                                                                                                                                 (7)
                                                                                                                                                        (8)
    _get_signature_of = functools.partial(_signature_from_callable,=====================================================================================(9)
                                                                                                                                 so that it can use in itself
                                follow_wrapper_chains=follow_wrapper_chains,                                                                            (10)
                                skip_bound_arg=skip_bound_arg,                                                                                          (11)
def _signature_from_callable(obj, *,======================================================(0)       
                             follow_wrapper_chains=True,==================================(1)       
                             skip_bound_arg=True,=========================================(2)       
                             sigcls):=====================================================(3)       
                                                                                                                                                        (4)
    """Private helper function to get signature for arbitrary=============================(5)       
    callable objects.=====================================================================(6)       
    """===================================================================================(7)       
                                                                                                                                                        (8)
    _get_signature_of = functools.partial(_signature_from_callable,=======================(9) # so that it can use in itself
                                follow_wrapper_chains=follow_wrapper_chains,==============(10)      
                                skip_bound_arg=skip_bound_arg,============================(11)      
                                sigcls=sigcls)============================================(12)      
                                                                                                                                                        (13)
    if not callable(obj):=================================================================(14)      
        raise TypeError('{!r} is not a callable object'.format(obj))======================(15)      
                                                                                                                                                        (16)
    if isinstance(obj, types.MethodType):=================================================(17)      
        # In this case we skip the first parameter of the underlying======================(18)      
        # function (usually `self` or `cls`).=============================================(19)      
        sig = _get_signature_of(obj.__func__)=============================================(20)      
                                                                                                                                                        (21)
        if skip_bound_arg:================================================================(22)      
            return _signature_bound_method(sig)===========================================(23)      
        else:=============================================================================(24)      
            return sig====================================================================(25)      
                                                                                                                                                        (26)
    # Was this function wrapped by a decorator?===========================================(27)      
    if follow_wrapper_chains:=============================================================(28)      
        obj = unwrap(obj, stop=(lambda f: hasattr(f, "__signature__")))===================(29)      
        if isinstance(obj, types.MethodType):=============================================(30)      
            # If the unwrapped object is a *method*, we might want to=====================(31)      
            # skip its first parameter (self).============================================(32)      
                                                                                                                                     part No.1 out of 6 parts</code></pre>
</div>
</div>
<div class="cell" data-execution_count="9">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>sig.dbprint(<span class="dv">14</span>, <span class="st">"obj must be callable"</span>)</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>sig.<span class="bu">print</span>(part<span class="op">=</span><span class="dv">1</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>                                sigcls=sigcls)                                                                                                          (12)
                                                                                                                                                        (13)
    if not callable(obj):===============================================================================================================================(14)
                                                                                                                                         obj must be callable
        raise TypeError('{!r} is not a callable object'.format(obj))                                                                                    (15)
                                                                                                                                                        (16)
def _signature_from_callable(obj, *,======================================================(0)       
                             follow_wrapper_chains=True,==================================(1)       
                             skip_bound_arg=True,=========================================(2)       
                             sigcls):=====================================================(3)       
                                                                                                                                                        (4)
    """Private helper function to get signature for arbitrary=============================(5)       
    callable objects.=====================================================================(6)       
    """===================================================================================(7)       
                                                                                                                                                        (8)
    _get_signature_of = functools.partial(_signature_from_callable,=======================(9) # so that it can use in itself
                                follow_wrapper_chains=follow_wrapper_chains,==============(10)      
                                skip_bound_arg=skip_bound_arg,============================(11)      
                                sigcls=sigcls)============================================(12)      
                                                                                                                                                        (13)
    if not callable(obj):=================================================================(14) # obj must be callable
        raise TypeError('{!r} is not a callable object'.format(obj))======================(15)      
                                                                                                                                                        (16)
    if isinstance(obj, types.MethodType):=================================================(17)      
        # In this case we skip the first parameter of the underlying======================(18)      
        # function (usually `self` or `cls`).=============================================(19)      
        sig = _get_signature_of(obj.__func__)=============================================(20)      
                                                                                                                                                        (21)
        if skip_bound_arg:================================================================(22)      
            return _signature_bound_method(sig)===========================================(23)      
        else:=============================================================================(24)      
            return sig====================================================================(25)      
                                                                                                                                                        (26)
    # Was this function wrapped by a decorator?===========================================(27)      
    if follow_wrapper_chains:=============================================================(28)      
        obj = unwrap(obj, stop=(lambda f: hasattr(f, "__signature__")))===================(29)      
        if isinstance(obj, types.MethodType):=============================================(30)      
            # If the unwrapped object is a *method*, we might want to=====================(31)      
            # skip its first parameter (self).============================================(32)      
                                                                                                                                     part No.1 out of 6 parts</code></pre>
</div>
</div>
<div class="cell" data-execution_count="10">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="bu">isinstance</span>(Foo.clsmed, types.MethodType)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="10">
<pre><code>True</code></pre>
</div>
</div>
<div class="cell" data-execution_count="11">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>sig.dbprint(<span class="dv">17</span>, <span class="st">"obj can be a classmethod"</span>)</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>sig.<span class="bu">print</span>(part<span class="op">=</span><span class="dv">1</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>        raise TypeError('{!r} is not a callable object'.format(obj))                                                                                    (15)
                                                                                                                                                        (16)
    if isinstance(obj, types.MethodType):===============================================================================================================(17)
                                                                                                                                     obj can be a classmethod
        # In this case we skip the first parameter of the underlying                                                                                    (18)
        # function (usually `self` or `cls`).                                                                                                           (19)
def _signature_from_callable(obj, *,======================================================(0)       
                             follow_wrapper_chains=True,==================================(1)       
                             skip_bound_arg=True,=========================================(2)       
                             sigcls):=====================================================(3)       
                                                                                                                                                        (4)
    """Private helper function to get signature for arbitrary=============================(5)       
    callable objects.=====================================================================(6)       
    """===================================================================================(7)       
                                                                                                                                                        (8)
    _get_signature_of = functools.partial(_signature_from_callable,=======================(9) # so that it can use in itself
                                follow_wrapper_chains=follow_wrapper_chains,==============(10)      
                                skip_bound_arg=skip_bound_arg,============================(11)      
                                sigcls=sigcls)============================================(12)      
                                                                                                                                                        (13)
    if not callable(obj):=================================================================(14) # obj must be callable
        raise TypeError('{!r} is not a callable object'.format(obj))======================(15)      
                                                                                                                                                        (16)
    if isinstance(obj, types.MethodType):=================================================(17) # obj can be a classmethod
        # In this case we skip the first parameter of the underlying======================(18)      
        # function (usually `self` or `cls`).=============================================(19)      
        sig = _get_signature_of(obj.__func__)=============================================(20)      
                                                                                                                                                        (21)
        if skip_bound_arg:================================================================(22)      
            return _signature_bound_method(sig)===========================================(23)      
        else:=============================================================================(24)      
            return sig====================================================================(25)      
                                                                                                                                                        (26)
    # Was this function wrapped by a decorator?===========================================(27)      
    if follow_wrapper_chains:=============================================================(28)      
        obj = unwrap(obj, stop=(lambda f: hasattr(f, "__signature__")))===================(29)      
        if isinstance(obj, types.MethodType):=============================================(30)      
            # If the unwrapped object is a *method*, we might want to=====================(31)      
            # skip its first parameter (self).============================================(32)      
                                                                                                                                     part No.1 out of 6 parts</code></pre>
</div>
</div>
<div class="cell" data-execution_count="12">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> fastcore.meta <span class="im">import</span> delegates</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="13">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> low(a, b<span class="op">=</span><span class="dv">1</span>): <span class="cf">pass</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="at">@delegates</span>(low)</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> mid(c, d<span class="op">=</span><span class="dv">1</span>, <span class="op">**</span>kwargs): <span class="cf">pass</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="14">
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>sig.dbprint(<span class="dv">28</span>, <span class="st">"does Foo has __signature__?"</span>, <span class="st">"follow_wrapper_chains"</span>, <span class="st">"obj = unwrap(obj, stop=(lambda f: hasattr(f, '__signature__')))"</span>, <span class="st">"isinstance(obj, types.MethodType)"</span>)</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>inspect._signature_from_callable <span class="op">=</span> _signature_from_callable</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>inspect.signature(mid)</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>sig.<span class="bu">print</span>(part<span class="op">=</span><span class="dv">1</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>                                                                                                                                                        (26)
    # Was this function wrapped by a decorator?                                                                                                         (27)
    if follow_wrapper_chains:===========================================================================================================================(28)
                                                                                                                                  does Foo has __signature__?
        obj = unwrap(obj, stop=(lambda f: hasattr(f, "__signature__")))                                                                                 (29)
        if isinstance(obj, types.MethodType):                                                                                                           (30)


                                                                                                        follow_wrapper_chains =&gt; follow_wrapper_chains : True


                                                        obj = unwrap(obj, stop=(lambda f: hasattr(f, '__signature__'))) =&gt; obj: &lt;function mid at 0x105c97160&gt;


                                                                               isinstance(obj, types.MethodType) =&gt; isinstance(obj, types.MethodType) : False
def _signature_from_callable(obj, *,======================================================(0)       
                             follow_wrapper_chains=True,==================================(1)       
                             skip_bound_arg=True,=========================================(2)       
                             sigcls):=====================================================(3)       
                                                                                                                                                        (4)
    """Private helper function to get signature for arbitrary=============================(5)       
    callable objects.=====================================================================(6)       
    """===================================================================================(7)       
                                                                                                                                                        (8)
    _get_signature_of = functools.partial(_signature_from_callable,=======================(9) # so that it can use in itself
                                follow_wrapper_chains=follow_wrapper_chains,==============(10)      
                                skip_bound_arg=skip_bound_arg,============================(11)      
                                sigcls=sigcls)============================================(12)      
                                                                                                                                                        (13)
    if not callable(obj):=================================================================(14) # obj must be callable
        raise TypeError('{!r} is not a callable object'.format(obj))======================(15)      
                                                                                                                                                        (16)
    if isinstance(obj, types.MethodType):=================================================(17) # obj can be a classmethod
        # In this case we skip the first parameter of the underlying======================(18)      
        # function (usually `self` or `cls`).=============================================(19)      
        sig = _get_signature_of(obj.__func__)=============================================(20)      
                                                                                                                                                        (21)
        if skip_bound_arg:================================================================(22)      
            return _signature_bound_method(sig)===========================================(23)      
        else:=============================================================================(24)      
            return sig====================================================================(25)      
                                                                                                                                                        (26)
    # Was this function wrapped by a decorator?===========================================(27)      
    if follow_wrapper_chains:=============================================================(28) # does Foo has __signature__?
        obj = unwrap(obj, stop=(lambda f: hasattr(f, "__signature__")))===================(29)      
        if isinstance(obj, types.MethodType):=============================================(30)      
            # If the unwrapped object is a *method*, we might want to=====================(31)      
            # skip its first parameter (self).============================================(32)      
                                                                                                                                     part No.1 out of 6 parts</code></pre>
</div>
</div>
<div class="cell" data-execution_count="15">
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>sig.dbprint(<span class="dv">37</span>, <span class="st">"check __signature__"</span>, <span class="st">"obj = unwrap(obj, stop=(lambda f: hasattr(f, '__signature__')))"</span>, <span class="st">"obj.__signature__"</span>)</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>inspect._signature_from_callable <span class="op">=</span> _signature_from_callable</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>inspect.signature(mid)</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>sig.<span class="bu">print</span>(part<span class="op">=</span><span class="dv">2</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>                                                                                                                                                        (35)
    try:                                                                                                                                                (36)
        sig = obj.__signature__=========================================================================================================================(37)
                                                                                                                                          check __signature__
    except AttributeError:                                                                                                                              (38)
        pass                                                                                                                                            (39)


                                                        obj = unwrap(obj, stop=(lambda f: hasattr(f, '__signature__'))) =&gt; obj: &lt;function mid at 0x105c97160&gt;


                                                                                                    obj.__signature__ =&gt; obj.__signature__ : (c, d=1, *, b=1)
            # See test_signature_wrapped_bound_method for details.========================(33)      
            return _get_signature_of(obj)=================================================(34)      
                                                                                                                                                        (35)
    try:==================================================================================(36)      
        sig = obj.__signature__===========================================================(37) # check __signature__
    except AttributeError:================================================================(38)      
        pass==============================================================================(39)      
    else:=================================================================================(40)      
        if sig is not None:===============================================================(41)      
            if not isinstance(sig, Signature):============================================(42)      
                raise TypeError(==========================================================(43)      
                    'unexpected object {!r} in __signature__ '============================(44)      
                    'attribute'.format(sig))==============================================(45)      
            return sig====================================================================(46)      
                                                                                                                                                        (47)
    try:==================================================================================(48)      
        partialmethod = obj._partialmethod================================================(49)      
    except AttributeError:================================================================(50)      
        pass==============================================================================(51)      
    else:=================================================================================(52)      
        if isinstance(partialmethod, functools.partialmethod):============================(53)      
            # Unbound partialmethod (see functools.partialmethod)=========================(54)      
            # This means, that we need to calculate the signature=========================(55)      
            # as if it's a regular partial object, but taking into========================(56)      
            # account that the first positional argument==================================(57)      
            # (usually `self`, or `cls`) will not be passed===============================(58)      
            # automatically (as for boundmethods)=========================================(59)      
                                                                                                                                                        (60)
            wrapped_sig = _get_signature_of(partialmethod.func)===========================(61)      
                                                                                                                                                        (62)
            sig = _signature_get_partial(wrapped_sig, partialmethod, (None,))=============(63)      
            first_wrapped_param = tuple(wrapped_sig.parameters.values())[0]===============(64)      
            if first_wrapped_param.kind is Parameter.VAR_POSITIONAL:======================(65)      
                                                                                                                                     part No.2 out of 6 parts</code></pre>
</div>
</div>
</section>
<section id="how-exactly-foo-get-sig-from-__init__" class="level3">
<h3 class="anchored" data-anchor-id="how-exactly-foo-get-sig-from-__init__">How exactly Foo get sig from <code>__init__</code></h3>
<div class="cell" data-execution_count="16">
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>sig.dbprint(<span class="dv">91</span>, <span class="st">"step 1: obj is a class?"</span>, <span class="st">"isinstance(obj, type)"</span>)</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>inspect._signature_from_callable <span class="op">=</span> _signature_from_callable</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>inspect.signature(Foo)</span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>sig.<span class="bu">print</span>(part<span class="op">=</span><span class="dv">3</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>

                                                                                                        follow_wrapper_chains =&gt; follow_wrapper_chains : True


                                   obj = unwrap(obj, stop=(lambda f: hasattr(f, '__signature__'))) =&gt; obj: &lt;function IPythonKernel.do_execute at 0x105810040&gt;


                                                                               isinstance(obj, types.MethodType) =&gt; isinstance(obj, types.MethodType) : False


                                                                                                        follow_wrapper_chains =&gt; follow_wrapper_chains : True


                            obj = unwrap(obj, stop=(lambda f: hasattr(f, '__signature__'))) =&gt; obj: &lt;function InteractiveShell.run_cell_async at 0x103f62f70&gt;


                                                                               isinstance(obj, types.MethodType) =&gt; isinstance(obj, types.MethodType) : False
                                                                                                                                                        (89)
    sig = None                                                                                                                                          (90)
    if isinstance(obj, type):===========================================================================================================================(91)
                                                                                                                                      step 1: obj is a class?
        # obj is a class or a metaclass                                                                                                                 (92)
                                                                                                                                                        (93)


                                                                                                        isinstance(obj, type) =&gt; isinstance(obj, type) : True


                                               obj = unwrap(obj, stop=(lambda f: hasattr(f, '__signature__'))) =&gt; obj: &lt;function Foo.__init__ at 0x105c2a4c0&gt;


                # First argument of the wrapped callable is `*args`, as in================(66)      
                # `partialmethod(lambda *args)`.==========================================(67)      
                return sig================================================================(68)      
            else:=========================================================================(69)      
                sig_params = tuple(sig.parameters.values())===============================(70)      
                assert (not sig_params or=================================================(71)      
                        first_wrapped_param is not sig_params[0])=========================(72)      
                new_params = (first_wrapped_param,) + sig_params==========================(73)      
                return sig.replace(parameters=new_params)=================================(74)      
                                                                                                                                                        (75)
    if isfunction(obj) or _signature_is_functionlike(obj):================================(76)      
        # If it's a pure Python function, or an object that is duck type==================(77)      
        # of a Python function (Cython functions, for instance), then:====================(78)      
        return _signature_from_function(sigcls, obj,======================================(79)      
                                        skip_bound_arg=skip_bound_arg)====================(80)      
                                                                                                                                                        (81)
    if _signature_is_builtin(obj):========================================================(82)      
        return _signature_from_builtin(sigcls, obj,=======================================(83)      
                                       skip_bound_arg=skip_bound_arg)=====================(84)      
                                                                                                                                                        (85)
    if isinstance(obj, functools.partial):================================================(86)      
        wrapped_sig = _get_signature_of(obj.func)=========================================(87)      
        return _signature_get_partial(wrapped_sig, obj)===================================(88)      
                                                                                                                                                        (89)
    sig = None============================================================================(90)      
    if isinstance(obj, type):=============================================================(91) # step 1: obj is a class?
        # obj is a class or a metaclass===================================================(92)      
                                                                                                                                                        (93)
        # First, let's see if it has an overloaded __call__ defined=======================(94)      
        # in its metaclass================================================================(95)      
        call = _signature_get_user_defined_method(type(obj), '__call__')==================(96)      
        if call is not None:==============================================================(97)      
            sig = _get_signature_of(call)=================================================(98)      
                                                                                                                                     part No.3 out of 6 parts</code></pre>
</div>
</div>
<div class="cell" data-execution_count="17">
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>sig.dbprint(<span class="dv">96</span>, <span class="st">"step 2: define its own __call__?"</span>, <span class="st">"call = _signature_get_user_defined_method(type(obj), '__call__')"</span>)</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>inspect._signature_from_callable <span class="op">=</span> _signature_from_callable</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>inspect.signature(Foo)</span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>sig.<span class="bu">print</span>(part<span class="op">=</span><span class="dv">3</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>

                                   obj = unwrap(obj, stop=(lambda f: hasattr(f, '__signature__'))) =&gt; obj: &lt;function IPythonKernel.do_execute at 0x105810040&gt;




                            obj = unwrap(obj, stop=(lambda f: hasattr(f, '__signature__'))) =&gt; obj: &lt;function InteractiveShell.run_cell_async at 0x103f62f70&gt;


        # First, let's see if it has an overloaded __call__ defined                                                                                     (94)
        # in its metaclass                                                                                                                              (95)
        call = _signature_get_user_defined_method(type(obj), '__call__')================================================================================(96)
                                                                                                                             step 2: define its own __call__?
        if call is not None:                                                                                                                            (97)
            sig = _get_signature_of(call)                                                                                                               (98)


                                                                               call = _signature_get_user_defined_method(type(obj), '__call__') =&gt; call: None
                # First argument of the wrapped callable is `*args`, as in================(66)      
                # `partialmethod(lambda *args)`.==========================================(67)      
                return sig================================================================(68)      
            else:=========================================================================(69)      
                sig_params = tuple(sig.parameters.values())===============================(70)      
                assert (not sig_params or=================================================(71)      
                        first_wrapped_param is not sig_params[0])=========================(72)      
                new_params = (first_wrapped_param,) + sig_params==========================(73)      
                return sig.replace(parameters=new_params)=================================(74)      
                                                                                                                                                        (75)
    if isfunction(obj) or _signature_is_functionlike(obj):================================(76)      
        # If it's a pure Python function, or an object that is duck type==================(77)      
        # of a Python function (Cython functions, for instance), then:====================(78)      
        return _signature_from_function(sigcls, obj,======================================(79)      
                                        skip_bound_arg=skip_bound_arg)====================(80)      
                                                                                                                                                        (81)
    if _signature_is_builtin(obj):========================================================(82)      
        return _signature_from_builtin(sigcls, obj,=======================================(83)      
                                       skip_bound_arg=skip_bound_arg)=====================(84)      
                                                                                                                                                        (85)
    if isinstance(obj, functools.partial):================================================(86)      
        wrapped_sig = _get_signature_of(obj.func)=========================================(87)      
        return _signature_get_partial(wrapped_sig, obj)===================================(88)      
                                                                                                                                                        (89)
    sig = None============================================================================(90)      
    if isinstance(obj, type):=============================================================(91) # step 1: obj is a class?
        # obj is a class or a metaclass===================================================(92)      
                                                                                                                                                        (93)
        # First, let's see if it has an overloaded __call__ defined=======================(94)      
        # in its metaclass================================================================(95)      
        call = _signature_get_user_defined_method(type(obj), '__call__')==================(96) # step 2: define its own __call__?
        if call is not None:==============================================================(97)      
            sig = _get_signature_of(call)=================================================(98)      
                                                                                                                                     part No.3 out of 6 parts</code></pre>
</div>
</div>
<div class="cell" data-execution_count="18">
<div class="sourceCode cell-code" id="cb27"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>sig.dbprint(<span class="dv">101</span>, <span class="st">"step 3: define its own __new__?"</span>, <span class="st">"new = _signature_get_user_defined_method(obj, '__new__')"</span>)</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>inspect._signature_from_callable <span class="op">=</span> _signature_from_callable</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>inspect.signature(Foo)</span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>sig.<span class="bu">print</span>(part<span class="op">=</span><span class="dv">4</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>        else:                                                                                                                                           (99)
            factory_method = None                                                                                                                       (100)
            new = _signature_get_user_defined_method(obj, '__new__')====================================================================================(101)
                                                                                                                              step 3: define its own __new__?
            init = _signature_get_user_defined_method(obj, '__init__')                                                                                  (102)
            # Now we check if the 'obj' class has an own '__new__' method                                                                               (103)


                                                                                        new = _signature_get_user_defined_method(obj, '__new__') =&gt; new: None
        else:=============================================================================(99)      
            factory_method = None=========================================================(100)     
            new = _signature_get_user_defined_method(obj, '__new__')======================(101) # step 3: define its own __new__?
            init = _signature_get_user_defined_method(obj, '__init__')====================(102)     
            # Now we check if the 'obj' class has an own '__new__' method=================(103)     
            if '__new__' in obj.__dict__:=================================================(104)     
                factory_method = new======================================================(105)     
            # or an own '__init__' method=================================================(106)     
            elif '__init__' in obj.__dict__:==============================================(107)     
                factory_method = init=====================================================(108)     
            # If not, we take inherited '__new__' or '__init__', if present===============(109)     
            elif new is not None:=========================================================(110)     
                factory_method = new======================================================(111)     
            elif init is not None:========================================================(112)     
                factory_method = init=====================================================(113)     
                                                                                                                                                        (114)
            if factory_method is not None:================================================(115)     
                sig = _get_signature_of(factory_method)===================================(116)     
                                                                                                                                                        (117)
        if sig is None:===================================================================(118)     
            # At this point we know, that `obj` is a class, with no user-=================(119)     
            # defined '__init__', '__new__', or class-level '__call__'====================(120)     
                                                                                                                                                        (121)
            for base in obj.__mro__[:-1]:=================================================(122)     
                # Since '__text_signature__' is implemented as a==========================(123)     
                # descriptor that extracts text signature from the========================(124)     
                # class docstring, if 'obj' is derived from a builtin=====================(125)     
                # class, its own '__text_signature__' may be 'None'.======================(126)     
                # Therefore, we go through the MRO (except the last=======================(127)     
                # class in there, which is 'object') to find the first====================(128)     
                # class with non-empty text signature.====================================(129)     
                try:======================================================================(130)     
                    text_sig = base.__text_signature__====================================(131)     
                                                                                                                                     part No.4 out of 6 parts</code></pre>
</div>
</div>
<div class="cell" data-execution_count="19">
<div class="sourceCode cell-code" id="cb29"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a>sig.dbprint(<span class="dv">102</span>, <span class="st">"step 4: define its own __init__?"</span>, <span class="st">"init = _signature_get_user_defined_method(obj, '__init__')"</span>)</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>inspect._signature_from_callable <span class="op">=</span> _signature_from_callable</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>inspect.signature(Foo)</span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>sig.<span class="bu">print</span>(part<span class="op">=</span><span class="dv">4</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>            factory_method = None                                                                                                                       (100)
            new = _signature_get_user_defined_method(obj, '__new__')                                                                                    (101)
            init = _signature_get_user_defined_method(obj, '__init__')==================================================================================(102)
                                                                                                                             step 4: define its own __init__?
            # Now we check if the 'obj' class has an own '__new__' method                                                                               (103)
            if '__new__' in obj.__dict__:                                                                                                               (104)


                                                   init = _signature_get_user_defined_method(obj, '__init__') =&gt; init: &lt;function Foo.__init__ at 0x105c2a4c0&gt;
        else:=============================================================================(99)      
            factory_method = None=========================================================(100)     
            new = _signature_get_user_defined_method(obj, '__new__')======================(101) # step 3: define its own __new__?
            init = _signature_get_user_defined_method(obj, '__init__')====================(102) # step 4: define its own __init__?
            # Now we check if the 'obj' class has an own '__new__' method=================(103)     
            if '__new__' in obj.__dict__:=================================================(104)     
                factory_method = new======================================================(105)     
            # or an own '__init__' method=================================================(106)     
            elif '__init__' in obj.__dict__:==============================================(107)     
                factory_method = init=====================================================(108)     
            # If not, we take inherited '__new__' or '__init__', if present===============(109)     
            elif new is not None:=========================================================(110)     
                factory_method = new======================================================(111)     
            elif init is not None:========================================================(112)     
                factory_method = init=====================================================(113)     
                                                                                                                                                        (114)
            if factory_method is not None:================================================(115)     
                sig = _get_signature_of(factory_method)===================================(116)     
                                                                                                                                                        (117)
        if sig is None:===================================================================(118)     
            # At this point we know, that `obj` is a class, with no user-=================(119)     
            # defined '__init__', '__new__', or class-level '__call__'====================(120)     
                                                                                                                                                        (121)
            for base in obj.__mro__[:-1]:=================================================(122)     
                # Since '__text_signature__' is implemented as a==========================(123)     
                # descriptor that extracts text signature from the========================(124)     
                # class docstring, if 'obj' is derived from a builtin=====================(125)     
                # class, its own '__text_signature__' may be 'None'.======================(126)     
                # Therefore, we go through the MRO (except the last=======================(127)     
                # class in there, which is 'object') to find the first====================(128)     
                # class with non-empty text signature.====================================(129)     
                try:======================================================================(130)     
                    text_sig = base.__text_signature__====================================(131)     
                                                                                                                                     part No.4 out of 6 parts</code></pre>
</div>
</div>
<div class="cell" data-execution_count="20">
<div class="sourceCode cell-code" id="cb31"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>sig.dbprint(<span class="dv">108</span>, <span class="st">"step 5: __init__ is inside obj.__dict__?"</span>, <span class="st">"'__init__' in obj.__dict__"</span>)</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>inspect._signature_from_callable <span class="op">=</span> _signature_from_callable</span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>inspect.signature(Foo)</span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>sig.<span class="bu">print</span>(part<span class="op">=</span><span class="dv">4</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>            # or an own '__init__' method                                                                                                               (106)
            elif '__init__' in obj.__dict__:                                                                                                            (107)
                factory_method = init===================================================================================================================(108)
                                                                                                                     step 5: __init__ is inside obj.__dict__?
            # If not, we take inherited '__new__' or '__init__', if present                                                                             (109)
            elif new is not None:                                                                                                                       (110)


                                                                                              '__init__' in obj.__dict__ =&gt; '__init__' in obj.__dict__ : True
        else:=============================================================================(99)      
            factory_method = None=========================================================(100)     
            new = _signature_get_user_defined_method(obj, '__new__')======================(101) # step 3: define its own __new__?
            init = _signature_get_user_defined_method(obj, '__init__')====================(102) # step 4: define its own __init__?
            # Now we check if the 'obj' class has an own '__new__' method=================(103)     
            if '__new__' in obj.__dict__:=================================================(104)     
                factory_method = new======================================================(105)     
            # or an own '__init__' method=================================================(106)     
            elif '__init__' in obj.__dict__:==============================================(107)     
                factory_method = init=====================================================(108) # step 5: __init__ is inside obj.__dict__?
            # If not, we take inherited '__new__' or '__init__', if present===============(109)     
            elif new is not None:=========================================================(110)     
                factory_method = new======================================================(111)     
            elif init is not None:========================================================(112)     
                factory_method = init=====================================================(113)     
                                                                                                                                                        (114)
            if factory_method is not None:================================================(115)     
                sig = _get_signature_of(factory_method)===================================(116)     
                                                                                                                                                        (117)
        if sig is None:===================================================================(118)     
            # At this point we know, that `obj` is a class, with no user-=================(119)     
            # defined '__init__', '__new__', or class-level '__call__'====================(120)     
                                                                                                                                                        (121)
            for base in obj.__mro__[:-1]:=================================================(122)     
                # Since '__text_signature__' is implemented as a==========================(123)     
                # descriptor that extracts text signature from the========================(124)     
                # class docstring, if 'obj' is derived from a builtin=====================(125)     
                # class, its own '__text_signature__' may be 'None'.======================(126)     
                # Therefore, we go through the MRO (except the last=======================(127)     
                # class in there, which is 'object') to find the first====================(128)     
                # class with non-empty text signature.====================================(129)     
                try:======================================================================(130)     
                    text_sig = base.__text_signature__====================================(131)     
                                                                                                                                     part No.4 out of 6 parts</code></pre>
</div>
</div>
<div class="cell" data-execution_count="21">
<div class="sourceCode cell-code" id="cb33"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a>sig.dbprint(<span class="dv">116</span>, <span class="st">"step 6: run on itself using functools.partial"</span>, <span class="st">"sig = _get_signature_of(factory_method)"</span>)</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>inspect._signature_from_callable <span class="op">=</span> _signature_from_callable</span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>inspect.signature(Foo)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>                                                                                                                                                        (114)
            if factory_method is not None:                                                                                                              (115)
                sig = _get_signature_of(factory_method)=================================================================================================(116)
                                                                                                                step 6: run on itself using functools.partial
                                                                                                                                                        (117)
        if sig is None:                                                                                                                                 (118)


                                                                                              sig = _get_signature_of(factory_method) =&gt; sig: (self, a, b, c)</code></pre>
</div>
<div class="cell-output cell-output-display" data-execution_count="21">
<pre><code>&lt;Signature (a, b, c)&gt;</code></pre>
</div>
</div>
<div class="cell" data-execution_count="22">
<div class="sourceCode cell-code" id="cb36"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a>sig.dbprint(<span class="dv">76</span>, <span class="st">"step 7: run on itself will run here"</span>, <span class="st">"isfunction(obj)"</span>, <span class="st">"_signature_is_functionlike(obj)"</span>)</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a>inspect._signature_from_callable <span class="op">=</span> _signature_from_callable</span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a>inspect.signature(Foo.<span class="fu">__init__</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>                return sig.replace(parameters=new_params)                                                                                               (74)
                                                                                                                                                        (75)
    if isfunction(obj) or _signature_is_functionlike(obj):==============================================================================================(76)
                                                                                                                          step 7: run on itself will run here
        # If it's a pure Python function, or an object that is duck type                                                                                (77)
        # of a Python function (Cython functions, for instance), then:                                                                                  (78)


                                                                                                                    isfunction(obj) =&gt; isfunction(obj) : True


                                                                                    _signature_is_functionlike(obj) =&gt; _signature_is_functionlike(obj) : True</code></pre>
</div>
<div class="cell-output cell-output-display" data-execution_count="22">
<pre><code>&lt;Signature (self, a, b, c)&gt;</code></pre>
</div>
</div>
<div class="cell" data-execution_count="23">
<div class="sourceCode cell-code" id="cb39"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a>sig.dbprint(<span class="dv">79</span>, <span class="st">"step 8: get sig with a different func"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>        # If it's a pure Python function, or an object that is duck type                                                                                (77)
        # of a Python function (Cython functions, for instance), then:                                                                                  (78)
        return _signature_from_function(sigcls, obj,====================================================================================================(79)
                                                                                                                        step 8: get sig with a different func
                                        skip_bound_arg=skip_bound_arg)                                                                                  (80)
                                                                                                                                                        (81)


                                                                                                                    isfunction(obj) =&gt; isfunction(obj) : True


                                                                                    _signature_is_functionlike(obj) =&gt; _signature_is_functionlike(obj) : True</code></pre>
</div>
<div class="cell-output cell-output-display" data-execution_count="23">
<pre><code>&lt;function __main__._signature_from_callable(obj, *, follow_wrapper_chains=True, skip_bound_arg=True, sigcls)&gt;</code></pre>
</div>
</div>
<div class="cell" data-execution_count="24">
<div class="sourceCode cell-code" id="cb42"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a>sig.<span class="bu">print</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>

                                                                                                                    isfunction(obj) =&gt; isfunction(obj) : True


                                                                                    _signature_is_functionlike(obj) =&gt; _signature_is_functionlike(obj) : True


                                                                                                                    isfunction(obj) =&gt; isfunction(obj) : True


                                                                                    _signature_is_functionlike(obj) =&gt; _signature_is_functionlike(obj) : True
def _signature_from_callable(obj, *,======================================================(0)       
                             follow_wrapper_chains=True,==================================(1)       
                             skip_bound_arg=True,=========================================(2)       
                             sigcls):=====================================================(3)       
                                                                                                                                                        (4)
    """Private helper function to get signature for arbitrary=============================(5)       
    callable objects.=====================================================================(6)       
    """===================================================================================(7)       
                                                                                                                                                        (8)
    _get_signature_of = functools.partial(_signature_from_callable,=======================(9) # so that it can use in itself
                                follow_wrapper_chains=follow_wrapper_chains,==============(10)      
                                skip_bound_arg=skip_bound_arg,============================(11)      
                                sigcls=sigcls)============================================(12)      
                                                                                                                                                        (13)
    if not callable(obj):=================================================================(14) # obj must be callable
        raise TypeError('{!r} is not a callable object'.format(obj))======================(15)      
                                                                                                                                                        (16)
    if isinstance(obj, types.MethodType):=================================================(17) # obj can be a classmethod
        # In this case we skip the first parameter of the underlying======================(18)      
        # function (usually `self` or `cls`).=============================================(19)      
        sig = _get_signature_of(obj.__func__)=============================================(20)      
                                                                                                                                                        (21)
        if skip_bound_arg:================================================================(22)      
            return _signature_bound_method(sig)===========================================(23)      
        else:=============================================================================(24)      
            return sig====================================================================(25)      
                                                                                                                                                        (26)
    # Was this function wrapped by a decorator?===========================================(27)      
    if follow_wrapper_chains:=============================================================(28) # does Foo has __signature__?
        obj = unwrap(obj, stop=(lambda f: hasattr(f, "__signature__")))===================(29)      
        if isinstance(obj, types.MethodType):=============================================(30)      
            # If the unwrapped object is a *method*, we might want to=====================(31)      
            # skip its first parameter (self).============================================(32)      
            # See test_signature_wrapped_bound_method for details.========================(33)      
            return _get_signature_of(obj)=================================================(34)      
                                                                                                                                                        (35)
    try:==================================================================================(36)      
        sig = obj.__signature__===========================================================(37) # check __signature__
    except AttributeError:================================================================(38)      
        pass==============================================================================(39)      
    else:=================================================================================(40)      
        if sig is not None:===============================================================(41)      
            if not isinstance(sig, Signature):============================================(42)      
                raise TypeError(==========================================================(43)      
                    'unexpected object {!r} in __signature__ '============================(44)      
                    'attribute'.format(sig))==============================================(45)      
            return sig====================================================================(46)      
                                                                                                                                                        (47)
    try:==================================================================================(48)      
        partialmethod = obj._partialmethod================================================(49)      
    except AttributeError:================================================================(50)      
        pass==============================================================================(51)      
    else:=================================================================================(52)      
        if isinstance(partialmethod, functools.partialmethod):============================(53)      
            # Unbound partialmethod (see functools.partialmethod)=========================(54)      
            # This means, that we need to calculate the signature=========================(55)      
            # as if it's a regular partial object, but taking into========================(56)      
            # account that the first positional argument==================================(57)      
            # (usually `self`, or `cls`) will not be passed===============================(58)      
            # automatically (as for boundmethods)=========================================(59)      
                                                                                                                                                        (60)
            wrapped_sig = _get_signature_of(partialmethod.func)===========================(61)      
                                                                                                                                                        (62)
            sig = _signature_get_partial(wrapped_sig, partialmethod, (None,))=============(63)      
            first_wrapped_param = tuple(wrapped_sig.parameters.values())[0]===============(64)      
            if first_wrapped_param.kind is Parameter.VAR_POSITIONAL:======================(65)      
                # First argument of the wrapped callable is `*args`, as in================(66)      
                # `partialmethod(lambda *args)`.==========================================(67)      
                return sig================================================================(68)      
            else:=========================================================================(69)      
                sig_params = tuple(sig.parameters.values())===============================(70)      
                assert (not sig_params or=================================================(71)      
                        first_wrapped_param is not sig_params[0])=========================(72)      
                new_params = (first_wrapped_param,) + sig_params==========================(73)      
                return sig.replace(parameters=new_params)=================================(74)      
                                                                                                                                                        (75)
    if isfunction(obj) or _signature_is_functionlike(obj):================================(76) # step 7: run on itself will run here
        # If it's a pure Python function, or an object that is duck type==================(77)      
        # of a Python function (Cython functions, for instance), then:====================(78)      
        return _signature_from_function(sigcls, obj,======================================(79) # step 8: get sig with a different func
                                        skip_bound_arg=skip_bound_arg)====================(80)      
                                                                                                                                                        (81)
    if _signature_is_builtin(obj):========================================================(82)      
        return _signature_from_builtin(sigcls, obj,=======================================(83)      
                                       skip_bound_arg=skip_bound_arg)=====================(84)      
                                                                                                                                                        (85)
    if isinstance(obj, functools.partial):================================================(86)      
        wrapped_sig = _get_signature_of(obj.func)=========================================(87)      
        return _signature_get_partial(wrapped_sig, obj)===================================(88)      
                                                                                                                                                        (89)
    sig = None============================================================================(90)      
    if isinstance(obj, type):=============================================================(91) # step 1: obj is a class?
        # obj is a class or a metaclass===================================================(92)      
                                                                                                                                                        (93)
        # First, let's see if it has an overloaded __call__ defined=======================(94)      
        # in its metaclass================================================================(95)      
        call = _signature_get_user_defined_method(type(obj), '__call__')==================(96) # step 2: define its own __call__?
        if call is not None:==============================================================(97)      
            sig = _get_signature_of(call)=================================================(98)      
        else:=============================================================================(99)      
            factory_method = None=========================================================(100)     
            new = _signature_get_user_defined_method(obj, '__new__')======================(101) # step 3: define its own __new__?
            init = _signature_get_user_defined_method(obj, '__init__')====================(102) # step 4: define its own __init__?
            # Now we check if the 'obj' class has an own '__new__' method=================(103)     
            if '__new__' in obj.__dict__:=================================================(104)     
                factory_method = new======================================================(105)     
            # or an own '__init__' method=================================================(106)     
            elif '__init__' in obj.__dict__:==============================================(107)     
                factory_method = init=====================================================(108) # step 5: __init__ is inside obj.__dict__?
            # If not, we take inherited '__new__' or '__init__', if present===============(109)     
            elif new is not None:=========================================================(110)     
                factory_method = new======================================================(111)     
            elif init is not None:========================================================(112)     
                factory_method = init=====================================================(113)     
                                                                                                                                                        (114)
            if factory_method is not None:================================================(115)     
                sig = _get_signature_of(factory_method)===================================(116) # step 6: run on itself using functools.partial
                                                                                                                                                        (117)
        if sig is None:===================================================================(118)     
            # At this point we know, that `obj` is a class, with no user-=================(119)     
            # defined '__init__', '__new__', or class-level '__call__'====================(120)     
                                                                                                                                                        (121)
            for base in obj.__mro__[:-1]:=================================================(122)     
                # Since '__text_signature__' is implemented as a==========================(123)     
                # descriptor that extracts text signature from the========================(124)     
                # class docstring, if 'obj' is derived from a builtin=====================(125)     
                # class, its own '__text_signature__' may be 'None'.======================(126)     
                # Therefore, we go through the MRO (except the last=======================(127)     
                # class in there, which is 'object') to find the first====================(128)     
                # class with non-empty text signature.====================================(129)     
                try:======================================================================(130)     
                    text_sig = base.__text_signature__====================================(131)     
                except AttributeError:====================================================(132)     
                    pass==================================================================(133)     
                else:=====================================================================(134)     
                    if text_sig:==========================================================(135)     
                        # If 'base' class has a __text_signature__ attribute:=============(136)     
                        # return a signature based on it==================================(137)     
                        return _signature_fromstr(sigcls, base, text_sig)=================(138)     
                                                                                                                                                        (139)
            # No '__text_signature__' was found for the 'obj' class.======================(140)     
            # Last option is to check if its '__init__' is================================(141)     
            # object.__init__ or type.__init__.===========================================(142)     
            if type not in obj.__mro__:===================================================(143)     
                # We have a class (not metaclass), but no user-defined====================(144)     
                # __init__ or __new__ for it==============================================(145)     
                if (obj.__init__ is object.__init__ and===================================(146)     
                    obj.__new__ is object.__new__):=======================================(147)     
                    # Return a signature of 'object' builtin.=============================(148)     
                    return sigcls.from_callable(object)===================================(149)     
                else:=====================================================================(150)     
                    raise ValueError(=====================================================(151)     
                        'no signature found for builtin type {!r}'.format(obj))===========(152)     
                                                                                                                                                        (153)
    elif not isinstance(obj, _NonUserDefinedCallables):===================================(154)     
        # An object with __call__=========================================================(155)     
        # We also check that the 'obj' is not an instance of==============================(156)     
        # _WrapperDescriptor or _MethodWrapper to avoid===================================(157)     
        # infinite recursion (and even potential segfault)================================(158)     
        call = _signature_get_user_defined_method(type(obj), '__call__')==================(159)     
        if call is not None:==============================================================(160)     
            try:==========================================================================(161)     
                sig = _get_signature_of(call)=============================================(162)     
            except ValueError as ex:======================================================(163)     
                msg = 'no signature found for {!r}'.format(obj)===========================(164)     
                raise ValueError(msg) from ex=============================================(165)     
                                                                                                                                                        (166)
    if sig is not None:===================================================================(167)     
        # For classes and objects we skip the first parameter of their====================(168)     
        # __call__, __new__, or __init__ methods==========================================(169)     
        if skip_bound_arg:================================================================(170)     
            return _signature_bound_method(sig)===========================================(171)     
        else:=============================================================================(172)     
            return sig====================================================================(173)     
                                                                                                                                                        (174)
    if isinstance(obj, types.BuiltinFunctionType):========================================(175)     
        # Raise a nicer error message for builtins========================================(176)     
        msg = 'no signature found for builtin function {!r}'.format(obj)==================(177)     
        raise ValueError(msg)=============================================================(178)     
                                                                                                                                                        (179)
    raise ValueError('callable {!r} is not supported by signature'.format(obj))===========(180)     
                                                                                                                                                        (181)</code></pre>
</div>
</div>
</section>
<section id="read-commented-_signature_from_callable-from-python-3.9" class="level3">
<h3 class="anchored" data-anchor-id="read-commented-_signature_from_callable-from-python-3.9">Read commented <code>_signature_from_callable</code> from python 3.9+</h3>
<div class="cell" data-execution_count="25">
<div class="sourceCode cell-code" id="cb44"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a>sig.<span class="bu">print</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>

                                                                                                                    isfunction(obj) =&gt; isfunction(obj) : True


                                                                                    _signature_is_functionlike(obj) =&gt; _signature_is_functionlike(obj) : True


                                                                                                                    isfunction(obj) =&gt; isfunction(obj) : True


                                                                                    _signature_is_functionlike(obj) =&gt; _signature_is_functionlike(obj) : True
def _signature_from_callable(obj, *,======================================================(0)       
                             follow_wrapper_chains=True,==================================(1)       
                             skip_bound_arg=True,=========================================(2)       
                             sigcls):=====================================================(3)       
                                                                                                                                                        (4)
    """Private helper function to get signature for arbitrary=============================(5)       
    callable objects.=====================================================================(6)       
    """===================================================================================(7)       
                                                                                                                                                        (8)
    _get_signature_of = functools.partial(_signature_from_callable,=======================(9) # so that it can use in itself
                                follow_wrapper_chains=follow_wrapper_chains,==============(10)      
                                skip_bound_arg=skip_bound_arg,============================(11)      
                                sigcls=sigcls)============================================(12)      
                                                                                                                                                        (13)
    if not callable(obj):=================================================================(14) # obj must be callable
        raise TypeError('{!r} is not a callable object'.format(obj))======================(15)      
                                                                                                                                                        (16)
    if isinstance(obj, types.MethodType):=================================================(17) # obj can be a classmethod
        # In this case we skip the first parameter of the underlying======================(18)      
        # function (usually `self` or `cls`).=============================================(19)      
        sig = _get_signature_of(obj.__func__)=============================================(20)      
                                                                                                                                                        (21)
        if skip_bound_arg:================================================================(22)      
            return _signature_bound_method(sig)===========================================(23)      
        else:=============================================================================(24)      
            return sig====================================================================(25)      
                                                                                                                                                        (26)
    # Was this function wrapped by a decorator?===========================================(27)      
    if follow_wrapper_chains:=============================================================(28) # does Foo has __signature__?
        obj = unwrap(obj, stop=(lambda f: hasattr(f, "__signature__")))===================(29)      
        if isinstance(obj, types.MethodType):=============================================(30)      
            # If the unwrapped object is a *method*, we might want to=====================(31)      
            # skip its first parameter (self).============================================(32)      
            # See test_signature_wrapped_bound_method for details.========================(33)      
            return _get_signature_of(obj)=================================================(34)      
                                                                                                                                                        (35)
    try:==================================================================================(36)      
        sig = obj.__signature__===========================================================(37) # check __signature__
    except AttributeError:================================================================(38)      
        pass==============================================================================(39)      
    else:=================================================================================(40)      
        if sig is not None:===============================================================(41)      
            if not isinstance(sig, Signature):============================================(42)      
                raise TypeError(==========================================================(43)      
                    'unexpected object {!r} in __signature__ '============================(44)      
                    'attribute'.format(sig))==============================================(45)      
            return sig====================================================================(46)      
                                                                                                                                                        (47)
    try:==================================================================================(48)      
        partialmethod = obj._partialmethod================================================(49)      
    except AttributeError:================================================================(50)      
        pass==============================================================================(51)      
    else:=================================================================================(52)      
        if isinstance(partialmethod, functools.partialmethod):============================(53)      
            # Unbound partialmethod (see functools.partialmethod)=========================(54)      
            # This means, that we need to calculate the signature=========================(55)      
            # as if it's a regular partial object, but taking into========================(56)      
            # account that the first positional argument==================================(57)      
            # (usually `self`, or `cls`) will not be passed===============================(58)      
            # automatically (as for boundmethods)=========================================(59)      
                                                                                                                                                        (60)
            wrapped_sig = _get_signature_of(partialmethod.func)===========================(61)      
                                                                                                                                                        (62)
            sig = _signature_get_partial(wrapped_sig, partialmethod, (None,))=============(63)      
            first_wrapped_param = tuple(wrapped_sig.parameters.values())[0]===============(64)      
            if first_wrapped_param.kind is Parameter.VAR_POSITIONAL:======================(65)      
                # First argument of the wrapped callable is `*args`, as in================(66)      
                # `partialmethod(lambda *args)`.==========================================(67)      
                return sig================================================================(68)      
            else:=========================================================================(69)      
                sig_params = tuple(sig.parameters.values())===============================(70)      
                assert (not sig_params or=================================================(71)      
                        first_wrapped_param is not sig_params[0])=========================(72)      
                new_params = (first_wrapped_param,) + sig_params==========================(73)      
                return sig.replace(parameters=new_params)=================================(74)      
                                                                                                                                                        (75)
    if isfunction(obj) or _signature_is_functionlike(obj):================================(76) # step 7: run on itself will run here
        # If it's a pure Python function, or an object that is duck type==================(77)      
        # of a Python function (Cython functions, for instance), then:====================(78)      
        return _signature_from_function(sigcls, obj,======================================(79) # step 8: get sig with a different func
                                        skip_bound_arg=skip_bound_arg)====================(80)      
                                                                                                                                                        (81)
    if _signature_is_builtin(obj):========================================================(82)      
        return _signature_from_builtin(sigcls, obj,=======================================(83)      
                                       skip_bound_arg=skip_bound_arg)=====================(84)      
                                                                                                                                                        (85)
    if isinstance(obj, functools.partial):================================================(86)      
        wrapped_sig = _get_signature_of(obj.func)=========================================(87)      
        return _signature_get_partial(wrapped_sig, obj)===================================(88)      
                                                                                                                                                        (89)
    sig = None============================================================================(90)      
    if isinstance(obj, type):=============================================================(91) # step 1: obj is a class?
        # obj is a class or a metaclass===================================================(92)      
                                                                                                                                                        (93)
        # First, let's see if it has an overloaded __call__ defined=======================(94)      
        # in its metaclass================================================================(95)      
        call = _signature_get_user_defined_method(type(obj), '__call__')==================(96) # step 2: define its own __call__?
        if call is not None:==============================================================(97)      
            sig = _get_signature_of(call)=================================================(98)      
        else:=============================================================================(99)      
            factory_method = None=========================================================(100)     
            new = _signature_get_user_defined_method(obj, '__new__')======================(101) # step 3: define its own __new__?
            init = _signature_get_user_defined_method(obj, '__init__')====================(102) # step 4: define its own __init__?
            # Now we check if the 'obj' class has an own '__new__' method=================(103)     
            if '__new__' in obj.__dict__:=================================================(104)     
                factory_method = new======================================================(105)     
            # or an own '__init__' method=================================================(106)     
            elif '__init__' in obj.__dict__:==============================================(107)     
                factory_method = init=====================================================(108) # step 5: __init__ is inside obj.__dict__?
            # If not, we take inherited '__new__' or '__init__', if present===============(109)     
            elif new is not None:=========================================================(110)     
                factory_method = new======================================================(111)     
            elif init is not None:========================================================(112)     
                factory_method = init=====================================================(113)     
                                                                                                                                                        (114)
            if factory_method is not None:================================================(115)     
                sig = _get_signature_of(factory_method)===================================(116) # step 6: run on itself using functools.partial
                                                                                                                                                        (117)
        if sig is None:===================================================================(118)     
            # At this point we know, that `obj` is a class, with no user-=================(119)     
            # defined '__init__', '__new__', or class-level '__call__'====================(120)     
                                                                                                                                                        (121)
            for base in obj.__mro__[:-1]:=================================================(122)     
                # Since '__text_signature__' is implemented as a==========================(123)     
                # descriptor that extracts text signature from the========================(124)     
                # class docstring, if 'obj' is derived from a builtin=====================(125)     
                # class, its own '__text_signature__' may be 'None'.======================(126)     
                # Therefore, we go through the MRO (except the last=======================(127)     
                # class in there, which is 'object') to find the first====================(128)     
                # class with non-empty text signature.====================================(129)     
                try:======================================================================(130)     
                    text_sig = base.__text_signature__====================================(131)     
                except AttributeError:====================================================(132)     
                    pass==================================================================(133)     
                else:=====================================================================(134)     
                    if text_sig:==========================================================(135)     
                        # If 'base' class has a __text_signature__ attribute:=============(136)     
                        # return a signature based on it==================================(137)     
                        return _signature_fromstr(sigcls, base, text_sig)=================(138)     
                                                                                                                                                        (139)
            # No '__text_signature__' was found for the 'obj' class.======================(140)     
            # Last option is to check if its '__init__' is================================(141)     
            # object.__init__ or type.__init__.===========================================(142)     
            if type not in obj.__mro__:===================================================(143)     
                # We have a class (not metaclass), but no user-defined====================(144)     
                # __init__ or __new__ for it==============================================(145)     
                if (obj.__init__ is object.__init__ and===================================(146)     
                    obj.__new__ is object.__new__):=======================================(147)     
                    # Return a signature of 'object' builtin.=============================(148)     
                    return sigcls.from_callable(object)===================================(149)     
                else:=====================================================================(150)     
                    raise ValueError(=====================================================(151)     
                        'no signature found for builtin type {!r}'.format(obj))===========(152)     
                                                                                                                                                        (153)
    elif not isinstance(obj, _NonUserDefinedCallables):===================================(154)     
        # An object with __call__=========================================================(155)     
        # We also check that the 'obj' is not an instance of==============================(156)     
        # _WrapperDescriptor or _MethodWrapper to avoid===================================(157)     
        # infinite recursion (and even potential segfault)================================(158)     
        call = _signature_get_user_defined_method(type(obj), '__call__')==================(159)     
        if call is not None:==============================================================(160)     
            try:==========================================================================(161)     
                sig = _get_signature_of(call)=============================================(162)     
            except ValueError as ex:======================================================(163)     
                msg = 'no signature found for {!r}'.format(obj)===========================(164)     
                raise ValueError(msg) from ex=============================================(165)     
                                                                                                                                                        (166)
    if sig is not None:===================================================================(167)     
        # For classes and objects we skip the first parameter of their====================(168)     
        # __call__, __new__, or __init__ methods==========================================(169)     
        if skip_bound_arg:================================================================(170)     
            return _signature_bound_method(sig)===========================================(171)     
        else:=============================================================================(172)     
            return sig====================================================================(173)     
                                                                                                                                                        (174)
    if isinstance(obj, types.BuiltinFunctionType):========================================(175)     
        # Raise a nicer error message for builtins========================================(176)     
        msg = 'no signature found for builtin function {!r}'.format(obj)==================(177)     
        raise ValueError(msg)=============================================================(178)     
                                                                                                                                                        (179)
    raise ValueError('callable {!r} is not supported by signature'.format(obj))===========(180)     
                                                                                                                                                        (181)</code></pre>
</div>
</div>
</section>
</section>
<section id="foos-super-class-overriding-__new__-can-stop-foo-getting-sig-from-__init__" class="level2">
<h2 class="anchored" data-anchor-id="foos-super-class-overriding-__new__-can-stop-foo-getting-sig-from-__init__">Foo’s super class overriding <code>__new__</code> can stop Foo getting sig from <code>__init__</code></h2>
<p>Many things can go wrong to prevent a class to use the signature from <code>__init__</code>.</p>
<p>FixSigMeta is a metaclass, which helps us to get our classes’ signature right.</p>
<p>Then what types of the signature problems can FixSigMeta fix?</p>
<section id="when-foos-super-class-override-__new__-python3.7-cant-give-foo-sig-from-__init__" class="level3">
<h3 class="anchored" data-anchor-id="when-foos-super-class-override-__new__-python3.7-cant-give-foo-sig-from-__init__">When Foo’s super class override <code>__new__</code>, python3.7 can’t give Foo sig from <code>__init__</code></h3>
<ol type="1">
<li>when your class Foo inherits from class Base, if Base defines its <code>__new__</code>, then Foo can’t get signature from <code>__init__</code>. (True for python 3.7 see <a href="https://www.kaggle.com/code/danielliao/notebook3edc928f49?scriptVersionId=104385507&amp;cellId=1">demos</a>, no more for 3.9+)</li>
</ol>
<div class="cell" data-execution_count="26">
<div class="sourceCode cell-code" id="cb46"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Base: <span class="co"># pass</span></span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__new__</span>(<span class="va">self</span>, <span class="op">**</span>args): <span class="cf">pass</span>  <span class="co"># defines a __new__ </span></span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-4"><a href="#cb46-4" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Foo(Base):</span>
<span id="cb46-5"><a href="#cb46-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, d, e, f): <span class="cf">pass</span></span>
<span id="cb46-6"><a href="#cb46-6" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb46-7"><a href="#cb46-7" aria-hidden="true" tabindex="-1"></a>inspect._signature_from_callable <span class="op">=</span> sig.orisrc</span>
<span id="cb46-8"><a href="#cb46-8" aria-hidden="true" tabindex="-1"></a>inspect.signature(Foo) <span class="co"># no more problem for python 3.9+,</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>

                                                                                                                    isfunction(obj) =&gt; isfunction(obj) : True


                                                                                    _signature_is_functionlike(obj) =&gt; _signature_is_functionlike(obj) : True


                                                                                                                    isfunction(obj) =&gt; isfunction(obj) : True


                                                                                    _signature_is_functionlike(obj) =&gt; _signature_is_functionlike(obj) : True</code></pre>
</div>
<div class="cell-output cell-output-display" data-execution_count="26">
<pre><code>&lt;Signature (d, e, f)&gt;</code></pre>
</div>
</div>
<div class="cell" data-execution_count="27">
<div class="sourceCode cell-code" id="cb49"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> IPython.display <span class="im">import</span> IFrame</span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a>IFrame(src<span class="op">=</span><span class="st">"https://www.kaggle.com/embed/danielliao/notebook3edc928f49?cellIds=2&amp;kernelSessionId=104407182"</span>, width <span class="op">=</span> <span class="st">"1200"</span>, height<span class="op">=</span><span class="st">"300"</span>, <span class="op">\</span></span>
<span id="cb49-4"><a href="#cb49-4" aria-hidden="true" tabindex="-1"></a>       style<span class="op">=</span><span class="st">"margin: 0 auto; width: 100%; max-width: 950px;"</span>, frameborder<span class="op">=</span><span class="st">"0"</span>, scrolling<span class="op">=</span><span class="st">"auto"</span>, title<span class="op">=</span><span class="st">"notebook3edc928f49"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="27">

        <iframe width="1200" height="300" src="https://www.kaggle.com/embed/danielliao/notebook3edc928f49?cellIds=2&amp;kernelSessionId=104407182?style=margin%3A+0+auto%3B+width%3A+100%25%3B+max-width%3A+950px%3B&amp;frameborder=0&amp;scrolling=auto&amp;title=notebook3edc928f49" frameborder="0" allowfullscreen=""></iframe>
        
</div>
</div>
<div class="cell" data-execution_count="28">
<div class="sourceCode cell-code" id="cb50"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a>inspect._signature_from_callable <span class="op">=</span> _signature_from_callableOld</span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a>inspect.signature(Foo) <span class="co"># it is a problem for python 3.7,</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="28">
<pre><code>&lt;Signature (**args)&gt;</code></pre>
</div>
</div>
</section>
<section id="how-python3.7-and-its-inspect-mess-it-up" class="level3">
<h3 class="anchored" data-anchor-id="how-python3.7-and-its-inspect-mess-it-up">How python3.7 and its inspect mess it up</h3>
<div class="cell" data-execution_count="29">
<div class="sourceCode cell-code" id="cb52"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a>g <span class="op">=</span> <span class="bu">globals</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="30">
<div class="sourceCode cell-code" id="cb53"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a>sigOld <span class="op">=</span> Fastdb(_signature_from_callableOld, g)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="31">
<div class="sourceCode cell-code" id="cb54"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a>sigOld.dbprint(<span class="dv">115</span>, <span class="st">"messup step 1: overriding __new__ is detected"</span>, <span class="st">"new = _signature_get_user_defined_method(obj, '__new__')"</span>)</span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a>inspect._signature_from_callable <span class="op">=</span> _signature_from_callableOld</span>
<span id="cb54-3"><a href="#cb54-3" aria-hidden="true" tabindex="-1"></a>inspect.signature(Foo) <span class="co"># it is a problem for python 3.7, </span></span>
<span id="cb54-4"><a href="#cb54-4" aria-hidden="true" tabindex="-1"></a>sigOld.<span class="bu">print</span>(part<span class="op">=</span><span class="dv">4</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>        else:                                                                                                                                           (113)
            # Now we check if the 'obj' class has a '__new__' method                                                                                    (114)
            new = _signature_get_user_defined_method(obj, '__new__')====================================================================================(115)
                                                                                                                messup step 1: overriding __new__ is detected
            if new is not None:                                                                                                                         (116)
                sig = _signature_from_callable(                                                                                                         (117)


                                                      new = _signature_get_user_defined_method(obj, '__new__') =&gt; new: &lt;function Base.__new__ at 0x105cca160&gt;
                                                                                                                                                        (99)
    sig = None============================================================================(100)     
    if isinstance(obj, type):=============================================================(101)     
        # obj is a class or a metaclass===================================================(102)     
                                                                                                                                                        (103)
        # First, let's see if it has an overloaded __call__ defined=======================(104)     
        # in its metaclass================================================================(105)     
        call = _signature_get_user_defined_method(type(obj), '__call__')==================(106)     
        if call is not None:==============================================================(107)     
            sig = _signature_from_callable(===============================================(108)     
                call,=====================================================================(109)     
                follow_wrapper_chains=follow_wrapper_chains,==============================(110)     
                skip_bound_arg=skip_bound_arg,============================================(111)     
                sigcls=sigcls)============================================================(112)     
        else:=============================================================================(113)     
            # Now we check if the 'obj' class has a '__new__' method======================(114)     
            new = _signature_get_user_defined_method(obj, '__new__')======================(115) # messup step 1: overriding __new__ is detected
            if new is not None:===========================================================(116)     
                sig = _signature_from_callable(===========================================(117)     
                    new,==================================================================(118)     
                    follow_wrapper_chains=follow_wrapper_chains,==========================(119)     
                    skip_bound_arg=skip_bound_arg,========================================(120)     
                    sigcls=sigcls)========================================================(121)     
            else:=========================================================================(122)     
                # Finally, we should have at least __init__ implemented===================(123)     
                init = _signature_get_user_defined_method(obj, '__init__')================(124)     
                if init is not None:======================================================(125)     
                    sig = _signature_from_callable(=======================================(126)     
                        init,=============================================================(127)     
                        follow_wrapper_chains=follow_wrapper_chains,======================(128)     
                        skip_bound_arg=skip_bound_arg,====================================(129)     
                        sigcls=sigcls)====================================================(130)     
                                                                                                                                                        (131)
                                                                                                                                     part No.4 out of 7 parts</code></pre>
</div>
</div>
<div class="cell" data-execution_count="32">
<div class="sourceCode cell-code" id="cb56"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a>sigOld.dbprint(<span class="dv">117</span>, <span class="st">"messup step 2: only __new__ sig is extracted"</span>, <span class="st">"locals()"</span>)</span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a>inspect._signature_from_callable <span class="op">=</span> _signature_from_callableOld</span>
<span id="cb56-3"><a href="#cb56-3" aria-hidden="true" tabindex="-1"></a>inspect.signature(Foo) <span class="co"># it is a problem for python 3.7, </span></span>
<span id="cb56-4"><a href="#cb56-4" aria-hidden="true" tabindex="-1"></a>sigOld.<span class="bu">print</span>(part<span class="op">=</span><span class="dv">4</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>            new = _signature_get_user_defined_method(obj, '__new__')                                                                                    (115)
            if new is not None:                                                                                                                         (116)
                sig = _signature_from_callable(=========================================================================================================(117)
                                                                                                                 messup step 2: only __new__ sig is extracted
                    new,                                                                                                                                (118)
                    follow_wrapper_chains=follow_wrapper_chains,                                                                                        (119)


locals() =&gt; locals() : {'env': {'obj': &lt;class '__main__.Foo'&gt;, 'follow_wrapper_chains': True, 'skip_bound_arg': True, 'sigcls': &lt;class 'inspect.Signature'&gt;, 'sig': None, 'call': None, 'new': &lt;function Base.__new__ at 0x105cca160&gt;}, 'codes': ('locals()',), 'c': 'locals()'}
                                                                                                                                                        (99)
    sig = None============================================================================(100)     
    if isinstance(obj, type):=============================================================(101)     
        # obj is a class or a metaclass===================================================(102)     
                                                                                                                                                        (103)
        # First, let's see if it has an overloaded __call__ defined=======================(104)     
        # in its metaclass================================================================(105)     
        call = _signature_get_user_defined_method(type(obj), '__call__')==================(106)     
        if call is not None:==============================================================(107)     
            sig = _signature_from_callable(===============================================(108)     
                call,=====================================================================(109)     
                follow_wrapper_chains=follow_wrapper_chains,==============================(110)     
                skip_bound_arg=skip_bound_arg,============================================(111)     
                sigcls=sigcls)============================================================(112)     
        else:=============================================================================(113)     
            # Now we check if the 'obj' class has a '__new__' method======================(114)     
            new = _signature_get_user_defined_method(obj, '__new__')======================(115) # messup step 1: overriding __new__ is detected
            if new is not None:===========================================================(116)     
                sig = _signature_from_callable(===========================================(117) # messup step 2: only __new__ sig is extracted
                    new,==================================================================(118)     
                    follow_wrapper_chains=follow_wrapper_chains,==========================(119)     
                    skip_bound_arg=skip_bound_arg,========================================(120)     
                    sigcls=sigcls)========================================================(121)     
            else:=========================================================================(122)     
                # Finally, we should have at least __init__ implemented===================(123)     
                init = _signature_get_user_defined_method(obj, '__init__')================(124)     
                if init is not None:======================================================(125)     
                    sig = _signature_from_callable(=======================================(126)     
                        init,=============================================================(127)     
                        follow_wrapper_chains=follow_wrapper_chains,======================(128)     
                        skip_bound_arg=skip_bound_arg,====================================(129)     
                        sigcls=sigcls)====================================================(130)     
                                                                                                                                                        (131)
                                                                                                                                     part No.4 out of 7 parts</code></pre>
</div>
</div>
<div class="cell" data-execution_count="33">
<div class="sourceCode cell-code" id="cb58"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a>sigOld.dbprint(<span class="dv">124</span>, <span class="st">"messup step 3: __init__ don't even get accessed"</span>)</span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a>sigOld.<span class="bu">print</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>            else:                                                                                                                                       (122)
                # Finally, we should have at least __init__ implemented                                                                                 (123)
                init = _signature_get_user_defined_method(obj, '__init__')==============================================================================(124)
                                                                                                              messup step 3: __init__ don't even get accessed
                if init is not None:                                                                                                                    (125)
                    sig = _signature_from_callable(                                                                                                     (126)
def _signature_from_callableOld(obj, *,===================================================(0)       
                             follow_wrapper_chains=True,==================================(1)       
                             skip_bound_arg=True,=========================================(2)       
                             sigcls):=====================================================(3)       
                                                                                                                                                        (4)
    """Private helper function to get signature for arbitrary=============================(5)       
    callable objects.=====================================================================(6)       
    """===================================================================================(7)       
                                                                                                                                                        (8)
    if not callable(obj):=================================================================(9)       
        raise TypeError('{!r} is not a callable object'.format(obj))======================(10)      
                                                                                                                                                        (11)
    if isinstance(obj, types.MethodType):=================================================(12)      
        # In this case we skip the first parameter of the underlying======================(13)      
        # function (usually `self` or `cls`).=============================================(14)      
        sig = _signature_from_callable(===================================================(15)      
            obj.__func__,=================================================================(16)      
            follow_wrapper_chains=follow_wrapper_chains,==================================(17)      
            skip_bound_arg=skip_bound_arg,================================================(18)      
            sigcls=sigcls)================================================================(19)      
                                                                                                                                                        (20)
        if skip_bound_arg:================================================================(21)      
            return _signature_bound_method(sig)===========================================(22)      
        else:=============================================================================(23)      
            return sig====================================================================(24)      
                                                                                                                                                        (25)
    # Was this function wrapped by a decorator?===========================================(26)      
    if follow_wrapper_chains:=============================================================(27)      
        obj = unwrap(obj, stop=(lambda f: hasattr(f, "__signature__")))===================(28)      
        if isinstance(obj, types.MethodType):=============================================(29)      
            # If the unwrapped object is a *method*, we might want to=====================(30)      
            # skip its first parameter (self).============================================(31)      
            # See test_signature_wrapped_bound_method for details.========================(32)      
            return _signature_from_callable(==============================================(33)      
                obj,======================================================================(34)      
                follow_wrapper_chains=follow_wrapper_chains,==============================(35)      
                skip_bound_arg=skip_bound_arg,============================================(36)      
                sigcls=sigcls)============================================================(37)      
                                                                                                                                                        (38)
    try:==================================================================================(39)      
        sig = obj.__signature__===========================================================(40)      
    except AttributeError:================================================================(41)      
        pass==============================================================================(42)      
    else:=================================================================================(43)      
        if sig is not None:===============================================================(44)      
            if not isinstance(sig, Signature):============================================(45)      
                raise TypeError(==========================================================(46)      
                    'unexpected object {!r} in __signature__ '============================(47)      
                    'attribute'.format(sig))==============================================(48)      
            return sig====================================================================(49)      
                                                                                                                                                        (50)
    try:==================================================================================(51)      
        partialmethod = obj._partialmethod================================================(52)      
    except AttributeError:================================================================(53)      
        pass==============================================================================(54)      
    else:=================================================================================(55)      
        if isinstance(partialmethod, functools.partialmethod):============================(56)      
            # Unbound partialmethod (see functools.partialmethod)=========================(57)      
            # This means, that we need to calculate the signature=========================(58)      
            # as if it's a regular partial object, but taking into========================(59)      
            # account that the first positional argument==================================(60)      
            # (usually `self`, or `cls`) will not be passed===============================(61)      
            # automatically (as for boundmethods)=========================================(62)      
                                                                                                                                                        (63)
            wrapped_sig = _signature_from_callable(=======================================(64)      
                partialmethod.func,=======================================================(65)      
                follow_wrapper_chains=follow_wrapper_chains,==============================(66)      
                skip_bound_arg=skip_bound_arg,============================================(67)      
                sigcls=sigcls)============================================================(68)      
                                                                                                                                                        (69)
            sig = _signature_get_partial(wrapped_sig, partialmethod, (None,))=============(70)      
            first_wrapped_param = tuple(wrapped_sig.parameters.values())[0]===============(71)      
            if first_wrapped_param.kind is Parameter.VAR_POSITIONAL:======================(72)      
                # First argument of the wrapped callable is `*args`, as in================(73)      
                # `partialmethod(lambda *args)`.==========================================(74)      
                return sig================================================================(75)      
            else:=========================================================================(76)      
                sig_params = tuple(sig.parameters.values())===============================(77)      
                assert (not sig_params or=================================================(78)      
                        first_wrapped_param is not sig_params[0])=========================(79)      
                new_params = (first_wrapped_param,) + sig_params==========================(80)      
                return sig.replace(parameters=new_params)=================================(81)      
                                                                                                                                                        (82)
    if isfunction(obj) or _signature_is_functionlike(obj):================================(83)      
        # If it's a pure Python function, or an object that is duck type==================(84)      
        # of a Python function (Cython functions, for instance), then:====================(85)      
        return _signature_from_function(sigcls, obj)======================================(86)      
                                                                                                                                                        (87)
    if _signature_is_builtin(obj):========================================================(88)      
        return _signature_from_builtin(sigcls, obj,=======================================(89)      
                                       skip_bound_arg=skip_bound_arg)=====================(90)      
                                                                                                                                                        (91)
    if isinstance(obj, functools.partial):================================================(92)      
        wrapped_sig = _signature_from_callable(===========================================(93)      
            obj.func,=====================================================================(94)      
            follow_wrapper_chains=follow_wrapper_chains,==================================(95)      
            skip_bound_arg=skip_bound_arg,================================================(96)      
            sigcls=sigcls)================================================================(97)      
        return _signature_get_partial(wrapped_sig, obj)===================================(98)      
                                                                                                                                                        (99)
    sig = None============================================================================(100)     
    if isinstance(obj, type):=============================================================(101)     
        # obj is a class or a metaclass===================================================(102)     
                                                                                                                                                        (103)
        # First, let's see if it has an overloaded __call__ defined=======================(104)     
        # in its metaclass================================================================(105)     
        call = _signature_get_user_defined_method(type(obj), '__call__')==================(106)     
        if call is not None:==============================================================(107)     
            sig = _signature_from_callable(===============================================(108)     
                call,=====================================================================(109)     
                follow_wrapper_chains=follow_wrapper_chains,==============================(110)     
                skip_bound_arg=skip_bound_arg,============================================(111)     
                sigcls=sigcls)============================================================(112)     
        else:=============================================================================(113)     
            # Now we check if the 'obj' class has a '__new__' method======================(114)     
            new = _signature_get_user_defined_method(obj, '__new__')======================(115) # messup step 1: overriding __new__ is detected
            if new is not None:===========================================================(116)     
                sig = _signature_from_callable(===========================================(117) # messup step 2: only __new__ sig is extracted
                    new,==================================================================(118)     
                    follow_wrapper_chains=follow_wrapper_chains,==========================(119)     
                    skip_bound_arg=skip_bound_arg,========================================(120)     
                    sigcls=sigcls)========================================================(121)     
            else:=========================================================================(122)     
                # Finally, we should have at least __init__ implemented===================(123)     
                init = _signature_get_user_defined_method(obj, '__init__')================(124) # messup step 3: __init__ don't even get accessed
                if init is not None:======================================================(125)     
                    sig = _signature_from_callable(=======================================(126)     
                        init,=============================================================(127)     
                        follow_wrapper_chains=follow_wrapper_chains,======================(128)     
                        skip_bound_arg=skip_bound_arg,====================================(129)     
                        sigcls=sigcls)====================================================(130)     
                                                                                                                                                        (131)
        if sig is None:===================================================================(132)     
            # At this point we know, that `obj` is a class, with no user-=================(133)     
            # defined '__init__', '__new__', or class-level '__call__'====================(134)     
                                                                                                                                                        (135)
            for base in obj.__mro__[:-1]:=================================================(136)     
                # Since '__text_signature__' is implemented as a==========================(137)     
                # descriptor that extracts text signature from the========================(138)     
                # class docstring, if 'obj' is derived from a builtin=====================(139)     
                # class, its own '__text_signature__' may be 'None'.======================(140)     
                # Therefore, we go through the MRO (except the last=======================(141)     
                # class in there, which is 'object') to find the first====================(142)     
                # class with non-empty text signature.====================================(143)     
                try:======================================================================(144)     
                    text_sig = base.__text_signature__====================================(145)     
                except AttributeError:====================================================(146)     
                    pass==================================================================(147)     
                else:=====================================================================(148)     
                    if text_sig:==========================================================(149)     
                        # If 'obj' class has a __text_signature__ attribute:==============(150)     
                        # return a signature based on it==================================(151)     
                        return _signature_fromstr(sigcls, obj, text_sig)==================(152)     
                                                                                                                                                        (153)
            # No '__text_signature__' was found for the 'obj' class.======================(154)     
            # Last option is to check if its '__init__' is================================(155)     
            # object.__init__ or type.__init__.===========================================(156)     
            if type not in obj.__mro__:===================================================(157)     
                # We have a class (not metaclass), but no user-defined====================(158)     
                # __init__ or __new__ for it==============================================(159)     
                if (obj.__init__ is object.__init__ and===================================(160)     
                    obj.__new__ is object.__new__):=======================================(161)     
                    # Return a signature of 'object' builtin.=============================(162)     
                    return sigcls.from_callable(object)===================================(163)     
                else:=====================================================================(164)     
                    raise ValueError(=====================================================(165)     
                        'no signature found for builtin type {!r}'.format(obj))===========(166)     
                                                                                                                                                        (167)
    elif not isinstance(obj, _NonUserDefinedCallables):===================================(168)     
        # An object with __call__=========================================================(169)     
        # We also check that the 'obj' is not an instance of==============================(170)     
        # _WrapperDescriptor or _MethodWrapper to avoid===================================(171)     
        # infinite recursion (and even potential segfault)================================(172)     
        call = _signature_get_user_defined_method(type(obj), '__call__')==================(173)     
        if call is not None:==============================================================(174)     
            try:==========================================================================(175)     
                sig = _signature_from_callable(===========================================(176)     
                    call,=================================================================(177)     
                    follow_wrapper_chains=follow_wrapper_chains,==========================(178)     
                    skip_bound_arg=skip_bound_arg,========================================(179)     
                    sigcls=sigcls)========================================================(180)     
            except ValueError as ex:======================================================(181)     
                msg = 'no signature found for {!r}'.format(obj)===========================(182)     
                raise ValueError(msg) from ex=============================================(183)     
                                                                                                                                                        (184)
    if sig is not None:===================================================================(185)     
        # For classes and objects we skip the first parameter of their====================(186)     
        # __call__, __new__, or __init__ methods==========================================(187)     
        if skip_bound_arg:================================================================(188)     
            return _signature_bound_method(sig)===========================================(189)     
        else:=============================================================================(190)     
            return sig====================================================================(191)     
                                                                                                                                                        (192)
    if isinstance(obj, types.BuiltinFunctionType):========================================(193)     
        # Raise a nicer error message for builtins========================================(194)     
        msg = 'no signature found for builtin function {!r}'.format(obj)==================(195)     
        raise ValueError(msg)=============================================================(196)     
                                                                                                                                                        (197)
    raise ValueError('callable {!r} is not supported by signature'.format(obj))===========(198)     
                                                                                                                                                        (199)</code></pre>
</div>
</div>
</section>
<section id="fixsigmeta-can-fix-it-for-python-3.7-inspect" class="level3">
<h3 class="anchored" data-anchor-id="fixsigmeta-can-fix-it-for-python-3.7-inspect">FixSigMeta can fix it for python 3.7 inspect</h3>
<div class="cell" data-execution_count="34">
<div class="sourceCode cell-code" id="cb60"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a>inspect._signature_from_callable <span class="op">=</span> _signature_from_callableNew</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Solution to 1: By also inheriting from the metaclass FixSigMeta can solve the signature problem for Foo (for python 3.7)</p>
<div class="cell" data-execution_count="35">
<div class="sourceCode cell-code" id="cb61"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> fastcore.meta <span class="im">import</span> FixSigMeta, test_sig</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="36">
<div class="sourceCode cell-code" id="cb62"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Base: <span class="co"># pass</span></span>
<span id="cb62-2"><a href="#cb62-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__new__</span>(<span class="va">self</span>, <span class="op">**</span>args): <span class="cf">pass</span>  <span class="co"># defines a __new__ </span></span>
<span id="cb62-3"><a href="#cb62-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-4"><a href="#cb62-4" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Foo(Base, metaclass<span class="op">=</span>FixSigMeta):</span>
<span id="cb62-5"><a href="#cb62-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, d, e, f): <span class="cf">pass</span></span>
<span id="cb62-6"><a href="#cb62-6" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb62-7"><a href="#cb62-7" aria-hidden="true" tabindex="-1"></a>test_sig(Foo, <span class="st">'(d, e, f)'</span>)</span>
<span id="cb62-8"><a href="#cb62-8" aria-hidden="true" tabindex="-1"></a>inspect.signature(Foo)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="36">
<pre><code>&lt;Signature (d, e, f)&gt;</code></pre>
</div>
</div>
<div class="cell" data-execution_count="37">
<div class="sourceCode cell-code" id="cb64"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a>IFrame(src<span class="op">=</span><span class="st">"https://www.kaggle.com/embed/danielliao/notebook3edc928f49?cellIds=4&amp;kernelSessionId=104407182"</span>, width <span class="op">=</span> <span class="st">"1200"</span>, height<span class="op">=</span><span class="st">"300"</span>, <span class="op">\</span></span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true" tabindex="-1"></a>       style<span class="op">=</span><span class="st">"margin: 0 auto; width: 100%; max-width: 950px;"</span>, frameborder<span class="op">=</span><span class="st">"0"</span>, scrolling<span class="op">=</span><span class="st">"auto"</span>, title<span class="op">=</span><span class="st">"notebook3edc928f49"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="37">

        <iframe width="1200" height="300" src="https://www.kaggle.com/embed/danielliao/notebook3edc928f49?cellIds=4&amp;kernelSessionId=104407182?style=margin%3A+0+auto%3B+width%3A+100%25%3B+max-width%3A+950px%3B&amp;frameborder=0&amp;scrolling=auto&amp;title=notebook3edc928f49" frameborder="0" allowfullscreen=""></iframe>
        
</div>
</div>
<div class="cell" data-execution_count="38">
<div class="sourceCode cell-code" id="cb65"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a>inspect._signature_from_callable <span class="op">=</span> _signature_from_callableOld</span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true" tabindex="-1"></a>inspect.signature(Foo) <span class="co"># it is a problem for python 3.7,</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="38">
<pre><code>&lt;Signature (d, e, f)&gt;</code></pre>
</div>
</div>
</section>
<section id="how-fixsigmeta-fix-it" class="level3">
<h3 class="anchored" data-anchor-id="how-fixsigmeta-fix-it">How FixSigMeta fix it?</h3>
<div class="cell" data-execution_count="39">
<div class="sourceCode cell-code" id="cb67"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a>FixSigMeta??</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div class="ansi-escaped-output">
<pre><span class="ansi-red-fg">Init signature:</span> FixSigMeta<span class="ansi-blue-fg">(</span>name<span class="ansi-blue-fg">,</span> bases<span class="ansi-blue-fg">,</span> dict<span class="ansi-blue-fg">)</span>
<span class="ansi-red-fg">Source:</span>        
<span class="ansi-green-fg">class</span> FixSigMeta<span class="ansi-blue-fg">(</span>type<span class="ansi-blue-fg">)</span><span class="ansi-blue-fg">:</span>
    <span class="ansi-blue-fg">"A metaclass that fixes the signature on classes that override `__new__`"</span>
    <span class="ansi-green-fg">def</span> __new__<span class="ansi-blue-fg">(</span>cls<span class="ansi-blue-fg">,</span> name<span class="ansi-blue-fg">,</span> bases<span class="ansi-blue-fg">,</span> dict<span class="ansi-blue-fg">)</span><span class="ansi-blue-fg">:</span>
        res <span class="ansi-blue-fg">=</span> super<span class="ansi-blue-fg">(</span><span class="ansi-blue-fg">)</span><span class="ansi-blue-fg">.</span>__new__<span class="ansi-blue-fg">(</span>cls<span class="ansi-blue-fg">,</span> name<span class="ansi-blue-fg">,</span> bases<span class="ansi-blue-fg">,</span> dict<span class="ansi-blue-fg">)</span>
        <span class="ansi-green-fg">if</span> res<span class="ansi-blue-fg">.</span>__init__ <span class="ansi-green-fg">is</span> <span class="ansi-green-fg">not</span> object<span class="ansi-blue-fg">.</span>__init__<span class="ansi-blue-fg">:</span> res<span class="ansi-blue-fg">.</span>__signature__ <span class="ansi-blue-fg">=</span> _rm_self<span class="ansi-blue-fg">(</span>inspect<span class="ansi-blue-fg">.</span>signature<span class="ansi-blue-fg">(</span>res<span class="ansi-blue-fg">.</span>__init__<span class="ansi-blue-fg">)</span><span class="ansi-blue-fg">)</span>
        <span class="ansi-green-fg">return</span> res
<span class="ansi-red-fg">File:</span>           ~/mambaforge/lib/python3.9/site-packages/fastcore/meta.py
<span class="ansi-red-fg">Type:</span>           type
<span class="ansi-red-fg">Subclasses:</span>     PrePostInitMeta, NewChkMeta, BypassNewMeta
</pre>
</div>
</div>
</div>
<div class="cell" data-execution_count="40">
<div class="sourceCode cell-code" id="cb68"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Base: <span class="co"># pass</span></span>
<span id="cb68-2"><a href="#cb68-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__new__</span>(<span class="va">self</span>, <span class="op">**</span>args): <span class="cf">pass</span>  <span class="co"># defines a __new__ </span></span>
<span id="cb68-3"><a href="#cb68-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-4"><a href="#cb68-4" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Foo(Base):</span>
<span id="cb68-5"><a href="#cb68-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, d, e, f): <span class="cf">pass</span></span>
<span id="cb68-6"><a href="#cb68-6" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb68-7"><a href="#cb68-7" aria-hidden="true" tabindex="-1"></a>inspect._signature_from_callable <span class="op">=</span> sigOld.orisrc</span>
<span id="cb68-8"><a href="#cb68-8" aria-hidden="true" tabindex="-1"></a>inspect.signature(Foo)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="40">
<pre><code>&lt;Signature (**args)&gt;</code></pre>
</div>
</div>
<div class="cell" data-execution_count="41">
<div class="sourceCode cell-code" id="cb70"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb70-1"><a href="#cb70-1" aria-hidden="true" tabindex="-1"></a><span class="bu">hasattr</span>(Foo, <span class="st">'__signature__'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="41">
<pre><code>False</code></pre>
</div>
</div>
<div class="cell" data-execution_count="42">
<div class="sourceCode cell-code" id="cb72"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb72-1"><a href="#cb72-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Base: <span class="co"># pass</span></span>
<span id="cb72-2"><a href="#cb72-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__new__</span>(<span class="va">self</span>, <span class="op">**</span>args): <span class="cf">pass</span>  <span class="co"># defines a __new__ </span></span>
<span id="cb72-3"><a href="#cb72-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb72-4"><a href="#cb72-4" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Foo(Base, metaclass<span class="op">=</span>FixSigMeta):</span>
<span id="cb72-5"><a href="#cb72-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, d, e, f): <span class="cf">pass</span></span>
<span id="cb72-6"><a href="#cb72-6" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb72-7"><a href="#cb72-7" aria-hidden="true" tabindex="-1"></a>test_sig(Foo, <span class="st">'(d, e, f)'</span>)</span>
<span id="cb72-8"><a href="#cb72-8" aria-hidden="true" tabindex="-1"></a>inspect.signature(Foo)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="42">
<pre><code>&lt;Signature (d, e, f)&gt;</code></pre>
</div>
</div>
<div class="cell" data-execution_count="43">
<div class="sourceCode cell-code" id="cb74"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb74-1"><a href="#cb74-1" aria-hidden="true" tabindex="-1"></a>Foo.__signature__</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="43">
<pre><code>&lt;Signature (d, e, f)&gt;</code></pre>
</div>
</div>
<div class="cell" data-execution_count="44">
<div class="sourceCode cell-code" id="cb76"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb76-1"><a href="#cb76-1" aria-hidden="true" tabindex="-1"></a>sigOld.cmts</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="44">
<pre><code>{115: 'messup step 1: overriding __new__ is detected',
 117: 'messup step 2: only __new__ sig is extracted',
 124: "messup step 3: __init__ don't even get accessed"}</code></pre>
</div>
</div>
<div class="cell" data-execution_count="45">
<div class="sourceCode cell-code" id="cb78"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb78-1"><a href="#cb78-1" aria-hidden="true" tabindex="-1"></a>unwrap(Foo, stop<span class="op">=</span>(<span class="kw">lambda</span> f: <span class="bu">hasattr</span>(f, <span class="st">'__signature__'</span>))) <span class="op">==</span> Foo</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="45">
<pre><code>True</code></pre>
</div>
</div>
<div class="cell" data-execution_count="46">
<div class="sourceCode cell-code" id="cb80"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb80-1"><a href="#cb80-1" aria-hidden="true" tabindex="-1"></a>Foo.__signature__</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="46">
<pre><code>&lt;Signature (d, e, f)&gt;</code></pre>
</div>
</div>
<div class="cell" data-execution_count="47">
<div class="sourceCode cell-code" id="cb82"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb82-1"><a href="#cb82-1" aria-hidden="true" tabindex="-1"></a>sigOld.dbprint(<span class="dv">27</span>, <span class="st">"FixSigMeta step 1: does it have __signature__"</span>, <span class="st">"env"</span>, <span class="st">"hasattr(obj, '__signature__')"</span>, <span class="op">\</span></span>
<span id="cb82-2"><a href="#cb82-2" aria-hidden="true" tabindex="-1"></a>               <span class="st">"obj = unwrap(obj, stop=(lambda f: hasattr(f, '__signature__')))"</span>, <span class="st">"inspect.getdoc(unwrap)"</span>)</span>
<span id="cb82-3"><a href="#cb82-3" aria-hidden="true" tabindex="-1"></a>inspect._signature_from_callable <span class="op">=</span> _signature_from_callableOld</span>
<span id="cb82-4"><a href="#cb82-4" aria-hidden="true" tabindex="-1"></a>inspect.signature(Foo) <span class="co"># it is a problem for python 3.7,</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>                                                                                                                                                        (25)
    # Was this function wrapped by a decorator?                                                                                                         (26)
    if follow_wrapper_chains:===========================================================================================================================(27)
                                                                                                                FixSigMeta step 1: does it have __signature__
        obj = unwrap(obj, stop=(lambda f: hasattr(f, "__signature__")))                                                                                 (28)
        if isinstance(obj, types.MethodType):                                                                                                           (29)


                   env =&gt; env : {'obj': &lt;class '__main__.Foo'&gt;, 'follow_wrapper_chains': True, 'skip_bound_arg': True, 'sigcls': &lt;class 'inspect.Signature'&gt;}


                                                                                        hasattr(obj, '__signature__') =&gt; hasattr(obj, '__signature__') : True


                                                               obj = unwrap(obj, stop=(lambda f: hasattr(f, '__signature__'))) =&gt; obj: &lt;class '__main__.Foo'&gt;


inspect.getdoc(unwrap) =&gt; inspect.getdoc(unwrap) : Get the object wrapped by *func*.

Follows the chain of :attr:`__wrapped__` attributes returning the last
object in the chain.

*stop* is an optional callback accepting an object in the wrapper chain
as its sole argument that allows the unwrapping to be terminated early if
the callback returns a true value. If the callback never returns a true
value, the last object in the chain is returned as usual. For example,
:func:`signature` uses this to stop unwrapping if any object in the
chain has a ``__signature__`` attribute defined.

:exc:`ValueError` is raised if a cycle is encountered.

 </code></pre>
</div>
<div class="cell-output cell-output-display" data-execution_count="47">
<pre><code>&lt;Signature (d, e, f)&gt;</code></pre>
</div>
</div>
<div class="cell" data-execution_count="48">
<div class="sourceCode cell-code" id="cb85"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb85-1"><a href="#cb85-1" aria-hidden="true" tabindex="-1"></a>sigOld.dbprint(<span class="dv">44</span>, <span class="st">"FixSigMeta step 2: use __signature__ as Foo's sig"</span>, <span class="st">"env"</span>, <span class="st">"sig = obj.__signature__"</span>, <span class="st">"isinstance(sig, Signature)"</span>)</span>
<span id="cb85-2"><a href="#cb85-2" aria-hidden="true" tabindex="-1"></a>inspect._signature_from_callable <span class="op">=</span> _signature_from_callableOld</span>
<span id="cb85-3"><a href="#cb85-3" aria-hidden="true" tabindex="-1"></a>inspect.signature(Foo) <span class="co"># it is a problem for python 3.7,</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>        pass                                                                                                                                            (42)
    else:                                                                                                                                               (43)
        if sig is not None:=============================================================================================================================(44)
                                                                                                            FixSigMeta step 2: use __signature__ as Foo's sig
            if not isinstance(sig, Signature):                                                                                                          (45)
                raise TypeError(                                                                                                                        (46)


env =&gt; env : {'obj': &lt;class '__main__.Foo'&gt;, 'follow_wrapper_chains': True, 'skip_bound_arg': True, 'sigcls': &lt;class 'inspect.Signature'&gt;, 'sig': &lt;Signature (d, e, f)&gt;}


                                                                                                                    sig = obj.__signature__ =&gt; sig: (d, e, f)


                                                                                              isinstance(sig, Signature) =&gt; isinstance(sig, Signature) : True</code></pre>
</div>
<div class="cell-output cell-output-display" data-execution_count="48">
<pre><code>&lt;Signature (d, e, f)&gt;</code></pre>
</div>
</div>
<div class="cell" data-execution_count="49">
<div class="sourceCode cell-code" id="cb88"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb88-1"><a href="#cb88-1" aria-hidden="true" tabindex="-1"></a>sig.<span class="bu">print</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>def _signature_from_callable(obj, *,======================================================(0)       
                             follow_wrapper_chains=True,==================================(1)       
                             skip_bound_arg=True,=========================================(2)       
                             sigcls):=====================================================(3)       
                                                                                                                                                        (4)
    """Private helper function to get signature for arbitrary=============================(5)       
    callable objects.=====================================================================(6)       
    """===================================================================================(7)       
                                                                                                                                                        (8)
    _get_signature_of = functools.partial(_signature_from_callable,=======================(9) # so that it can use in itself
                                follow_wrapper_chains=follow_wrapper_chains,==============(10)      
                                skip_bound_arg=skip_bound_arg,============================(11)      
                                sigcls=sigcls)============================================(12)      
                                                                                                                                                        (13)
    if not callable(obj):=================================================================(14) # obj must be callable
        raise TypeError('{!r} is not a callable object'.format(obj))======================(15)      
                                                                                                                                                        (16)
    if isinstance(obj, types.MethodType):=================================================(17) # obj can be a classmethod
        # In this case we skip the first parameter of the underlying======================(18)      
        # function (usually `self` or `cls`).=============================================(19)      
        sig = _get_signature_of(obj.__func__)=============================================(20)      
                                                                                                                                                        (21)
        if skip_bound_arg:================================================================(22)      
            return _signature_bound_method(sig)===========================================(23)      
        else:=============================================================================(24)      
            return sig====================================================================(25)      
                                                                                                                                                        (26)
    # Was this function wrapped by a decorator?===========================================(27)      
    if follow_wrapper_chains:=============================================================(28) # does Foo has __signature__?
        obj = unwrap(obj, stop=(lambda f: hasattr(f, "__signature__")))===================(29)      
        if isinstance(obj, types.MethodType):=============================================(30)      
            # If the unwrapped object is a *method*, we might want to=====================(31)      
            # skip its first parameter (self).============================================(32)      
            # See test_signature_wrapped_bound_method for details.========================(33)      
            return _get_signature_of(obj)=================================================(34)      
                                                                                                                                                        (35)
    try:==================================================================================(36)      
        sig = obj.__signature__===========================================================(37) # check __signature__
    except AttributeError:================================================================(38)      
        pass==============================================================================(39)      
    else:=================================================================================(40)      
        if sig is not None:===============================================================(41)      
            if not isinstance(sig, Signature):============================================(42)      
                raise TypeError(==========================================================(43)      
                    'unexpected object {!r} in __signature__ '============================(44)      
                    'attribute'.format(sig))==============================================(45)      
            return sig====================================================================(46)      
                                                                                                                                                        (47)
    try:==================================================================================(48)      
        partialmethod = obj._partialmethod================================================(49)      
    except AttributeError:================================================================(50)      
        pass==============================================================================(51)      
    else:=================================================================================(52)      
        if isinstance(partialmethod, functools.partialmethod):============================(53)      
            # Unbound partialmethod (see functools.partialmethod)=========================(54)      
            # This means, that we need to calculate the signature=========================(55)      
            # as if it's a regular partial object, but taking into========================(56)      
            # account that the first positional argument==================================(57)      
            # (usually `self`, or `cls`) will not be passed===============================(58)      
            # automatically (as for boundmethods)=========================================(59)      
                                                                                                                                                        (60)
            wrapped_sig = _get_signature_of(partialmethod.func)===========================(61)      
                                                                                                                                                        (62)
            sig = _signature_get_partial(wrapped_sig, partialmethod, (None,))=============(63)      
            first_wrapped_param = tuple(wrapped_sig.parameters.values())[0]===============(64)      
            if first_wrapped_param.kind is Parameter.VAR_POSITIONAL:======================(65)      
                # First argument of the wrapped callable is `*args`, as in================(66)      
                # `partialmethod(lambda *args)`.==========================================(67)      
                return sig================================================================(68)      
            else:=========================================================================(69)      
                sig_params = tuple(sig.parameters.values())===============================(70)      
                assert (not sig_params or=================================================(71)      
                        first_wrapped_param is not sig_params[0])=========================(72)      
                new_params = (first_wrapped_param,) + sig_params==========================(73)      
                return sig.replace(parameters=new_params)=================================(74)      
                                                                                                                                                        (75)
    if isfunction(obj) or _signature_is_functionlike(obj):================================(76) # step 7: run on itself will run here
        # If it's a pure Python function, or an object that is duck type==================(77)      
        # of a Python function (Cython functions, for instance), then:====================(78)      
        return _signature_from_function(sigcls, obj,======================================(79) # step 8: get sig with a different func
                                        skip_bound_arg=skip_bound_arg)====================(80)      
                                                                                                                                                        (81)
    if _signature_is_builtin(obj):========================================================(82)      
        return _signature_from_builtin(sigcls, obj,=======================================(83)      
                                       skip_bound_arg=skip_bound_arg)=====================(84)      
                                                                                                                                                        (85)
    if isinstance(obj, functools.partial):================================================(86)      
        wrapped_sig = _get_signature_of(obj.func)=========================================(87)      
        return _signature_get_partial(wrapped_sig, obj)===================================(88)      
                                                                                                                                                        (89)
    sig = None============================================================================(90)      
    if isinstance(obj, type):=============================================================(91) # step 1: obj is a class?
        # obj is a class or a metaclass===================================================(92)      
                                                                                                                                                        (93)
        # First, let's see if it has an overloaded __call__ defined=======================(94)      
        # in its metaclass================================================================(95)      
        call = _signature_get_user_defined_method(type(obj), '__call__')==================(96) # step 2: define its own __call__?
        if call is not None:==============================================================(97)      
            sig = _get_signature_of(call)=================================================(98)      
        else:=============================================================================(99)      
            factory_method = None=========================================================(100)     
            new = _signature_get_user_defined_method(obj, '__new__')======================(101) # step 3: define its own __new__?
            init = _signature_get_user_defined_method(obj, '__init__')====================(102) # step 4: define its own __init__?
            # Now we check if the 'obj' class has an own '__new__' method=================(103)     
            if '__new__' in obj.__dict__:=================================================(104)     
                factory_method = new======================================================(105)     
            # or an own '__init__' method=================================================(106)     
            elif '__init__' in obj.__dict__:==============================================(107)     
                factory_method = init=====================================================(108) # step 5: __init__ is inside obj.__dict__?
            # If not, we take inherited '__new__' or '__init__', if present===============(109)     
            elif new is not None:=========================================================(110)     
                factory_method = new======================================================(111)     
            elif init is not None:========================================================(112)     
                factory_method = init=====================================================(113)     
                                                                                                                                                        (114)
            if factory_method is not None:================================================(115)     
                sig = _get_signature_of(factory_method)===================================(116) # step 6: run on itself using functools.partial
                                                                                                                                                        (117)
        if sig is None:===================================================================(118)     
            # At this point we know, that `obj` is a class, with no user-=================(119)     
            # defined '__init__', '__new__', or class-level '__call__'====================(120)     
                                                                                                                                                        (121)
            for base in obj.__mro__[:-1]:=================================================(122)     
                # Since '__text_signature__' is implemented as a==========================(123)     
                # descriptor that extracts text signature from the========================(124)     
                # class docstring, if 'obj' is derived from a builtin=====================(125)     
                # class, its own '__text_signature__' may be 'None'.======================(126)     
                # Therefore, we go through the MRO (except the last=======================(127)     
                # class in there, which is 'object') to find the first====================(128)     
                # class with non-empty text signature.====================================(129)     
                try:======================================================================(130)     
                    text_sig = base.__text_signature__====================================(131)     
                except AttributeError:====================================================(132)     
                    pass==================================================================(133)     
                else:=====================================================================(134)     
                    if text_sig:==========================================================(135)     
                        # If 'base' class has a __text_signature__ attribute:=============(136)     
                        # return a signature based on it==================================(137)     
                        return _signature_fromstr(sigcls, base, text_sig)=================(138)     
                                                                                                                                                        (139)
            # No '__text_signature__' was found for the 'obj' class.======================(140)     
            # Last option is to check if its '__init__' is================================(141)     
            # object.__init__ or type.__init__.===========================================(142)     
            if type not in obj.__mro__:===================================================(143)     
                # We have a class (not metaclass), but no user-defined====================(144)     
                # __init__ or __new__ for it==============================================(145)     
                if (obj.__init__ is object.__init__ and===================================(146)     
                    obj.__new__ is object.__new__):=======================================(147)     
                    # Return a signature of 'object' builtin.=============================(148)     
                    return sigcls.from_callable(object)===================================(149)     
                else:=====================================================================(150)     
                    raise ValueError(=====================================================(151)     
                        'no signature found for builtin type {!r}'.format(obj))===========(152)     
                                                                                                                                                        (153)
    elif not isinstance(obj, _NonUserDefinedCallables):===================================(154)     
        # An object with __call__=========================================================(155)     
        # We also check that the 'obj' is not an instance of==============================(156)     
        # _WrapperDescriptor or _MethodWrapper to avoid===================================(157)     
        # infinite recursion (and even potential segfault)================================(158)     
        call = _signature_get_user_defined_method(type(obj), '__call__')==================(159)     
        if call is not None:==============================================================(160)     
            try:==========================================================================(161)     
                sig = _get_signature_of(call)=============================================(162)     
            except ValueError as ex:======================================================(163)     
                msg = 'no signature found for {!r}'.format(obj)===========================(164)     
                raise ValueError(msg) from ex=============================================(165)     
                                                                                                                                                        (166)
    if sig is not None:===================================================================(167)     
        # For classes and objects we skip the first parameter of their====================(168)     
        # __call__, __new__, or __init__ methods==========================================(169)     
        if skip_bound_arg:================================================================(170)     
            return _signature_bound_method(sig)===========================================(171)     
        else:=============================================================================(172)     
            return sig====================================================================(173)     
                                                                                                                                                        (174)
    if isinstance(obj, types.BuiltinFunctionType):========================================(175)     
        # Raise a nicer error message for builtins========================================(176)     
        msg = 'no signature found for builtin function {!r}'.format(obj)==================(177)     
        raise ValueError(msg)=============================================================(178)     
                                                                                                                                                        (179)
    raise ValueError('callable {!r} is not supported by signature'.format(obj))===========(180)     
                                                                                                                                                        (181)</code></pre>
</div>
</div>
<p>Note: new and old <code>_signature_from_callable</code> have the same code for getting signature for object with <code>__signature__</code>.</p>
</section>
<section id="read-commented-_signature_from_callable-of-python-3.7" class="level3">
<h3 class="anchored" data-anchor-id="read-commented-_signature_from_callable-of-python-3.7">Read commented <code>_signature_from_callable</code> of python 3.7</h3>
<div class="cell" data-jupyter="{&quot;source_hidden&quot;:true}" data-tags="[]" data-execution_count="50">
<div class="sourceCode cell-code" id="cb90"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb90-1"><a href="#cb90-1" aria-hidden="true" tabindex="-1"></a>sigOld.<span class="bu">print</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>def _signature_from_callableOld(obj, *,===================================================(0)       
                             follow_wrapper_chains=True,==================================(1)       
                             skip_bound_arg=True,=========================================(2)       
                             sigcls):=====================================================(3)       
                                                                                                                                                        (4)
    """Private helper function to get signature for arbitrary=============================(5)       
    callable objects.=====================================================================(6)       
    """===================================================================================(7)       
                                                                                                                                                        (8)
    if not callable(obj):=================================================================(9)       
        raise TypeError('{!r} is not a callable object'.format(obj))======================(10)      
                                                                                                                                                        (11)
    if isinstance(obj, types.MethodType):=================================================(12)      
        # In this case we skip the first parameter of the underlying======================(13)      
        # function (usually `self` or `cls`).=============================================(14)      
        sig = _signature_from_callable(===================================================(15)      
            obj.__func__,=================================================================(16)      
            follow_wrapper_chains=follow_wrapper_chains,==================================(17)      
            skip_bound_arg=skip_bound_arg,================================================(18)      
            sigcls=sigcls)================================================================(19)      
                                                                                                                                                        (20)
        if skip_bound_arg:================================================================(21)      
            return _signature_bound_method(sig)===========================================(22)      
        else:=============================================================================(23)      
            return sig====================================================================(24)      
                                                                                                                                                        (25)
    # Was this function wrapped by a decorator?===========================================(26)      
    if follow_wrapper_chains:=============================================================(27) # FixSigMeta step 1: does it have __signature__
        obj = unwrap(obj, stop=(lambda f: hasattr(f, "__signature__")))===================(28)      
        if isinstance(obj, types.MethodType):=============================================(29)      
            # If the unwrapped object is a *method*, we might want to=====================(30)      
            # skip its first parameter (self).============================================(31)      
            # See test_signature_wrapped_bound_method for details.========================(32)      
            return _signature_from_callable(==============================================(33)      
                obj,======================================================================(34)      
                follow_wrapper_chains=follow_wrapper_chains,==============================(35)      
                skip_bound_arg=skip_bound_arg,============================================(36)      
                sigcls=sigcls)============================================================(37)      
                                                                                                                                                        (38)
    try:==================================================================================(39)      
        sig = obj.__signature__===========================================================(40)      
    except AttributeError:================================================================(41)      
        pass==============================================================================(42)      
    else:=================================================================================(43)      
        if sig is not None:===============================================================(44) # FixSigMeta step 2: use __signature__ as Foo's sig
            if not isinstance(sig, Signature):============================================(45)      
                raise TypeError(==========================================================(46)      
                    'unexpected object {!r} in __signature__ '============================(47)      
                    'attribute'.format(sig))==============================================(48)      
            return sig====================================================================(49)      
                                                                                                                                                        (50)
    try:==================================================================================(51)      
        partialmethod = obj._partialmethod================================================(52)      
    except AttributeError:================================================================(53)      
        pass==============================================================================(54)      
    else:=================================================================================(55)      
        if isinstance(partialmethod, functools.partialmethod):============================(56)      
            # Unbound partialmethod (see functools.partialmethod)=========================(57)      
            # This means, that we need to calculate the signature=========================(58)      
            # as if it's a regular partial object, but taking into========================(59)      
            # account that the first positional argument==================================(60)      
            # (usually `self`, or `cls`) will not be passed===============================(61)      
            # automatically (as for boundmethods)=========================================(62)      
                                                                                                                                                        (63)
            wrapped_sig = _signature_from_callable(=======================================(64)      
                partialmethod.func,=======================================================(65)      
                follow_wrapper_chains=follow_wrapper_chains,==============================(66)      
                skip_bound_arg=skip_bound_arg,============================================(67)      
                sigcls=sigcls)============================================================(68)      
                                                                                                                                                        (69)
            sig = _signature_get_partial(wrapped_sig, partialmethod, (None,))=============(70)      
            first_wrapped_param = tuple(wrapped_sig.parameters.values())[0]===============(71)      
            if first_wrapped_param.kind is Parameter.VAR_POSITIONAL:======================(72)      
                # First argument of the wrapped callable is `*args`, as in================(73)      
                # `partialmethod(lambda *args)`.==========================================(74)      
                return sig================================================================(75)      
            else:=========================================================================(76)      
                sig_params = tuple(sig.parameters.values())===============================(77)      
                assert (not sig_params or=================================================(78)      
                        first_wrapped_param is not sig_params[0])=========================(79)      
                new_params = (first_wrapped_param,) + sig_params==========================(80)      
                return sig.replace(parameters=new_params)=================================(81)      
                                                                                                                                                        (82)
    if isfunction(obj) or _signature_is_functionlike(obj):================================(83)      
        # If it's a pure Python function, or an object that is duck type==================(84)      
        # of a Python function (Cython functions, for instance), then:====================(85)      
        return _signature_from_function(sigcls, obj)======================================(86)      
                                                                                                                                                        (87)
    if _signature_is_builtin(obj):========================================================(88)      
        return _signature_from_builtin(sigcls, obj,=======================================(89)      
                                       skip_bound_arg=skip_bound_arg)=====================(90)      
                                                                                                                                                        (91)
    if isinstance(obj, functools.partial):================================================(92)      
        wrapped_sig = _signature_from_callable(===========================================(93)      
            obj.func,=====================================================================(94)      
            follow_wrapper_chains=follow_wrapper_chains,==================================(95)      
            skip_bound_arg=skip_bound_arg,================================================(96)      
            sigcls=sigcls)================================================================(97)      
        return _signature_get_partial(wrapped_sig, obj)===================================(98)      
                                                                                                                                                        (99)
    sig = None============================================================================(100)     
    if isinstance(obj, type):=============================================================(101)     
        # obj is a class or a metaclass===================================================(102)     
                                                                                                                                                        (103)
        # First, let's see if it has an overloaded __call__ defined=======================(104)     
        # in its metaclass================================================================(105)     
        call = _signature_get_user_defined_method(type(obj), '__call__')==================(106)     
        if call is not None:==============================================================(107)     
            sig = _signature_from_callable(===============================================(108)     
                call,=====================================================================(109)     
                follow_wrapper_chains=follow_wrapper_chains,==============================(110)     
                skip_bound_arg=skip_bound_arg,============================================(111)     
                sigcls=sigcls)============================================================(112)     
        else:=============================================================================(113)     
            # Now we check if the 'obj' class has a '__new__' method======================(114)     
            new = _signature_get_user_defined_method(obj, '__new__')======================(115) # messup step 1: overriding __new__ is detected
            if new is not None:===========================================================(116)     
                sig = _signature_from_callable(===========================================(117) # messup step 2: only __new__ sig is extracted
                    new,==================================================================(118)     
                    follow_wrapper_chains=follow_wrapper_chains,==========================(119)     
                    skip_bound_arg=skip_bound_arg,========================================(120)     
                    sigcls=sigcls)========================================================(121)     
            else:=========================================================================(122)     
                # Finally, we should have at least __init__ implemented===================(123)     
                init = _signature_get_user_defined_method(obj, '__init__')================(124) # messup step 3: __init__ don't even get accessed
                if init is not None:======================================================(125)     
                    sig = _signature_from_callable(=======================================(126)     
                        init,=============================================================(127)     
                        follow_wrapper_chains=follow_wrapper_chains,======================(128)     
                        skip_bound_arg=skip_bound_arg,====================================(129)     
                        sigcls=sigcls)====================================================(130)     
                                                                                                                                                        (131)
        if sig is None:===================================================================(132)     
            # At this point we know, that `obj` is a class, with no user-=================(133)     
            # defined '__init__', '__new__', or class-level '__call__'====================(134)     
                                                                                                                                                        (135)
            for base in obj.__mro__[:-1]:=================================================(136)     
                # Since '__text_signature__' is implemented as a==========================(137)     
                # descriptor that extracts text signature from the========================(138)     
                # class docstring, if 'obj' is derived from a builtin=====================(139)     
                # class, its own '__text_signature__' may be 'None'.======================(140)     
                # Therefore, we go through the MRO (except the last=======================(141)     
                # class in there, which is 'object') to find the first====================(142)     
                # class with non-empty text signature.====================================(143)     
                try:======================================================================(144)     
                    text_sig = base.__text_signature__====================================(145)     
                except AttributeError:====================================================(146)     
                    pass==================================================================(147)     
                else:=====================================================================(148)     
                    if text_sig:==========================================================(149)     
                        # If 'obj' class has a __text_signature__ attribute:==============(150)     
                        # return a signature based on it==================================(151)     
                        return _signature_fromstr(sigcls, obj, text_sig)==================(152)     
                                                                                                                                                        (153)
            # No '__text_signature__' was found for the 'obj' class.======================(154)     
            # Last option is to check if its '__init__' is================================(155)     
            # object.__init__ or type.__init__.===========================================(156)     
            if type not in obj.__mro__:===================================================(157)     
                # We have a class (not metaclass), but no user-defined====================(158)     
                # __init__ or __new__ for it==============================================(159)     
                if (obj.__init__ is object.__init__ and===================================(160)     
                    obj.__new__ is object.__new__):=======================================(161)     
                    # Return a signature of 'object' builtin.=============================(162)     
                    return sigcls.from_callable(object)===================================(163)     
                else:=====================================================================(164)     
                    raise ValueError(=====================================================(165)     
                        'no signature found for builtin type {!r}'.format(obj))===========(166)     
                                                                                                                                                        (167)
    elif not isinstance(obj, _NonUserDefinedCallables):===================================(168)     
        # An object with __call__=========================================================(169)     
        # We also check that the 'obj' is not an instance of==============================(170)     
        # _WrapperDescriptor or _MethodWrapper to avoid===================================(171)     
        # infinite recursion (and even potential segfault)================================(172)     
        call = _signature_get_user_defined_method(type(obj), '__call__')==================(173)     
        if call is not None:==============================================================(174)     
            try:==========================================================================(175)     
                sig = _signature_from_callable(===========================================(176)     
                    call,=================================================================(177)     
                    follow_wrapper_chains=follow_wrapper_chains,==========================(178)     
                    skip_bound_arg=skip_bound_arg,========================================(179)     
                    sigcls=sigcls)========================================================(180)     
            except ValueError as ex:======================================================(181)     
                msg = 'no signature found for {!r}'.format(obj)===========================(182)     
                raise ValueError(msg) from ex=============================================(183)     
                                                                                                                                                        (184)
    if sig is not None:===================================================================(185)     
        # For classes and objects we skip the first parameter of their====================(186)     
        # __call__, __new__, or __init__ methods==========================================(187)     
        if skip_bound_arg:================================================================(188)     
            return _signature_bound_method(sig)===========================================(189)     
        else:=============================================================================(190)     
            return sig====================================================================(191)     
                                                                                                                                                        (192)
    if isinstance(obj, types.BuiltinFunctionType):========================================(193)     
        # Raise a nicer error message for builtins========================================(194)     
        msg = 'no signature found for builtin function {!r}'.format(obj)==================(195)     
        raise ValueError(msg)=============================================================(196)     
                                                                                                                                                        (197)
    raise ValueError('callable {!r} is not supported by signature'.format(obj))===========(198)     
                                                                                                                                                        (199)</code></pre>
</div>
</div>
</section>
</section>
<section id="foos-metaclass-defines-its-own-__call__-will-stop-foo-get-sig-from-__init__" class="level2">
<h2 class="anchored" data-anchor-id="foos-metaclass-defines-its-own-__call__-will-stop-foo-get-sig-from-__init__">Foo’s metaclass defines its own <code>__call__</code> will stop Foo get sig from <code>__init__</code></h2>
<section id="problem-demo" class="level3">
<h3 class="anchored" data-anchor-id="problem-demo">Problem demo</h3>
<div class="cell" data-execution_count="51">
<div class="sourceCode cell-code" id="cb92"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb92-1"><a href="#cb92-1" aria-hidden="true" tabindex="-1"></a>inspect._signature_from_callable <span class="op">=</span> _signature_from_callableNew</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<ol start="2" type="1">
<li>when your Foo has a metaclass BaseMeta, if BaseMeta need to define its <code>__call__</code>, then Foo can’t get signature from <code>__init__</code>.</li>
</ol>
<div class="cell" data-execution_count="52">
<div class="sourceCode cell-code" id="cb93"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb93-1"><a href="#cb93-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> BaseMeta(<span class="bu">type</span>): </span>
<span id="cb93-2"><a href="#cb93-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># using __new__ from type</span></span>
<span id="cb93-3"><a href="#cb93-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__call__</span>(cls, <span class="op">*</span>args, <span class="op">**</span>kwargs): <span class="cf">pass</span></span>
<span id="cb93-4"><a href="#cb93-4" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Foo(metaclass<span class="op">=</span>BaseMeta): </span>
<span id="cb93-5"><a href="#cb93-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, d, e, f): <span class="cf">pass</span></span>
<span id="cb93-6"><a href="#cb93-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb93-7"><a href="#cb93-7" aria-hidden="true" tabindex="-1"></a>test_sig(Foo, <span class="st">'(*args, **kwargs)'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="53">
<div class="sourceCode cell-code" id="cb94"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb94-1"><a href="#cb94-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> BaseMeta(<span class="bu">type</span>): </span>
<span id="cb94-2"><a href="#cb94-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__new__</span>(cls, name, bases, <span class="bu">dict</span>):</span>
<span id="cb94-3"><a href="#cb94-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">super</span>().<span class="fu">__new__</span>(cls, name, bases, <span class="bu">dict</span>) <span class="co"># using __new__ from type</span></span>
<span id="cb94-4"><a href="#cb94-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__call__</span>(cls, <span class="op">*</span>args, <span class="op">**</span>kwargs): <span class="cf">pass</span></span>
<span id="cb94-5"><a href="#cb94-5" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Foo(metaclass<span class="op">=</span>BaseMeta): </span>
<span id="cb94-6"><a href="#cb94-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, d, e, f): <span class="cf">pass</span></span>
<span id="cb94-7"><a href="#cb94-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb94-8"><a href="#cb94-8" aria-hidden="true" tabindex="-1"></a>test_sig(Foo, <span class="st">'(*args, **kwargs)'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="cause-of-the-problem" class="level3">
<h3 class="anchored" data-anchor-id="cause-of-the-problem">Cause of the problem</h3>
<p>I want to investigate 2 places: line 96 and line 37</p>
<div class="cell" data-execution_count="54">
<div class="sourceCode cell-code" id="cb95"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb95-1"><a href="#cb95-1" aria-hidden="true" tabindex="-1"></a>sig.dbprint(<span class="dv">37</span>, <span class="st">"does Foo store sig inside __signature__"</span>, <span class="st">"hasattr(Foo, '__signature__')"</span>)</span>
<span id="cb95-2"><a href="#cb95-2" aria-hidden="true" tabindex="-1"></a>inspect._signature_from_callable <span class="op">=</span> _signature_from_callable</span>
<span id="cb95-3"><a href="#cb95-3" aria-hidden="true" tabindex="-1"></a>inspect.signature(Foo)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>                                                                                                                                                        (35)
    try:                                                                                                                                                (36)
        sig = obj.__signature__=========================================================================================================================(37)
                                                                                                                      does Foo store sig inside __signature__
    except AttributeError:                                                                                                                              (38)
        pass                                                                                                                                            (39)


                                                                                       hasattr(Foo, '__signature__') =&gt; hasattr(Foo, '__signature__') : False</code></pre>
</div>
<div class="cell-output cell-output-display" data-execution_count="54">
<pre><code>&lt;Signature (*args, **kwargs)&gt;</code></pre>
</div>
</div>
<div class="cell" data-execution_count="55">
<div class="sourceCode cell-code" id="cb98"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb98-1"><a href="#cb98-1" aria-hidden="true" tabindex="-1"></a>sig.dbprint(<span class="dv">98</span>, <span class="st">"__call__ is defined"</span>, <span class="st">"sig = _get_signature_of(call)"</span>)</span>
<span id="cb98-2"><a href="#cb98-2" aria-hidden="true" tabindex="-1"></a>inspect._signature_from_callable <span class="op">=</span> _signature_from_callable</span>
<span id="cb98-3"><a href="#cb98-3" aria-hidden="true" tabindex="-1"></a>inspect.signature(Foo)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>        call = _signature_get_user_defined_method(type(obj), '__call__')                                                                                (96)
        if call is not None:                                                                                                                            (97)
            sig = _get_signature_of(call)===============================================================================================================(98)
                                                                                                                                          __call__ is defined
        else:                                                                                                                                           (99)
            factory_method = None                                                                                                                       (100)




                                                                                       hasattr(Foo, '__signature__') =&gt; hasattr(Foo, '__signature__') : False
                                                                                                 sig = _get_signature_of(call) =&gt; sig: (cls, *args, **kwargs)


                                                                                       hasattr(Foo, '__signature__') =&gt; hasattr(Foo, '__signature__') : False</code></pre>
</div>
<div class="cell-output cell-output-display" data-execution_count="55">
<pre><code>&lt;Signature (*args, **kwargs)&gt;</code></pre>
</div>
</div>
<div class="cell" data-tags="[]" data-execution_count="56">
<div class="sourceCode cell-code" id="cb101"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb101-1"><a href="#cb101-1" aria-hidden="true" tabindex="-1"></a>sig.<span class="bu">print</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>

                                                                                       hasattr(Foo, '__signature__') =&gt; hasattr(Foo, '__signature__') : False


                                                                                       hasattr(Foo, '__signature__') =&gt; hasattr(Foo, '__signature__') : False
def _signature_from_callable(obj, *,======================================================(0)       
                             follow_wrapper_chains=True,==================================(1)       
                             skip_bound_arg=True,=========================================(2)       
                             sigcls):=====================================================(3)       
                                                                                                                                                        (4)
    """Private helper function to get signature for arbitrary=============================(5)       
    callable objects.=====================================================================(6)       
    """===================================================================================(7)       
                                                                                                                                                        (8)
    _get_signature_of = functools.partial(_signature_from_callable,=======================(9) # so that it can use in itself
                                follow_wrapper_chains=follow_wrapper_chains,==============(10)      
                                skip_bound_arg=skip_bound_arg,============================(11)      
                                sigcls=sigcls)============================================(12)      
                                                                                                                                                        (13)
    if not callable(obj):=================================================================(14) # obj must be callable
        raise TypeError('{!r} is not a callable object'.format(obj))======================(15)      
                                                                                                                                                        (16)
    if isinstance(obj, types.MethodType):=================================================(17) # obj can be a classmethod
        # In this case we skip the first parameter of the underlying======================(18)      
        # function (usually `self` or `cls`).=============================================(19)      
        sig = _get_signature_of(obj.__func__)=============================================(20)      
                                                                                                                                                        (21)
        if skip_bound_arg:================================================================(22)      
            return _signature_bound_method(sig)===========================================(23)      
        else:=============================================================================(24)      
            return sig====================================================================(25)      
                                                                                                                                                        (26)
    # Was this function wrapped by a decorator?===========================================(27)      
    if follow_wrapper_chains:=============================================================(28) # does Foo has __signature__?
        obj = unwrap(obj, stop=(lambda f: hasattr(f, "__signature__")))===================(29)      
        if isinstance(obj, types.MethodType):=============================================(30)      
            # If the unwrapped object is a *method*, we might want to=====================(31)      
            # skip its first parameter (self).============================================(32)      
            # See test_signature_wrapped_bound_method for details.========================(33)      
            return _get_signature_of(obj)=================================================(34)      
                                                                                                                                                        (35)
    try:==================================================================================(36)      
        sig = obj.__signature__===========================================================(37) # does Foo store sig inside __signature__
    except AttributeError:================================================================(38)      
        pass==============================================================================(39)      
    else:=================================================================================(40)      
        if sig is not None:===============================================================(41)      
            if not isinstance(sig, Signature):============================================(42)      
                raise TypeError(==========================================================(43)      
                    'unexpected object {!r} in __signature__ '============================(44)      
                    'attribute'.format(sig))==============================================(45)      
            return sig====================================================================(46)      
                                                                                                                                                        (47)
    try:==================================================================================(48)      
        partialmethod = obj._partialmethod================================================(49)      
    except AttributeError:================================================================(50)      
        pass==============================================================================(51)      
    else:=================================================================================(52)      
        if isinstance(partialmethod, functools.partialmethod):============================(53)      
            # Unbound partialmethod (see functools.partialmethod)=========================(54)      
            # This means, that we need to calculate the signature=========================(55)      
            # as if it's a regular partial object, but taking into========================(56)      
            # account that the first positional argument==================================(57)      
            # (usually `self`, or `cls`) will not be passed===============================(58)      
            # automatically (as for boundmethods)=========================================(59)      
                                                                                                                                                        (60)
            wrapped_sig = _get_signature_of(partialmethod.func)===========================(61)      
                                                                                                                                                        (62)
            sig = _signature_get_partial(wrapped_sig, partialmethod, (None,))=============(63)      
            first_wrapped_param = tuple(wrapped_sig.parameters.values())[0]===============(64)      
            if first_wrapped_param.kind is Parameter.VAR_POSITIONAL:======================(65)      
                # First argument of the wrapped callable is `*args`, as in================(66)      
                # `partialmethod(lambda *args)`.==========================================(67)      
                return sig================================================================(68)      
            else:=========================================================================(69)      
                sig_params = tuple(sig.parameters.values())===============================(70)      
                assert (not sig_params or=================================================(71)      
                        first_wrapped_param is not sig_params[0])=========================(72)      
                new_params = (first_wrapped_param,) + sig_params==========================(73)      
                return sig.replace(parameters=new_params)=================================(74)      
                                                                                                                                                        (75)
    if isfunction(obj) or _signature_is_functionlike(obj):================================(76) # step 7: run on itself will run here
        # If it's a pure Python function, or an object that is duck type==================(77)      
        # of a Python function (Cython functions, for instance), then:====================(78)      
        return _signature_from_function(sigcls, obj,======================================(79) # step 8: get sig with a different func
                                        skip_bound_arg=skip_bound_arg)====================(80)      
                                                                                                                                                        (81)
    if _signature_is_builtin(obj):========================================================(82)      
        return _signature_from_builtin(sigcls, obj,=======================================(83)      
                                       skip_bound_arg=skip_bound_arg)=====================(84)      
                                                                                                                                                        (85)
    if isinstance(obj, functools.partial):================================================(86)      
        wrapped_sig = _get_signature_of(obj.func)=========================================(87)      
        return _signature_get_partial(wrapped_sig, obj)===================================(88)      
                                                                                                                                                        (89)
    sig = None============================================================================(90)      
    if isinstance(obj, type):=============================================================(91) # step 1: obj is a class?
        # obj is a class or a metaclass===================================================(92)      
                                                                                                                                                        (93)
        # First, let's see if it has an overloaded __call__ defined=======================(94)      
        # in its metaclass================================================================(95)      
        call = _signature_get_user_defined_method(type(obj), '__call__')==================(96) # step 2: define its own __call__?
        if call is not None:==============================================================(97)      
            sig = _get_signature_of(call)=================================================(98) # __call__ is defined
        else:=============================================================================(99)      
            factory_method = None=========================================================(100)     
            new = _signature_get_user_defined_method(obj, '__new__')======================(101) # step 3: define its own __new__?
            init = _signature_get_user_defined_method(obj, '__init__')====================(102) # step 4: define its own __init__?
            # Now we check if the 'obj' class has an own '__new__' method=================(103)     
            if '__new__' in obj.__dict__:=================================================(104)     
                factory_method = new======================================================(105)     
            # or an own '__init__' method=================================================(106)     
            elif '__init__' in obj.__dict__:==============================================(107)     
                factory_method = init=====================================================(108) # step 5: __init__ is inside obj.__dict__?
            # If not, we take inherited '__new__' or '__init__', if present===============(109)     
            elif new is not None:=========================================================(110)     
                factory_method = new======================================================(111)     
            elif init is not None:========================================================(112)     
                factory_method = init=====================================================(113)     
                                                                                                                                                        (114)
            if factory_method is not None:================================================(115)     
                sig = _get_signature_of(factory_method)===================================(116) # step 6: run on itself using functools.partial
                                                                                                                                                        (117)
        if sig is None:===================================================================(118)     
            # At this point we know, that `obj` is a class, with no user-=================(119)     
            # defined '__init__', '__new__', or class-level '__call__'====================(120)     
                                                                                                                                                        (121)
            for base in obj.__mro__[:-1]:=================================================(122)     
                # Since '__text_signature__' is implemented as a==========================(123)     
                # descriptor that extracts text signature from the========================(124)     
                # class docstring, if 'obj' is derived from a builtin=====================(125)     
                # class, its own '__text_signature__' may be 'None'.======================(126)     
                # Therefore, we go through the MRO (except the last=======================(127)     
                # class in there, which is 'object') to find the first====================(128)     
                # class with non-empty text signature.====================================(129)     
                try:======================================================================(130)     
                    text_sig = base.__text_signature__====================================(131)     
                except AttributeError:====================================================(132)     
                    pass==================================================================(133)     
                else:=====================================================================(134)     
                    if text_sig:==========================================================(135)     
                        # If 'base' class has a __text_signature__ attribute:=============(136)     
                        # return a signature based on it==================================(137)     
                        return _signature_fromstr(sigcls, base, text_sig)=================(138)     
                                                                                                                                                        (139)
            # No '__text_signature__' was found for the 'obj' class.======================(140)     
            # Last option is to check if its '__init__' is================================(141)     
            # object.__init__ or type.__init__.===========================================(142)     
            if type not in obj.__mro__:===================================================(143)     
                # We have a class (not metaclass), but no user-defined====================(144)     
                # __init__ or __new__ for it==============================================(145)     
                if (obj.__init__ is object.__init__ and===================================(146)     
                    obj.__new__ is object.__new__):=======================================(147)     
                    # Return a signature of 'object' builtin.=============================(148)     
                    return sigcls.from_callable(object)===================================(149)     
                else:=====================================================================(150)     
                    raise ValueError(=====================================================(151)     
                        'no signature found for builtin type {!r}'.format(obj))===========(152)     
                                                                                                                                                        (153)
    elif not isinstance(obj, _NonUserDefinedCallables):===================================(154)     
        # An object with __call__=========================================================(155)     
        # We also check that the 'obj' is not an instance of==============================(156)     
        # _WrapperDescriptor or _MethodWrapper to avoid===================================(157)     
        # infinite recursion (and even potential segfault)================================(158)     
        call = _signature_get_user_defined_method(type(obj), '__call__')==================(159)     
        if call is not None:==============================================================(160)     
            try:==========================================================================(161)     
                sig = _get_signature_of(call)=============================================(162)     
            except ValueError as ex:======================================================(163)     
                msg = 'no signature found for {!r}'.format(obj)===========================(164)     
                raise ValueError(msg) from ex=============================================(165)     
                                                                                                                                                        (166)
    if sig is not None:===================================================================(167)     
        # For classes and objects we skip the first parameter of their====================(168)     
        # __call__, __new__, or __init__ methods==========================================(169)     
        if skip_bound_arg:================================================================(170)     
            return _signature_bound_method(sig)===========================================(171)     
        else:=============================================================================(172)     
            return sig====================================================================(173)     
                                                                                                                                                        (174)
    if isinstance(obj, types.BuiltinFunctionType):========================================(175)     
        # Raise a nicer error message for builtins========================================(176)     
        msg = 'no signature found for builtin function {!r}'.format(obj)==================(177)     
        raise ValueError(msg)=============================================================(178)     
                                                                                                                                                        (179)
    raise ValueError('callable {!r} is not supported by signature'.format(obj))===========(180)     
                                                                                                                                                        (181)</code></pre>
</div>
</div>
</section>
<section id="solution-demo" class="level3">
<h3 class="anchored" data-anchor-id="solution-demo">Solution demo</h3>
<p>Solution to problem 2: you need to inherit from FixSigMeta instead of type when constructing the metaclass to preserve the signature in <code>__init__</code>. Be careful not to override <code>__new__</code> when doing this:</p>
<div class="cell" data-execution_count="57">
<div class="sourceCode cell-code" id="cb103"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb103-1"><a href="#cb103-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> BaseMeta(FixSigMeta): </span>
<span id="cb103-2"><a href="#cb103-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># using __new__ of  FixSigMeta instead of type</span></span>
<span id="cb103-3"><a href="#cb103-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__call__</span>(cls, <span class="op">*</span>args, <span class="op">**</span>kwargs): <span class="cf">pass</span></span>
<span id="cb103-4"><a href="#cb103-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb103-5"><a href="#cb103-5" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Foo(metaclass<span class="op">=</span>BaseMeta): <span class="co"># Base</span></span>
<span id="cb103-6"><a href="#cb103-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, d, e, f): <span class="cf">pass</span></span>
<span id="cb103-7"><a href="#cb103-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb103-8"><a href="#cb103-8" aria-hidden="true" tabindex="-1"></a>test_sig(Foo, <span class="st">'(d, e, f)'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>

                                                                                       hasattr(Foo, '__signature__') =&gt; hasattr(Foo, '__signature__') : False


                                                                                       hasattr(Foo, '__signature__') =&gt; hasattr(Foo, '__signature__') : False</code></pre>
</div>
</div>
<div class="cell" data-execution_count="58">
<div class="sourceCode cell-code" id="cb105"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb105-1"><a href="#cb105-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> BaseMeta(FixSigMeta): </span>
<span id="cb105-2"><a href="#cb105-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__new__</span>(cls, name, bases, <span class="bu">dict</span>): <span class="co"># not really overriding __new__, still using FixSigMeta.__new__ actually</span></span>
<span id="cb105-3"><a href="#cb105-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">super</span>().<span class="fu">__new__</span>(cls, name, bases, <span class="bu">dict</span>)</span>
<span id="cb105-4"><a href="#cb105-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__call__</span>(cls, <span class="op">*</span>args, <span class="op">**</span>kwargs): <span class="cf">pass</span></span>
<span id="cb105-5"><a href="#cb105-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb105-6"><a href="#cb105-6" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Foo(metaclass<span class="op">=</span>BaseMeta): <span class="co"># Base</span></span>
<span id="cb105-7"><a href="#cb105-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, d, e, f): <span class="cf">pass</span></span>
<span id="cb105-8"><a href="#cb105-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb105-9"><a href="#cb105-9" aria-hidden="true" tabindex="-1"></a>test_sig(Foo, <span class="st">'(d, e, f)'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>

                                                                                       hasattr(Foo, '__signature__') =&gt; hasattr(Foo, '__signature__') : False


                                                                                       hasattr(Foo, '__signature__') =&gt; hasattr(Foo, '__signature__') : False</code></pre>
</div>
</div>
<p>Note: if Base also defines <code>__new__</code>, then FixSigMeta can’t help.</p>
</section>
<section id="how-fixsigmeta-fix-this-problem" class="level3">
<h3 class="anchored" data-anchor-id="how-fixsigmeta-fix-this-problem">How FixSigMeta fix this problem</h3>
<div class="cell" data-execution_count="59">
<div class="sourceCode cell-code" id="cb107"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb107-1"><a href="#cb107-1" aria-hidden="true" tabindex="-1"></a>sig.dbprint(<span class="dv">29</span>, <span class="st">"why has to unwrap?"</span>, <span class="st">"hasattr(Foo, '__signature__')"</span>)</span>
<span id="cb107-2"><a href="#cb107-2" aria-hidden="true" tabindex="-1"></a>inspect._signature_from_callable <span class="op">=</span> _signature_from_callable</span>
<span id="cb107-3"><a href="#cb107-3" aria-hidden="true" tabindex="-1"></a>inspect.signature(Foo)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>

                                                                                       hasattr(Foo, '__signature__') =&gt; hasattr(Foo, '__signature__') : False


                                                                                       hasattr(Foo, '__signature__') =&gt; hasattr(Foo, '__signature__') : False
    # Was this function wrapped by a decorator?                                                                                                         (27)
    if follow_wrapper_chains:                                                                                                                           (28)
        obj = unwrap(obj, stop=(lambda f: hasattr(f, "__signature__")))=================================================================================(29)
                                                                                                                                           why has to unwrap?
        if isinstance(obj, types.MethodType):                                                                                                           (30)
            # If the unwrapped object is a *method*, we might want to                                                                                   (31)


                                                                                        hasattr(Foo, '__signature__') =&gt; hasattr(Foo, '__signature__') : True</code></pre>
</div>
<div class="cell-output cell-output-display" data-execution_count="59">
<pre><code>&lt;Signature (d, e, f)&gt;</code></pre>
</div>
</div>
<div class="cell" data-execution_count="60">
<div class="sourceCode cell-code" id="cb110"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb110-1"><a href="#cb110-1" aria-hidden="true" tabindex="-1"></a>sig.dbprint(<span class="dv">30</span>, <span class="st">"what is wrapped by Foo?"</span>, <span class="st">"isinstance(obj, types.MethodType)"</span>, <span class="st">"object"</span>, <span class="st">"type(obj)"</span>)</span>
<span id="cb110-2"><a href="#cb110-2" aria-hidden="true" tabindex="-1"></a>inspect._signature_from_callable <span class="op">=</span> _signature_from_callable</span>
<span id="cb110-3"><a href="#cb110-3" aria-hidden="true" tabindex="-1"></a>inspect.signature(Foo)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>    if follow_wrapper_chains:                                                                                                                           (28)
        obj = unwrap(obj, stop=(lambda f: hasattr(f, "__signature__")))                                                                                 (29)
        if isinstance(obj, types.MethodType):===========================================================================================================(30)
                                                                                                                                      what is wrapped by Foo?
            # If the unwrapped object is a *method*, we might want to                                                                                   (31)
            # skip its first parameter (self).                                                                                                          (32)


                                                                               isinstance(obj, types.MethodType) =&gt; isinstance(obj, types.MethodType) : False


                                                                                                                          object =&gt; object : &lt;class 'object'&gt;


                                                                                                         type(obj) =&gt; type(obj) : &lt;class '__main__.BaseMeta'&gt;</code></pre>
</div>
<div class="cell-output cell-output-display" data-execution_count="60">
<pre><code>&lt;Signature (d, e, f)&gt;</code></pre>
</div>
</div>
<div class="cell" data-tags="[]" data-execution_count="61">
<div class="sourceCode cell-code" id="cb113"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb113-1"><a href="#cb113-1" aria-hidden="true" tabindex="-1"></a>sig.<span class="bu">print</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>

                                                                                        hasattr(Foo, '__signature__') =&gt; hasattr(Foo, '__signature__') : True


                                                                                        hasattr(Foo, '__signature__') =&gt; hasattr(Foo, '__signature__') : True
def _signature_from_callable(obj, *,======================================================(0)       
                             follow_wrapper_chains=True,==================================(1)       
                             skip_bound_arg=True,=========================================(2)       
                             sigcls):=====================================================(3)       
                                                                                                                                                        (4)
    """Private helper function to get signature for arbitrary=============================(5)       
    callable objects.=====================================================================(6)       
    """===================================================================================(7)       
                                                                                                                                                        (8)
    _get_signature_of = functools.partial(_signature_from_callable,=======================(9) # so that it can use in itself
                                follow_wrapper_chains=follow_wrapper_chains,==============(10)      
                                skip_bound_arg=skip_bound_arg,============================(11)      
                                sigcls=sigcls)============================================(12)      
                                                                                                                                                        (13)
    if not callable(obj):=================================================================(14) # obj must be callable
        raise TypeError('{!r} is not a callable object'.format(obj))======================(15)      
                                                                                                                                                        (16)
    if isinstance(obj, types.MethodType):=================================================(17) # obj can be a classmethod
        # In this case we skip the first parameter of the underlying======================(18)      
        # function (usually `self` or `cls`).=============================================(19)      
        sig = _get_signature_of(obj.__func__)=============================================(20)      
                                                                                                                                                        (21)
        if skip_bound_arg:================================================================(22)      
            return _signature_bound_method(sig)===========================================(23)      
        else:=============================================================================(24)      
            return sig====================================================================(25)      
                                                                                                                                                        (26)
    # Was this function wrapped by a decorator?===========================================(27)      
    if follow_wrapper_chains:=============================================================(28) # does Foo has __signature__?
        obj = unwrap(obj, stop=(lambda f: hasattr(f, "__signature__")))===================(29) # why has to unwrap?
        if isinstance(obj, types.MethodType):=============================================(30) # what is wrapped by Foo?
            # If the unwrapped object is a *method*, we might want to=====================(31)      
            # skip its first parameter (self).============================================(32)      
            # See test_signature_wrapped_bound_method for details.========================(33)      
            return _get_signature_of(obj)=================================================(34)      
                                                                                                                                                        (35)
    try:==================================================================================(36)      
        sig = obj.__signature__===========================================================(37) # does Foo store sig inside __signature__
    except AttributeError:================================================================(38)      
        pass==============================================================================(39)      
    else:=================================================================================(40)      
        if sig is not None:===============================================================(41)      
            if not isinstance(sig, Signature):============================================(42)      
                raise TypeError(==========================================================(43)      
                    'unexpected object {!r} in __signature__ '============================(44)      
                    'attribute'.format(sig))==============================================(45)      
            return sig====================================================================(46)      
                                                                                                                                                        (47)
    try:==================================================================================(48)      
        partialmethod = obj._partialmethod================================================(49)      
    except AttributeError:================================================================(50)      
        pass==============================================================================(51)      
    else:=================================================================================(52)      
        if isinstance(partialmethod, functools.partialmethod):============================(53)      
            # Unbound partialmethod (see functools.partialmethod)=========================(54)      
            # This means, that we need to calculate the signature=========================(55)      
            # as if it's a regular partial object, but taking into========================(56)      
            # account that the first positional argument==================================(57)      
            # (usually `self`, or `cls`) will not be passed===============================(58)      
            # automatically (as for boundmethods)=========================================(59)      
                                                                                                                                                        (60)
            wrapped_sig = _get_signature_of(partialmethod.func)===========================(61)      
                                                                                                                                                        (62)
            sig = _signature_get_partial(wrapped_sig, partialmethod, (None,))=============(63)      
            first_wrapped_param = tuple(wrapped_sig.parameters.values())[0]===============(64)      
            if first_wrapped_param.kind is Parameter.VAR_POSITIONAL:======================(65)      
                # First argument of the wrapped callable is `*args`, as in================(66)      
                # `partialmethod(lambda *args)`.==========================================(67)      
                return sig================================================================(68)      
            else:=========================================================================(69)      
                sig_params = tuple(sig.parameters.values())===============================(70)      
                assert (not sig_params or=================================================(71)      
                        first_wrapped_param is not sig_params[0])=========================(72)      
                new_params = (first_wrapped_param,) + sig_params==========================(73)      
                return sig.replace(parameters=new_params)=================================(74)      
                                                                                                                                                        (75)
    if isfunction(obj) or _signature_is_functionlike(obj):================================(76) # step 7: run on itself will run here
        # If it's a pure Python function, or an object that is duck type==================(77)      
        # of a Python function (Cython functions, for instance), then:====================(78)      
        return _signature_from_function(sigcls, obj,======================================(79) # step 8: get sig with a different func
                                        skip_bound_arg=skip_bound_arg)====================(80)      
                                                                                                                                                        (81)
    if _signature_is_builtin(obj):========================================================(82)      
        return _signature_from_builtin(sigcls, obj,=======================================(83)      
                                       skip_bound_arg=skip_bound_arg)=====================(84)      
                                                                                                                                                        (85)
    if isinstance(obj, functools.partial):================================================(86)      
        wrapped_sig = _get_signature_of(obj.func)=========================================(87)      
        return _signature_get_partial(wrapped_sig, obj)===================================(88)      
                                                                                                                                                        (89)
    sig = None============================================================================(90)      
    if isinstance(obj, type):=============================================================(91) # step 1: obj is a class?
        # obj is a class or a metaclass===================================================(92)      
                                                                                                                                                        (93)
        # First, let's see if it has an overloaded __call__ defined=======================(94)      
        # in its metaclass================================================================(95)      
        call = _signature_get_user_defined_method(type(obj), '__call__')==================(96) # step 2: define its own __call__?
        if call is not None:==============================================================(97)      
            sig = _get_signature_of(call)=================================================(98) # __call__ is defined
        else:=============================================================================(99)      
            factory_method = None=========================================================(100)     
            new = _signature_get_user_defined_method(obj, '__new__')======================(101) # step 3: define its own __new__?
            init = _signature_get_user_defined_method(obj, '__init__')====================(102) # step 4: define its own __init__?
            # Now we check if the 'obj' class has an own '__new__' method=================(103)     
            if '__new__' in obj.__dict__:=================================================(104)     
                factory_method = new======================================================(105)     
            # or an own '__init__' method=================================================(106)     
            elif '__init__' in obj.__dict__:==============================================(107)     
                factory_method = init=====================================================(108) # step 5: __init__ is inside obj.__dict__?
            # If not, we take inherited '__new__' or '__init__', if present===============(109)     
            elif new is not None:=========================================================(110)     
                factory_method = new======================================================(111)     
            elif init is not None:========================================================(112)     
                factory_method = init=====================================================(113)     
                                                                                                                                                        (114)
            if factory_method is not None:================================================(115)     
                sig = _get_signature_of(factory_method)===================================(116) # step 6: run on itself using functools.partial
                                                                                                                                                        (117)
        if sig is None:===================================================================(118)     
            # At this point we know, that `obj` is a class, with no user-=================(119)     
            # defined '__init__', '__new__', or class-level '__call__'====================(120)     
                                                                                                                                                        (121)
            for base in obj.__mro__[:-1]:=================================================(122)     
                # Since '__text_signature__' is implemented as a==========================(123)     
                # descriptor that extracts text signature from the========================(124)     
                # class docstring, if 'obj' is derived from a builtin=====================(125)     
                # class, its own '__text_signature__' may be 'None'.======================(126)     
                # Therefore, we go through the MRO (except the last=======================(127)     
                # class in there, which is 'object') to find the first====================(128)     
                # class with non-empty text signature.====================================(129)     
                try:======================================================================(130)     
                    text_sig = base.__text_signature__====================================(131)     
                except AttributeError:====================================================(132)     
                    pass==================================================================(133)     
                else:=====================================================================(134)     
                    if text_sig:==========================================================(135)     
                        # If 'base' class has a __text_signature__ attribute:=============(136)     
                        # return a signature based on it==================================(137)     
                        return _signature_fromstr(sigcls, base, text_sig)=================(138)     
                                                                                                                                                        (139)
            # No '__text_signature__' was found for the 'obj' class.======================(140)     
            # Last option is to check if its '__init__' is================================(141)     
            # object.__init__ or type.__init__.===========================================(142)     
            if type not in obj.__mro__:===================================================(143)     
                # We have a class (not metaclass), but no user-defined====================(144)     
                # __init__ or __new__ for it==============================================(145)     
                if (obj.__init__ is object.__init__ and===================================(146)     
                    obj.__new__ is object.__new__):=======================================(147)     
                    # Return a signature of 'object' builtin.=============================(148)     
                    return sigcls.from_callable(object)===================================(149)     
                else:=====================================================================(150)     
                    raise ValueError(=====================================================(151)     
                        'no signature found for builtin type {!r}'.format(obj))===========(152)     
                                                                                                                                                        (153)
    elif not isinstance(obj, _NonUserDefinedCallables):===================================(154)     
        # An object with __call__=========================================================(155)     
        # We also check that the 'obj' is not an instance of==============================(156)     
        # _WrapperDescriptor or _MethodWrapper to avoid===================================(157)     
        # infinite recursion (and even potential segfault)================================(158)     
        call = _signature_get_user_defined_method(type(obj), '__call__')==================(159)     
        if call is not None:==============================================================(160)     
            try:==========================================================================(161)     
                sig = _get_signature_of(call)=============================================(162)     
            except ValueError as ex:======================================================(163)     
                msg = 'no signature found for {!r}'.format(obj)===========================(164)     
                raise ValueError(msg) from ex=============================================(165)     
                                                                                                                                                        (166)
    if sig is not None:===================================================================(167)     
        # For classes and objects we skip the first parameter of their====================(168)     
        # __call__, __new__, or __init__ methods==========================================(169)     
        if skip_bound_arg:================================================================(170)     
            return _signature_bound_method(sig)===========================================(171)     
        else:=============================================================================(172)     
            return sig====================================================================(173)     
                                                                                                                                                        (174)
    if isinstance(obj, types.BuiltinFunctionType):========================================(175)     
        # Raise a nicer error message for builtins========================================(176)     
        msg = 'no signature found for builtin function {!r}'.format(obj)==================(177)     
        raise ValueError(msg)=============================================================(178)     
                                                                                                                                                        (179)
    raise ValueError('callable {!r} is not supported by signature'.format(obj))===========(180)     
                                                                                                                                                        (181)</code></pre>
</div>
</div>
</section>
<section id="common-feature-of-the-solutions-above-by-fixsigmeta" class="level3">
<h3 class="anchored" data-anchor-id="common-feature-of-the-solutions-above-by-fixsigmeta">Common feature of the solutions above by FixSigMeta</h3>
<p>The key is to create <code>__signature__</code> for Foo, and store its signature from <code>__init__</code> inside of it</p>
<div class="cell" data-execution_count="62">
<div class="sourceCode cell-code" id="cb115"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb115-1"><a href="#cb115-1" aria-hidden="true" tabindex="-1"></a>g <span class="op">=</span> <span class="bu">globals</span>()</span>
<span id="cb115-2"><a href="#cb115-2" aria-hidden="true" tabindex="-1"></a>fsm <span class="op">=</span> Fastdb(FixSigMeta, g)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>

                                                                                        hasattr(Foo, '__signature__') =&gt; hasattr(Foo, '__signature__') : True


                                                                                        hasattr(Foo, '__signature__') =&gt; hasattr(Foo, '__signature__') : True</code></pre>
</div>
</div>
<div class="cell" data-execution_count="63">
<div class="sourceCode cell-code" id="cb117"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb117-1"><a href="#cb117-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> fastcore.meta <span class="im">import</span> _rm_self</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>

                                                                                        hasattr(Foo, '__signature__') =&gt; hasattr(Foo, '__signature__') : True


                                                                                        hasattr(Foo, '__signature__') =&gt; hasattr(Foo, '__signature__') : True</code></pre>
</div>
</div>
<div class="cell" data-execution_count="64">
<div class="sourceCode cell-code" id="cb119"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb119-1"><a href="#cb119-1" aria-hidden="true" tabindex="-1"></a>fsm.dbprint(<span class="dv">4</span>, <span class="st">"what is res?"</span>, <span class="st">"res"</span>, <span class="st">"inspect.signature(res.__init__)"</span>, <span class="st">"_rm_self(inspect.signature(res.__init__))"</span>)</span>
<span id="cb119-2"><a href="#cb119-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> BaseMeta(FixSigMeta): </span>
<span id="cb119-3"><a href="#cb119-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__new__</span>(cls, name, bases, <span class="bu">dict</span>): <span class="co"># not really overriding __new__, still using FixSigMeta.__new__ actually</span></span>
<span id="cb119-4"><a href="#cb119-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">super</span>().<span class="fu">__new__</span>(cls, name, bases, <span class="bu">dict</span>)</span>
<span id="cb119-5"><a href="#cb119-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__call__</span>(cls, <span class="op">*</span>args, <span class="op">**</span>kwargs): <span class="cf">pass</span></span>
<span id="cb119-6"><a href="#cb119-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb119-7"><a href="#cb119-7" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Foo(metaclass<span class="op">=</span>BaseMeta): <span class="co"># Base</span></span>
<span id="cb119-8"><a href="#cb119-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, d, e, f): <span class="cf">pass</span></span>
<span id="cb119-9"><a href="#cb119-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb119-10"><a href="#cb119-10" aria-hidden="true" tabindex="-1"></a>test_sig(Foo, <span class="st">'(d, e, f)'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>

                                                                                        hasattr(Foo, '__signature__') =&gt; hasattr(Foo, '__signature__') : True


                                                                                        hasattr(Foo, '__signature__') =&gt; hasattr(Foo, '__signature__') : True
    def __new__(cls, name, bases, dict):                                                                                                                (2)
        res = super().__new__(cls, name, bases, dict)                                                                                                   (3)
        if res.__init__ is not object.__init__: res.__signature__ = _rm_self(inspect.signature(res.__init__))===========================================(4)
                                                                                                                                                 what is res?
        return res                                                                                                                                      (5)
                                                                                                                                                        (6)


                                                                                                                          res =&gt; res : &lt;class '__main__.Foo'&gt;




                                                                               isinstance(obj, types.MethodType) =&gt; isinstance(obj, types.MethodType) : False


                                                                                                                          object =&gt; object : &lt;class 'object'&gt;


                                                                                                                  type(obj) =&gt; type(obj) : &lt;class 'function'&gt;
                                                                         inspect.signature(res.__init__) =&gt; inspect.signature(res.__init__) : (self, d, e, f)




                                                                               isinstance(obj, types.MethodType) =&gt; isinstance(obj, types.MethodType) : False


                                                                                                                          object =&gt; object : &lt;class 'object'&gt;


                                                                                                                  type(obj) =&gt; type(obj) : &lt;class 'function'&gt;
                                                           _rm_self(inspect.signature(res.__init__)) =&gt; _rm_self(inspect.signature(res.__init__)) : (d, e, f)


                                                                               isinstance(obj, types.MethodType) =&gt; isinstance(obj, types.MethodType) : False


                                                                                                                          object =&gt; object : &lt;class 'object'&gt;


                                                                                                                  type(obj) =&gt; type(obj) : &lt;class 'function'&gt;


                                                                               isinstance(obj, types.MethodType) =&gt; isinstance(obj, types.MethodType) : False


                                                                                                                          object =&gt; object : &lt;class 'object'&gt;


                                                                                                         type(obj) =&gt; type(obj) : &lt;class '__main__.BaseMeta'&gt;</code></pre>
</div>
</div>
<div class="cell" data-execution_count="65">
<div class="sourceCode cell-code" id="cb121"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb121-1"><a href="#cb121-1" aria-hidden="true" tabindex="-1"></a>fsm.<span class="bu">print</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>

                                                                               isinstance(obj, types.MethodType) =&gt; isinstance(obj, types.MethodType) : False


                                                                                                                          object =&gt; object : &lt;class 'object'&gt;


                                                                                                                  type(obj) =&gt; type(obj) : &lt;class 'function'&gt;


                                                                               isinstance(obj, types.MethodType) =&gt; isinstance(obj, types.MethodType) : False


                                                                                                                          object =&gt; object : &lt;class 'object'&gt;


                                                                                                                  type(obj) =&gt; type(obj) : &lt;class 'function'&gt;
class FixSigMeta(type):===================================================================(0)       
    "A metaclass that fixes the signature on classes that override `__new__`"=============(1)       
    def __new__(cls, name, bases, dict):==================================================(2)       
        res = super().__new__(cls, name, bases, dict)=====================================(3)       
        if res.__init__ is not object.__init__: res.__signature__ = _rm_self(inspect.signature(res.__init__)) # what is res?                            (4)
        return res========================================================================(5)       
                                                                                                                                                        (6)</code></pre>
</div>
</div>
<div class="cell" data-execution_count="66">
<div class="sourceCode cell-code" id="cb123"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb123-1"><a href="#cb123-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> fastcore.meta <span class="im">import</span> test_eq</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>

                                                                               isinstance(obj, types.MethodType) =&gt; isinstance(obj, types.MethodType) : False


                                                                                                                          object =&gt; object : &lt;class 'object'&gt;


                                                                                                                  type(obj) =&gt; type(obj) : &lt;class 'function'&gt;


                                                                               isinstance(obj, types.MethodType) =&gt; isinstance(obj, types.MethodType) : False


                                                                                                                          object =&gt; object : &lt;class 'object'&gt;


                                                                                                                  type(obj) =&gt; type(obj) : &lt;class 'function'&gt;</code></pre>
</div>
</div>
<div class="cell" data-execution_count="67">
<div class="sourceCode cell-code" id="cb125"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb125-1"><a href="#cb125-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> BaseMeta(FixSigMeta): </span>
<span id="cb125-2"><a href="#cb125-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># __new__ comes from FixSigMeta</span></span>
<span id="cb125-3"><a href="#cb125-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__new__</span>(cls, <span class="op">*</span>args, <span class="op">**</span>kwargs): <span class="cf">pass</span> <span class="co"># actually overriding __new__, not using FixSigMeta.__new__ anymore</span></span>
<span id="cb125-4"><a href="#cb125-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__call__</span>(cls, <span class="op">*</span>args, <span class="op">**</span>kwargs): <span class="cf">pass</span></span>
<span id="cb125-5"><a href="#cb125-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb125-6"><a href="#cb125-6" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Foo(metaclass<span class="op">=</span>BaseMeta): <span class="co"># Base</span></span>
<span id="cb125-7"><a href="#cb125-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, d, e, f): <span class="cf">pass</span></span>
<span id="cb125-8"><a href="#cb125-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb125-9"><a href="#cb125-9" aria-hidden="true" tabindex="-1"></a>test_eq(<span class="bu">type</span>(Foo), <span class="bu">type</span>(<span class="va">None</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>

                                                                               isinstance(obj, types.MethodType) =&gt; isinstance(obj, types.MethodType) : False


                                                                                                                          object =&gt; object : &lt;class 'object'&gt;


                                                                                                                  type(obj) =&gt; type(obj) : &lt;class 'function'&gt;


                                                                               isinstance(obj, types.MethodType) =&gt; isinstance(obj, types.MethodType) : False


                                                                                                                          object =&gt; object : &lt;class 'object'&gt;


                                                                                                                  type(obj) =&gt; type(obj) : &lt;class 'function'&gt;</code></pre>
</div>
</div>
<p>Note: if Base also defines <code>__init__</code>, then FixSigMeta can still help.</p>
<div class="cell" data-execution_count="68">
<div class="sourceCode cell-code" id="cb127"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb127-1"><a href="#cb127-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> BaseMeta(FixSigMeta): </span>
<span id="cb127-2"><a href="#cb127-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># __new__ comes from FixSigMeta</span></span>
<span id="cb127-3"><a href="#cb127-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(cls, <span class="op">*</span>args, <span class="op">**</span>kwargs): <span class="cf">pass</span> <span class="co"># overriding __init__ of FixSigMeta, is fine</span></span>
<span id="cb127-4"><a href="#cb127-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__call__</span>(cls, <span class="op">*</span>args, <span class="op">**</span>kwargs): <span class="cf">pass</span></span>
<span id="cb127-5"><a href="#cb127-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb127-6"><a href="#cb127-6" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Foo(metaclass<span class="op">=</span>BaseMeta): <span class="co"># Base</span></span>
<span id="cb127-7"><a href="#cb127-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, d, e, f): <span class="cf">pass</span></span>
<span id="cb127-8"><a href="#cb127-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb127-9"><a href="#cb127-9" aria-hidden="true" tabindex="-1"></a>test_sig(Foo, <span class="st">'(d, e, f)'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>

                                                                               isinstance(obj, types.MethodType) =&gt; isinstance(obj, types.MethodType) : False


                                                                                                                          object =&gt; object : &lt;class 'object'&gt;


                                                                                                                  type(obj) =&gt; type(obj) : &lt;class 'function'&gt;


                                                                               isinstance(obj, types.MethodType) =&gt; isinstance(obj, types.MethodType) : False


                                                                                                                          object =&gt; object : &lt;class 'object'&gt;


                                                                                                                  type(obj) =&gt; type(obj) : &lt;class 'function'&gt;


                                                                                                                          res =&gt; res : &lt;class '__main__.Foo'&gt;




                                                                               isinstance(obj, types.MethodType) =&gt; isinstance(obj, types.MethodType) : False


                                                                                                                          object =&gt; object : &lt;class 'object'&gt;


                                                                                                                  type(obj) =&gt; type(obj) : &lt;class 'function'&gt;
                                                                         inspect.signature(res.__init__) =&gt; inspect.signature(res.__init__) : (self, d, e, f)




                                                                               isinstance(obj, types.MethodType) =&gt; isinstance(obj, types.MethodType) : False


                                                                                                                          object =&gt; object : &lt;class 'object'&gt;


                                                                                                                  type(obj) =&gt; type(obj) : &lt;class 'function'&gt;
                                                           _rm_self(inspect.signature(res.__init__)) =&gt; _rm_self(inspect.signature(res.__init__)) : (d, e, f)


                                                                               isinstance(obj, types.MethodType) =&gt; isinstance(obj, types.MethodType) : False


                                                                                                                          object =&gt; object : &lt;class 'object'&gt;


                                                                                                                  type(obj) =&gt; type(obj) : &lt;class 'function'&gt;


                                                                               isinstance(obj, types.MethodType) =&gt; isinstance(obj, types.MethodType) : False


                                                                                                                          object =&gt; object : &lt;class 'object'&gt;


                                                                                                         type(obj) =&gt; type(obj) : &lt;class '__main__.BaseMeta'&gt;</code></pre>
</div>
</div>
<div class="cell" data-execution_count="70">
<div class="sourceCode cell-code" id="cb129"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb129-1"><a href="#cb129-1" aria-hidden="true" tabindex="-1"></a>fsm.dbprint(<span class="dv">3</span>, <span class="st">"what inside the dbsrc?"</span>, <span class="st">"env"</span>, showdbsrc<span class="op">=</span><span class="va">True</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>

                                                                               isinstance(obj, types.MethodType) =&gt; isinstance(obj, types.MethodType) : False


                                                                                                                          object =&gt; object : &lt;class 'object'&gt;


                                                                                                                  type(obj) =&gt; type(obj) : &lt;class 'function'&gt;


                                                                               isinstance(obj, types.MethodType) =&gt; isinstance(obj, types.MethodType) : False


                                                                                                                          object =&gt; object : &lt;class 'object'&gt;


                                                                                                                  type(obj) =&gt; type(obj) : &lt;class 'function'&gt;
    "A metaclass that fixes the signature on classes that override `__new__`"                                                                           (1)
    def __new__(cls, name, bases, dict):                                                                                                                (2)
        res = super().__new__(cls, name, bases, dict)===================================================================================================(3)
                                                                                                                                       what inside the dbsrc?
        if res.__init__ is not object.__init__: res.__signature__ = _rm_self(inspect.signature(res.__init__))                                           (4)
        return res                                                                                                                                      (5)
class FixSigMeta(type):                                                                                                                                 (0)
    "A metaclass that fixes the signature on classes that override `__new__`"                                                                           (1)
    def __new__(cls, name, bases, dict):                                                                                                                (2)
        g = locals()                                                                                                                                    (3)
        dbprintinsert("env",env=g)                                                                                                                      (db)
        res = super().__new__(cls, name, bases, dict)                                                                                                   (5)
        if res.__init__ is not object.__init__: res.__signature__ = _rm_self(inspect.signature(res.__init__))                                           (6)
        return res                                                                                                                                      (7)</code></pre>
</div>
<div class="cell-output cell-output-display" data-execution_count="70">
<pre><code>__main__.FixSigMeta</code></pre>
</div>
</div>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    setTimeout(function() {
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const cites = ref.parentNode.getAttribute('data-cites').split(' ');
    tippyHover(ref, function() {
      var popup = window.document.createElement('div');
      cites.forEach(function(cite) {
        var citeDiv = window.document.createElement('div');
        citeDiv.classList.add('hanging-indent');
        citeDiv.classList.add('csl-entry');
        var biblioDiv = window.document.getElementById('ref-' + cite);
        if (biblioDiv) {
          citeDiv.innerHTML = biblioDiv.innerHTML;
        }
        popup.appendChild(citeDiv);
      });
      return popup.innerHTML;
    });
  }
});
</script>
</div> <!-- /content -->



</body></html>