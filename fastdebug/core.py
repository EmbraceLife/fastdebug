# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/lib/00_core.ipynb.

# %% auto 0
__all__ = ['defaults', 'pprint', 'inspect', 'dbcolors', 'randomColor', 'colorize', 'strip_ansi', 'printright',
           'printsrclinewithidx', 'printsrc', 'dbprintinsert', 'Fastdb', 'randomize_cmtparts_color', 'reliveonce']

# %% ../nbs/lib/00_core.ipynb 8
defaults = type('defaults', (object,), {'margin': 157, # align to the right by 157
                                        'orisrc': None, # keep a copy of original official src code
                                        'outenv': globals(), # outside global env
                                        'cmts': {} # a dict to store idx and cmt
                                        # 'eg': None, # examples
                                        # 'src': None, # official src
                                       }) 

# %% ../nbs/lib/00_core.ipynb 23
import pprint

# %% ../nbs/lib/00_core.ipynb 24
pprint = pprint.pprint # so that pprint is included inside __all__

# %% ../nbs/lib/00_core.ipynb 35
import inspect

# %% ../nbs/lib/00_core.ipynb 36
inspect = inspect # so that inspect is included inside __all__

# %% ../nbs/lib/00_core.ipynb 56
from fastcore.basics import *

# %% ../nbs/lib/00_core.ipynb 57
class dbcolors: # removing ;1 will return to normal color, with ;1 is bright color
    # "to access color in string for print, using dbcolors.g or dbcolors.r etc."
    g = '\033[92;1m' #GREEN
    y = '\033[93;1m' #YELLOW
    r = '\033[91;1m' #RED
    m = '\u001b[35;1m' # megenta
    c = '\u001b[36;1m' # cyan
    b = '\u001b[34;1m' # blue
    w = '\u001b[37;1m' # white
    reset = '\033[0m' #RESET COLOR

# %% ../nbs/lib/00_core.ipynb 58
import random

# %% ../nbs/lib/00_core.ipynb 60
def randomColor():
    "create a random color by return a random dbcolor from dbcolors"
    colst = ['b', 'c', 'm', 'r', 'y', 'w', 'g']
    dictNumColor = {i:v for i, v in zip(range(len(colst)), colst)}

    return dictNumColor[random.randint(0, 6)]

# %% ../nbs/lib/00_core.ipynb 62
def colorize(cmt, color:str=None):
    "return the string with dbcolors"
    if type(cmt) != str:
        cmt = str(cmt)
    if color == "g":
        return dbcolors.g + cmt + dbcolors.reset
    elif color == "y":
        return dbcolors.y + cmt + dbcolors.reset
    elif color == "r":
        return dbcolors.r + cmt + dbcolors.reset
    elif color == "b":
        return dbcolors.b + cmt + dbcolors.reset
    elif color == "c":
        return dbcolors.c + cmt + dbcolors.reset    
    elif color == "m":
        return dbcolors.m + cmt + dbcolors.reset    
    elif color == "w":
        return dbcolors.w + cmt + dbcolors.reset    
    else: 
        return cmt

# %% ../nbs/lib/00_core.ipynb 66
import re

# %% ../nbs/lib/00_core.ipynb 67
def strip_ansi(source):
    "to make printright work using regex"
    return re.sub(r'\033\[(\d|;)+?m', '', source)

# %% ../nbs/lib/00_core.ipynb 71
def printright(blocks, margin:int=157):
    "print a block of text to the right of the cell"
    lst = blocks.split('\n')
    maxlen = max(map(lambda l : len(strip_ansi(l)) , lst ))
    indent = margin - maxlen
    for l in lst:
        print(' '*indent + format(l))

# %% ../nbs/lib/00_core.ipynb 86
import inspect

# %% ../nbs/lib/00_core.ipynb 101
def printsrclinewithidx(idx, l, fill=" "):
    "add idx number to a srcline"
    totallen = 157
    lenidx = 5
    lenl = len(l)
    print(l + fill*(totallen-lenl-lenidx) + "(" + str(idx) + ")")

# %% ../nbs/lib/00_core.ipynb 108
def printsrc(src, # name of src code such as foo, or delegates
             dbcode, # string of codes or int of code idx number
             cmt,
             expand:int=2): # expand the codes around the srcline under investigation
    "print the seleted srcline with comment, idx and specified num of expanding srclines"
    lstsrc = inspect.getsource(src).split('\n')
    
    dblines = ""
    if type(dbcode) == int:
        dblines = lstsrc[dbcode]
    else:
        dblines = dbcode
        numdblines = list(map(lambda x: bool(x.strip()), dblines.split('\n'))).count(True)
    
    
    dblineidx = []
    for idx, l in zip(range(len(lstsrc)), lstsrc):
        if bool(l) and l.strip() in dblines:
            dblineidx.append(idx)

    for idx, l in zip(range(len(lstsrc)), lstsrc):
        
        srcidx = dbcode if type(dbcode) == int else dblineidx[0]
        
        if bool(l) and l.strip() in dblines and idx == srcidx:
            printsrclinewithidx(idx, l, fill="=")

            if bool(cmt):
                colcmt = colorize(cmt, "r")
#                 alignright(colcmt) # also print the comment
                printright(colcmt) # also print the comment                

        if idx >= srcidx - expand and idx < srcidx:
            printsrclinewithidx(idx, l)
        elif idx <= srcidx + expand and idx > srcidx:
            printsrclinewithidx(idx, l)


# %% ../nbs/lib/00_core.ipynb 160
import ast

# %% ../nbs/lib/00_core.ipynb 161
def dbprintinsert(*codes, env={}): 
    "insert arbitary code expressions into source code for evaluation"
        
    # trial and error version for real code, still not quite why globals vs locals work in exec and eval
    for c in codes:
        print("\n")
        
        # handle a block of code
        if "\n" in c: 
            output = f"Running the code block above => "
            print('{:<157}'.format(c))
            print()
            print('{:=<100}'.format(output)) 
            print()
            block = ast.parse(c, mode='exec')
            exec(compile(block, '<string>', mode='exec'), globals().update(env))
        
        # handle assignment:  1. when no if only =; 2. when = occur before if;
        elif ("=" in c and "if" not in c) or ("=" in c and c.find("=") < c.find("if")): 
            
            # print('k' in locals())
            exec(c, globals().update(env)) 
            # print('k' in locals())
            variable = c.partition(" = ")[0]
            # print(f"{c} => {variable}: {eval(variable)}")
            output = f"{c} => {variable}: {eval(variable)}"
            print('{:>157}'.format(output))       
            
        # handle if statement
        # Note: do insert code like this : `if abc == def: print(abc)`, print is a must
        elif "if" in c: 
            cond = re.search('if (.*?):', c).group(1)
            
            # when code in string is like 'if abc == def:'
            if c.endswith(':'):
                
                # print ... 
                # print(f"{c} => {cond}: {eval(cond)}")      
                output = f"{c} => {cond}: {eval(cond)}"
                print('{:>157}'.format(output))
                
            # when code in string is like 'if abc == def: print(...)'
            else: 
                # if the cond is true, then print ...
                if eval(cond):
                    
                    # "if abc == def: print(abc)".split(': ', 2)[1] to get 'print(abc)'
                    printc = c.split(': ', 1)[1]
                    # print(f"{c} => {printc} : ")
                    output = f"{c} => {printc} : "
                    print('{:>157}'.format(output))      
                    exec(c, globals().update(env))
                    
                # if cond is false, then print ...
                else: 
                    # print(f"{c} => {cond}: {eval(cond)}")
                    output = f"{c} => {cond}: {eval(cond)}"
                    print('{:>157}'.format(output))   
                
                
        # handle for in statement
        elif "for " in c and " in " in c:           
            
            # in example like 'for k, v in abc:' or `for k, v in abc: print(...)`, if abc is empty
            # step 1: access abc
            # get the substring between 'in ' and ':', which is like 'abc'
            abc = re.search('in (.*?):', c).group(1)
            # if abc is empty dict or list: print and pass
            if not bool(eval(abc)): 
                # print(f'{c} => {abc} is an emtpy {type(eval(abc))}')
                output = f'{c} => {abc} is an emtpy {type(eval(abc))}'
                print('{:>157}'.format(output))   
                continue 
                # The break statement can be used if you need to break out of a for or while loop and move onto the next section of code.
                # The continue statement can be used if you need to skip the current iteration of a for or while loop and move onto the next iteration.
            
            # if the code in string is like 'for k, v in abc:', there is no more code after `:`
            if c.endswith(':'):
                
                # get the substring between 'for ' and ' in', which is like 'k, v'
                variables = re.search('for (.*?) in', c).group(1)
                
                # if variables has a substring like ', ' inside
                if (',') in variables: 
                    
                    # split it by ', ' into a list of substrings
                    vl = variables.split(',')
                    key = vl[0]
                    value = vl[1]
                    
                    # make sure key and value will get evaluated first before exec run
                    # printc is for exec to run
                    printc = "print(f'{key}:{eval(key)}, {type(eval(key))} ; {value}:{eval(value)}, {type(eval(value))}')" 
                    # printmsg is for reader to understand with ease
                    printmsg = "print(f'key: {key}, {type(key)} ; value: {value}, {type(value)}')"
                    c1 = c + " " + printc
                    # print(f"{c} => {printmsg} : ")      
                    output = f"{c} => {printmsg} : "
                    print('{:>157}'.format(output))   
                    exec(c1, globals().update(env))
                
                else:
                    printc = "print(f'{variables} : {eval(variables)}')"
                    printmsg = "print(f'i : {variables}')"
                    c1 = c + " " + printc
                    # print(f"{c} => {printmsg} : ")     
                    output = f"{c} => {printmsg} : "
                    print('{:>157}'.format(output))   
                    exec(c1, globals().update(env))
                    
            # if the code in string is like 'for k, v in abc: print(abc)'
            else:                 
                # "for k, v in abc: print(k)".split(': ', 1)[1] to get 'print(k)'
                printc = c.split(': ', 1)[1]
                # print(f"{c} => {printc} : ")
                output = f"{c} => {printc} : "
                print('{:>157}'.format(output))   
                exec(c, globals().update(env)) # we can't use eval to run `for in` loop, but exec can.
            ### Note: we shall not use the expression like `for k, v in abc print(abc)`
            ### Note: we shall not use the expression like `for k, v in abc if k == def`
        
        
        # handle evaluation
        else: 
            print('{:>157}'.format(f"{c} => {c} : {eval(c, globals().update(env))}"))   
            
        # the benefit of using global().update(env) is 
        # to ensure we don't need to include the same env fo

# %% ../nbs/lib/00_core.ipynb 271
class Fastdb():

    def __init__(self, 
                 src, # name of src code you are exploring
                 db=False, # db=True will run some debugging prints
                 outloc={}): # outloc = g; g = locals() from the outer cell
        "Create a Fastdebug class which has two functionalities: dbprint and print."
        self.orisrc = src # important: it is making a real copy
        self.dbsrc = None # store dbsrc func
        self.dbsrcstr = None # store dbsrc string
        self.idxsrc = None # the idx of srcline under investigation
        self.margin = 157
        if inspect.isfunction(src):
            self.outenv = src.__globals__
#         elif type(src) == type:
        elif inspect.isclass(src):
            exec(f"import {src.__module__}")
            self.outenv = eval(src.__module__ + ".__dict__")
#             self.outenv = env # this approach works
        self.cmts = {}
        self.egsidx = {}
        self.orieg = ""
        self.eg = "" # add example in string format
        self.egEnv = outloc # no need to use self.takExample()
        if db:
            print(f"self.orisrc: {self.orisrc.__name__} is self.outenv['{self.orisrc.__name__}']: {self.orisrc is self.outenv[self.orisrc.__name__]}")

# %% ../nbs/lib/00_core.ipynb 318
@patch
def printtitle(self:Fastdb):
    "print title which includes src name, line number under investigation, example."
    if 'self.dbsrc' not in self.eg:
        self.orieg = self.eg  # make sure self.orieg has no self inside
    print('{:=^157}'.format(f"     Investigating {colorize(self.orisrc.__name__, color='r')}     ")) 
    print('{:=^157}'.format(f"     on line {colorize(str(self.idxsrc), color='r')}     "))
    print('{:=^157}'.format(f"     with example {colorize(self.orieg, color='r')}     ")) 
    print()

# %% ../nbs/lib/00_core.ipynb 327
@patch
def docsrc(self:Fastdb, 
            idxsrc:int, # idx of a srcline under investigation, can only be int
            cmt:str, # comment added to the srcline
            *codes, # a list of expressions (str) you write to be evaluated above the srcline
            expand:int=2, # span 2 lines of srcode up and down from the srcline investigated
            db:bool=False): # display debugging print
    "create dbsrc the string and turn the string into actual dbsrc function, we have self.dbsrcstr and self.dbsrc available from now on."
#     self.goback() # refresh, but put it in the front will cause multiple reprints of dbcodes outputs
    src = self.orisrc
    self.idxsrc = idxsrc
    
    if type(idxsrc) == int: 
        self.cmts.update({idxsrc: cmt})
        self.egsidx.update({idxsrc: self.eg}) # add up idxsrc: self.eg

    self.printtitle()    
    print('{:-<60}'.format(colorize("print selected srcline with expands below", color="y")))    
    printsrc(src, idxsrc, cmt, expand)
    
    if not bool(codes): return
    
    # create dbsrc the string
    self.create_dbsrc_string(idxsrc, *codes)
    
    # creating dbsrc as function from a string
    self.create_dbsrc_from_string()
    
    # run example with dbsrc
    self.run_example(db=db)


# %% ../nbs/lib/00_core.ipynb 333
@patch
def create_dbsrc_from_string(self:Fastdb):
    "create dbsrc from a string"
    file_name ='/tmp/' + self.orisrc.__name__ + '.py' 
    # learn about /tmp folder https://www.fosslinux.com/41739/linux-tmp-directory-everything-you-need-to-know.htm
    with open(file_name, 'w') as f:
        f.write(self.dbsrcstr)
    
    code = compile(self.dbsrcstr, file_name, 'exec')
    exec(code, globals().update(self.outenv)) # when dbsrc is a method, it will update as part of a class
    
    # store dbsrc func inside Fastdb obj
    self.dbsrc = locals()[self.orisrc.__name__]

    # replace original srcode with self.
#     self.egEnv[self.orisrc.__name__] = self.dbsrc

#     print(f'create_dbsrc_from_string, locals(): {locals()}')
#     print(f'locals()[self.orisrc.__name__] src is {inspect.getsource(locals()[self.orisrc.__name__])}')
#     print(f'create_dbsrc_from_string, self.dbsrcstr: {self.dbsrcstr}')
#     print(f'create_dbsrc_from_string, inspect.getsource(self.dbsrc): {inspect.getsource(self.dbsrc)}')

# %% ../nbs/lib/00_core.ipynb 337
@patch
def create_dbsrc_string(self:Fastdb, idxsrc, *codes):
    "create the dbsrc string"
    dbsrc = ""
    indent = 4

    lst = inspect.getsource(self.orisrc).split('\n')
    if not bool(lst[-1]): lst = lst[:-1]

    codes = [i  for i in codes if bool(i.strip())]

    if type(idxsrc) == int: srclines = lst[idxsrc]  
    else: raise TypeError("decode must be an integer.")

    # writing up dbsrc in string
    for idx, l in zip(range(len(lst)), lst):
        if bool(l.strip()) and l.strip() in srclines and idx == idxsrc:

            if len(codes) > 0: 
                numindent = len(l) - len(l.lstrip()) 
                dbcodes = "dbprintinsert("
                count = 1
                for c in codes:
                    if count == len(codes):
                        dbcodes = dbcodes + '"' + c + '"' + "," + "env=g" + ")"
                    else:
                        dbcodes = dbcodes + '"' + c + '"' + ","
                    count = count + 1

                emptyline = "print()"
                exploreStart = "print('{:=>157}'.format(colorize(f'Start of my srcline exploration:', color='r')))"
                exploreEnd = "print('{:=>157}'.format(colorize('End of my srcline exploration:', color='r')))"
                dbsrc = dbsrc + " "*numindent + emptyline + '\n'                   
                dbsrc = dbsrc + " "*numindent + exploreStart + '\n'   
                dbsrc = dbsrc + " "*numindent + "g = locals()" + '\n'
                dbsrc = dbsrc + " "*numindent + dbcodes + '\n'
                dbsrc = dbsrc + " "*numindent + exploreEnd + '\n'
                dbsrc = dbsrc + " "*numindent + emptyline + '\n'                   
                dbsrc = dbsrc + l + '\n'     
            else:
                dbsrc = dbsrc + l + '\n'                

        elif bool(l.strip()) and idx + 1 == len(lst):
            dbsrc = dbsrc + l
        else: # make sure this printout is identical to the printsrc output
            dbsrc = dbsrc + l + '\n'

    # store dbsrc in string to the Fastdb obj
    self.dbsrcstr = dbsrc 


# %% ../nbs/lib/00_core.ipynb 356
@patch
def replaceWithDbsrc(self:Fastdb, db=False):
    "to replace self.orisrc.__name__ with 'self.dbsrc' and assign this new self.eg to self.eg"
    new_eg = ""
#     if type(self.orisrc) == type: # as class
    if inspect.isclass(self.orisrc):
        for l in self.eg.split('\n'):
            # 1. class Foo(TargetCalss): ; 2. class Foo(metaclass=TargetClass): ; 4: class _T(_TestA, metaclass=BypassNewMeta):
            if "(" + self.orisrc.__name__ + ")" in l or "(metaclass=" + self.orisrc.__name__ + ")" in l \
            or ", metaclass=" + self.orisrc.__name__ + ")" in l: 
                lst = l.split(f'{self.orisrc.__name__ + ")"}')
                new_eg = new_eg + lst[0] + "self.dbsrc)" + lst[1] + "\n"
            elif "(" + self.orisrc.__name__ + "," in l: # 3. class Foo(TargetClass, OtherClass)
                lst = l.split(f'{self.orisrc.__name__ + ","}')
                new_eg = new_eg + lst[0] + "self.dbsrc," + lst[1] + "\n"
            else:
                new_eg = new_eg + l + "\n"
    
    else: # as function
        for l in self.eg.split('\n'):
            if "@" + self.orisrc.__name__ in l: # handling @delegates with indentation
                indent = len(l) - len(l.lstrip())
                lst = l.split("@" + self.orisrc.__name__)
                new_eg = new_eg + " "*indent + "@self.dbsrc" + lst[1] + "\n"
            elif self.orisrc.__name__ + "(" in l:
                lst = l.split(self.orisrc.__name__ + '(') 
                start = ""
                if lst[0].endswith(".") and "(" not in lst[0]: # if lst[0] = inspect.
                    start = "" # then remove 'inspect.'
                elif lst[0].endswith(".") and "(" in lst[0]: # if lst[0] = abc(print(inspect.
                    start = ""
                    for l in lst[0].split('(')[:-1]: # remove the last item, 'inspect.'
                        start = start + l + '('
                else:
                    start = lst[0]
                rest = lst[1]
                new_eg = new_eg + start + "self.dbsrc(" + rest + "\n"
            else:
                new_eg = new_eg + l + "\n"

    self.eg = new_eg

# %% ../nbs/lib/00_core.ipynb 369
@patch
def run_example(self:Fastdb, db=False):
    "run self.eg with self.dbsrc"
    self.replaceWithDbsrc()
    # use locals() as global env to bring in self or obj to enable self.dbsrc to run
    # use globals() to see whether pprint can be brought in 
    # so combine them both can have them both, as globals() do not contain locals() fully  
    globals().update(self.egEnv)
    globals().update(locals())
    exec(self.eg, globals()) # this is totally different from  =>   exec(self.eg, globals(), {})
    # leaving the local param as default, is using funcs and classes defined inside self.eg
    
    self.autoprint()
      

# %% ../nbs/lib/00_core.ipynb 374
@patch
def autoprint(self:Fastdb, maxpcell=20):
    "print srcode with appropriate number of lines automatically"
    totalines = len(inspect.getsource(self.orisrc).split('\n'))
    idx = self.idxsrc
    if bool(idx): 
        pt = idx // maxpcell 
    else:
        return
    
    print()
    print('{:=<157}'.format(colorize("Review srcode with all comments added so far", color="y")))
    if idx > maxpcell and idx % maxpcell != 0:
        self.print(maxpcell, pt + 1)
    elif idx % maxpcell == 0:
        self.print(maxpcell, pt + 1)
    else:
        self.print(maxpcell, 1)
    print()

# %% ../nbs/lib/00_core.ipynb 390
import os

# %% ../nbs/lib/00_core.ipynb 391
@patch
def printcmts1(self:Fastdb, maxlines, save=False):
    "print the entire srcode and save it to a file if save=True"
    totallen = 157
    lenidx = 5
    lspace = 10
    lstsrc = inspect.getsource(self.orisrc).split('\n')
    numparts = len(lstsrc) // maxlines + 1 if len(lstsrc) % maxlines != 0 else len(lstsrc) // maxlines
    cmts = self.cmts
    idxcmts = {k: idx for (k, v), idx in zip(cmts.items(), range(len(list(cmts))))} # order of cmts correspond to idxsrc

    randCol1 = randomColor()
    randCol2 = randomColor()    
    
    file_name ='/Users/Natsume/Documents/fastdebug/learnings/' + self.orisrc.__name__ + '.py' 
    # learn about /tmp folder https://www.fosslinux.com/41739/linux-tmp-directory-everything-you-need-to-know.htm
#     open(file_name, 'w').close()
    if os.path.exists(file_name):
        os.remove(file_name)
    
    with open(file_name, 'w') as f:
        f.write(self.orieg + "\n")
        
    for idx, l in zip(range(len(lstsrc)), lstsrc):
        lenl = len(l)

        if not bool(l.strip()):
            print(l + " "*(totallen-lenl-lenidx) + "(" + str(idx) + ")")
            with open(file_name, 'a') as f:
                f.write(l + " "*(totallen-lenl-lenidx) + "(" + str(idx) + ")"+ "\n")

        elif lenl + lspace >= 100:
            if bool(cmts):
                cmtidx = [cmt[0] for cmt in list(cmts.items())]
                if idx in cmtidx:
                    print(l + " # " + randomize_cmtparts_color(cmts[idx]) + \
                          #colorize(cmts[idx], color=randCol1) + \
                          " "*(totallen-lenl-lenidx-len(cmts[idx])-3) + " (" + str(idx) + ")")
                    with open(file_name, 'a') as f:
                        f.write(l + " # " + randomize_cmtparts_color(cmts[idx]) + \
                          " "*(totallen-lenl-lenidx-len(cmts[idx])-3) + " (" + str(idx) + ")" + "\n")
                else:
                    print(l + " "*(totallen-lenl-lenidx) + "(" + str(idx) + ")")
                    with open(file_name, 'a') as f:
                        f.write(l + " "*(totallen-lenl-lenidx) + "(" + str(idx) + ")" + "\n")
            else: 
                print(l + " "*(totallen-lenl-lenidx) + "(" + str(idx) + ")")
                with open(file_name, 'a') as f:
                    f.write(l + " "*(totallen-lenl-lenidx) + "(" + str(idx) + ")" + "\n")
        else:                
            if bool(cmts):
                cmtidx = [cmt[0] for cmt in list(cmts.items())]
                if idx in cmtidx:
                    print('{:<100}'.format(l + "="*(100-lenl-lspace) + f"({idx})" + " # " + \
                                           randomize_cmtparts_color(cmts[idx])))#colorize(cmts[idx], color=randCol1)))
                    with open(file_name, 'a') as f:
                        f.write('{:<100}'.format(l + "="*(100-lenl-lspace) + f"({idx})" + " # " + \
                                           randomize_cmtparts_color(cmts[idx])) + "\n")
                else:
                    print('{:<100}'.format(l + "="*(100-lenl-lspace) + f"({idx})"))                                                      
                    with open(file_name, 'a') as f:
                        f.write('{:<100}'.format(l + "="*(100-lenl-lspace) + f"({idx})") + "\n")                                                      
            else:
                print('{:<100}'.format(l + "="*(100-lenl-lspace) + f"({idx})"))    
                with open(file_name, 'a') as f:
                    f.write('{:<100}'.format(l + "="*(100-lenl-lspace) + f"({idx})") + "\n")                    


# %% ../nbs/lib/00_core.ipynb 395
@patch
def printcmts2(self:Fastdb, maxlines, part):
    "print the srcodes in parts"
    totallen = 157
    lenidx = 5
    lspace = 10
    lstsrc = inspect.getsource(self.orisrc).split('\n')
    numparts = len(lstsrc) // maxlines + 1 if len(lstsrc) % maxlines != 0 else len(lstsrc) // maxlines
    cmts = self.cmts
    idxcmts = {k: idx for (k, v), idx in zip(cmts.items(), range(len(list(cmts))))} # order of cmts correspond to idxsrc

    randCol1 = randomColor()
    randCol2 = randomColor()    
    for p in range(numparts):
        for idx, l in zip(range(len(lstsrc)), lstsrc):

            if (maxlines*p <= idx < maxlines*(p+1) and p+1 == part):
                lenl = len(l)
                if not bool(l.strip()):
                    print(l + " "*(totallen-lenl-lenidx) + "(" + str(idx) + ")")
                elif lenl + lspace >= 100:
                    if bool(cmts):
                        cmtidx = [cmt[0] for cmt in list(cmts.items())]
                        if idx in cmtidx:
                            print(l + " # " + randomize_cmtparts_color(cmts[idx]) + \
                                  #colorize(cmts[idx], color=randCol1) + \
                              " "*(totallen-lenl-lenidx-len(cmts[idx])-3) + " (" + str(idx) + ")")
                        else:
                            print(l + " "*(totallen-lenl-lenidx) + "(" + str(idx) + ")")
                    else: 
                        print(l + " "*(totallen-lenl-lenidx) + "(" + str(idx) + ")")

                else:
                    if bool(cmts):
                        cmtidx = [cmt[0] for cmt in list(cmts.items())]
                        if idx in cmtidx:
                            print('{:<100}'.format(l + "="*(100-lenl-lspace) + f"({idx})" + " # " + \
                                               randomize_cmtparts_color(cmts[idx])))#colorize(cmts[idx], color=randCol1)))
                        else:
                            print('{:<100}'.format(l + "="*(100-lenl-lspace) + f"({idx})"))                                                          

                    else:
                        print('{:<100}'.format(l + "="*(100-lenl-lspace) + f"({idx})"))                      

            if (idx == maxlines*(p+1) or idx == len(lstsrc) - 1) and p+1 == part:
                print('{:>157}'.format(f"part No.{p+1} out of {numparts} parts"))
                return

# %% ../nbs/lib/00_core.ipynb 397
def randomize_cmtparts_color(cmt):
    "give each comment a different color for easy viewing"
    newcmt = ""
    for p in cmt.split('; '):
        col = randomColor()
        newcmt = newcmt + colorize(p, color=col) + "; "
    return newcmt

# %% ../nbs/lib/00_core.ipynb 399
@patch
def print(self:Fastdb, 
            maxlines:int=33, # maximum num of lines per page
            part:int=0): # if the src is more than 33 lines, then divide the src by 33 into a few parts
    "Print the source code in whole or parts with idx and comments you added with dbprint along the way."

    if part == 0: 
        self.printtitle()
        self.printcmts1(maxlines=maxlines)
        
    self.printcmts2(maxlines=maxlines, part=part)



# %% ../nbs/lib/00_core.ipynb 405
@patch
def goback(self:Fastdb):
    "Return src back to original state."
    self.outenv[self.orisrc.__name__] = self.orisrc

# %% ../nbs/lib/00_core.ipynb 414
import ipdb 
# this handles the partial import error

# %% ../nbs/lib/00_core.ipynb 417
@patch
def create_explore_str(self:Fastdb):
    "create the explore dbsrc string"
    dbsrc = ""
    indent = 4

    lst = inspect.getsource(self.orisrc).split('\n')
    if not bool(lst[-1]): lst = lst[:-1]

    srclines = None
    idxlst = None
    if type(self.idxsrc) == int:
        srclines = lst[self.idxsrc]
    elif type(self.idxsrc) == list:
        idxlst = self.idxsrc
    else:
        raise TypeError("decode must be an integer or a list.")

    for idx, l in zip(range(len(lst)), lst):

        if bool(l.strip()) and type(self.idxsrc) == int and idx == self.idxsrc:
            numindent = len(l) - len(l.lstrip()) 
            dbcodes = "import ipdb; ipdb.set_trace()"
            dbsrc = dbsrc + " "*numindent + dbcodes + '\n'
            dbsrc = dbsrc + l + '\n'     
        elif type(self.idxsrc) == list and idx in idxlst:
            numindent = len(l) - len(l.lstrip()) 
            dbcodes = "import ipdb; ipdb.set_trace()"
            dbsrc = dbsrc + " "*numindent + dbcodes + '\n'
            dbsrc = dbsrc + l + '\n'  
            idxlst.remove(idx)
        elif bool(l.strip()) and idx + 1 == len(lst):
            dbsrc = dbsrc + l
        else: # make sure this printout is identical to the printsrc output
            dbsrc = dbsrc + l + '\n'

    self.dbsrcstr = dbsrc


# %% ../nbs/lib/00_core.ipynb 418
@patch
def create_explore_from_string(self:Fastdb):
    "evaluate the explore dbsrc from string"
    file_name ='/tmp/' + self.orisrc.__name__ + '.py' # learn about /tmp folder https://www.fosslinux.com/41739/linux-tmp-directory-everything-you-need-to-know.htm
    with open(file_name, 'w') as f:
        f.write(self.dbsrcstr)
    code = compile(self.dbsrcstr, file_name, 'exec')
    exec(code, globals().update(self.outenv)) # when dbsrc is a method, it will update as part of a class

    self.dbsrc = locals()[self.orisrc.__name__]

# %% ../nbs/lib/00_core.ipynb 419
@patch
def explore(self:Fastdb, 
            idxsrc:int, # idxsrc can be an int or a list of int
            db:bool=False): # display dbsrc
    "insert 'import ipdb; ipdb.set_trace()' above srcline of idx to create dbsrc, and exec on dbsrc"

    self.idxsrc = idxsrc
    self.create_explore_str()
    self.create_explore_from_string()
    self.run_example()
            
    
 

# %% ../nbs/lib/00_core.ipynb 423
import snoop

# %% ../nbs/lib/00_core.ipynb 424
@patch
def takeoutExample(self:Fastdb):
    "get the line of example code with srcode name in it"
    example = ""
    for l in self.eg.split('\n'):
        if self.orisrc.__name__ in l:
            example = l
    return example

# %% ../nbs/lib/00_core.ipynb 440
@patch
def create_snoop_str(self:Fastdb, 
                     watch:list=None, # add a list to be watched, seems not working or not used correctly?
                     deco=False, # whether it is a decorator or a normal func
                     db=False):
    "creat the snoop dbsrc string"
    dbsrc=""
    if not deco:
        for l in inspect.getsource(self.orisrc).split('\n'):
            if "def " + self.orisrc.__name__ in l or "def __" in l:
                indent = len(l) - len(l.lstrip())
                dbsrc = dbsrc + " "*indent + "import snoop\n"
                if bool(watch):
                    spreadlst = ''
                    for idx, i in zip(range(len(watch)), watch):
                        if idx < len(watch)-1:
                            spreadlst = spreadlst + '"' + i + '"' + ','
                        else:
                            spreadlst = spreadlst + '"' + i + '"'
                    dbsrc = dbsrc + " "*indent + f"@snoop(watch=({spreadlst}))\n"
                else:
                    dbsrc = dbsrc + " "*indent + "@snoop\n"
                dbsrc = dbsrc + l + '\n'
            else:
                dbsrc = dbsrc + l + '\n'

    if deco: # if self.orisrc is a decorator
        for l in inspect.getsource(self.orisrc).split('\n'):
            if "def " + self.orisrc.__name__ in l:
                indent = len(l) - len(l.lstrip())
                dbsrc = dbsrc + " "*indent + "import snoop\n"    
                dbsrc = dbsrc + " "*indent + "@snoop\n"         
                dbsrc = dbsrc + l + '\n'
            elif "def " in l:
                indent = len(l) - len(l.lstrip())
                dbsrc = dbsrc + " "*indent + "import snoop\n"                    
                dbsrc = dbsrc + " "*indent + "@snoop\n"                
                dbsrc = dbsrc + l + '\n'                
            else:
                dbsrc = dbsrc + l + '\n'          
    self.dbsrcstr = dbsrc

# %% ../nbs/lib/00_core.ipynb 443
@patch
def create_snoop_from_string(self:Fastdb, db=False):
    "evaluate the snoop dbsrc from string"
    # learn about /tmp folder https://www.fosslinux.com/41739/linux-tmp-directory-everything-you-need-to-know.htm
    file_name ='/tmp/' + self.orisrc.__name__ + '.py' 
    with open(file_name, 'w') as f:
        f.write(self.dbsrcstr)
    code = compile(self.dbsrcstr, file_name, 'exec')
#             exec(dbsrc, locals(), self.egEnv)                
#     exec(code, globals().update(self.outenv), locals()) # when dbsrc is a method, it will update as part of a class
    exec(code, globals().update(self.outenv)) # when dbsrc is a method, it will update as part of a class
    # store dbsrc func inside Fastdb obj
    self.dbsrc = locals()[self.orisrc.__name__]


# %% ../nbs/lib/00_core.ipynb 449
@patch
def snoop(self:Fastdb, watch:list=None, deco=False, db=False):
    "run snoop on the func or class under investigation only when example is available"
    self.idxsrc = None # so that autoprint won't print src at all for snoop
    self.printtitle() # maybe at some point, I should use await to make the output of printtitle appear first
    if bool(self.eg):
        self.create_snoop_str(watch=watch, deco=deco, db=db)
        self.create_snoop_from_string(db=db)
        self.run_example()


# %% ../nbs/lib/00_core.ipynb 457
def reliveonce(func, # the current func
               oldfunc:str, # the old version of func in string
               alive:bool=True, # True to bring old to live, False to return back to normal
               db=False): # True, to print for debugging
    "Replace current version of srcode with older version, and back to normal"
    if alive:
        safety = func
        block = ast.parse(oldfunc, mode='exec')
        exec(compile(block, '<string>', mode='exec'), globals().update(func.__globals__))
        if db:
            print(f"after exec: list(locals().keys()): {list(locals().keys())}")
            print(f"before update: inspect.getsourcefile(func.__globals__[func.__name__]): {inspect.getsourcefile(func.__globals__[func.__name__])}")
        
        # update the old version of func from locals() into func.__globals__, so that outside this reliveonce function, the old func can be used
        func.__globals__.update(locals())
        if db:
            print(f"after update: inspect.getsourcefile(func.__globals__[func.__name__]): {inspect.getsourcefile(func.__globals__[func.__name__])}")
    else:
        func.__globals__[func.__name__] = func.__globals__['safety']

# %% ../nbs/lib/00_core.ipynb 460
@patch
def debug(self:Fastdb):
    "to quickly check for clues of errors"
    print(f"{self.orisrc.__name__}\'s dbsrc code: ==============")
    address = f"/tmp/{self.orisrc.__name__}.py"
    dbsrc = open(address, "r+")
    print(dbsrc.read())
    print()
    print(f"{self.orisrc.__name__}\'s example processed with dbsrc: ===============")
    print(self.eg)
