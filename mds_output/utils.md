# Utils

> little functions to tell you the basics of a module

## setup for exporting to a module


```
#| default_exp utils
```


```
#| export
import os
```

## how to get current notebook's name, path and url


```

```


```
#| export
def nb_url():
    "run this func to get nb_url of this current notebook"
    import ipyparams
    return eval("ipyparams.raw_url")
```


```
nb_url()
```


    <IPython.core.display.Javascript object>





    ''




```
#| export
def nb_path():
    "run this func to get nb_path of this current notebook"
    import ipyparams
    return eval("os.path.join(os.getcwd(), ipyparams.notebook_name)")
```


```
nb_path()
```




    '/Users/Natsume/Documents/fastdebug/nbs/lib/'




```
#| export
def nb_name():
    "run this func to get nb_path of this current notebook"
    import ipyparams
    return eval("ipyparams.notebook_name")
```


```
nb_name()
```




    ''



## how to convert ipynb to md automatically; how to run commands in python


```
#| export
def ipy2md(db=True):
    "convert the current notebook to md"
    import ipyparams
    import os
    path = nb_path()
    name = nb_name()
    url = nb_url()
    obs_path = "/Users/Natsume/Documents/divefastai/Debuggable/jupytext"
    obs_output_path = "/Users/Natsume/Documents/divefastai/Debuggable/nbconvert"    
    mds_path = path.replace("nbs", "mds").split(name)[0]
    mds_output = "/Users/Natsume/Documents/fastdebug/mds_output"
    # https://stackabuse.com/executing-shell-commands-with-python/
    os.system(f"jupytext --to md {path}")
    os.system(f"cp {path.split('.ipynb')[0]+'.md'} {obs_path}")
    if db: print(f'cp to : {obs_path}')
    os.system(f"mv {path.split('.ipynb')[0]+'.md'} {mds_path}")
    if db: print(f'move to : {mds_path}')
    os.system(f"jupyter nbconvert --to markdown {path}")
    os.system(f"cp {path.split('.ipynb')[0]+'.md'} {mds_output}")
    os.system(f"mv {path.split('.ipynb')[0]+'.md'} {obs_output_path}")
    if db: print(f'copy to : {mds_output}')
    if db: print(f'move to : {obs_output_path}')        
```


```
# ipy2md()
```


```
# #| export
# def ipy2md(db=False):
#     "convert the current notebook to md"
#     path, name, url = get_notebook_path()
#     obs_path = "/Users/Natsume/Documents/divefastai/Debuggable/jupytext"
#     mds_path = path.replace("nbs", "mds").split(name)[0]
#     mds_output = "/Users/Natsume/Documents/fastdebug/mds_output"
#     if db: 
#         print(f'path: {path}')
#         print(f'mds_path: {mds_path}')
#     eval(f'!jupytext --to md {path}')
#     eval(f'!cp {path.split(".ipynb")[0]+".md"} {obs_path}')
#     eval(f'!mv {path.split(".ipynb")[0]+".md"} {mds_path}')
#     eval(f'!jupyter nbconvert --to markdown {path}')
#     eval(f'!mv {path.split(".ipynb")[0]+".md"} {mds_output}')
```


```
# ipy2md()
```


```

```

## Autoreload for every notebook

As mentioned above, you need the autoreload extension. If you want it to automatically start every time you launch ipython, you need to add it to the ipython_config.py startup file:

It may be necessary to generate one first:
```python
ipython profile create
```
Then include these lines in ~/.ipython/profile_default/ipython_config.py:

```python
c.InteractiveShellApp.exec_lines = []
c.InteractiveShellApp.exec_lines.append('%load_ext autoreload')
c.InteractiveShellApp.exec_lines.append('%autoreload 2')
```

As well as an optional warning in case you need to take advantage of compiled Python code in .pyc files:
```python
c.InteractiveShellApp.exec_lines.append('print("Warning: disable autoreload in ipython_config.py to improve performance.")')
```


```

def reload():
    exec("%load_ext autoreload")
    exec("%autoreload 2")
```


```
# reload()
```

## Expand cells


```
#| export
def expandcell():
    "expand cells of the current notebook to its full width"
    from IPython.display import display, HTML 
    display(HTML("<style>.container { width:100% !important; }</style>"))
```


```
#| export
expand = expandcell()
```


<style>.container { width:100% !important; }</style>


## Import fastcore env


```
#| export
from fastcore.test import * # so that it automated
```


```
#| export
test_eq = test_eq
test_is = test_is
```


```
#| export 
from fastcore.imports import FunctionType, MethodType
```


```
#| export
FunctionType = FunctionType
MethodType = MethodType
```

## to inspect a class


```

def inspect_class(c):
    "examine the details of a class"
    try:
        print(inspect.getsource(c))
    except: 
        pass
    print()
    print(f'is {c.__name__} a metaclass: {ismetaclass(c)}')
    print(f'is {c.__name__} created by a metaclass: {False if c.__class__ == type else True}')
    if c.__class__ is not type:
        print(f'{c.__name__} is created by metaclass {c.__class__}')
    else:
        print(f'{c.__name__} is created by {c.__class__}')
    print(f'{c.__name__}.__new__ is object.__new__: {c.__new__ is object.__new__}')   
    print(f'{c.__name__}.__new__ is type.__new__: {c.__new__ is type.__new__}')       
    print(f'{c.__name__}.__new__: {c.__new__}')
    print(f'{c.__name__}.__init__ is object.__init__: {c.__init__ is object.__init__}')
    print(f'{c.__name__}.__init__ is type.__init__: {c.__init__ is type.__init__}')    
    print(f'{c.__name__}.__init__: {c.__init__}')
    print(f'{c.__name__}.__call__ is object.__call__: {c.__call__ is object.__call__}')
    print(f'{c.__name__}.__call__ is type.__call__: {c.__call__ is type.__call__}')    
    print(f'{c.__name__}.__call__: {c.__call__}')
    print(f'{c.__name__}.__class__: {c.__class__}')
    print(f'{c.__name__}.__bases__: {c.__bases__}')
    print(f'{c.__name__}.__mro__: {c.__mro__}')
    
    if c.__class__ is not type:
        print()
        print(f'{c.__name__}\'s metaclass {c.__class__}\'s function members are:')
        funcs = {item[0]: item[1] for item in inspect.getmembers(c.__class__) \
                 if inspect.isfunction(getattr(c.__class__, item[0], None))}   
        pprint(funcs)
        
    
    
    funcs = {item[0]: item[1] for item in inspect.getmembers(c) \
             if inspect.isfunction(getattr(c, item[0], None))}
    methods = {item[0]: item[1] for item in inspect.getmembers(c) \
             if inspect.ismethod(getattr(c, item[0], None))}
    classes = {item[0]: item[1] for item in inspect.getmembers(c) \
             if inspect.isclass(getattr(c, item[0], None))}
    
    print()
    print(f'{c.__name__}\'s function members are:')
    pprint(funcs)
    print()
    print(f'{c.__name__}\'s method members are:')
    pprint(methods)
    print()
    print(f'{c.__name__}\'s class members are:')
    pprint(classes)
    print()
    print(f'{c.__name__}\'s namespace are:')
    pprint(c.__dict__)
```

### get the docs for each function of a class


```

```


```
#| export 
def inspect_class(c, src=False):
    "examine the details of a class"
    if src:
        try:
            print(inspect.getsource(c))
        except: 
            pass
    print()
    print(f'is {c.__name__} a metaclass: {ismetaclass(c)}')
    print(f'is {c.__name__} created by a metaclass: {False if c.__class__ == type else True}')
    if c.__class__ is not type:
        print(f'{c.__name__} is created by metaclass {c.__class__}')
    else:
        print(f'{c.__name__} is created by {c.__class__}')
    print(f'{c.__name__}.__new__ is object.__new__: {c.__new__ is object.__new__}')   
    print(f'{c.__name__}.__new__ is type.__new__: {c.__new__ is type.__new__}')       
    print(f'{c.__name__}.__new__: {c.__new__}')
    print(f'{c.__name__}.__init__ is object.__init__: {c.__init__ is object.__init__}')
    print(f'{c.__name__}.__init__ is type.__init__: {c.__init__ is type.__init__}')    
    print(f'{c.__name__}.__init__: {c.__init__}')
    print(f'{c.__name__}.__call__ is object.__call__: {c.__call__ is object.__call__}')
    print(f'{c.__name__}.__call__ is type.__call__: {c.__call__ is type.__call__}')    
    print(f'{c.__name__}.__call__: {c.__call__}')
    print(f'{c.__name__}.__class__: {c.__class__}')
    print(f'{c.__name__}.__bases__: {c.__bases__}')
    print(f'{c.__name__}.__mro__: {c.__mro__}')
    
    if c.__class__ is not type:
        print()
        print(f'{c.__name__}\'s metaclass {c.__class__}\'s function members are:')
        funcs = {item[0]: item[1] for item in inspect.getmembers(c.__class__) \
                 if inspect.isfunction(getattr(c.__class__, item[0], None))}   
        pprint(funcs)
        
    funcs = {item[0]: item[1] for item in inspect.getmembers(c) \
             if inspect.isfunction(getattr(c, item[0], None))}
    methods = {item[0]: item[1] for item in inspect.getmembers(c) \
             if inspect.ismethod(getattr(c, item[0], None))}
    classes = {item[0]: item[1] for item in inspect.getmembers(c) \
             if inspect.isclass(getattr(c, item[0], None))}
    
    print()
    print(f'{c.__name__}\'s function members are:')
    # todos: print some space between k and v
    for k, v in funcs.items():
        print(f"{k}: {inspect.getdoc(v)}")
    print()
    print(f'{c.__name__}\'s method members are:')
    pprint(methods)
    print()
    print(f'{c.__name__}\'s class members are:')
    pprint(classes)
    print()
    print(f'{c.__name__}\'s namespace are:')
    pprint(c.__dict__)
```


```

```

## is it a metaclass?


```
#| export
def ismetaclass(mc): 
    "check whether a class is a metaclass or not"
    if inspect.isclass(mc):
        return type in mc.__mro__ 
```


```
from fastcore.meta import *
import inspect
```


```
ismetaclass(FixSigMeta)
```




    True




```
ismetaclass(PrePostInitMeta)
```




    True



## is it a decorator


```

def isdecorator(obj):
    if inspect.isfunction(obj):
        count = 0
        defretn = ""
        for l in inspect.getsource(obj).split('\n'):
            if "def " in l:
                if count >=1:
                    defretn = l
                count = count + 1
            if "return " in l and "partial(" in l:
                return True
            if "return " in l: 
                retn = l.split('return ')[1]
                if "(" not in retn:
                    if retn in defretn:
                        return True
                    try:
                        retneval = eval(retn, obj.__globals__)
                    except NameError:
                        return False
                    if type(retneval).__name__ == 'function':
                        return True
                
        return False

```

### handle all kinds of exceptions for evaluating retn 


```
#| export
def isdecorator(obj):
    "check whether a function is a decorator"
    if inspect.isfunction(obj):
        count = 0
        defretn = ""
        for l in inspect.getsource(obj).split('\n'):
            if "def " in l:
                if count >=1:
                    defretn = l
                count = count + 1
            if "return " in l and "partial(" in l:
                return True
            if "return " in l: 
                retn = l.split('return ')[1]
                if "(" not in retn:
                    if retn in defretn:
                        return True
                    try:
                        retneval = eval(retn, obj.__globals__)
                    except:
                        return False
                    if type(retneval).__name__ == 'function':
                        return True
                
        return False

```


```
test_eq(isdecorator(delegates), True)
```


```
test_eq(isdecorator(test_sig), False)
```

## whatinside a module of a library


```
#| export
# from inspect import getmembers, isfunction, isclass, isbuiltin, getsource
import os.path, pkgutil
from pprint import pprint
import inspect

```


```

def whatinside(mo, # module, e.g., `import fastcore.all as fa`, use `fa` here
               dun:bool=False, # print all items in __all__
               func:bool=False, # print all user defined functions
               clas:bool=False, # print all class objects
               bltin:bool=False, # print all builtin funcs or methods
               lib:bool=False, # print all the modules of the library it belongs to
               cal:bool=False # print all callables
             ): 
    'Check what inside a module: `__all__`, functions, classes, builtins, and callables'
    dun_all = len(mo.__all__) if hasattr(mo, "__all__") else 0
    funcs = inspect.getmembers(mo, inspect.isfunction)
    classes = inspect.getmembers(mo, inspect.isclass)
    builtins = inspect.getmembers(mo, inspect.isbuiltin)
    callables = inspect.getmembers(mo, callable)
    pkgpath = os.path.dirname(mo.__file__)
    if not lib:
        print(f"{mo.__name__} has: \n{dun_all} items in its __all__, and \n{len(funcs)} user defined functions, \n{len(classes)} classes or class objects, \n{len(builtins)} builtin funcs and methods, and\n{len(callables)} callables.\n")  
    if hasattr(mo, "__all__") and dun: pprint(mo.__all__)
    if func: 
        print(f'The user defined functions are:')
        pprint([i[0] for i in funcs])
    if clas: 
        print(f'The class objects are:')
        pprint([i[0] for i in classes])
    if bltin: 
        print(f'The builtin functions or methods are:')
        pprint([i[0] for i in builtins])
    if cal: 
        print(f'The callables are: ')
        pprint([i[0] for i in callables])
    if lib: 
        modules = [name for _, name, _ in pkgutil.iter_modules([pkgpath])]
        print(f'The library has {len(modules)} modules')
        pprint(modules)
```

### show the type of objects inside `__all__`


```

def whatinside(mo, # module, e.g., `import fastcore.all as fa`, use `fa` here
               dun:bool=False, # print all items in __all__
               func:bool=False, # print all user defined functions
               clas:bool=False, # print all class objects
               bltin:bool=False, # print all builtin funcs or methods
               lib:bool=False, # print all the modules of the library it belongs to
               cal:bool=False # print all callables
             ): 
    'Check what inside a module: `__all__`, functions, classes, builtins, and callables'
    dun_all = len(mo.__all__) if hasattr(mo, "__all__") else 0
    funcs = inspect.getmembers(mo, inspect.isfunction)
    classes = inspect.getmembers(mo, inspect.isclass)
    builtins = inspect.getmembers(mo, inspect.isbuiltin)
    callables = inspect.getmembers(mo, callable)
    pkgpath = os.path.dirname(mo.__file__)
    module_env = mo.__dict__
    kind = None # assignment first before reference
    if not lib:
        print(f"{mo.__name__} has: \n{dun_all} items in its __all__, and \n{len(funcs)} user defined functions, \n{len(classes)} classes or class objects, \n{len(builtins)} builtin funcs and methods, and\n{len(callables)} callables.\n")  
    if hasattr(mo, "__all__") and dun: 
        maxlen = max(map(lambda i : len(i) , mo.__all__ ))
        for i in mo.__all__:
            obj = eval(i, module_env)
            if ismetaclass(obj):
                kind = "metaclass" 
            elif inspect.isclass(obj):
                kind = "class"
            elif isdecorator(obj):
                kind = "decorator"
            elif inspect.isfunction(obj):
                kind = "function"
            tp = type(eval(i, module_env)).__name__
            startlen = len(i)
            if tp == kind: print(i + ":" + " "*(maxlen-startlen + 5) + kind + "    " + \
                                 inspect.getdoc(eval(i, module_env)))  
            elif tp != 'NoneType': print(i + ":" + " "*(maxlen-startlen+5) + kind + ", " + tp + "    " + \
                                 inspect.getdoc(eval(i, module_env)))
            else: print(i + ":" + tp)
    if func: 
        print(f'The user defined functions are:')
        maxlen = max(map(lambda i : len(i[0]) , funcs ))
        for i in funcs:
            if isdecorator(i[1]):
                kind = "decorator"
            elif inspect.isfunction(i[1]):
                kind = "function"
#             print(f"{i[0]}: {kind}")  
            startlen = len(i[0])
            print(i[0] + ":" + " "*(maxlen-startlen + 5) + kind + "    " + \
                                 str(inspect.signature(i[1])))               
    if clas: 
        print(f'The class objects are:')
        maxlen = max(map(lambda i : len(i[0]) , funcs ))
        for i in classes:
            if ismetaclass(i[1]):
                kind = "metaclass"
            elif inspect.isclass(i[1]):
                kind = "class"
#             print(f"{i[0]}: {kind}")  
            startlen = len(i[0])
            if not inspect.isbuiltin(i[1]):         
                print(i[0] + ":" + " "*(maxlen-startlen + 5) + kind)
    if bltin: 
        print(f'The builtin functions or methods are:')
        pprint([i[0] for i in builtins])
    if cal: 
        print(f'The callables are: ')
        pprint([i[0] for i in callables])
    if lib: 
        modules = [name for _, name, _ in pkgutil.iter_modules([pkgpath])]
        print(f'The library has {len(modules)} modules')
        pprint(modules)
```

### working for fastdebug.core


```

def whatinside(mo, # module, e.g., `import fastcore.all as fa`, use `fa` here
               dun:bool=False, # print all items in __all__
               func:bool=False, # print all user defined functions
               clas:bool=False, # print all class objects
               bltin:bool=False, # print all builtin funcs or methods
               lib:bool=False, # print all the modules of the library it belongs to
               cal:bool=False # print all callables
             ): 
    'Check what inside a module: `__all__`, functions, classes, builtins, and callables'
    dun_all = len(mo.__all__) if hasattr(mo, "__all__") else 0
    funcs = inspect.getmembers(mo, inspect.isfunction)
    classes = inspect.getmembers(mo, inspect.isclass)
    builtins = inspect.getmembers(mo, inspect.isbuiltin)
    callables = inspect.getmembers(mo, callable)
    pkgpath = os.path.dirname(mo.__file__)
    module_env = mo.__dict__
    kind = None # assignment first before reference
    if not lib:
        print(f"{mo.__name__} has: \n{dun_all} items in its __all__, and \n{len(funcs)} user defined functions, \n{len(classes)} classes or class objects, \n{len(builtins)} builtin funcs and methods, and\n{len(callables)} callables.\n")  
    if hasattr(mo, "__all__") and dun: 
        maxlen = max(map(lambda i : len(i) , mo.__all__ ))
        for i in mo.__all__:
            obj = eval(i, module_env)
            if ismetaclass(obj):
                kind = "metaclass" 
            elif inspect.isclass(obj):
                kind = "class"
            elif isdecorator(obj):
                kind = "decorator"
            elif inspect.isfunction(obj):
                kind = "function"
            tp = type(eval(i, module_env)).__name__
            startlen = len(i)
            if tp == kind: print(i + ":" + " "*(maxlen-startlen + 5) + kind + "    " + \
                                 inspect.getdoc(eval(i, module_env)))  
            elif kind != None and callable(eval(i, module_env)): print(i + ":" + " "*(maxlen-startlen+5) + kind + ", " + tp + "    " + \
                                 str(inspect.getdoc(eval(i, module_env))))
#             elif tp != 'NoneType': print(i + ":" + " "*(maxlen-startlen+5) + kind + ", " + tp + "    " + \
#                                  inspect.getdoc(eval(i, module_env)))
            else: print(i + ":" + tp)
    if func: 
        print(f'The user defined functions are:')
        maxlen = max(map(lambda i : len(i[0]) , funcs ))
        for i in funcs:
            if isdecorator(i[1]):
                kind = "decorator"
            elif inspect.isfunction(i[1]):
                kind = "function"
#             print(f"{i[0]}: {kind}")  
            startlen = len(i[0])
            print(i[0] + ":" + " "*(maxlen-startlen + 5) + kind + "    " + \
                                 str(inspect.signature(i[1])))               
    if clas: 
        print(f'The class objects are:')
        maxlen = max(map(lambda i : len(i[0]) , funcs ))
        for i in classes:
            if ismetaclass(i[1]):
                kind = "metaclass"
            elif inspect.isclass(i[1]):
                kind = "class"
#             print(f"{i[0]}: {kind}")  
            startlen = len(i[0])
            if not inspect.isbuiltin(i[1]):         
                print(i[0] + ":" + " "*(maxlen-startlen + 5) + kind)
    if bltin: 
        print(f'The builtin functions or methods are:')
        pprint([i[0] for i in builtins])
    if cal: 
        print(f'The callables are: ')
        pprint([i[0] for i in callables])
    if lib: 
        modules = [name for _, name, _ in pkgutil.iter_modules([pkgpath])]
        print(f'The library has {len(modules)} modules')
        pprint(modules)
```

### to show Fastdb methods


```
#| export
def whatinside(mo, # module, e.g., `import fastcore.all as fa`, use `fa` here
               dun:bool=False, # print all items in __all__
               func:bool=False, # print all user defined functions
               method:bool=False, 
               clas:bool=False, # print all class objects
               bltin:bool=False, # print all builtin funcs or methods
               lib:bool=False, # print all the modules of the library it belongs to
               cal:bool=False # print all callables
             ): 
    'Check what inside a module: `__all__`, functions, classes, builtins, and callables'
    dun_all = len(mo.__all__) if hasattr(mo, "__all__") else 0
    funcs = inspect.getmembers(mo, inspect.isfunction)
    methods = inspect.getmembers(mo, inspect.ismethod)    
    classes = inspect.getmembers(mo, inspect.isclass)
    builtins = inspect.getmembers(mo, inspect.isbuiltin)
    callables = inspect.getmembers(mo, callable)
    pkgpath = os.path.dirname(mo.__file__)
    module_env = mo.__dict__
    kind = None # assignment first before reference
    if not lib:
        print(f"{mo.__name__} has: \n{dun_all} items in its __all__, and \n{len(funcs)} user defined functions, \n{len(classes)} classes or class objects, \n{len(builtins)} builtin funcs and methods, and\n{len(callables)} callables.\n")  
    if hasattr(mo, "__all__") and dun: 
        maxlen = max(map(lambda i : len(i) , mo.__all__ ))
        for i in mo.__all__:
            obj = eval(i, module_env)
            if ismetaclass(obj):
                kind = "metaclass" 
            elif inspect.isclass(obj):
                kind = "class"
            elif isdecorator(obj):
                kind = "decorator"
            elif inspect.isfunction(obj):
                kind = "function"
            tp = type(eval(i, module_env)).__name__
            startlen = len(i)
            if tp == kind: print(i + ":" + " "*(maxlen-startlen + 5) + kind + "    " + \
                                 inspect.getdoc(eval(i, module_env)))  
            elif kind != None and callable(eval(i, module_env)): print(i + ":" + " "*(maxlen-startlen+5) + kind + ", " + tp + "    " + \
                                 str(inspect.getdoc(eval(i, module_env))))
#             elif tp != 'NoneType': print(i + ":" + " "*(maxlen-startlen+5) + kind + ", " + tp + "    " + \
#                                  inspect.getdoc(eval(i, module_env)))
            else: print(i + ":" + tp)
    if func: 
        print(f'The user defined functions are:')
        maxlen = max(map(lambda i : len(i[0]) , funcs ))
        for i in funcs:
            if isdecorator(i[1]):
                kind = "decorator"
            elif inspect.isfunction(i[1]):
                kind = "function"
#             print(f"{i[0]}: {kind}")  
            startlen = len(i[0])
            print(i[0] + ":" + " "*(maxlen-startlen + 5) + kind + "    " + \
                                 str(inspect.signature(i[1])))               
    if clas: 
        print(f'The class objects are:')
        maxlen = max(map(lambda i : len(i[0]) , funcs ))
        for i in classes:
            if ismetaclass(i[1]):
                kind = "metaclass"
            elif inspect.isclass(i[1]):
                kind = "class"
#             print(f"{i[0]}: {kind}")  
            startlen = len(i[0])
            if not inspect.isbuiltin(i[1]):         
                print(i[0] + ":" + " "*(maxlen-startlen + 5) + kind)
    if method: 
        print(f'The methods are:')
        pprint([i[0] for i in methods])
    if bltin: 
        print(f'The builtin functions or methods are:')
        pprint([i[0] for i in builtins])
    if cal: 
        print(f'The callables are: ')
        pprint([i[0] for i in callables])
    if lib: 
        modules = [name for _, name, _ in pkgutil.iter_modules([pkgpath])]
        print(f'The library has {len(modules)} modules')
        pprint(modules)
```


```

```


```
str(None)
```




    'None'




```

```

## whichversion of a library


```
#| export
from importlib.metadata import version, metadata, distribution
from platform import python_version 
```


```
#| export
def whichversion(libname:str, # library name not string
                req:bool=False, # print lib requirements 
                file:bool=False): # print all lib files
    "Give you library version and other basic info."
    if libname == "python":
        print(f"python: {python_version()}")
    else: 
        print(f"{metadata(libname)['Name']}: {version(libname)} \n{metadata(libname)['Summary']}\
    \n{metadata(libname)['Author']} \n{metadata(libname)['Home-page']} \
    \npython_version: {metadata(libname)['Requires-Python']} \
    \n{distribution(libname).locate_file(libname)}")

    if req: 
        print(f"\n{libname} requires: ")
        pprint(distribution(libname).requires)
    if file: 
        print(f"\n{libname} has: ")
        pprint(distribution(libname).files)
    
```


```
whichversion("python")
```

    python: 3.9.13



```
whichversion("fastcore")
```

    fastcore: 1.5.27 
    Python supercharged for fastai development    
    Jeremy Howard and Sylvain Gugger 
    https://github.com/fastai/fastcore/     
    python_version: >=3.7     
    /Users/Natsume/mambaforge/lib/python3.9/site-packages/fastcore



```
whichversion("fastai")
```

    fastai: 2.7.9 
    fastai simplifies training fast and accurate neural nets using modern best practices    
    Jeremy Howard, Sylvain Gugger, and contributors 
    https://github.com/fastai/fastai/tree/master/     
    python_version: >=3.7     
    /Users/Natsume/mambaforge/lib/python3.9/site-packages/fastai



```
whichversion("snoop")
```

    snoop: 0.4.1 
    Powerful debugging tools for Python    
    Alex Hall 
    https://github.com/alexmojaki/snoop     
    python_version: None     
    /Users/Natsume/mambaforge/lib/python3.9/site-packages/snoop



```
try:
    whichversion("inspect")
except: 
    print("inspect won't work here")
```

    inspect won't work here



```

def tstenv(outenv=globals()):
    print(f'out global env has {len(outenv.keys())} vars')
    print(f'inner global env has {len(globals().keys())} vars')
    print(f'inner local env has {len(globals().keys())} vars')
    lstout = list(outenv.keys())
    lstin = list(globals().keys())
    print(lstout[:10])
    print(lstin[:10])
    print(f"out env['__name__']: {outenv['__name__']}")
    print(f"inner env['__name__']: {globals()['__name__']}")
```


```
tstenv()
```

    out global env has 125 vars
    inner global env has 125 vars
    inner local env has 125 vars
    ['__name__', '__doc__', '__package__', '__loader__', '__spec__', '__builtin__', '__builtins__', '_ih', '_oh', '_dh']
    ['__name__', '__doc__', '__package__', '__loader__', '__spec__', '__builtin__', '__builtins__', '_ih', '_oh', '_dh']
    out env['__name__']: __main__
    inner env['__name__']: __main__



```
len(globals().keys())
```




    126



## fastview
display the commented source code


```
#| export
def fastview(name, # can be both object itself or str, e.g., delegates, FixSigMeta
            nb=False # add a link to the notebook where comments are added
            ): 
    "to view the commented src code in color print and with examples"
    if type(name) == str:
        file_name ='/Users/Natsume/Documents/fastdebug/learnings/' + name + '.py'
    else:
        file_name ='/Users/Natsume/Documents/fastdebug/learnings/' + name.__name__ + '.py' 

    with open(file_name, 'r') as f:
        # Read and print the entire file line by line
        for l in f:
            print(l, end='')
    if nb:
        openNB(name)    
```


```
# file_name ='/Users/Natsume/Documents/fastdebug/learnings/' + self.orisrc.__name__ + '.py' 
#     # learn about /tmp folder https://www.fosslinux.com/41739/linux-tmp-directory-everything-you-need-to-know.htm
# with open(file_name, 'w') as f:
# # with open(file_name, 'r') as f:    
#     f.write("this is me")

# with open('dog_breeds.txt', 'r') as reader:
#     # Read & print the entire file
#     print(reader.read())    
    
# with open(file_name, 'r') as f:
#     # Read and print the entire file line by line
#     for l in f:
#         print(l, end='')    
        
# with open(file_name, 'a') as f:
#     f.write('\nBeagle')
```


```
#| export
import os
```


```
# fastsrcs()
fastview("PrePostInitMeta")
```

    
    class _T(metaclass=PrePostInitMeta):
        def __pre_init__(self):  self.a  = 0; 
        def __init__(self,b=0):  self.b = self.a + 1; assert self.b==1
        def __post_init__(self): self.c = self.b + 2; assert self.c==3
    
    t = _T()
    test_eq(t.a, 0) # set with __pre_init__
    test_eq(t.b, 1) # set with __init__
    test_eq(t.c, 3) # set with __post_init__
    inspect.signature(_T)
    
    class PrePostInitMeta(FixSigMeta):========================================================(0)       
        "A metaclass that calls optional `__pre_init__` and `__post_init__` methods"==========(1) # [37;1mPrePostInitMeta inherit __new__ and __init__ from FixSigMeta as a metaclass (a different type)[0m; [37;1mnot from type, nor from object[0m; [92;1mPrePostInitMeta is itself a metaclass, which is used to create class instance not object instance[0m; [34;1mPrePostInitMeta writes its own __call__ which regulates how its class instance create and initialize object instance[0m; 
        def __call__(cls, *args, **kwargs):===================================================(2)       
            res = cls.__new__(cls)============================================================(3) # [34;1mhow to create an object instance with a cls[0m; [37;1mhow to check the type of an object is cls[0m; [92;1mhow to run a function without knowing its params;[0m; 
            if type(res)==cls:================================================================(4)       
                if hasattr(res,'__pre_init__'): res.__pre_init__(*args,**kwargs)==============(5)       
                res.__init__(*args,**kwargs)==================================================(6) # [36;1mhow to run __init__ without knowing its params[0m; 
                if hasattr(res,'__post_init__'): res.__post_init__(*args,**kwargs)============(7)       
            return res========================================================================(8)       
                                                                                                                                                            (9)



```

```

## fastscrs


```
#| export
def fastsrcs():
    "to list all commented src files"
    folder ='/Users/Natsume/Documents/fastdebug/learnings/'
    for f in os.listdir(folder):
        if f.endswith(".py"):
            # Prints only text file present in My Folder
            print(f)
```


```
fastsrcs()
```

    anno_dict.py
    test_sig.py
    BypassNewMeta.py
    snoop.py
    FixSigMeta.py
    fastnbs.py
    funcs_kwargs.py
    NewChkMeta.py
    printtitle.py
    AutoInit.py
    method.py
    _rm_self.py
    delegates.py
    create_explore_str.py
    PrePostInitMeta.py
    _funcs_kwargs.py
    whatinside.py


## getrootport


```

```


```
#| export
def getrootport():
    "get the local port and notebook dir"
    from notebook import notebookapp
    root_server = ""
    root_dir = ""
    for note in notebookapp.list_running_servers():
        if "fastdebug" in note['notebook_dir']:
            root_server = str(note['url']) + "tree/"
            root_dir = note['notebook_dir']
    return (root_server, root_dir)
```


```
from notebook import notebookapp
for note in notebookapp.list_running_servers():
    print(note)
```

    {'base_url': '/', 'hostname': 'localhost', 'notebook_dir': '/Users/Natsume/Documents/fastdebug', 'password': False, 'pid': 27880, 'port': 8888, 'secure': False, 'sock': '', 'token': '860d973349ff9360e2537458cb57a8c9aa1cc35cb1da6df1', 'url': 'http://localhost:8888/'}
    {'base_url': '/', 'hostname': 'localhost', 'notebook_dir': '/Users/Natsume/Documents/debuggable', 'password': False, 'pid': 186, 'port': 8891, 'secure': False, 'sock': '', 'token': 'c012783787faf5572be76a83057225b9183cf1d5f77407d0', 'url': 'http://localhost:8891/'}



```
getrootport()
```




    ('http://localhost:8888/tree/', '/Users/Natsume/Documents/fastdebug')



## jn_link


```
#| export
def jn_link(name, file_path, where="locally"):
    "Get a link to the notebook at `path` on Jupyter Notebook"
    from IPython.display import Markdown
    display(Markdown(f'[Open `{name}` in Jupyter Notebook {where}]({file_path})'))                
```


```
jn_link("utils", "http://localhost:8888/notebooks/nbs/lib/utils.ipynb")
```


[Open `utils` in Jupyter Notebook locally](http://localhost:8888/notebooks/nbs/lib/utils.ipynb)


## get_all_nbs


```
def get_all_nbs(folder='/Users/Natsume/Documents/divefastai/Debuggable/jupytext/'):
    "return all nbs of subfolders of the `folder` into a list"
    all_nbs = []
    for i in os.listdir(folder):
        if "." not in i:
            all_nbs = all_nbs + [folder + i + "/" + j for j in os.listdir(folder + i) if j.endswith('.md')]
    return (all_nbs, folder)
```

### get all nbs path for both md and ipynb


```

def get_all_nbs():
    "return paths for all nbs both in md and ipynb format into lists"
#     md_folder = '/Users/Natsume/Documents/divefastai/Debuggable/jupytext/'
    md_folder = '/Users/Natsume/Documents/fastdebug/mds/'
    ipy_folder = '/Users/Natsume/Documents/fastdebug/nbs/'
    md_nbs = []
    for i in os.listdir(md_folder):
        if "." not in i:
            md_nbs = md_nbs + [md_folder + i + "/" + j for j in os.listdir(md_folder + i) if j.endswith('.md')]
            
    ipy_nbs = []
    for i in os.listdir(ipy_folder):
        if "." not in i:
            ipy_nbs = ipy_nbs + [ipy_folder + i + "/" + j for j in os.listdir(ipy_folder + i) if j.endswith('.ipynb')]
            
    return (md_nbs, md_folder, ipy_nbs, ipy_folder)
```


```

```


```

def get_all_nbs():
    "return paths for all nbs both in md and ipynb format into lists"
#     md_folder = '/Users/Natsume/Documents/divefastai/Debuggable/jupytext/'
    md_folder = '/Users/Natsume/Documents/fastdebug/mds/'
    md_output_folder = '/Users/Natsume/Documents/fastdebug/mds_output/'    
    ipy_folder = '/Users/Natsume/Documents/fastdebug/nbs/'
    md_nbs = []
    for i in os.listdir(md_folder):
        if "." not in i:
            md_nbs = md_nbs + [md_folder + i + "/" + j for j in os.listdir(md_folder + i) if j.endswith('.md')]

    md_output_nbs = [md_output_folder + i for i in os.listdir(md_output_folder) if ".md" in i]        
            
    ipy_nbs = []
    for i in os.listdir(ipy_folder):
        if "." not in i:
            ipy_nbs = ipy_nbs + [ipy_folder + i + "/" + j for j in os.listdir(ipy_folder + i) if j.endswith('.ipynb')]
            
    return (md_nbs, md_folder, ipy_nbs, ipy_folder, md_output_nbs, md_output_folder)
```

### add index.ipynb


```
#| export
def get_all_nbs():
    "return paths for all nbs both in md and ipynb format into lists"
#     md_folder = '/Users/Natsume/Documents/divefastai/Debuggable/jupytext/'
    md_folder = '/Users/Natsume/Documents/fastdebug/mds/'
    md_output_folder = '/Users/Natsume/Documents/fastdebug/mds_output/'    
    ipy_folder = '/Users/Natsume/Documents/fastdebug/nbs/'
    md_nbs = []
    for i in os.listdir(md_folder):
        if "." not in i:
            md_nbs = md_nbs + [md_folder + i + "/" + j for j in os.listdir(md_folder + i) if j.endswith('.md')]

    md_output_nbs = [md_output_folder + i for i in os.listdir(md_output_folder) if ".md" in i]        
            
    ipy_nbs = []
    for i in os.listdir(ipy_folder):
        if ".ipynb" in i: 
            ipy_nbs.append(ipy_folder + i)
        elif "." not in i:
            ipy_nbs = ipy_nbs + [ipy_folder + i + "/" + j for j in os.listdir(ipy_folder + i) if j.endswith('.ipynb')]

            
    return (md_nbs, md_folder, ipy_nbs, ipy_folder, md_output_nbs, md_output_folder)
```


```

```


```
nbs_md, fdmd, nbs_ipy, fdipy, md_out, md_out_fd = get_all_nbs()
for i in [nbs_md, fdmd, nbs_ipy, fdipy, md_out, md_out_fd]:
    pprint(i)
    print()
```

    ['/Users/Natsume/Documents/fastdebug/mds/2022part1/0004_fastai_how_neuralnet_work.md',
     '/Users/Natsume/Documents/fastdebug/mds/2022part1/0001_fastai_is_it_a_bird.md',
     '/Users/Natsume/Documents/fastdebug/mds/2022part1/0006_fastai_why_should_use_framework.md',
     '/Users/Natsume/Documents/fastdebug/mds/2022part1/0002_fastai_saving_a_basic_fastai_model.md',
     '/Users/Natsume/Documents/fastdebug/mds/2022part1/0005_fastai_linear_neuralnet_scratch.md',
     '/Users/Natsume/Documents/fastdebug/mds/2022part1/0003_fastai_which_image_model_best.md',
     '/Users/Natsume/Documents/fastdebug/mds/lib/utils.md',
     '/Users/Natsume/Documents/fastdebug/mds/lib/00_core.md',
     '/Users/Natsume/Documents/fastdebug/mds/demos/0001_fastcore_meta_delegates.md',
     '/Users/Natsume/Documents/fastdebug/mds/demos/0003_Explore_document_FixSigMeta_PrePostInitMeta_AutoInit.md',
     '/Users/Natsume/Documents/fastdebug/mds/demos/0004_fastcore.meta._rm_self.md',
     '/Users/Natsume/Documents/fastdebug/mds/demos/0005_fastcore.meta.test_sig.md',
     '/Users/Natsume/Documents/fastdebug/mds/demos/0007_fastcore.meta.BypassNewMeta.md',
     '/Users/Natsume/Documents/fastdebug/mds/demos/0002_signature_from_callable.md',
     '/Users/Natsume/Documents/fastdebug/mds/demos/0008_use_kwargs_dict.md',
     '/Users/Natsume/Documents/fastdebug/mds/demos/0006_fastcore.meta.NewChkMeta.md',
     '/Users/Natsume/Documents/fastdebug/mds/demos/0000_tour.md',
     '/Users/Natsume/Documents/fastdebug/mds/demos/0012_fastcore_foundation_L.md',
     '/Users/Natsume/Documents/fastdebug/mds/demos/0011_Fastdb.md',
     '/Users/Natsume/Documents/fastdebug/mds/demos/0009_funcs_kwargs.md',
     '/Users/Natsume/Documents/fastdebug/mds/demos/0010_fastcore_meta_summary.md',
     '/Users/Natsume/Documents/fastdebug/mds/questions/00_question_anno_dict.md']
    
    '/Users/Natsume/Documents/fastdebug/mds/'
    
    ['/Users/Natsume/Documents/fastdebug/nbs/2022part1/0001_fastai_is_it_a_bird.ipynb',
     '/Users/Natsume/Documents/fastdebug/nbs/2022part1/0005_fastai_linear_neuralnet_scratch.ipynb',
     '/Users/Natsume/Documents/fastdebug/nbs/2022part1/0003_fastai_which_image_model_best.ipynb',
     '/Users/Natsume/Documents/fastdebug/nbs/2022part1/0006_fastai_why_should_use_framework.ipynb',
     '/Users/Natsume/Documents/fastdebug/nbs/2022part1/0002_fastai_saving_a_basic_fastai_model.ipynb',
     '/Users/Natsume/Documents/fastdebug/nbs/2022part1/0004_fastai_how_neuralnet_work.ipynb',
     '/Users/Natsume/Documents/fastdebug/nbs/lib/utils.ipynb',
     '/Users/Natsume/Documents/fastdebug/nbs/lib/00_core.ipynb',
     '/Users/Natsume/Documents/fastdebug/nbs/.ipynb_checkpoints',
     '/Users/Natsume/Documents/fastdebug/nbs/demos/0001_fastcore_meta_delegates.ipynb',
     '/Users/Natsume/Documents/fastdebug/nbs/demos/0005_fastcore.meta.test_sig.ipynb',
     '/Users/Natsume/Documents/fastdebug/nbs/demos/0000_tour.ipynb',
     '/Users/Natsume/Documents/fastdebug/nbs/demos/0007_fastcore.meta.BypassNewMeta.ipynb',
     '/Users/Natsume/Documents/fastdebug/nbs/demos/0008_use_kwargs_dict.ipynb',
     '/Users/Natsume/Documents/fastdebug/nbs/demos/0012_fastcore_foundation_L.ipynb',
     '/Users/Natsume/Documents/fastdebug/nbs/demos/0002_signature_from_callable.ipynb',
     '/Users/Natsume/Documents/fastdebug/nbs/demos/0004_fastcore.meta._rm_self.ipynb',
     '/Users/Natsume/Documents/fastdebug/nbs/demos/0009_funcs_kwargs.ipynb',
     '/Users/Natsume/Documents/fastdebug/nbs/demos/0010_fastcore_meta_summary.ipynb',
     '/Users/Natsume/Documents/fastdebug/nbs/demos/0006_fastcore.meta.NewChkMeta.ipynb',
     '/Users/Natsume/Documents/fastdebug/nbs/demos/0003_Explore_document_FixSigMeta_PrePostInitMeta_AutoInit.ipynb',
     '/Users/Natsume/Documents/fastdebug/nbs/demos/0011_Fastdb.ipynb',
     '/Users/Natsume/Documents/fastdebug/nbs/index.ipynb',
     '/Users/Natsume/Documents/fastdebug/nbs/questions/00_question_anno_dict.ipynb']
    
    '/Users/Natsume/Documents/fastdebug/nbs/'
    
    ['/Users/Natsume/Documents/fastdebug/mds_output/0001_fastcore_meta_delegates.md',
     '/Users/Natsume/Documents/fastdebug/mds_output/00_question_anno_dict.md',
     '/Users/Natsume/Documents/fastdebug/mds_output/0003_Explore_document_FixSigMeta_PrePostInitMeta_AutoInit.md',
     '/Users/Natsume/Documents/fastdebug/mds_output/0004_fastcore.meta._rm_self.md',
     '/Users/Natsume/Documents/fastdebug/mds_output/0004_fastai_how_neuralnet_work.md',
     '/Users/Natsume/Documents/fastdebug/mds_output/0001_fastai_is_it_a_bird.md',
     '/Users/Natsume/Documents/fastdebug/mds_output/utils.md',
     '/Users/Natsume/Documents/fastdebug/mds_output/0006_fastai_why_should_use_framework.md',
     '/Users/Natsume/Documents/fastdebug/mds_output/0005_fastcore.meta.test_sig.md',
     '/Users/Natsume/Documents/fastdebug/mds_output/0007_fastcore.meta.BypassNewMeta.md',
     '/Users/Natsume/Documents/fastdebug/mds_output/0002_signature_from_callable.md',
     '/Users/Natsume/Documents/fastdebug/mds_output/0008_use_kwargs_dict.md',
     '/Users/Natsume/Documents/fastdebug/mds_output/0002_fastai_saving_a_basic_fastai_model.md',
     '/Users/Natsume/Documents/fastdebug/mds_output/0006_fastcore.meta.NewChkMeta.md',
     '/Users/Natsume/Documents/fastdebug/mds_output/index.md',
     '/Users/Natsume/Documents/fastdebug/mds_output/00_core.md',
     '/Users/Natsume/Documents/fastdebug/mds_output/0005_fastai_linear_neuralnet_scratch.md',
     '/Users/Natsume/Documents/fastdebug/mds_output/0000_tour.md',
     '/Users/Natsume/Documents/fastdebug/mds_output/0012_fastcore_foundation_L.md',
     '/Users/Natsume/Documents/fastdebug/mds_output/0011_Fastdb.md',
     '/Users/Natsume/Documents/fastdebug/mds_output/0003_fastai_which_image_model_best.md',
     '/Users/Natsume/Documents/fastdebug/mds_output/0009_funcs_kwargs.md',
     '/Users/Natsume/Documents/fastdebug/mds_output/0010_fastcore_meta_summary.md']
    
    '/Users/Natsume/Documents/fastdebug/mds_output/'
    


## openNB


```

def openNB(name, folder='nbs/demos/', db=False):
    "Get a link to the notebook at by name locally"
#     root = "/Users/Natsume/Documents/fastdebug/"
#     root_server = "http://localhost:8888/tree/"
    root = getrootport()[1] + "/"
    root_server = getrootport()[0]
    path = root + folder
    path_server = root_server + folder
    for f in os.listdir(path):  
        if f.endswith(".ipynb"):
            if name in f: 
                file_name = path_server + f
                if db: print(f'file_name: {file_name}')
                jn_link(name, file_name)
```


```

def openNB(name, folder='nbs/demos/', db=False):
    "Get a link to the notebook at by name locally"
#     root = "/Users/Natsume/Documents/fastdebug/"
#     root_server = "http://localhost:8888/tree/"
    root = getrootport()[1] + "/"
    root_server = getrootport()[0]
    path = root + folder
    path_server = root_server + folder
    for f in os.listdir(path):  
        if f.endswith(".ipynb"):
            name = name.split('.md')[0]
            if db: print(f, name)
            if name in f: 
                file_name = path_server + f
                jn_link(name, file_name)
```


```

```


```
#| export
def openNB(name, db=False):
    "Get a link to the notebook at by searching keyword or notebook name"
    _, _, ipynbs, _, _, _= get_all_nbs()
    name = name.split(".md")[0]
    root = getrootport()[1]
    nb_path = ""
    for f in ipynbs:
        if name in f:
            nb_path = f
            name = f.split("/")[-1].split(".")[0]
            if db: print(f'nb_path:{nb_path}, name: {name}')
    root_server = getrootport()[0]
    folder_mid = nb_path.split(root)[1].split(name)[0]
    if db: print(f'root: {root}, root_server: {root_server}, name: {name}, folder_mid: {folder_mid}')
    path = root + folder_mid
    path_server = root_server[:-1] + folder_mid
    if db: print(f'path: {path}, path_server: {path_server}')
    for f in os.listdir(path):  
        if f.endswith(".ipynb"):
            if name in f: 
                file_name = path_server + f
                jn_link(name, file_name)
```


```

```


```
openNB("FixSigMeta", db=True)
```

    nb_path:/Users/Natsume/Documents/fastdebug/nbs/demos/0003_Explore_document_FixSigMeta_PrePostInitMeta_AutoInit.ipynb, name: 0003_Explore_document_FixSigMeta_PrePostInitMeta_AutoInit
    root: /Users/Natsume/Documents/fastdebug, root_server: http://localhost:8888/tree/, name: 0003_Explore_document_FixSigMeta_PrePostInitMeta_AutoInit, folder_mid: /nbs/demos/
    path: /Users/Natsume/Documents/fastdebug/nbs/demos/, path_server: http://localhost:8888/tree/nbs/demos/



[Open `0003_Explore_document_FixSigMeta_PrePostInitMeta_AutoInit` in Jupyter Notebook locally](http://localhost:8888/tree/nbs/demos/0003_Explore_document_FixSigMeta_PrePostInitMeta_AutoInit.ipynb)


## openNBKaggle


```
"is_it_me".split("_")
```




    ['is', 'it', 'me']




```
#| export
kagglenbs = [
    "https://www.kaggle.com/code/jhoward/how-does-a-neural-net-really-work",
    "https://www.kaggle.com/code/jhoward/is-it-a-bird-creating-a-model-from-your-own-data",
    "https://www.kaggle.com/code/jhoward/why-you-should-use-a-framework",
    "https://www.kaggle.com/code/jhoward/using-nbdev-export-in-a-kaggle-notebook",
    "https://www.kaggle.com/code/jhoward/the-best-vision-models-for-fine-tuning",
    "https://www.kaggle.com/code/jhoward/collaborative-filtering-deep-dive",
    "https://www.kaggle.com/code/jhoward/multi-target-road-to-the-top-part-4",
    "https://www.kaggle.com/code/jhoward/scaling-up-road-to-the-top-part-3",
    "https://www.kaggle.com/code/jhoward/small-models-road-to-the-top-part-2",
    "https://www.kaggle.com/code/jhoward/first-steps-road-to-the-top-part-1",
    "https://www.kaggle.com/code/jhoward/which-image-models-are-best",
    "https://www.kaggle.com/code/jhoward/linear-model-and-neural-net-from-scratch",
    "https://www.kaggle.com/code/jhoward/iterate-like-a-grandmaster",
    "https://www.kaggle.com/code/jhoward/how-random-forests-really-work",
    "https://www.kaggle.com/code/jhoward/getting-started-with-nlp-for-absolute-beginners",
    "https://www.kaggle.com/code/jhoward/resize-images",
    "https://www.kaggle.com/code/jhoward/saving-a-basic-fastai-model",
    "https://www.kaggle.com/code/jhoward/practical-deep-learning-for-coders-chapter-1",
    "https://www.kaggle.com/code/jhoward/from-prototyping-to-submission-fastai",
    "https://www.kaggle.com/code/jhoward/cleaning-the-data-for-rapid-prototyping-fastai",
    "https://www.kaggle.com/code/jhoward/don-t-see-like-a-radiologist-fastai",
    "https://www.kaggle.com/code/jhoward/some-dicom-gotchas-to-be-aware-of-fastai",
    "https://www.kaggle.com/code/jhoward/creating-a-metadata-dataframe-fastai",
    "https://www.kaggle.com/code/jhoward/fastai-v2-pipeline-tutorial",
    "https://www.kaggle.com/code/jhoward/minimal-lstm-nb-svm-baseline-ensemble",
    "https://www.kaggle.com/code/jhoward/nb-svm-strong-linear-baseline",
    "https://www.kaggle.com/code/jhoward/improved-lstm-baseline-glove-dropout"
]
```


<style>.container { width:100% !important; }</style>



```
len(kagglenbs)
```




    27




```
#| export
def openNBKaggle(filename_full, db=False):
    if 'fastai' in filename_full:
        # split by 'fastai' and take the later
        filename = filename_full
        filename = filename.split("fastai_")[1]
        # split by '.ipynb'
        filename = filename.split(".md")[0]
        # split by '_'
        nameparts = filename.split("_")
        if db: print(f'filename: {filename}')
        for f in kagglenbs: 
            truelst = [p.lower() in f.lower() for p in nameparts]
            pct = sum(truelst)/len(truelst)
            if pct >= 0.9:
                if db: print(f'pct is {pct}')
                jn_link(filename_full.split(".md")[0], f, where="on Kaggle") 
```


```
# get_all_nbs()
openNBKaggle("0001_fastai_is_it_a_bird.md", db=True)
```

    filename: is_it_a_bird
    pct is 1.0



[Open `0001_fastai_is_it_a_bird` in Jupyter Notebook on Kaggle](https://www.kaggle.com/code/jhoward/is-it-a-bird-creating-a-model-from-your-own-data)


## highlight

<mark style="background-color: #FFFF00">text with highlighted background</mark>  


```

def highlight(question:str, line:str, db=False):
    "highlight a string with yellow background"
    questlst = question.split(' ')
    questlst_hl = [' <mark style="background-color: #FFFF00">' + q + '</mark> ' for q in questlst]
    for q, q_hl in zip(questlst, questlst_hl):
        if " " + q + " " in line.lower() or "[" + q + "]" in line.lower() and not '<mark style="background-color: #FFFF00">' + q in line.lower():
            line = line.lower().replace(" " + q + " ", q_hl)
            
    if db: print(f'line: {line}')
    return line
```


```

def highlight(question:str, line:str, db=False):
    "highlight a string with yellow background"
    questlst = question.split(' ')
    questlst_hl = [' <mark style="background-color: #FFFF00">' + q + '</mark> ' for q in questlst]
    for q, q_hl in zip(questlst, questlst_hl):
        if " " + q in line.lower(): # don't do anything to [q] or <>q<>. Using regex can be more accurate here
            line = line.lower().replace(q, q_hl)
            
    if db: print(f'line: {line}')
    return line
```


```

def highlight(question:str, line:str, db=False):
    "highlight a string with yellow background"
    questlst = question.split(' ')
    questlst_hl = [' <mark style="background-color: #FFFF00">' + q.lower() + '</mark> ' for q in questlst]
    for q, q_hl in zip(questlst, questlst_hl):
        if " " + q.lower() in line.lower(): # don't do anything to [q] or <>q<>. Using regex can be more accurate here
            line = line.lower().replace(q.lower(), q_hl)
            
    if db: print(f'line: {line}')
    return line
```


```

```


```
#| export
def highlight(question:str, line:str, db=False):
    "highlight a string with yellow background"
    questlst = question.split(' ')
    questlst_hl = [' <mark style="background-color: #FFFF00">' + q.lower() + '</mark> ' for q in questlst]
    for q, q_hl in zip(questlst, questlst_hl):
        if " " + q.lower() in line.lower(): # don't do anything to [q] or <>q<>. Using regex can be more accurate here
            line = line.lower().replace(" "+ q.lower(), q_hl)
            
    if db: print(f'line: {line}')
    return line
```


<style>.container { width:100% !important; }</style>



```
str(0.8).split(" ")
print(highlight("0.8 a", "this is a 0.8 of face"))

```

    this is  <mark style="background-color: #FFFF00">a</mark>   <m <mark style="background-color: #FFFF00">a</mark> rk style="b <mark style="background-color: #FFFF00">a</mark> ckground-color: #ffff00">0.8</m <mark style="background-color: #FFFF00">a</mark> rk>  of f <mark style="background-color: #FFFF00">a</mark> ce



```

```

## display_md


```
#| export
def display_md(text):
    "Get a link to the notebook at `path` on Jupyter Notebook"
    from IPython.display import Markdown
    display(Markdown(text))                
```


```
display_md("#### heading level 4")
```


#### heading level 4



```

```

## display_block


```

def display_block(line, file):
    "`line` is a section title, find all subsequent lines which belongs to the same section and display them together"
    from IPython.display import Markdown
    with open(file, 'r') as file:
        entire = file.read()
        belowline = entire.split(line)[1]
        head_no = line.count("#")
        lochead2 = belowline.find("##")
        lochead3 = belowline.find("###")
        lochead4 = belowline.find("####")
        loclst = [lochead2,lochead3, lochead4]
        loclst = [i for i in loclst if i != -1]
        num_hash = 0
        if bool(loclst):
            if lochead2 == min(loclst):
                num_hash = 2
            elif lochead3 == min(loclst):
                num_hash = 3
            elif lochead4 == min(loclst):
                num_hash = 4
        if num_hash == 0:
            section_content = belowline
        else:
            section_content = belowline.split("#"*num_hash)[0]
        entire_section = line + "\n" + section_content
        display(Markdown(entire_section))
```


```

```


```

def display_block(line, file, keywords=""):
    "`line` is a section title, find all subsequent lines which belongs to the same section and display them together"
    from IPython.display import Markdown
    with open(file, 'r') as file:
        entire = file.read()
        belowline = entire.split(line)[1]
        head_no = line.count("#")
        lochead2 = belowline.find("##")
        lochead3 = belowline.find("###")
        lochead4 = belowline.find("####")
        loclst = [lochead2,lochead3, lochead4]
        loclst = [i for i in loclst if i != -1]
        num_hash = 0
        if bool(loclst):
            if lochead2 == min(loclst):
                num_hash = 2
            elif lochead3 == min(loclst):
                num_hash = 3
            elif lochead4 == min(loclst):
                num_hash = 4
        if num_hash == 0:
            section_content = belowline
        else:
            section_content = belowline.split("#"*num_hash)[0]
#         entire_content = line + "\n" + section_content
#         display(Markdown(entire_content))        
        title_hl = highlight(keywords, line)
        display(Markdown(title_hl))
        display(Markdown(section_content))

```

### handle both file path and file content at the same time


```
#| export
def display_block(line, file, output=False, keywords=""):
    "`line` is a section title, find all subsequent lines which belongs to the same section and display them together"
    from IPython.display import Markdown
    entire = ""
    if file.endswith(".md") or file.endswith(".ipynb"):
        with open(file, 'r') as file:
            entire = file.read()
    else:
        entire = file
        
    belowline = entire.split(line)[1]
    head_no = line.count("#")
    lochead2 = belowline.find("##")
    lochead3 = belowline.find("###")
    lochead4 = belowline.find("####")
    loclst = [lochead2,lochead3, lochead4]
    loclst = [i for i in loclst if i != -1]
    num_hash = 0
    if bool(loclst):
        if lochead2 == min(loclst):
            num_hash = 2
        elif lochead3 == min(loclst):
            num_hash = 3
        elif lochead4 == min(loclst):
            num_hash = 4
    if num_hash == 0:
        section_content = belowline
    else:
        section_content = belowline.split("#"*num_hash)[0]
#         entire_content = line + "\n" + section_content
#         display(Markdown(entire_content))        
    title_hl = highlight(keywords, line)
    display(Markdown(title_hl))
    if not output: display(Markdown(section_content))
    else: print(section_content)

```


```
display_block("whichversion of a library", "/Users/Natsume/Documents/divefastai/Debuggable/jupytext/lib/utils.md", \
              keywords="whichversion library")
```


whichversion of a  <mark style="background-color: #FFFF00">library</mark> 





```python
#| export
from importlib.metadata import version, metadata, distribution
from platform import python_version 
```

```python
#| export
def whichversion(libname:str, # library name not string
                req:bool=False, # print lib requirements 
                file:bool=False): # print all lib files
    "Give you library version and other basic info."
    if libname == "python":
        print(f"python: {python_version()}")
    else: 
        print(f"{metadata(libname)['Name']}: {version(libname)} \n{metadata(libname)['Summary']}\
    \n{metadata(libname)['Author']} \n{metadata(libname)['Home-page']} \
    \npython_version: {metadata(libname)['Requires-Python']} \
    \n{distribution(libname).locate_file(libname)}")

    if req: 
        print(f"\n{libname} requires: ")
        pprint(distribution(libname).requires)
    if file: 
        print(f"\n{libname} has: ")
        pprint(distribution(libname).files)
    
```

```python
whichversion("python")
```

```python
whichversion("fastcore")
```

```python
whichversion("fastai")
```

```python
whichversion("snoop")
```

```python
try:
    whichversion("inspect")
except: 
    print("inspect won't work here")
```

```python

def tstenv(outenv=globals()):
    print(f'out global env has {len(outenv.keys())} vars')
    print(f'inner global env has {len(globals().keys())} vars')
    print(f'inner local env has {len(globals().keys())} vars')
    lstout = list(outenv.keys())
    lstin = list(globals().keys())
    print(lstout[:10])
    print(lstin[:10])
    print(f"out env['__name__']: {outenv['__name__']}")
    print(f"inner env['__name__']: {globals()['__name__']}")
```

```python
tstenv()
```

```python
len(globals().keys())
```





```

```


```

```

## fastnbs


```

def fastnbs(question:str, accu:float=0.8, n=10, nb=False, db=False):
    "using keywords to search learning points from my documented fastai notebooks"
    questlst = question.split(' ')
    folder ='/Users/Natsume/Documents/divefastai/Debuggable/jupytext/2022part1/'
    for f in os.listdir(folder):  
        if f.endswith(".md"):
            file_name =folder + f
            with open(file_name, 'r') as file:
                for count, l in enumerate(file):
#                 for l in file:
                    truelst = [q in l for q in questlst]
                    pct = sum(truelst)/len(truelst)

                    if pct >= accu:
                        head1 = f"keyword match is {pct}, Found a line: in {f}"
                        head1 = highlight(str(pct), head1)
                        head1 = highlight(f, head1)
                        display_md(head1)
                        l = highlight(question, l, db=db)                        
                        display_md(l)
                        print()
                        
                        head2 = f"Show {n} lines after in {f}:"
                        head2 = highlight(f, head2)
                        head2 = highlight(str(n), head2)
                        display_md(head2)                        
                        idx = count
                        with open(file_name, 'r') as file:
                            for count, l in enumerate(file):
                                if count >= idx and count <= idx + n:
                                    if count == idx: display_md(highlight(question, l))
                                    else: display_md(l)                        
                        if nb:
                            openNB(f, "nbs/2022part1/")
```


```
#| export
def fastnbs(question:str, output=False, accu:float=0.8, nb=True, db=False):
    "check with fastlistnbs() to find interesting things to search \
fastnbs() can use keywords to search learning points (a section title and a section itself) from my documented fastai notebooks"
    questlst = question.split(' ')
    mds_no_output, folder, ipynbs, ipyfolder, mds_output, output_fd = get_all_nbs()
    if not output: mds = mds_no_output
    else: mds = mds_output
        
    for file_fullname in mds:
        file_name = file_fullname.split('/')[-1]
        with open(file_fullname, 'r') as file:
            for count, l in enumerate(file):
                truelst = [q.lower() in l.lower() for q in questlst]
                pct = sum(truelst)/len(truelst)
                if pct >= accu and (l.startswith("##") or l.startswith("###") or l.startswith("####")):
                    if db: 
                        head1 = f"keyword match is {pct}, Found a section: in {file_name}"
                        head1 = highlight(str(pct), head1)
                        head1 = highlight(file_name, head1)
                        display_md(head1)
                        highlighted_line = highlight(question, l, db=db)                        
                        print()
                    display_block(l, file_fullname, output=output, keywords=question)
                    if nb: 
                        openNB(file_name, db=db)
                        openNBKaggle(file_name, db=db)
```


```
# fastnbs("Snoop them together in one go", output=True)
# fastnbs("Snoop them together in one go")
fastnbs("what is fastai")
```


###  <mark style="background-color: #ffff00">what</mark>   <mark style="background-color: #ffff00">is</mark>   <mark style="background-color: #FFFF00">fastai</mark> 





```python
import fastai
```

```python
whichversion("fastai")
```

```python
whatinside(fastai, lib=True)
```

```python
import fastai.losses as fl
```

```python
whatinside(fl, dun=True)
```





[Open `0001_fastai_is_it_a_bird` in Jupyter Notebook locally](http://localhost:8888/tree/nbs/2022part1/0001_fastai_is_it_a_bird.ipynb)



[Open `0001_fastai_is_it_a_bird` in Jupyter Notebook on Kaggle](https://www.kaggle.com/code/jhoward/is-it-a-bird-creating-a-model-from-your-own-data)



##  <mark style="background-color: #ffff00">what</mark>  to import to handle vision problems in  <mark style="background-color: #FFFF00">fastai</mark> 






First, import all the stuff we need from fastai:

```python
from fastai.vision.all import *
```





[Open `0002_fastai_saving_a_basic_fastai_model` in Jupyter Notebook locally](http://localhost:8888/tree/nbs/2022part1/0002_fastai_saving_a_basic_fastai_model.ipynb)



[Open `0002_fastai_saving_a_basic_fastai_model` in Jupyter Notebook on Kaggle](https://www.kaggle.com/code/jhoward/saving-a-basic-fastai-model)



```

```

## fastcodes


```
#| export
def fastcodes(question:str, accu:float=0.8, nb=False, db=False):
    "using keywords to search learning points from commented sources files"
    questlst = question.split(' ')
    # loop through all pyfile in learnings folder
    folder ='/Users/Natsume/Documents/fastdebug/learnings/'
    for f in os.listdir(folder):  
        if f.endswith(".py"):
            name = f.split('.py')[0]
            # open each pyfile and read each line
            file_name =folder + f
            with open(file_name, 'r') as file:
                for count, l in enumerate(file):                
                    # if search match >= 0.8, print the line and the pyfile
                    truelst = [q.lower() in l.lower() for q in questlst]
                    pct = sum(truelst)/len(truelst)
                    if pct >= accu:
                        head1 = f"keyword match is {pct}, Found a line: in {f}"
                        head1 = highlight(str(pct), head1)
                        head1 = highlight(f, head1)
                        display_md(head1)
                        print(l, end='')
                        print()                        
                        head2 = f"The entire source code in {f}"
                        head2 = highlight(f, head2)
                        display_md(head2)
                        fastview(name)
                        print()
                        if nb:
                            openNB(name)
```


```
fastcodes("how to remove self")
```


keyword match is  <mark style="background-color: #ffff00">1.0</mark> , found a line: in  <mark style="background-color: #FFFF00">fixsigmeta.py</mark> 


            if res.__init__ is not object.__init__: res.__signature__ = _rm_self(inspect.signature(res.__init__)) # [91;1mhow to remove self from a signature[0m; [36;1mhow to check whether a class' __init__ is inherited from object or not;[0m;  (4)
    



the entire source code in  <mark style="background-color: #FFFF00">fixsigmeta.py</mark> 


    
    class BaseMeta(FixSigMeta): 
        # using __new__ of  FixSigMeta instead of type
        def __call__(cls, *args, **kwargs): pass
    
    class Foo_call_fix(metaclass=BaseMeta): # Base
        def __init__(self, d, e, f): pass
    
    pprint(inspect._signature_from_callable(Foo_call_fix, sigcls=inspect.Signature))    
    
    class FixSigMeta(type):===================================================================(0)       
        "A metaclass that fixes the signature on classes that override `__new__`"=============(1) # [37;1mAny class having FixSigMeta as metaclass will have its own __init__ func stored in its attr __signature__;FixSigMeta uses its __new__ to create a class instance[0m; [37;1mthen check whether its class instance has its own __init__;if so, remove self from the sig of __init__[0m; [36;1mthen assign this new sig to __signature__ for the class instance;[0m; 
        def __new__(cls, name, bases, dict):==================================================(2) # [92;1mhow does a metaclass create a class instance[0m; [35;1mwhat does super().__new__() do here;[0m; 
            res = super().__new__(cls, name, bases, dict)=====================================(3)       
            if res.__init__ is not object.__init__: res.__signature__ = _rm_self(inspect.signature(res.__init__)) # [91;1mhow to remove self from a signature[0m; [36;1mhow to check whether a class' __init__ is inherited from object or not;[0m;  (4)
            return res========================================================================(5)       
                                                                                                                                                            (6)
    



keyword match is  <mark style="background-color: #ffff00">1.0</mark> , found a line: in  <mark style="background-color: #FFFF00">_rm_self.py</mark> 


        sigd.pop('self')======================================================================(2) # [34;1mhow to remove the self parameter from the dict of sig;[0m; 
    



the entire source code in  <mark style="background-color: #FFFF00">_rm_self.py</mark> 


    
    class Foo:
        def __init__(self, a, b:int=1): pass
    pprint(inspect.signature(Foo.__init__))
    pprint(_rm_self(inspect.signature(Foo.__init__)))
    
    def _rm_self(sig):========================================================================(0) # [34;1mremove parameter self from a signature which has self;[0m; 
        sigd = dict(sig.parameters)===========================================================(1) # [92;1mhow to access parameters from a signature[0m; [93;1mhow is parameters stored in sig[0m; [35;1mhow to turn parameters into a dict;[0m; 
        sigd.pop('self')======================================================================(2) # [34;1mhow to remove the self parameter from the dict of sig;[0m; 
        return sig.replace(parameters=sigd.values())==========================================(3) # [36;1mhow to update a sig using a updated dict of sig's parameters[0m; 
                                                                                                                                                            (4)
    



```

```

## fastnotes


```

def fastnotes(question:str, accu:float=0.8, n=2, db=False):
    "display found notes with key words search"
    questlst = question.split(' ')
    folder ='/Users/Natsume/Documents/divefastai/lectures/'
    for f in os.listdir(folder):  
        if f.endswith(".md"):
            name = f.split('.md')[0]
            file_name =folder + f
            with open(file_name, 'r') as file:
                for count, l in enumerate(file):
                    truelst = [q in l.lower() for q in questlst]
                    pct = sum(truelst)/len(truelst)
                    if pct >= accu:
                        print()
                        head1 = f"keyword match is {pct}, Found a line: in {f}"
                        head1 = highlight(str(pct), head1)
                        head1 = highlight(f, head1)
                        display_md(head1)
                        l = highlight(question, l, db=db)
                        display_md(l)
                        print()                        
                        print('{:=<157}'.format(f"Show {n} lines above and after in {f}:"))
                        head2 = f"Show {n} lines above and after in {f}:"
                        head2 = highlight(f, head2)
                        head2 = highlight(str(n), head2)
                        display_md(head2)                        
                        idx = count
                        with open(file_name, 'r') as file:
                            for count, l in enumerate(file):
                                if count >= idx - n and count <= idx + n:
                                    if count == idx: display_md(highlight(question, l))
                                    else: display_md(l)
```

### multiple folders


```
[1,3] + [5,6]
```




    [1, 3, 5, 6]




```
#| export
def fastnotes(question:str, accu:float=0.8, n=2, folder="lec", # folder: 'lec' or 'live' or 'all'
              db=False):
    "using key words to search notes and display the found line and lines surround it"
    questlst = question.split(' ')
    root = '/Users/Natsume/Documents/divefastai/'
    folder1 = '2022_part1/'
    folder2 = '2022_livecoding/'
    lectures = [root + folder1 + f for f in os.listdir(root + folder1)]
    livecodings = [root + folder2 + f for f in os.listdir(root + folder2)]
    all_notes = lectures + livecodings
    if folder == "lec": files = lectures
    elif folder == "live": files = livecodings
    else: files = all_notes
    for f in files:
#     for f in os.listdir(folder):  
        if f.endswith(".md"):
#             name = f.split('.md')[0]
#             file_name =folder + f
            with open(f, 'r') as file:
                for count, l in enumerate(file):
                    truelst = [q in l.lower() for q in questlst]
                    pct = sum(truelst)/len(truelst)
                    if pct >= accu:
                        print()
                        head1 = f"keyword match is {pct}, Found a line: in {f.split(root)[1]}"
                        head1 = highlight(str(pct), head1)
                        head1 = highlight(f.split(root)[1], head1)
                        display_md(head1)
                        l = highlight(question, l, db=db)
                        display_md(l)
                        print()                        
#                         print('{:=<157}'.format(f"Show {n} lines above and after in {f}:"))
                        head2 = f"Show {n} lines above and after in {f.split(root)[1]}:"
                        head2 = highlight(f.split(root)[1], head2)
                        head2 = highlight(str(n), head2)
                        display_md(head2)                        
                        idx = count
                        with open(f, 'r') as file:
                            for count, l in enumerate(file):
                                if count >= idx - n and count <= idx + n:
                                    if count == idx: display_md(highlight(question, l))
                                    else: display_md(l)
```


```
fastnotes("why read fastbook", n=2)
```

    



keyword match is  <mark style="background-color: #ffff00">1.0</mark> , found a line: in  <mark style="background-color: #FFFF00">2022_part1/fastai-lecture-1.md</mark> 



do you know that learning the same thing in different ways betters understanding? -  <mark style="background-color: #ffff00">why</mark>  should you  <mark style="background-color: #FFFF00">read</mark>  the [fastbook](https://github.com/fastai/fastbook)?



    



show  <mark style="background-color: #FFFF00">2</mark>  lines above and after in  <mark style="background-color: #ffff00"> <mark style="background-color: #FFFF00">2</mark> 0 <mark style="background-color: #FFFF00">2</mark>  <mark style="background-color: #FFFF00">2</mark> _part1/fastai-lecture-1.md</mark> :



Do you know people learn naturally (better) with context rather than by theoretical curriculum? - Do you want this course to make you a competent deep learning practitioner by context and practical knowledge? - If you want theory from ground up, should you go to part 2 fastai 2019?




[20:01](https://www.youtube.com/watch?v=RLvUfyLcT48&t=80s&loop=10&start=20:01&end=21:25) Fastbook  




do you know that learning the same thing in different ways betters understanding? -  <mark style="background-color: #ffff00">why</mark>  should you  <mark style="background-color: #FFFF00">read</mark>  the [fastbook](https://github.com/fastai/fastbook)?




[21:25](https://www.youtube.com/watch?v=RLvUfyLcT48&t=80s&loop=10&start=21:25&end=24:38) Take it seriously  




Why you must take this course very seriously?



    



keyword match is  <mark style="background-color: #ffff00">1.0</mark> , found a line: in  <mark style="background-color: #FFFF00">2022_part1/fastai-lecture-4.md</mark> 



- how to check what inside the dataset folder? -  <mark style="background-color: #ffff00">why</mark>  it is important to  <mark style="background-color: #ffff00">read</mark>  [competition data introduction](https://www.kaggle.com/competitions/us-patent-phrase-to-phrase-matching/data) which is often overlooked? - how to  <mark style="background-color: #ffff00">read</mark>  a csv file with pandas? [24:30](https://youtu.be/tougbqv1bt8?t=1470) - what are the key four libraries for data science in python? [24:46](https://youtu.be/tougbqv1bt8?t=1486) - what is the other [book](https://wesmckinney.com/book/) besides  <mark style="background-color: #FFFF00">fastbook</mark>  recommended by jeremy? [25:36](https://youtu.be/tougbqv1bt8?t=1536) -  <mark style="background-color: #ffff00">why</mark>  you must  <mark style="background-color: #ffff00">read</mark>  it too? - how to access and show the dataset in dataframe? [26:39](https://youtu.be/tougbqv1bt8?t=1599) - how to `describe` the dataset? what does it tell us in general? [27:10](https://youtu.be/tougbqv1bt8?t=1630) - what did the number of unique data samples mean to jeremy at first? [27:57](https://youtu.be/tougbqv1bt8?t=1677) - how to create a single string based on the model strategy? [28:26](https://youtu.be/tougbqv1bt8?t=1706) - how to refer to a column of a dataframe in  <mark style="background-color: #ffff00">read</mark> ing and writing a column data?



    



show  <mark style="background-color: #FFFF00">2</mark>  lines above and after in  <mark style="background-color: #ffff00"> <mark style="background-color: #FFFF00">2</mark> 0 <mark style="background-color: #FFFF00">2</mark>  <mark style="background-color: #FFFF00">2</mark> _part1/fastai-lecture-4.md</mark> :



- When and how to use a GPU on Kaggle? - Why Jeremy recommend Paperspace over Kaggle as your workstation? - How easy has Jeremy made it to download Kaggle dataset and work on Paperspace or locally? - How to do both python and bash in the same jupyter cell?




#### [23:33](https://youtu.be/toUgBQv1BT8?t=1413) Get raw dataset into documents  




- how to check what inside the dataset folder? -  <mark style="background-color: #ffff00">why</mark>  it is important to  <mark style="background-color: #ffff00">read</mark>  [competition data introduction](https://www.kaggle.com/competitions/us-patent-phrase-to-phrase-matching/data) which is often overlooked? - how to  <mark style="background-color: #ffff00">read</mark>  a csv file with pandas? [24:30](https://youtu.be/tougbqv1bt8?t=1470) - what are the key four libraries for data science in python? [24:46](https://youtu.be/tougbqv1bt8?t=1486) - what is the other [book](https://wesmckinney.com/book/) besides  <mark style="background-color: #FFFF00">fastbook</mark>  recommended by jeremy? [25:36](https://youtu.be/tougbqv1bt8?t=1536) -  <mark style="background-color: #ffff00">why</mark>  you must  <mark style="background-color: #ffff00">read</mark>  it too? - how to access and show the dataset in dataframe? [26:39](https://youtu.be/tougbqv1bt8?t=1599) - how to `describe` the dataset? what does it tell us in general? [27:10](https://youtu.be/tougbqv1bt8?t=1630) - what did the number of unique data samples mean to jeremy at first? [27:57](https://youtu.be/tougbqv1bt8?t=1677) - how to create a single string based on the model strategy? [28:26](https://youtu.be/tougbqv1bt8?t=1706) - how to refer to a column of a dataframe in  <mark style="background-color: #ffff00">read</mark> ing and writing a column data?




#### [29:17](https://youtu.be/toUgBQv1BT8?t=1757) Tokenization: Intro  




- How to turn strings/documents into numbers for neuralnet? - Do we split the string into words first? - What's the problem with the Chinese language on words? - What are vocabularies compared with splitted words? - What to do with the vocabulary? - Why we want the vocabulary to be concise not too big? - What nowadays people prefer rather than words to be included in vocab?




```

```


```

```

## fastlistnbs


```

def fastlistnbs():
    "display all my commented notebooks subheadings in a long list"
    nbs, folder, _, _, _, _ = get_all_nbs()
    for nb in nbs:
        print("\n"+nb)
        with open(nb, 'r') as file:
            for idx, l in enumerate(file):
                if "##" in l:
                    print(l, end="") # no extra new line between each line printed
        
```


```

def fastlistnbs():
    "display all my commented notebooks subheadings in a long list. Best to work with fastnbs together."
    nbs, folder, _, _, _, _ = get_all_nbs()
    for nb in nbs:
        print("\n"+nb)
        with open(nb, 'r') as file:
            for idx, l in enumerate(file):
                if l.startswith("##"):
                    print(l, end="") # no extra new line between each line printed
        
```

### add filter 


```
#| export
def fastlistnbs(filter="fastai"):
    "display all my commented notebooks subheadings in a long list. Best to work with fastnbs together."
    nbs, folder, _, _, _, _ = get_all_nbs()
    nb_rt = ""
    for nb in nbs:
        if filter == "fastai" and "_fastai_" in nb: 
            nb_rt = nb
        elif filter == "all": 
            nb_rt = nb
        else: 
            continue
            
        print("\n"+nb_rt)
        with open(nb_rt, 'r') as file:
            for idx, l in enumerate(file):
                if "##" in l:
                    print(l, end="") # no extra new line between each line printed

                    
                    
```


```

```


```
fastlistnbs(filter="all")
```

    
    /Users/Natsume/Documents/fastdebug/mds/2022part1/0007_fastai_how_random_forests_really_work.md
    ## Introduction
    ### why ensemble of decision trees, such as Random Forests and Gradient Boosting Machines
    ### how to set print options for numpy and import `fastai.imports`
    ## Data preprocessing
    ### how to get Titanic dataset ready for creating a decision tree model
    ## Binary splits
    ### what is binary splits and who does it work
    ### how to plot barplot and countplot with Seaborn
    ### Create a simplest model based on binary split
    ### how to do train and test split using `sklearn.model_selection.train_test_split`
    ### how to access dependent and independent values for both training set and test set 
    ### calc the prediction (the simplest so far)
    ### calc loss with mean absolute error using `sklearn.metrics.mean_absolute_error`
    ### how to do binary split on a continuous column rather than category column
    ### how to plot a boxenplot on survival and non-survival using `sns.logFare` column; how to a density plot with logFare using `sns.kdeplot` 
    ### how to find the binary split to calc predictions based on logFare using the boxenplot above
    ### see how good is this model and prediction using loss (mean absolute error)
    ### how does impurity measure the goodness of a split; how to create impurity as a measure for how good of a split
    ### how to create a score function for a single side of the split
    ### how to create the score function to measure the goodness of a binary split
    ### calc the impurity score for sex split and then logFare split
    ### how to make interactive on choose different split and calc score on continuous columns
    ### how to make interactive on choose different split and calc score on categorical columns
    ### how to make a list of all possible split points
    ### how to get the score for all possible splits of a particular column like Age; how to get the index for the lowest core
    ### how to write a function to return the best split value and its score on a particular column given the dataframe and the name of the column
    ### how to run this function on all columns of the dataset
    ### what is OneR classifier; why should it be a baseline to more sophisiticated models
    ## Creating a decision tree
    ### how is to do better than a OneR classifier which predict survival using sex? how about doing another OneR upon the first OneR classifier result (male group and female group)
    ### how to get the dataset splitted by sex in pandas dataframe
    ### how to find the best binary splits and score out of all columns in male dataset and then femal dataset
    ### what does a decision tree mean when the second binary split is done here
    ### how to do a decision tree automatically using sklearn
    ### how to visualize the decision tree above
    ## how is gini different from impurity 
    ### how to cacl gini
    ### how to wrap the process of preparing submission csv file for kaggle
    ### why no need to worry about dummy variables in decision trees
    ## The random forest
    ### what is random forest; what is bagging; what is the great insight behind it
    ### how to create uncorrelated trees using random subset of data
    ### how to make prediciton on each tree and take average on them, and then calc the loss
    ### how is sklearn's RandomForestClassifier differ from the forest from scratch above; how to do random forest with sklearn
    ## Conclusion
    ### how should we think of simple models like OneR and decision tree and randomforest
    
    /Users/Natsume/Documents/fastdebug/mds/2022part1/0004_fastai_how_neuralnet_work.md
    ## Fitting a function with *gradient descent*
    ### Is neuralnet just a math function? what does the function look like?
    ### why neuralnet is random at first and how to make neuralnet useful
    ### `plot_function`: how to plot a function with plt; how to create x input with torch.linspace; how to plot x, y, color and title with plt;
    ### how to create a particular quadratic function
    ### how to write a function `quad` to create any quadratic function
    ### how does `partial` and `quad` work to modify `quad` to a slightly different func?
    ### how to add noise to both mult and add of the neuralnet/function; how to create noise using `np.random.normal`
    ### how to create a random seed to ensure x and y are the same each run
    ## A numpy book recommended by Jeremy; what is a tensor
    ### how to scatterplot with plt
    ### how to plot a scatterplot and a line and slides for 3 params of the line func
    ### why need a loss function? how to write a mean absolute error function with torch.abs and mean
    ### how display and change loss by changing values of params with sliders of interactive plot
    ### A 15-min calculus video series recommended by Jeremy to watch first
    ## Automating gradient descent
    ### how derivatives automatically guide params to change for a lower loss
    ### how to create a mean absolute error function on any quadratic model
    ### how to create an random tensor with 3 values as initialized params
    ### how to calc gradients of params? 1. tell PyTorch to get ready for calculating gradients for these params; 2. calc loss; 3. calc the gradients with `loss.backward()`; 4. how to access params' gradients; 
    ### how to change params with gradients properly to lower loss¶
    ### why `with torch.no_grad():` when updating params with gradients
    ### how to do 10 iterations of updating params with gradients
    ## How a neural network approximates any given function
    ## how to combine a linear func with max(x, 0) into a rectified linear function; how to use torch.clip(y, 0.) to perform max(y, 0.)
    ## how to use partial to wrap rectified_linear to create a specific rectified_linear func
    ## how to use `F.relu` to replace `torch.clip` to create a rectified linear func; 
    ### create double and quaduple relu func/neuralnet
    ## How to recognise an owl
    ### deep learning basically is drawing squiggly lines infinitely given computation and time
    
    /Users/Natsume/Documents/fastdebug/mds/2022part1/0001_fastai_is_it_a_bird.md
    ## Useful Course sites
    ## How to use autoreload
    ## How to install and update libraries
    ## Know a little about the libraries
    ### what is fastai
    ### what is duckduckgo
    ## How to use fastdebug with fastai notebooks
    ### how to use fastdebug
    ### Did I document it in a notebook before?
    ### Did I document it in a src before?
    ## how to search and get a url of an image; how to download with an url; how to view an image;
    ### how to create folders using path; how to search and download images in folders; how to resize images 
    ## Train my model
    ### How to find and unlink images not properly downloaded
    ### How to create a DataLoaders with DataBlock; how to view data with it
    ### How to build my model with dataloaders and pretrained model; how to train my model
    ### How to predict with my model; how to avoid running cells in nbdev_prepare
    
    /Users/Natsume/Documents/fastdebug/mds/2022part1/0006_fastai_why_should_use_framework.md
    ## Introduction and set up
    ### what are the benefits of using fastai and PyTorch frameworks
    ### which fastai module is for tabular data; how to set float format display for pandas; how to set random seed;
    ## Prep the data
    ### no worry of dummy variables, normalization, missing values and so on if using fastai; interesting feature ideas from a nice Titanic feature notebook;
    ### how to create a tabular dataloaders with `TabularPandas` which handles all messing processing; how to set the parameters of `TabularPandas`
    ## Train the model
    ### how to create a tabular learner using tabular dataloader, metrics and layers
    ### how to find the learning rate automatically in fastai
    ### how to pick the best learning rate from the learning rate curve; how to train model 16 epochs using `learn.fit`
    ## Submit to Kaggle
    ### how to prepare test data including added new features
    ### how to apply all the processing steps of training data to test data with `learn.dls.test_dl`
    ### how to calc all predictions for test set using `learn.get_preds`
    ### how to prepare the results of test set into a csv file for kaggle submission; how to save into csv file without idx number
    ## Ensembling
    ### what is ensembling and why it is more robust than any single model
    ### how to create an ensemble function to create multiple models and generate predictions from each of them
    ### how to get the average predictions from all ensembed models
    ### how to create the csv file to Titanic competition
    ## Final thoughts
    ### Why you should use a framework like fastai
    
    /Users/Natsume/Documents/fastdebug/mds/2022part1/0008_fastai_first_steps_road_to_top_part_1.md
    ### how to install fastkaggle if not available
    ### how to iterate like a grandmaster
    ### what are the related walkthrus on paddy doctor competition
    ## Getting set up
    ### how to setup for fastkaggle; how to use fastkaggle to download dataset from kaggle; how to access the path
    ### which fastai module to use for vision problem; how to check files inside the dataset path; why Jeremy recommend not to use seed in your own analysis;
    ## Looking at the data
    ### how to access a subfolder by name using path from `setup_comp`; how to extract all image files from a folder
    ### how to create an image from an image file; how to access the size of an image; how to display it with specified size for viewing
    ### how to use `fastcore.parallel` to quickly access size of all images; how to count the occurance of each unique value in a pandas 
    ### how to create an image dataloaders; how to setup `item_tfms` and `batch_tfms` on image sizes; why to start with the smallest sizes first; how to display images in batch
    ## Our first model
    ### how to pick the first pretrained model for our model; how to build our model based on the selected pretrained model
    ### how to find the learning rate for our model
    ## Submitting to Kaggle
    ### how to check the kaggle submission sample csv file
    ### how to sort the files in the test set in the alphabetical order; how to create dataloaders for the test set based on the dataloaders of the training set
    ### how to make predictions for all test set; and what does `learn.get_preds` return
    ### how to access all the classes of labels with dataloaders
    ### how to map classes to each idx from the predictions
    ### how to save result into csv file
    ### how to submit to kaggle with fastkaggle api
    ## Conclusion
    ### what is the most important thing for your first model
    ## Addendum
    ### how to quickly push your local notebook to become kaggle notebook online
    
    /Users/Natsume/Documents/fastdebug/mds/2022part1/0009_fastai_small_models_road_to_the_top_part_2.md
    ## Going faster
    ### why kaggle gpu is much slower for training and how does fastai to fix it with `resize_images`
    ### how to create a new folder with `Path`
    ### how to resize all images (including those in subfolders) of `train_images` folder and save them into a new destination folder; max_size = 256 does shrink the total size by 4+, but question: how Jeremy pick 256 not 250; 
    ### how to create an image dataloaders using the resized image folder and specify the resize for each image item; how to display just 3 images in a batch
    ### how to wrap dataloaders creation, model creation, fine tuning together in a func `train` and return the trained model; how use model architecture, item transforms, and batch transforms, and num of epochs as the params of the `train` function;
    ## A ConvNeXt model
    ### How to tell whether a larger pretrained model would affect our training speed by reading GPU and CPU usage bar? why to pick convnext_small for our second model;
    ### how to load and use a new pretrained model in fastai
    ## Preprocessing experiments
    ### question: why trying different ways of cutting images could possibly improve model performance; what are the proper options for cutting images or preparing images
    ### how to try cutting image with `crop` instead of `squish` 
    ### what is transform image with padding and how does it differ from squish and crop
    ### question: how `resize(256, 192)` and `size(171, 128)` are determined
    ## Test time augmentation
    ### how does test time augmentation TTA work; question: what is the rationale behind TTA
    ### how to check the performance of our model on validation set
    ### how to display the transformations which have been done to a single image in the training set
    ### how to do TTA on validation set
    ### how to calc the error rate of the tta_preds
    ## Scaling up
    ### how to scale up on the model using padding and the tta approach in terms of image size and epoch number
    ### how to check the performance of the scaled up model using validation set
    ## Submission
    ### how to use TTA to predict instead of the usual `get_preds` to get predictions on the test set
    ### how to get the index of the predictions
    ### how to replace index with vocab or classes
    ### how to submit prediction csv to kaggle with comment using fastkaggle api
    ### how to push local notebook to Kaggle online
    ## Conclusion
    
    /Users/Natsume/Documents/fastdebug/mds/2022part1/0002_fastai_saving_a_basic_fastai_model.md
    ## what to import to handle vision problems in fastai
    ## how to download and decompress datasets prepared by fastai
    ## how to tell it is a cat by reading filename
    ## how to create dataloaders with `from_name_func`
    ## how to create a pretrained model with resnet18 and error_rate; how to fine tune it 3 epochs
    ## how to export model to a pickle file and download it from Kaggle
    ## how to convert ipynb to md
    
    /Users/Natsume/Documents/fastdebug/mds/2022part1/0005_fastai_linear_neuralnet_scratch.md
    ## how to not execute the entire notebook
    ## Introduction
    ## How to download kaggle dataset to your local machine or colab? how to ues kaggle api and zipfile to download data into specified folder; how to use `pathlib.Path` to create a path;
    ## how to set the print display option for numpy, torch and pandas
    ## Cleaning the data
    ### how to read csv file with pandas and `path/'subfolder_name'`
    ### why missing value is a problem? how to find out the num of missing values of each column with pandas?
    ### which value is most used to replace missing value? how to get mode for each column with pandas using `iloc[0]`
    ### how to use pandas `iloc` function
    ### how to fill missing values with mode without making a new copy with `pandas.fillna`
    ### how to get a quick summary of all the numeric columns with pandas and numpy
    ### what is long-tailed data in histogram and why it is a problem for neuralnet
    ### how to plot histogram with pandas on a single column
    ### how to fix long-tailed data with logarithm; why should logarithm work; how to handle zero values when applying logarithm
    ### how to get a quick summary of all the non-numeric columns with pandas
    ### when do we need dummy variables and how to create dummy variables with pandas
    ### how to check the first few rows of selected columns with pandas
    ### how to create dependent/target variable and independent/predictor variables in PyTorch tensors; how to create variables in tensor from pandas dataframe
    ### how to check the size (rows and columns) of independent variables in tensor
    ## Setting up a linear model
    ### how to create coefficients for each (column) of our independent variables; how to get random seed in torch; how to get the num of columns; how to create random number between -0.5 and 0.5;
    ### why no bias or a constant is needed for this Titanic dataset?
    ### why a column `Age` having higher values than other columns can cause problem for our model; how to solve this problem by making them the same scale; how to get the max value of each column with pandas dataframe max func
    ### what is maxtrix by vector operation (multiply or divide)
    ### How to calculate the prediction of a linear model
    ### how to look at the first 10 values of predictions
    ### how to calc mean absolute error
    ### how to calc predictions with a func `calc_preds`; how to calc loss with a func `calc_loss`
    ## Doing a gradient descent step
    ### How to cacl gradients for coefficients
    ### why set gradients to zero after each gradient descent step; how to set gradient to zero; how to do one iteration of training
    ### what does _ mean for `coeffs.sub_()` and `grad.zero_()`
    ## Training the linear model
    ### how to split the dataset by using train and valid idx produced by `fastai.data.transforms.RandomSplitter`
    ### how to udpate coefficients in a function `update_coeffs`
    ### how to do one epoch training in a function `one_epoch`
    ### how to initializing coefficients in a function `init_coeffs`
    ### how to integrate funcs above to form a function `train_model` on multiple epochs
    ### how to display coefficients of the model with func `show_coeffs`
    ## Measuring accuracy
    ### There are many possible loss options such as accuracy other than mean absolute error
    ### how to calc accuracy for the binary dependent variable
    ### how to wrap the process of calc accuracy using coeffs into a func `acc(coeffs)`
    ## Using sigmoid
    ### when will we be needing something like sigmoid
    ### how to write and plot a func like `sigmoid` using sympy
    ### how to update `calc_preds` by wrapping `torch.sigmoid` around prediction
    ## Submitting to Kaggle
    ### read test data using `pandas.read_csv`
    ### why and how to fill the missing value in Fare column with 0 instead of mode
    ### how to handle missing values, long-tailed distribution and dummies together for test data
    ### how to turn independent variable values into tensor
    ### how to make sure independent variable in test data share the same value scare with those in training data
    ### how to turn true or false into 1 or 0 and save them into a column
    ### how to select two columns of a dataframe and save them into a csv file using `to_csv`
    ### how to check the first few lines of the csv file using `!head`
    ## Using matrix product
    ### how to do matrix product `@` between a matrix and a vector with PyTorch; how to use `@` instead of doing multiplication and then addition together
    ### update `calc_preds` func using matrix multiplication `@`
    ### how to initialize coeffs and turn it into a matrix with a single column; question: but why make coeffs between 0 and 0.1 instead of -0.5 and 0.5
    ### how to turn a single column of dependent variable into a single column matrix or a column vector
    ### question: why set learning rate to be 100 for this Titanic model
    ## A neural network
    ### how to initialize coeffs for a neuralnet with two layers (including a hidden layer of n neurons) and the final output layer is a single neuron with a single coeff; question: how do `-0.5` and `-0.3` come from?
    ### how to update `calc_preds` for this 2 layer neuralnet using `F.relu`, matrix product `@`, and `torch.sigmoid`
    ### how to update coeffs layer by layer with `layer.sub_` and `layer.grad.zero_`
    ### question: how the learning rate is chosen (1.4 or 20) when training
    ## Deep learning
    ### how to move from neuralnet with one hidden layer to a deep learning
    ### why so many messy constants and how they block the progress of deep learning in the early days
    ### how to use `enumerate` to loop both idx and item
    ## Final thoughts
    ### How much similar or different between practical models and the models from scratch above
    
    /Users/Natsume/Documents/fastdebug/mds/2022part1/0003_fastai_which_image_model_best.md
    ## timm
    ## how to git clone TIMM analysis data; how to enter a directory with %cd
    ## how to read a csv file with pandas
    ## how to merge data with pandas; how to create new column with pandas; how to string extract with regex expression; how to select columns up to a particular column with pandas; how to do loc in pandas; how to select a group of columns using str.contains and regex
    ## Inference results
    ### how to scatterplot with plotly.express; how to set the plot's width, height, size, title, x, y, log_x, color, hover_name, hover_data; 
    ### how to scatterplot on a subgroup of data using regex and plotly
    ## Training results
    ### convert ipynb to md
    
    /Users/Natsume/Documents/fastdebug/mds/lib/utils.md
    ## setup for exporting to a module
    ## how to get current notebook's name, path and url
    ## how to convert ipynb to md automatically; how to run commands in python
    ## Autoreload for every notebook
    ## Expand cells
    ## Import fastcore env
    ## to inspect a class
    ### get the docs for each function of a class
    ## is it a metaclass?
    ## is it a decorator
    ### handle all kinds of exceptions for evaluating retn 
    ## whatinside a module of a library
    ### show the type of objects inside `__all__`
    ### working for fastdebug.core
    ### to show Fastdb methods
    ## whichversion of a library
    ## fastview
    ## fastscrs
    ## getrootport
    ## jn_link
    ## get_all_nbs
    ### get all nbs path for both md and ipynb
    ### add index.ipynb
    ## openNB
    ## openNBKaggle
    ## highlight
    ## display_md
    display_md("#### heading level 4")
    ## display_block
            lochead2 = belowline.find("##")
            lochead3 = belowline.find("###")
            lochead4 = belowline.find("####")
            lochead2 = belowline.find("##")
            lochead3 = belowline.find("###")
            lochead4 = belowline.find("####")
    ### handle both file path and file content at the same time
        lochead2 = belowline.find("##")
        lochead3 = belowline.find("###")
        lochead4 = belowline.find("####")
    ## fastnbs
                    if pct >= accu and (l.startswith("##") or l.startswith("###") or l.startswith("####")):
    ## fastcodes
    ## fastnotes
    ### multiple folders
    ## fastlistnbs
                    if "##" in l:
                    if l.startswith("##"):
    ## fastlistsrcs
    ## Best practice of fastdebug.core
    ## Best practice of fastdebug.utils
    ## Export
    
    /Users/Natsume/Documents/fastdebug/mds/lib/00_core.md
    ## make life easier with defaults  
    ## globals() and locals()
    ## Execute strings
    ### new variable or updated variable by exec will only be accessible from locals()
    ### eval can override its own globals() and locals()
    ### when exec update existing functions
    ### when the func to be udpated involve other libraries
    ### inside a function, exec() allow won't give you necessary env from function namespace
    ### magic of `exec(b, globals().update(locals()))`
    ### Bring variables from a func namespace to the sideout world
    ### globals() in a cell vs globals() in a func
    ## make a colorful string
    ## align text to the most right
    ## printsrcwithidx
    ### print the entire source code with idx from 0
    ### print the whole src with idx or print them in parts
    ### use cmts from dbprint to print out src with comments
    ### no more update for printsrcwithidx, for the latest see Fastdb.print
    ## print out src code
    ### basic version
    ### print src with specific number of lines
    ### make the naming more sensible
    ### Allow a dbline occur more than once
    ### adding idx to the selected srclines
    #### printsrclinewithidx
    ### dblines can be string of code or idx number
    ### avoid multi-occurrance of the same srcline
    ## dbprint on expression
    ### basic version
    ### insert dbcode and make a new dbfunc
    ### Bring outside namespace variables into exec()
    ### Bring what inside the func namespace variables to the outside world
    ### Adding g = locals() to dbprintinsert to avoid adding env individually
    ### enable srclines to be either string or int 
    ### enable = to be used as assignment in codes
    ### avoid adding "env=g" for dbprintinsert
    ### collect cmt for later printsrcwithidx to print comments together
    ### make sure only one line with correct idx is debugged
    ### avoid typing "" when there is no codes
    ### no more update for dbprint, for the latest see Fastdb.dbprint
    ### use dbprint to override the original official code without changing its own pyfile
    # overriding the original official source with our dbsrc, even though rewriting _signature_from_callable inside inspect.py ######################
    ## dbprintinsert
    ### Run and display the inserted dbcodes 
    ### use locals() inside the dbsrc code to avoid adding env individually
    ### enable dbprintinsert to do exec on a block of code
                ### Note: we shall not use the expression like `for k, v in abc print(abc)`
                ### Note: we shall not use the expression like `for k, v in abc if k == def`
    ## printrunsrclines() 
    ### Examples
    #### simple example
    #### complex example
    ### insert a line after each srcline to add idx
    ### add correct indentation to each inserted line
    #### count the indentation for each srcline
    ### indentation special case: if, else, for, def
    ### remove pure comments or docs from dbsrc
    ### print out the srclines which get run
    ### Make sure all if, else, for get printed
    ### Put all together into the function printrunsrclines()
    #### no more renaming of foo
    #### add example as a param into the function
    #### improve on search for `if`, else, for, def to avoid errors for more examples
    #### remove an empty line with indentation
    ### make it work
    ### more difficult examples to test printrunsrc()
    ## Make fastdebug a class
    ### improve on the line idx readability
    ### collect cmt from dbprint and print
    ### make sure only the line with correct idx is debugged
    ### having "" or "   " inside codes without causing error
    ### replace Fastdb.printsrcwithdix with Fastdb.print
    ### add idx to dbsrc when showdbsrc=True
    ### not load the inner locals() to outenv can prevent mysterious printing of previous db messages
    ### using @patch to enable docs for instance methods like `dbprint` and `print`
    ### move param env into `__init__`
    ### Add example to the obj
    ### Take not only function but also class
    ### To remove the necessity of self.takExample()
    ### Try to remove g = locals()
    ### Make sure `showdbsrc=True` give us the line starting with 'dbprintinsert'
    ### Make sure `showdbsrc=True` give us info on changes in g or outenv
    ### exit and print a warning message: idx has to be int
    ### handle errors by codes with trailing spaces 
    ### showdbsrc=True, check whether Fastdb.dbprint and fdb.dbprint are same object using `is`
    ### remove unnecessary db printout when showdbsrc=True and add printout to display sections
    ### raise TypeError when decode are not integer and showdbsrc=true working on both method and function
    ### when debugging dbprint, make sure dbsrc is printed with the same idx as original
    ### update dbsrc to the global env
    ### go back to normal before running dbprint again
    ### auto print src with cmt and idx as the ending part of dbprint
    ### to mark my explorations (expressions to evaluate) to stand out
    ### Add the print of src with idx and comments at the end of dbsrc
    ### embed example and autoprint to shorten the code to type
    ### Make title for dbprint
    ### Adding self.eg info and color group into dbprint and print
    #### todo: make the comments with same self.eg have the same color
    ### make dbsrc print idx right
    ### add self.eg to a dict with keys are idxsrc
    ### handle both function and class as src
    ### documenting on Fastdb.dbprint itself
    ## mk_dbsrc
    ## Turn mk_dbsrc into docsrc 
    ### handle when no codes are given
    ## create_dbsrc_from_string
    ## replaceWithDbsrc
    ### handle class and metaclass
    ### improve on handling function as decorator
    ### Handling `inspect._signature_from_callable` to become `self.dbsrc`
    ### handling usage of `@delegates`
    ### handling `@delegates` with indentation before it
    ### handling classes by inspect.isclass() rather than == type and add more class situations
    ### handling `class _T(_TestA, metaclass=BypassNewMeta): `
    ## run_example
    ### `exec(self.eg, globals().update(self.egEnv), locals())` works better than `...update(locals()), self.egEnv)
    ### no more env cells run before `fdb.eg` to make `fdb.run_example` work
    ## Autoprint
    ## Take an example and its env into Fastdb obj
    ## print src with idx and cmt in whole or parts
    ### print self.eg after each comment and colorize comments
    ### color examples and cmts separately and make the func simpler
    ### split each cmt and colorize parts randomly
    ### printcmts1 while saving into a file
    ## goback
    ## Fastdb.explore
    ### adding one breakpoint with comment
    ### Adding multiple breakpoints by multiple set_trace()
    ### Go back to normal before running explore again
    ### enable fdb.takExample("whatinside(fu), ...) without using `fu.whatinside`
    ### refactory explore
    ## snoop
    ### snoop on both function and class
    ### snoop on class and method and all???
    ### snoop
    ### simplify adding @snoop for both normal function and decorator
    ### handling classes
    ### add watch
    ## Snoop
    ### add watch
    ### use guide on Fastdb.dbprint
    ## reliveonce
    ## Fastdb.debug
    ## Export
    ## Send to Obsidian
    
    /Users/Natsume/Documents/fastdebug/mds/demos/0001_fastcore_meta_delegates.md
    ## Import
    ## Initiate Fastdb and example in str
    ## Example
    ## docsrc
    ## Snoop
    
    /Users/Natsume/Documents/fastdebug/mds/demos/0003_Explore_document_FixSigMeta_PrePostInitMeta_AutoInit.md
    ## Initialize fastdebug objects
    ## class FixSigMeta(type) vs class Foo(type)
    ## class Foo()
    ## class PrePostInitMeta(FixSigMeta)
    ## class Foo(metaclass=FixSigMeta)
    ## class AutoInit(metaclass=PrePostInitMeta)
    ## Prepare examples for FixSigMeta, PrePostInitMeta, AutoInit 
    ## Snoop them together in one go
    ### embed the dbsrc of FixSigMeta into PrePostInitMeta
    ### embed dbsrc of PrePostInitMeta into AutoInit
    ## Explore and Document on them together 
    
    /Users/Natsume/Documents/fastdebug/mds/demos/0004_fastcore.meta._rm_self.md
    ## imports
    ## set up
    ## document
    ## snoop
    
    /Users/Natsume/Documents/fastdebug/mds/demos/0005_fastcore.meta.test_sig.md
    ## imports
    ## setups
    ## documents
    ## snoop
    
    /Users/Natsume/Documents/fastdebug/mds/demos/0007_fastcore.meta.BypassNewMeta.md
    ## Reading official docs
    ## Inspecting class
    ## Initiating with examples
    ## Snoop
    ## Document
    
    /Users/Natsume/Documents/fastdebug/mds/demos/0002_signature_from_callable.md
    ## Expand cell
    ## Imports and initiate
    ## Examples
    
    /Users/Natsume/Documents/fastdebug/mds/demos/0008_use_kwargs_dict.md
    ## Imports
    ## Reading official docs
    ## empty2none
    ## `_mk_param`
    ## use_kwargs_dict
    ### Reading docs
    ## use_kwargs
    ### Reading docs
    
    /Users/Natsume/Documents/fastdebug/mds/demos/0006_fastcore.meta.NewChkMeta.md
    ## Import and Initalization
    ## Official docs
    ## Prepare Example
    ## Inspect classes
    ## Snoop
    ## Document
    
    /Users/Natsume/Documents/fastdebug/mds/demos/0000_tour.md
    ### Documentation
    ### Testing
    ### Foundations
    ### L
    ### Transforms
    
    /Users/Natsume/Documents/fastdebug/mds/demos/0012_fastcore_foundation_L.md
    ## Document `L` with fastdebug
    
    /Users/Natsume/Documents/fastdebug/mds/demos/0011_Fastdb.md
    
    /Users/Natsume/Documents/fastdebug/mds/demos/0009_funcs_kwargs.md
    ## fastcore.meta.method
    ### Reading Docs
    ### Running codes
    ### Document
    ### snoop
    ## funcs_kwargs
    ### Official docs
    ### snoop: from _funcs_kwargs to funcs_kwargs
    ### snoop only '_funcs_kwargs' by breaking up 'funcs_kwargs'
    
    /Users/Natsume/Documents/fastdebug/mds/demos/0010_fastcore_meta_summary.md
    ## import
    ## fastcore and fastcore.meta
    ### What's inside fastcore.meta
    ## Review individual funcs and classes
    ### What is fastcore.meta all about? 
    ### What can these metaclasses do for me?
    #### FixSigMeta
    #### PrePostInitMeta
    #### AutoInit
    #### NewChkMeta
    #### BypassNewMeta
    ### What can those decorators do for me?
    #### use_kwargs_dict
    #### use_kwargs
    #### delegates
    #### funcs_kwargs
    ### The remaining functions
    ## What is fastcore.meta all about
    
    /Users/Natsume/Documents/fastdebug/mds/questions/00_question_anno_dict.md
    ## `anno_dict` docs
    ## Dive in
    ## `anno_dict` seems not add anything new to `__annotations__`
    ## use fastdebug to double check
    ## Does fastcore want anno_dict to include params with no annos?
    ## Jeremy's response


## fastlistsrcs

Todos: it should be retired by fastlistnbs() after all src notebooks are properly documented.


```
#| export
def fastlistsrcs():
    "display all my commented src codes learning comments in a long list"
    folder ='/Users/Natsume/Documents/fastdebug/learnings/'
    for f in os.listdir(folder):
        if f.endswith(".py"):
            path_f = folder + f
            with open(path_f, 'r') as file:
                for idx, l in enumerate(file):
                    if "#" in l:
                        print(l.split("#")[1], end="")
#                         print(l, end="") # no extra new line between each line printed
        
```


```
fastcodes("Test the signature", nb=True)
```


keyword match is  <mark style="background-color: #ffff00">1.0</mark> , found a line: in  <mark style="background-color: #FFFF00">test_sig.py</mark> 


        "Test the signature of an object"=====================================================(1) # [91;1mtest_sig(f:FunctionType or ClassType, b:str)[0m; [34;1mtest_sig will get f's signature as a string[0m; [37;1mb is a signature in string provided by the user[0m; [92;1min fact, test_sig is to compare two strings[0m; 
    



the entire source code in  <mark style="background-color: #FFFF00">test_sig.py</mark> 


    
    def func_2(h,i=3, j=[5,6]): pass
    test_sig(func_2, '(h, i=3, j=[5, 6])')
    
    def test_sig(f, b):=======================================================================(0)       
        "Test the signature of an object"=====================================================(1) # [91;1mtest_sig(f:FunctionType or ClassType, b:str)[0m; [34;1mtest_sig will get f's signature as a string[0m; [37;1mb is a signature in string provided by the user[0m; [92;1min fact, test_sig is to compare two strings[0m; 
        test_eq(str(inspect.signature(f)), b)=================================================(2) # [34;1mtest_sig is to test two strings with test_eq[0m; [37;1mhow to turn a signature into a string;[0m; 
                                                                                                                                                            (3)
    



[Open `0005_fastcore` in Jupyter Notebook locally](http://localhost:8888/tree/nbs/demos/0005_fastcore.meta.test_sig.ipynb)



```

```


```

```

## Best practice of fastdebug.core

1. test some examples 

2. import fastdebug and initialize fdb objects, put examples into fdb.eg

3. run fdb.snoop() to see all lines that get run

4. if error, run fdb.debug() to check for clues

5. run fdb.print() to see bare source

6. run fdb.docsrc() to run expression and document srcline

7. how snoop: from _funcs_kwargs to funcs_kwargs, see the learning point below
 



```
fastnbs("snoop: from _funcs_kwargs to funcs_kwargs", output=True)
```


###  <mark style="background-color: #ffff00">snoop:</mark>   <mark style="background-color: #ffff00">from</mark>   <mark style="background-color: #ffff00">_ <mark style="background-color: #FFFF00">funcs_kwargs</mark> </mark>   <mark style="background-color: #ffff00">to</mark>   <mark style="background-color: #FFFF00">funcs_kwargs</mark> 



    
    
    
        
        
        
            
            
            
                
                how to snoop on two functions one wrap around another: `funcs_kwargs` is a wrapper around `_funcs_kwargs`, so I can first snoop on `_funcs_kwargs` and assign its snoop dbsrc to \
                `fm._funcs_kwargs` so that when I snoop on `funcs_kwargs`, it can use the snoop dbsrc of `_funcs_kwargs` and no example codes need to change.
                
                
                ```
                from fastcore.meta import _funcs_kwargs
                ```
                
                
                ```
                fdb_ = Fastdb(_funcs_kwargs)
                fdb_.eg = """
                @funcs_kwargs
                class T:
                    _methods=['b'] # allows you to add method b upon instantiation
                    def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                    def a(self): return 1
                    def b(self): return 2
                    
                t = T()
                test_eq(t.a(), 1)
                test_eq(t.b(), 2)
                
                test_sig(T, '(f=1, *, b=None)')
                inspect.signature(T)
                
                def _new_func(): return 5
                
                t = T(b = _new_func)
                test_eq(t.b(), 5)
                
                t = T(a = lambda:3)
                test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                """
                ```
                
                
                ```
                #| column: screen
                # no snoop result, it is expected, because the example is not calling _funcs_kwargs, but funcs_kwargs
                fdb_.snoop(deco=True) # how to snoop decorator: _funcs_kwargs is a decorator, so set deco=True to see running codes in inner f
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    [0m     
                    
                
                
                
                ```
                import fastcore.meta as fm
                ```
                
                
                ```
                fm._funcs_kwargs = fdb_.dbsrc # how to snoop on two functions one wrap around another
                ```
                
                
                ```
                fdb = Fastdb(funcs_kwargs)
                fdb.eg = """
                @funcs_kwargs
                class T:
                    _methods=['b'] # allows you to add method b upon instantiation
                    def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                    def a(self): return 1
                    def b(self): return 2
                    
                t = T()
                test_eq(t.a(), 1)
                test_eq(t.b(), 2)
                
                test_sig(T, '(f=1, *, b=None)')
                inspect.signature(T)
                
                def _new_func(): return 5
                
                t = T(b = _new_func)
                test_eq(t.b(), 5)
                
                t = T(a = lambda:3)
                test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                
                def _f(self,a=1): return self.num + a # access the num attribute from the instance
                
                @funcs_kwargs(as_method=True)
                class T: 
                    _methods=['b']
                    num = 5
                    
                t = T(b = _f) # adds method b
                test_eq(t.b(5), 10) # self.num + 5 = 10
                
                def _f(self,a=1): return self.num * a #multiply instead of add 
                
                class T2(T):
                    def __init__(self,num):
                        super().__init__(b = _f) # add method b from the super class
                        self.num=num
                        
                t = T2(num=3)
                test_eq(t.b(a=5), 15) # 3 * 5 = 15
                test_sig(T2, '(num)')
                """
                ```
                
                
                ```
                #| column: screen
                fdb.print()
                ```
                
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    def funcs_kwargs(as_method=False):========================================================(0)       
                        "Replace methods in `cls._methods` with those from `kwargs`"==========================(1)       
                        if callable(as_method): return _funcs_kwargs(as_method, False)========================(2)       
                        return partial(_funcs_kwargs, as_method=as_method)====================================(3)       
                                                                                                                                                                            (4)
                
                
                
                ```
                #| column: screen
                fdb_.print()
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    def _funcs_kwargs(cls, as_method):========================================================(0)       
                        old_init = cls.__init__===============================================================(1)       
                        def _init(self, *args, **kwargs):=====================================================(2)       
                            for k in cls._methods:============================================================(3)       
                                arg = kwargs.pop(k,None)======================================================(4)       
                                if arg is not None:===========================================================(5)       
                                    if as_method: arg = method(arg)===========================================(6)       
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)=======(7)       
                                    setattr(self, k, arg)=====================================================(8)       
                            old_init(self, *args, **kwargs)===================================================(9)       
                        functools.update_wrapper(_init, old_init)=============================================(10)      
                        cls.__init__ = use_kwargs(cls._methods)(_init)========================================(11)      
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))                                                     (12)
                        return cls============================================================================(13)      
                                                                                                                                                                            (14)
                
                
                
                ```
                #| column: screen
                fdb.docsrc(1, "how funcs_kwargs works; it is a wrapper around _funcs_kwargs; it offers two ways of running _funcs_kwargs; \
                the first, default way, is to add a func to a class without using self; second way is to add func to class enabling self use;")
                fdb.docsrc(2, "how to check whether an object is callable; how to return a result of running a func; ")
                fdb.docsrc(3, "how to custom the params of `_funcs_kwargs` for a particular use with partial")
                ```
                
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m1[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                    def funcs_kwargs(as_method=False):                                                                                                                      (0)
                        "Replace methods in `cls._methods` with those from `kwargs`"========================================================================================(1)
                    [91;1mhow funcs_kwargs works; it is a wrapper around _funcs_kwargs; it offers two ways of running _funcs_kwargs; the first, default way, is to add a func to a class without using self; second way is to add func to class enabling self use;[0m
                        if callable(as_method): return _funcs_kwargs(as_method, False)                                                                                      (2)
                        return partial(_funcs_kwargs, as_method=as_method)                                                                                                  (3)
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m2[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                    def funcs_kwargs(as_method=False):                                                                                                                      (0)
                        "Replace methods in `cls._methods` with those from `kwargs`"                                                                                        (1)
                        if callable(as_method): return _funcs_kwargs(as_method, False)======================================================================================(2)
                                                                                           [91;1mhow to check whether an object is callable; how to return a result of running a func; [0m
                        return partial(_funcs_kwargs, as_method=as_method)                                                                                                  (3)
                                                                                                                                                                            (4)
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m3[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                        "Replace methods in `cls._methods` with those from `kwargs`"                                                                                        (1)
                        if callable(as_method): return _funcs_kwargs(as_method, False)                                                                                      (2)
                        return partial(_funcs_kwargs, as_method=as_method)==================================================================================================(3)
                                                                                                    [91;1mhow to custom the params of `_funcs_kwargs` for a particular use with partial[0m
                                                                                                                                                                            (4)
                
                
                
                ```
                #| column: screen
                fdb_.print()
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    def _funcs_kwargs(cls, as_method):========================================================(0)       
                        old_init = cls.__init__===============================================================(1)       
                        def _init(self, *args, **kwargs):=====================================================(2)       
                            for k in cls._methods:============================================================(3)       
                                arg = kwargs.pop(k,None)======================================================(4)       
                                if arg is not None:===========================================================(5)       
                                    if as_method: arg = method(arg)===========================================(6)       
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)=======(7)       
                                    setattr(self, k, arg)=====================================================(8)       
                            old_init(self, *args, **kwargs)===================================================(9)       
                        functools.update_wrapper(_init, old_init)=============================================(10)      
                        cls.__init__ = use_kwargs(cls._methods)(_init)========================================(11)      
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))                                                     (12)
                        return cls============================================================================(13)      
                                                                                                                                                                            (14)
                
                
                
                ```
                #| column: screen
                fdb_.docsrc(0, "how does _funcs_kwargs work: _funcs_kwargs is a decorator; it helps class e.g., T to add more methods; \
                I need to give the method a name, \
                and put the name e.g., 'b' inside a list called _methods=['b'] inside class T; \
                then after writing a func e.g., _new_func, I can add it by T(b = _new_func); if I want the func added to class to use self, \
                I shall write @funcs_kwargs(as_method=True)")
                fdb_.docsrc(2, "how to define a method which can use self and accept any parameters")
                fdb_.docsrc(3, "how to pop out the value of an item in a dict (with None as default), and if the item name is not found, pop out None instead; ")
                fdb_.docsrc(6, "how to turn a func into a method")
                fdb_.docsrc(7, "how to give a method a different instance, like self")
                fdb_.docsrc(8, "how to add a method to a class as an attribute")
                fdb_.docsrc(10, "how to wrap `_init` around `old_init`, so that `_init` can use `old_init` inside itself")
                fdb_.docsrc(11, "how to add a list of names with None as default value to function `_init` to repalce its kwargs param")
                fdb_.docsrc(12, "how to make a class.`__init__` signature to be the signature of the class using `__signature__` and `_rm_self`")
                
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m0[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                    def _funcs_kwargs(cls, as_method):======================================================================================================================(0)
                    [91;1mhow does _funcs_kwargs work: _funcs_kwargs is a decorator; it helps class e.g., T to add more methods; I need to give the method a name, and put the name e.g., 'b' inside a list called _methods=['b'] inside class T; then after writing a func e.g., _new_func, I can add it by T(b = _new_func); if I want the func added to class to use self, I shall write @funcs_kwargs(as_method=True)[0m
                        old_init = cls.__init__                                                                                                                             (1)
                        def _init(self, *args, **kwargs):                                                                                                                   (2)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m2[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                    def _funcs_kwargs(cls, as_method):                                                                                                                      (0)
                        old_init = cls.__init__                                                                                                                             (1)
                        def _init(self, *args, **kwargs):===================================================================================================================(2)
                                                                                                              [91;1mhow to define a method which can use self and accept any parameters[0m
                            for k in cls._methods:                                                                                                                          (3)
                                arg = kwargs.pop(k,None)                                                                                                                    (4)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m3[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                        old_init = cls.__init__                                                                                                                             (1)
                        def _init(self, *args, **kwargs):                                                                                                                   (2)
                            for k in cls._methods:==========================================================================================================================(3)
                                                  [91;1mhow to pop out the value of an item in a dict (with None as default), and if the item name is not found, pop out None instead; [0m
                                arg = kwargs.pop(k,None)                                                                                                                    (4)
                                if arg is not None:                                                                                                                         (5)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m6[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                                arg = kwargs.pop(k,None)                                                                                                                    (4)
                                if arg is not None:                                                                                                                         (5)
                                    if as_method: arg = method(arg)=========================================================================================================(6)
                                                                                                                                                 [91;1mhow to turn a func into a method[0m
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)                                                                     (7)
                                    setattr(self, k, arg)                                                                                                                   (8)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m7[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                                if arg is not None:                                                                                                                         (5)
                                    if as_method: arg = method(arg)                                                                                                         (6)
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)=====================================================================(7)
                                                                                                                             [91;1mhow to give a method a different instance, like self[0m
                                    setattr(self, k, arg)                                                                                                                   (8)
                            old_init(self, *args, **kwargs)                                                                                                                 (9)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m8[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                                    if as_method: arg = method(arg)                                                                                                         (6)
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)                                                                     (7)
                                    setattr(self, k, arg)===================================================================================================================(8)
                                                                                                                                   [91;1mhow to add a method to a class as an attribute[0m
                            old_init(self, *args, **kwargs)                                                                                                                 (9)
                        functools.update_wrapper(_init, old_init)                                                                                                           (10)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m10[0m     ===============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                                    setattr(self, k, arg)                                                                                                                   (8)
                            old_init(self, *args, **kwargs)                                                                                                                 (9)
                        functools.update_wrapper(_init, old_init)===========================================================================================================(10)
                                                                                          [91;1mhow to wrap `_init` around `old_init`, so that `_init` can use `old_init` inside itself[0m
                        cls.__init__ = use_kwargs(cls._methods)(_init)                                                                                                      (11)
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))                                                     (12)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m11[0m     ===============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                            old_init(self, *args, **kwargs)                                                                                                                 (9)
                        functools.update_wrapper(_init, old_init)                                                                                                           (10)
                        cls.__init__ = use_kwargs(cls._methods)(_init)======================================================================================================(11)
                                                                            [91;1mhow to add a list of names with None as default value to function `_init` to repalce its kwargs param[0m
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))                                                     (12)
                        return cls                                                                                                                                          (13)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m12[0m     ===============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                        functools.update_wrapper(_init, old_init)                                                                                                           (10)
                        cls.__init__ = use_kwargs(cls._methods)(_init)                                                                                                      (11)
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))=====================================================(12)
                                                                   [91;1mhow to make a class.`__init__` signature to be the signature of the class using `__signature__` and `_rm_self`[0m
                        return cls                                                                                                                                          (13)
                                                                                                                                                                            (14)
                
                
                
                ```
                #| column: screen
                fdb.snoop() # how to snoop together with docsrc: snoop first and docsrc above it
                ```
                
                    22:28:59.99 >>> Call to funcs_kwargs in File "/tmp/funcs_kwargs.py", line 3
                    22:28:59.99 ...... as_method = <class 'fastcore.meta.T'>
                    22:28:59.99    3 | def funcs_kwargs(as_method=False):
                    22:28:59.99    5 |     if callable(as_method): return _funcs_kwargs(as_method, False)
                        22:28:59.99 >>> Call to _funcs_kwargs in File "/tmp/_funcs_kwargs.py", line 3
                        22:28:59.99 ...... cls = <class 'fastcore.meta.T'>
                        22:28:59.99 ...... as_method = False
                        22:28:59.99    3 | def _funcs_kwargs(cls, as_method):
                        22:28:59.99    4 |     old_init = cls.__init__
                        22:28:59.99 .......... old_init = <function T.__init__>
                        22:28:59.99    5 |     import snoop
                        22:28:59.99 .......... snoop = <class 'snoop.configuration.Config.__init__.<locals>.ConfiguredTracer'>
                        22:28:59.99    6 |     @snoop
                        22:28:59.99    7 |     def _init(self, *args, **kwargs):
                        22:28:59.99 .......... _init = <function _funcs_kwargs.<locals>._init>
                        22:28:59.99   15 |     functools.update_wrapper(_init, old_init)
                        22:28:59.99 .......... _init = <function T.__init__>
                        22:28:59.99   16 |     cls.__init__ = use_kwargs(cls._methods)(_init)
                        22:28:59.99   17 |     if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))
                        22:28:59.99   18 |     return cls
                        22:28:59.99 <<< Return value from _funcs_kwargs: <class 'fastcore.meta.T'>
                    22:28:59.99    5 |     if callable(as_method): return _funcs_kwargs(as_method, False)
                    22:28:59.99 <<< Return value from funcs_kwargs: <class 'fastcore.meta.T'>
                    22:28:59.99 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:28:59.99 .......... self = <fastcore.meta.T object>
                    22:28:59.99 .......... args = ()
                    22:28:59.99 .......... kwargs = {}
                    22:28:59.99 .......... as_method = False
                    22:28:59.99 .......... cls = <class 'fastcore.meta.T'>
                    22:28:59.99 .......... old_init = <function T.__init__>
                    22:28:59.99    7 |     def _init(self, *args, **kwargs):
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00 .............. k = 'b'
                    22:29:00.00    9 |             arg = kwargs.pop(k,None)
                    22:29:00.00 .................. arg = None
                    22:29:00.00   10 |             if arg is not None:
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00   14 |         old_init(self, *args, **kwargs)
                    22:29:00.00 <<< Return value from _funcs_kwargs.<locals>._init: None
                    22:29:00.00 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:29:00.00 .......... self = <fastcore.meta.T object>
                    22:29:00.00 .......... args = ()
                    22:29:00.00 .......... kwargs = {'b': <function _new_func>}
                    22:29:00.00 .......... len(kwargs) = 1
                    22:29:00.00 .......... as_method = False
                    22:29:00.00 .......... cls = <class 'fastcore.meta.T'>
                    22:29:00.00 .......... old_init = <function T.__init__>
                    22:29:00.00    7 |     def _init(self, *args, **kwargs):
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00 .............. k = 'b'
                    22:29:00.00    9 |             arg = kwargs.pop(k,None)
                    22:29:00.00 .................. kwargs = {}
                    22:29:00.00 .................. arg = <function _new_func>
                    22:29:00.00   10 |             if arg is not None:
                    22:29:00.00   11 |                 if as_method: arg = method(arg)
                    22:29:00.00   12 |                 if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)
                    22:29:00.00   13 |                 setattr(self, k, arg)
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00   14 |         old_init(self, *args, **kwargs)
                    22:29:00.00 <<< Return value from _funcs_kwargs.<locals>._init: None
                    22:29:00.00 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:29:00.00 .......... self = <fastcore.meta.T object>
                    22:29:00.00 .......... args = ()
                    22:29:00.00 .......... kwargs = {'a': <function <lambda>>}
                    22:29:00.00 .......... len(kwargs) = 1
                    22:29:00.00 .......... as_method = False
                    22:29:00.00 .......... cls = <class 'fastcore.meta.T'>
                    22:29:00.00 .......... old_init = <function T.__init__>
                    22:29:00.00    7 |     def _init(self, *args, **kwargs):
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00 .............. k = 'b'
                    22:29:00.00    9 |             arg = kwargs.pop(k,None)
                    22:29:00.00 .................. arg = None
                    22:29:00.00   10 |             if arg is not None:
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00   14 |         old_init(self, *args, **kwargs)
                    22:29:00.00 <<< Return value from _funcs_kwargs.<locals>._init: None
                    22:29:00.00 >>> Call to funcs_kwargs in File "/tmp/funcs_kwargs.py", line 3
                    22:29:00.00 ...... as_method = True
                    22:29:00.00    3 | def funcs_kwargs(as_method=False):
                    22:29:00.00    5 |     if callable(as_method): return _funcs_kwargs(as_method, False)
                    22:29:00.00    6 |     return partial(_funcs_kwargs, as_method=as_method)
                    22:29:00.00 <<< Return value from funcs_kwargs: functools.partial(<function _funcs_kwargs>, as_method=True)
                    22:29:00.00 >>> Call to _funcs_kwargs in File "/tmp/_funcs_kwargs.py", line 3
                    22:29:00.00 ...... cls = <class 'fastcore.meta.T'>
                    22:29:00.00 ...... as_method = True
                    22:29:00.00    3 | def _funcs_kwargs(cls, as_method):
                    22:29:00.00    4 |     old_init = cls.__init__
                    22:29:00.00 .......... old_init = <slot wrapper '__init__' of 'object' objects>
                    22:29:00.00    5 |     import snoop
                    22:29:00.00 .......... snoop = <class 'snoop.configuration.Config.__init__.<locals>.ConfiguredTracer'>
                    22:29:00.00    6 |     @snoop
                    22:29:00.00    7 |     def _init(self, *args, **kwargs):
                    22:29:00.00 .......... _init = <function _funcs_kwargs.<locals>._init>
                    22:29:00.00   15 |     functools.update_wrapper(_init, old_init)
                    22:29:00.00 .......... _init = <function object.__init__>
                    22:29:00.00   16 |     cls.__init__ = use_kwargs(cls._methods)(_init)
                    22:29:00.01   17 |     if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))
                    22:29:00.01   18 |     return cls
                    22:29:00.01 <<< Return value from _funcs_kwargs: <class 'fastcore.meta.T'>
                    22:29:00.01 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:29:00.01 .......... self = <fastcore.meta.T object>
                    22:29:00.01 .......... args = ()
                    22:29:00.01 .......... kwargs = {'b': <function _f>}
                    22:29:00.01 .......... len(kwargs) = 1
                    22:29:00.01 .......... as_method = True
                    22:29:00.01 .......... cls = <class 'fastcore.meta.T'>
                    22:29:00.01 .......... old_init = <slot wrapper '__init__' of 'object' objects>
                    22:29:00.01    7 |     def _init(self, *args, **kwargs):
                    22:29:00.01    8 |         for k in cls._methods:
                    22:29:00.01 .............. k = 'b'
                    22:29:00.01    9 |             arg = kwargs.pop(k,None)
                    22:29:00.01 .................. kwargs = {}
                    22:29:00.01 .................. arg = <function _f>
                    22:29:00.01   10 |             if arg is not None:
                    22:29:00.01   11 |                 if as_method: arg = method(arg)
                    22:29:00.01 ...... arg = <bound method int._f of 1>
                    22:29:00.01   12 |                 if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)
                    22:29:00.01 ...... arg = <bound method T._f of <fastcore.meta.T object>>
                    22:29:00.01   13 |                 setattr(self, k, arg)
                    22:29:00.01    8 |         for k in cls._methods:
                    22:29:00.01   14 |         old_init(self, *args, **kwargs)
                    22:29:00.01 <<< Return value from _funcs_kwargs.<locals>._init: None
                    22:29:00.01 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:29:00.01 .......... self = <fastcore.meta.T2 object>
                    22:29:00.01 .......... args = ()
                    22:29:00.01 .......... kwargs = {'b': <function _f>}
                    22:29:00.01 .......... len(kwargs) = 1
                    22:29:00.01 .......... as_method = True
                    22:29:00.01 .......... cls = <class 'fastcore.meta.T'>
                    22:29:00.01 .......... old_init = <slot wrapper '__init__' of 'object' objects>
                    22:29:00.01    7 |     def _init(self, *args, **kwargs):
                    22:29:00.01    8 |         for k in cls._methods:
                    22:29:00.01 .............. k = 'b'
                    22:29:00.01    9 |             arg = kwargs.pop(k,None)
                    22:29:00.01 .................. kwargs = {}
                    22:29:00.01 .................. arg = <function _f>
                    22:29:00.01   10 |             if arg is not None:
                    22:29:00.01   11 |                 if as_method: arg = method(arg)
                    22:29:00.01 ...... arg = <bound method int._f of 1>
                    22:29:00.01   12 |                 if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)
                    22:29:00.01 ...... arg = <bound method T2._f of <fastcore.meta.T2 object>>
                    22:29:00.01   13 |                 setattr(self, k, arg)
                    22:29:00.01    8 |         for k in cls._methods:
                    22:29:00.01   14 |         old_init(self, *args, **kwargs)
                    22:29:00.01 <<< Return value from _funcs_kwargs.<locals>._init: None
                
                
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                
                
                
                ```
                fdb_.debug()
                ```
                
                    _funcs_kwargs's dbsrc code: ==============
                    import snoop
                    @snoop
                    def _funcs_kwargs(cls, as_method):
                        old_init = cls.__init__
                        import snoop
                        @snoop
                        def _init(self, *args, **kwargs):
                            for k in cls._methods:
                                arg = kwargs.pop(k,None)
                                if arg is not None:
                                    if as_method: arg = method(arg)
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)
                                    setattr(self, k, arg)
                            old_init(self, *args, **kwargs)
                        functools.update_wrapper(_init, old_init)
                        cls.__init__ = use_kwargs(cls._methods)(_init)
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))
                        return cls
                    
                    
                    
                    _funcs_kwargs's example processed with dbsrc: ===============
                    
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    
                
                
                
                ```
                #| column: screen
                fdb.print()
                ```
                
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    def funcs_kwargs(as_method=False):========================================================(0)       
                        "Replace methods in `cls._methods` with those from `kwargs`"==========================(1) # [93;1mhow funcs_kwargs works[0m; [93;1mit is a wrapper around _funcs_kwargs[0m; [91;1mit offers two ways of running _funcs_kwargs[0m; [37;1mthe first, default way, is to add a func to a class without using self[0m; [91;1msecond way is to add func to class enabling self use;[0m; 
                        if callable(as_method): return _funcs_kwargs(as_method, False)========================(2) # [37;1mhow to check whether an object is callable[0m; [93;1mhow to return a result of running a func[0m; [37;1m[0m; 
                        return partial(_funcs_kwargs, as_method=as_method)====================================(3) # [92;1mhow to custom the params of `_funcs_kwargs` for a particular use with partial[0m; 
                                                                                                                                                                            (4)
                
                
                
                ```
                #| column: screen
                fdb_.print()
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m12[0m     ===============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    def _funcs_kwargs(cls, as_method):========================================================(0) # [93;1mhow does _funcs_kwargs work: _funcs_kwargs is a decorator[0m; [35;1mit helps class e.g., T to add more methods[0m; [93;1mI need to give the method a name, and put the name e.g., 'b' inside a list called _methods=['b'] inside class T[0m; [36;1mthen after writing a func e.g., _new_func, I can add it by T(b = _new_func)[0m; [36;1mif I want the func added to class to use self, I shall write @funcs_kwargs(as_method=True)[0m; 
                        old_init = cls.__init__===============================================================(1)       
                        def _init(self, *args, **kwargs):=====================================================(2) # [37;1mhow to define a method which can use self and accept any parameters[0m; 
                            for k in cls._methods:============================================================(3) # [35;1mhow to pop out the value of an item in a dict (with None as default), and if the item name is not found, pop out None instead[0m; [91;1m[0m; 
                                arg = kwargs.pop(k,None)======================================================(4)       
                                if arg is not None:===========================================================(5)       
                                    if as_method: arg = method(arg)===========================================(6) # [36;1mhow to turn a func into a method[0m; 
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)=======(7) # [93;1mhow to give a method a different instance, like self[0m; 
                                    setattr(self, k, arg)=====================================================(8) # [36;1mhow to add a method to a class as an attribute[0m; 
                            old_init(self, *args, **kwargs)===================================================(9)       
                        functools.update_wrapper(_init, old_init)=============================================(10) # [34;1mhow to wrap `_init` around `old_init`, so that `_init` can use `old_init` inside itself[0m; 
                        cls.__init__ = use_kwargs(cls._methods)(_init)========================================(11) # [34;1mhow to add a list of names with None as default value to function `_init` to repalce its kwargs param[0m; 
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__)) # [35;1mhow to make a class.`__init__` signature to be the signature of the class using `__signature__` and `_rm_self`[0m;  (12)
                        return cls============================================================================(13)      
                                                                                                                                                                            (14)
                
                
                
                ```
                
                ```
                
                
            
            
            
            [Open `0009_funcs_kwargs` in Jupyter Notebook](http://localhost:8888/tree/nbs/demos/0009_funcs_kwargs.ipynb)
            
            
            
        
        
        
        [Open `utils` in Jupyter Notebook](http://localhost:8888/tree/nbs/lib/utils.ipynb)
        
        
        
        
    
    
    
    [Open `utils` in Jupyter Notebook](http://localhost:8888/tree/nbs/lib/utils.ipynb)
    
    
    
    



[Open `utils` in Jupyter Notebook locally](http://localhost:8888/tree/nbs/lib/utils.ipynb)



###  <mark style="background-color: #ffff00">snoop:</mark>   <mark style="background-color: #ffff00">from</mark>   <mark style="background-color: #ffff00">_ <mark style="background-color: #FFFF00">funcs_kwargs</mark> </mark>   <mark style="background-color: #ffff00">to</mark>   <mark style="background-color: #FFFF00">funcs_kwargs</mark> 



    
    
    
        
        
        
            
            
            
                
                how to snoop on two functions one wrap around another: `funcs_kwargs` is a wrapper around `_funcs_kwargs`, so I can first snoop on `_funcs_kwargs` and assign its snoop dbsrc to \
                `fm._funcs_kwargs` so that when I snoop on `funcs_kwargs`, it can use the snoop dbsrc of `_funcs_kwargs` and no example codes need to change.
                
                
                ```
                from fastcore.meta import _funcs_kwargs
                ```
                
                
                ```
                fdb_ = Fastdb(_funcs_kwargs)
                fdb_.eg = """
                @funcs_kwargs
                class T:
                    _methods=['b'] # allows you to add method b upon instantiation
                    def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                    def a(self): return 1
                    def b(self): return 2
                    
                t = T()
                test_eq(t.a(), 1)
                test_eq(t.b(), 2)
                
                test_sig(T, '(f=1, *, b=None)')
                inspect.signature(T)
                
                def _new_func(): return 5
                
                t = T(b = _new_func)
                test_eq(t.b(), 5)
                
                t = T(a = lambda:3)
                test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                """
                ```
                
                
                ```
                #| column: screen
                # no snoop result, it is expected, because the example is not calling _funcs_kwargs, but funcs_kwargs
                fdb_.snoop(deco=True) # how to snoop decorator: _funcs_kwargs is a decorator, so set deco=True to see running codes in inner f
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    [0m     
                    
                
                
                
                ```
                import fastcore.meta as fm
                ```
                
                
                ```
                fm._funcs_kwargs = fdb_.dbsrc # how to snoop on two functions one wrap around another
                ```
                
                
                ```
                fdb = Fastdb(funcs_kwargs)
                fdb.eg = """
                @funcs_kwargs
                class T:
                    _methods=['b'] # allows you to add method b upon instantiation
                    def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                    def a(self): return 1
                    def b(self): return 2
                    
                t = T()
                test_eq(t.a(), 1)
                test_eq(t.b(), 2)
                
                test_sig(T, '(f=1, *, b=None)')
                inspect.signature(T)
                
                def _new_func(): return 5
                
                t = T(b = _new_func)
                test_eq(t.b(), 5)
                
                t = T(a = lambda:3)
                test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                
                def _f(self,a=1): return self.num + a # access the num attribute from the instance
                
                @funcs_kwargs(as_method=True)
                class T: 
                    _methods=['b']
                    num = 5
                    
                t = T(b = _f) # adds method b
                test_eq(t.b(5), 10) # self.num + 5 = 10
                
                def _f(self,a=1): return self.num * a #multiply instead of add 
                
                class T2(T):
                    def __init__(self,num):
                        super().__init__(b = _f) # add method b from the super class
                        self.num=num
                        
                t = T2(num=3)
                test_eq(t.b(a=5), 15) # 3 * 5 = 15
                test_sig(T2, '(num)')
                """
                ```
                
                
                ```
                #| column: screen
                fdb.print()
                ```
                
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    def funcs_kwargs(as_method=False):========================================================(0)       
                        "Replace methods in `cls._methods` with those from `kwargs`"==========================(1)       
                        if callable(as_method): return _funcs_kwargs(as_method, False)========================(2)       
                        return partial(_funcs_kwargs, as_method=as_method)====================================(3)       
                                                                                                                                                                            (4)
                
                
                
                ```
                #| column: screen
                fdb_.print()
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    def _funcs_kwargs(cls, as_method):========================================================(0)       
                        old_init = cls.__init__===============================================================(1)       
                        def _init(self, *args, **kwargs):=====================================================(2)       
                            for k in cls._methods:============================================================(3)       
                                arg = kwargs.pop(k,None)======================================================(4)       
                                if arg is not None:===========================================================(5)       
                                    if as_method: arg = method(arg)===========================================(6)       
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)=======(7)       
                                    setattr(self, k, arg)=====================================================(8)       
                            old_init(self, *args, **kwargs)===================================================(9)       
                        functools.update_wrapper(_init, old_init)=============================================(10)      
                        cls.__init__ = use_kwargs(cls._methods)(_init)========================================(11)      
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))                                                     (12)
                        return cls============================================================================(13)      
                                                                                                                                                                            (14)
                
                
                
                ```
                #| column: screen
                fdb.docsrc(1, "how funcs_kwargs works; it is a wrapper around _funcs_kwargs; it offers two ways of running _funcs_kwargs; \
                the first, default way, is to add a func to a class without using self; second way is to add func to class enabling self use;")
                fdb.docsrc(2, "how to check whether an object is callable; how to return a result of running a func; ")
                fdb.docsrc(3, "how to custom the params of `_funcs_kwargs` for a particular use with partial")
                ```
                
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m1[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                    def funcs_kwargs(as_method=False):                                                                                                                      (0)
                        "Replace methods in `cls._methods` with those from `kwargs`"========================================================================================(1)
                    [91;1mhow funcs_kwargs works; it is a wrapper around _funcs_kwargs; it offers two ways of running _funcs_kwargs; the first, default way, is to add a func to a class without using self; second way is to add func to class enabling self use;[0m
                        if callable(as_method): return _funcs_kwargs(as_method, False)                                                                                      (2)
                        return partial(_funcs_kwargs, as_method=as_method)                                                                                                  (3)
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m2[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                    def funcs_kwargs(as_method=False):                                                                                                                      (0)
                        "Replace methods in `cls._methods` with those from `kwargs`"                                                                                        (1)
                        if callable(as_method): return _funcs_kwargs(as_method, False)======================================================================================(2)
                                                                                           [91;1mhow to check whether an object is callable; how to return a result of running a func; [0m
                        return partial(_funcs_kwargs, as_method=as_method)                                                                                                  (3)
                                                                                                                                                                            (4)
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m3[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                        "Replace methods in `cls._methods` with those from `kwargs`"                                                                                        (1)
                        if callable(as_method): return _funcs_kwargs(as_method, False)                                                                                      (2)
                        return partial(_funcs_kwargs, as_method=as_method)==================================================================================================(3)
                                                                                                    [91;1mhow to custom the params of `_funcs_kwargs` for a particular use with partial[0m
                                                                                                                                                                            (4)
                
                
                
                ```
                #| column: screen
                fdb_.print()
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    def _funcs_kwargs(cls, as_method):========================================================(0)       
                        old_init = cls.__init__===============================================================(1)       
                        def _init(self, *args, **kwargs):=====================================================(2)       
                            for k in cls._methods:============================================================(3)       
                                arg = kwargs.pop(k,None)======================================================(4)       
                                if arg is not None:===========================================================(5)       
                                    if as_method: arg = method(arg)===========================================(6)       
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)=======(7)       
                                    setattr(self, k, arg)=====================================================(8)       
                            old_init(self, *args, **kwargs)===================================================(9)       
                        functools.update_wrapper(_init, old_init)=============================================(10)      
                        cls.__init__ = use_kwargs(cls._methods)(_init)========================================(11)      
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))                                                     (12)
                        return cls============================================================================(13)      
                                                                                                                                                                            (14)
                
                
                
                ```
                #| column: screen
                fdb_.docsrc(0, "how does _funcs_kwargs work: _funcs_kwargs is a decorator; it helps class e.g., T to add more methods; \
                I need to give the method a name, \
                and put the name e.g., 'b' inside a list called _methods=['b'] inside class T; \
                then after writing a func e.g., _new_func, I can add it by T(b = _new_func); if I want the func added to class to use self, \
                I shall write @funcs_kwargs(as_method=True)")
                fdb_.docsrc(2, "how to define a method which can use self and accept any parameters")
                fdb_.docsrc(3, "how to pop out the value of an item in a dict (with None as default), and if the item name is not found, pop out None instead; ")
                fdb_.docsrc(6, "how to turn a func into a method")
                fdb_.docsrc(7, "how to give a method a different instance, like self")
                fdb_.docsrc(8, "how to add a method to a class as an attribute")
                fdb_.docsrc(10, "how to wrap `_init` around `old_init`, so that `_init` can use `old_init` inside itself")
                fdb_.docsrc(11, "how to add a list of names with None as default value to function `_init` to repalce its kwargs param")
                fdb_.docsrc(12, "how to make a class.`__init__` signature to be the signature of the class using `__signature__` and `_rm_self`")
                
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m0[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                    def _funcs_kwargs(cls, as_method):======================================================================================================================(0)
                    [91;1mhow does _funcs_kwargs work: _funcs_kwargs is a decorator; it helps class e.g., T to add more methods; I need to give the method a name, and put the name e.g., 'b' inside a list called _methods=['b'] inside class T; then after writing a func e.g., _new_func, I can add it by T(b = _new_func); if I want the func added to class to use self, I shall write @funcs_kwargs(as_method=True)[0m
                        old_init = cls.__init__                                                                                                                             (1)
                        def _init(self, *args, **kwargs):                                                                                                                   (2)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m2[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                    def _funcs_kwargs(cls, as_method):                                                                                                                      (0)
                        old_init = cls.__init__                                                                                                                             (1)
                        def _init(self, *args, **kwargs):===================================================================================================================(2)
                                                                                                              [91;1mhow to define a method which can use self and accept any parameters[0m
                            for k in cls._methods:                                                                                                                          (3)
                                arg = kwargs.pop(k,None)                                                                                                                    (4)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m3[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                        old_init = cls.__init__                                                                                                                             (1)
                        def _init(self, *args, **kwargs):                                                                                                                   (2)
                            for k in cls._methods:==========================================================================================================================(3)
                                                  [91;1mhow to pop out the value of an item in a dict (with None as default), and if the item name is not found, pop out None instead; [0m
                                arg = kwargs.pop(k,None)                                                                                                                    (4)
                                if arg is not None:                                                                                                                         (5)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m6[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                                arg = kwargs.pop(k,None)                                                                                                                    (4)
                                if arg is not None:                                                                                                                         (5)
                                    if as_method: arg = method(arg)=========================================================================================================(6)
                                                                                                                                                 [91;1mhow to turn a func into a method[0m
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)                                                                     (7)
                                    setattr(self, k, arg)                                                                                                                   (8)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m7[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                                if arg is not None:                                                                                                                         (5)
                                    if as_method: arg = method(arg)                                                                                                         (6)
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)=====================================================================(7)
                                                                                                                             [91;1mhow to give a method a different instance, like self[0m
                                    setattr(self, k, arg)                                                                                                                   (8)
                            old_init(self, *args, **kwargs)                                                                                                                 (9)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m8[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                                    if as_method: arg = method(arg)                                                                                                         (6)
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)                                                                     (7)
                                    setattr(self, k, arg)===================================================================================================================(8)
                                                                                                                                   [91;1mhow to add a method to a class as an attribute[0m
                            old_init(self, *args, **kwargs)                                                                                                                 (9)
                        functools.update_wrapper(_init, old_init)                                                                                                           (10)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m10[0m     ===============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                                    setattr(self, k, arg)                                                                                                                   (8)
                            old_init(self, *args, **kwargs)                                                                                                                 (9)
                        functools.update_wrapper(_init, old_init)===========================================================================================================(10)
                                                                                          [91;1mhow to wrap `_init` around `old_init`, so that `_init` can use `old_init` inside itself[0m
                        cls.__init__ = use_kwargs(cls._methods)(_init)                                                                                                      (11)
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))                                                     (12)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m11[0m     ===============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                            old_init(self, *args, **kwargs)                                                                                                                 (9)
                        functools.update_wrapper(_init, old_init)                                                                                                           (10)
                        cls.__init__ = use_kwargs(cls._methods)(_init)======================================================================================================(11)
                                                                            [91;1mhow to add a list of names with None as default value to function `_init` to repalce its kwargs param[0m
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))                                                     (12)
                        return cls                                                                                                                                          (13)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m12[0m     ===============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                        functools.update_wrapper(_init, old_init)                                                                                                           (10)
                        cls.__init__ = use_kwargs(cls._methods)(_init)                                                                                                      (11)
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))=====================================================(12)
                                                                   [91;1mhow to make a class.`__init__` signature to be the signature of the class using `__signature__` and `_rm_self`[0m
                        return cls                                                                                                                                          (13)
                                                                                                                                                                            (14)
                
                
                
                ```
                #| column: screen
                fdb.snoop() # how to snoop together with docsrc: snoop first and docsrc above it
                ```
                
                    22:28:59.99 >>> Call to funcs_kwargs in File "/tmp/funcs_kwargs.py", line 3
                    22:28:59.99 ...... as_method = <class 'fastcore.meta.T'>
                    22:28:59.99    3 | def funcs_kwargs(as_method=False):
                    22:28:59.99    5 |     if callable(as_method): return _funcs_kwargs(as_method, False)
                        22:28:59.99 >>> Call to _funcs_kwargs in File "/tmp/_funcs_kwargs.py", line 3
                        22:28:59.99 ...... cls = <class 'fastcore.meta.T'>
                        22:28:59.99 ...... as_method = False
                        22:28:59.99    3 | def _funcs_kwargs(cls, as_method):
                        22:28:59.99    4 |     old_init = cls.__init__
                        22:28:59.99 .......... old_init = <function T.__init__>
                        22:28:59.99    5 |     import snoop
                        22:28:59.99 .......... snoop = <class 'snoop.configuration.Config.__init__.<locals>.ConfiguredTracer'>
                        22:28:59.99    6 |     @snoop
                        22:28:59.99    7 |     def _init(self, *args, **kwargs):
                        22:28:59.99 .......... _init = <function _funcs_kwargs.<locals>._init>
                        22:28:59.99   15 |     functools.update_wrapper(_init, old_init)
                        22:28:59.99 .......... _init = <function T.__init__>
                        22:28:59.99   16 |     cls.__init__ = use_kwargs(cls._methods)(_init)
                        22:28:59.99   17 |     if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))
                        22:28:59.99   18 |     return cls
                        22:28:59.99 <<< Return value from _funcs_kwargs: <class 'fastcore.meta.T'>
                    22:28:59.99    5 |     if callable(as_method): return _funcs_kwargs(as_method, False)
                    22:28:59.99 <<< Return value from funcs_kwargs: <class 'fastcore.meta.T'>
                    22:28:59.99 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:28:59.99 .......... self = <fastcore.meta.T object>
                    22:28:59.99 .......... args = ()
                    22:28:59.99 .......... kwargs = {}
                    22:28:59.99 .......... as_method = False
                    22:28:59.99 .......... cls = <class 'fastcore.meta.T'>
                    22:28:59.99 .......... old_init = <function T.__init__>
                    22:28:59.99    7 |     def _init(self, *args, **kwargs):
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00 .............. k = 'b'
                    22:29:00.00    9 |             arg = kwargs.pop(k,None)
                    22:29:00.00 .................. arg = None
                    22:29:00.00   10 |             if arg is not None:
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00   14 |         old_init(self, *args, **kwargs)
                    22:29:00.00 <<< Return value from _funcs_kwargs.<locals>._init: None
                    22:29:00.00 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:29:00.00 .......... self = <fastcore.meta.T object>
                    22:29:00.00 .......... args = ()
                    22:29:00.00 .......... kwargs = {'b': <function _new_func>}
                    22:29:00.00 .......... len(kwargs) = 1
                    22:29:00.00 .......... as_method = False
                    22:29:00.00 .......... cls = <class 'fastcore.meta.T'>
                    22:29:00.00 .......... old_init = <function T.__init__>
                    22:29:00.00    7 |     def _init(self, *args, **kwargs):
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00 .............. k = 'b'
                    22:29:00.00    9 |             arg = kwargs.pop(k,None)
                    22:29:00.00 .................. kwargs = {}
                    22:29:00.00 .................. arg = <function _new_func>
                    22:29:00.00   10 |             if arg is not None:
                    22:29:00.00   11 |                 if as_method: arg = method(arg)
                    22:29:00.00   12 |                 if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)
                    22:29:00.00   13 |                 setattr(self, k, arg)
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00   14 |         old_init(self, *args, **kwargs)
                    22:29:00.00 <<< Return value from _funcs_kwargs.<locals>._init: None
                    22:29:00.00 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:29:00.00 .......... self = <fastcore.meta.T object>
                    22:29:00.00 .......... args = ()
                    22:29:00.00 .......... kwargs = {'a': <function <lambda>>}
                    22:29:00.00 .......... len(kwargs) = 1
                    22:29:00.00 .......... as_method = False
                    22:29:00.00 .......... cls = <class 'fastcore.meta.T'>
                    22:29:00.00 .......... old_init = <function T.__init__>
                    22:29:00.00    7 |     def _init(self, *args, **kwargs):
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00 .............. k = 'b'
                    22:29:00.00    9 |             arg = kwargs.pop(k,None)
                    22:29:00.00 .................. arg = None
                    22:29:00.00   10 |             if arg is not None:
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00   14 |         old_init(self, *args, **kwargs)
                    22:29:00.00 <<< Return value from _funcs_kwargs.<locals>._init: None
                    22:29:00.00 >>> Call to funcs_kwargs in File "/tmp/funcs_kwargs.py", line 3
                    22:29:00.00 ...... as_method = True
                    22:29:00.00    3 | def funcs_kwargs(as_method=False):
                    22:29:00.00    5 |     if callable(as_method): return _funcs_kwargs(as_method, False)
                    22:29:00.00    6 |     return partial(_funcs_kwargs, as_method=as_method)
                    22:29:00.00 <<< Return value from funcs_kwargs: functools.partial(<function _funcs_kwargs>, as_method=True)
                    22:29:00.00 >>> Call to _funcs_kwargs in File "/tmp/_funcs_kwargs.py", line 3
                    22:29:00.00 ...... cls = <class 'fastcore.meta.T'>
                    22:29:00.00 ...... as_method = True
                    22:29:00.00    3 | def _funcs_kwargs(cls, as_method):
                    22:29:00.00    4 |     old_init = cls.__init__
                    22:29:00.00 .......... old_init = <slot wrapper '__init__' of 'object' objects>
                    22:29:00.00    5 |     import snoop
                    22:29:00.00 .......... snoop = <class 'snoop.configuration.Config.__init__.<locals>.ConfiguredTracer'>
                    22:29:00.00    6 |     @snoop
                    22:29:00.00    7 |     def _init(self, *args, **kwargs):
                    22:29:00.00 .......... _init = <function _funcs_kwargs.<locals>._init>
                    22:29:00.00   15 |     functools.update_wrapper(_init, old_init)
                    22:29:00.00 .......... _init = <function object.__init__>
                    22:29:00.00   16 |     cls.__init__ = use_kwargs(cls._methods)(_init)
                    22:29:00.01   17 |     if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))
                    22:29:00.01   18 |     return cls
                    22:29:00.01 <<< Return value from _funcs_kwargs: <class 'fastcore.meta.T'>
                    22:29:00.01 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:29:00.01 .......... self = <fastcore.meta.T object>
                    22:29:00.01 .......... args = ()
                    22:29:00.01 .......... kwargs = {'b': <function _f>}
                    22:29:00.01 .......... len(kwargs) = 1
                    22:29:00.01 .......... as_method = True
                    22:29:00.01 .......... cls = <class 'fastcore.meta.T'>
                    22:29:00.01 .......... old_init = <slot wrapper '__init__' of 'object' objects>
                    22:29:00.01    7 |     def _init(self, *args, **kwargs):
                    22:29:00.01    8 |         for k in cls._methods:
                    22:29:00.01 .............. k = 'b'
                    22:29:00.01    9 |             arg = kwargs.pop(k,None)
                    22:29:00.01 .................. kwargs = {}
                    22:29:00.01 .................. arg = <function _f>
                    22:29:00.01   10 |             if arg is not None:
                    22:29:00.01   11 |                 if as_method: arg = method(arg)
                    22:29:00.01 ...... arg = <bound method int._f of 1>
                    22:29:00.01   12 |                 if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)
                    22:29:00.01 ...... arg = <bound method T._f of <fastcore.meta.T object>>
                    22:29:00.01   13 |                 setattr(self, k, arg)
                    22:29:00.01    8 |         for k in cls._methods:
                    22:29:00.01   14 |         old_init(self, *args, **kwargs)
                    22:29:00.01 <<< Return value from _funcs_kwargs.<locals>._init: None
                    22:29:00.01 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:29:00.01 .......... self = <fastcore.meta.T2 object>
                    22:29:00.01 .......... args = ()
                    22:29:00.01 .......... kwargs = {'b': <function _f>}
                    22:29:00.01 .......... len(kwargs) = 1
                    22:29:00.01 .......... as_method = True
                    22:29:00.01 .......... cls = <class 'fastcore.meta.T'>
                    22:29:00.01 .......... old_init = <slot wrapper '__init__' of 'object' objects>
                    22:29:00.01    7 |     def _init(self, *args, **kwargs):
                    22:29:00.01    8 |         for k in cls._methods:
                    22:29:00.01 .............. k = 'b'
                    22:29:00.01    9 |             arg = kwargs.pop(k,None)
                    22:29:00.01 .................. kwargs = {}
                    22:29:00.01 .................. arg = <function _f>
                    22:29:00.01   10 |             if arg is not None:
                    22:29:00.01   11 |                 if as_method: arg = method(arg)
                    22:29:00.01 ...... arg = <bound method int._f of 1>
                    22:29:00.01   12 |                 if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)
                    22:29:00.01 ...... arg = <bound method T2._f of <fastcore.meta.T2 object>>
                    22:29:00.01   13 |                 setattr(self, k, arg)
                    22:29:00.01    8 |         for k in cls._methods:
                    22:29:00.01   14 |         old_init(self, *args, **kwargs)
                    22:29:00.01 <<< Return value from _funcs_kwargs.<locals>._init: None
                
                
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                
                
                
                ```
                fdb_.debug()
                ```
                
                    _funcs_kwargs's dbsrc code: ==============
                    import snoop
                    @snoop
                    def _funcs_kwargs(cls, as_method):
                        old_init = cls.__init__
                        import snoop
                        @snoop
                        def _init(self, *args, **kwargs):
                            for k in cls._methods:
                                arg = kwargs.pop(k,None)
                                if arg is not None:
                                    if as_method: arg = method(arg)
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)
                                    setattr(self, k, arg)
                            old_init(self, *args, **kwargs)
                        functools.update_wrapper(_init, old_init)
                        cls.__init__ = use_kwargs(cls._methods)(_init)
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))
                        return cls
                    
                    
                    
                    _funcs_kwargs's example processed with dbsrc: ===============
                    
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    
                
                
                
                ```
                #| column: screen
                fdb.print()
                ```
                
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    def funcs_kwargs(as_method=False):========================================================(0)       
                        "Replace methods in `cls._methods` with those from `kwargs`"==========================(1) # [93;1mhow funcs_kwargs works[0m; [93;1mit is a wrapper around _funcs_kwargs[0m; [91;1mit offers two ways of running _funcs_kwargs[0m; [37;1mthe first, default way, is to add a func to a class without using self[0m; [91;1msecond way is to add func to class enabling self use;[0m; 
                        if callable(as_method): return _funcs_kwargs(as_method, False)========================(2) # [37;1mhow to check whether an object is callable[0m; [93;1mhow to return a result of running a func[0m; [37;1m[0m; 
                        return partial(_funcs_kwargs, as_method=as_method)====================================(3) # [92;1mhow to custom the params of `_funcs_kwargs` for a particular use with partial[0m; 
                                                                                                                                                                            (4)
                
                
                
                ```
                #| column: screen
                fdb_.print()
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m12[0m     ===============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    def _funcs_kwargs(cls, as_method):========================================================(0) # [93;1mhow does _funcs_kwargs work: _funcs_kwargs is a decorator[0m; [35;1mit helps class e.g., T to add more methods[0m; [93;1mI need to give the method a name, and put the name e.g., 'b' inside a list called _methods=['b'] inside class T[0m; [36;1mthen after writing a func e.g., _new_func, I can add it by T(b = _new_func)[0m; [36;1mif I want the func added to class to use self, I shall write @funcs_kwargs(as_method=True)[0m; 
                        old_init = cls.__init__===============================================================(1)       
                        def _init(self, *args, **kwargs):=====================================================(2) # [37;1mhow to define a method which can use self and accept any parameters[0m; 
                            for k in cls._methods:============================================================(3) # [35;1mhow to pop out the value of an item in a dict (with None as default), and if the item name is not found, pop out None instead[0m; [91;1m[0m; 
                                arg = kwargs.pop(k,None)======================================================(4)       
                                if arg is not None:===========================================================(5)       
                                    if as_method: arg = method(arg)===========================================(6) # [36;1mhow to turn a func into a method[0m; 
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)=======(7) # [93;1mhow to give a method a different instance, like self[0m; 
                                    setattr(self, k, arg)=====================================================(8) # [36;1mhow to add a method to a class as an attribute[0m; 
                            old_init(self, *args, **kwargs)===================================================(9)       
                        functools.update_wrapper(_init, old_init)=============================================(10) # [34;1mhow to wrap `_init` around `old_init`, so that `_init` can use `old_init` inside itself[0m; 
                        cls.__init__ = use_kwargs(cls._methods)(_init)========================================(11) # [34;1mhow to add a list of names with None as default value to function `_init` to repalce its kwargs param[0m; 
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__)) # [35;1mhow to make a class.`__init__` signature to be the signature of the class using `__signature__` and `_rm_self`[0m;  (12)
                        return cls============================================================================(13)      
                                                                                                                                                                            (14)
                
                
                
                ```
                
                ```
                
                
            
            
            
            [Open `0009_funcs_kwargs` in Jupyter Notebook](http://localhost:8888/tree/nbs/demos/0009_funcs_kwargs.ipynb)
            
            
            
        
        
        
        [Open `utils` in Jupyter Notebook](http://localhost:8888/tree/nbs/lib/utils.ipynb)
        
        
        
        
    
    
    
    [Open `utils` in Jupyter Notebook](http://localhost:8888/tree/nbs/lib/utils.ipynb)
    
    
    
    



[Open `utils` in Jupyter Notebook locally](http://localhost:8888/tree/nbs/lib/utils.ipynb)



###  <mark style="background-color: #ffff00">snoop:</mark>   <mark style="background-color: #ffff00">from</mark>   <mark style="background-color: #ffff00">_ <mark style="background-color: #FFFF00">funcs_kwargs</mark> </mark>   <mark style="background-color: #ffff00">to</mark>   <mark style="background-color: #FFFF00">funcs_kwargs</mark> 



    
    
    
        
        
        
            
            
            
                
                how to snoop on two functions one wrap around another: `funcs_kwargs` is a wrapper around `_funcs_kwargs`, so I can first snoop on `_funcs_kwargs` and assign its snoop dbsrc to \
                `fm._funcs_kwargs` so that when I snoop on `funcs_kwargs`, it can use the snoop dbsrc of `_funcs_kwargs` and no example codes need to change.
                
                
                ```
                from fastcore.meta import _funcs_kwargs
                ```
                
                
                ```
                fdb_ = Fastdb(_funcs_kwargs)
                fdb_.eg = """
                @funcs_kwargs
                class T:
                    _methods=['b'] # allows you to add method b upon instantiation
                    def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                    def a(self): return 1
                    def b(self): return 2
                    
                t = T()
                test_eq(t.a(), 1)
                test_eq(t.b(), 2)
                
                test_sig(T, '(f=1, *, b=None)')
                inspect.signature(T)
                
                def _new_func(): return 5
                
                t = T(b = _new_func)
                test_eq(t.b(), 5)
                
                t = T(a = lambda:3)
                test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                """
                ```
                
                
                ```
                #| column: screen
                # no snoop result, it is expected, because the example is not calling _funcs_kwargs, but funcs_kwargs
                fdb_.snoop(deco=True) # how to snoop decorator: _funcs_kwargs is a decorator, so set deco=True to see running codes in inner f
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    [0m     
                    
                
                
                
                ```
                import fastcore.meta as fm
                ```
                
                
                ```
                fm._funcs_kwargs = fdb_.dbsrc # how to snoop on two functions one wrap around another
                ```
                
                
                ```
                fdb = Fastdb(funcs_kwargs)
                fdb.eg = """
                @funcs_kwargs
                class T:
                    _methods=['b'] # allows you to add method b upon instantiation
                    def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                    def a(self): return 1
                    def b(self): return 2
                    
                t = T()
                test_eq(t.a(), 1)
                test_eq(t.b(), 2)
                
                test_sig(T, '(f=1, *, b=None)')
                inspect.signature(T)
                
                def _new_func(): return 5
                
                t = T(b = _new_func)
                test_eq(t.b(), 5)
                
                t = T(a = lambda:3)
                test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                
                def _f(self,a=1): return self.num + a # access the num attribute from the instance
                
                @funcs_kwargs(as_method=True)
                class T: 
                    _methods=['b']
                    num = 5
                    
                t = T(b = _f) # adds method b
                test_eq(t.b(5), 10) # self.num + 5 = 10
                
                def _f(self,a=1): return self.num * a #multiply instead of add 
                
                class T2(T):
                    def __init__(self,num):
                        super().__init__(b = _f) # add method b from the super class
                        self.num=num
                        
                t = T2(num=3)
                test_eq(t.b(a=5), 15) # 3 * 5 = 15
                test_sig(T2, '(num)')
                """
                ```
                
                
                ```
                #| column: screen
                fdb.print()
                ```
                
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    def funcs_kwargs(as_method=False):========================================================(0)       
                        "Replace methods in `cls._methods` with those from `kwargs`"==========================(1)       
                        if callable(as_method): return _funcs_kwargs(as_method, False)========================(2)       
                        return partial(_funcs_kwargs, as_method=as_method)====================================(3)       
                                                                                                                                                                            (4)
                
                
                
                ```
                #| column: screen
                fdb_.print()
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    def _funcs_kwargs(cls, as_method):========================================================(0)       
                        old_init = cls.__init__===============================================================(1)       
                        def _init(self, *args, **kwargs):=====================================================(2)       
                            for k in cls._methods:============================================================(3)       
                                arg = kwargs.pop(k,None)======================================================(4)       
                                if arg is not None:===========================================================(5)       
                                    if as_method: arg = method(arg)===========================================(6)       
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)=======(7)       
                                    setattr(self, k, arg)=====================================================(8)       
                            old_init(self, *args, **kwargs)===================================================(9)       
                        functools.update_wrapper(_init, old_init)=============================================(10)      
                        cls.__init__ = use_kwargs(cls._methods)(_init)========================================(11)      
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))                                                     (12)
                        return cls============================================================================(13)      
                                                                                                                                                                            (14)
                
                
                
                ```
                #| column: screen
                fdb.docsrc(1, "how funcs_kwargs works; it is a wrapper around _funcs_kwargs; it offers two ways of running _funcs_kwargs; \
                the first, default way, is to add a func to a class without using self; second way is to add func to class enabling self use;")
                fdb.docsrc(2, "how to check whether an object is callable; how to return a result of running a func; ")
                fdb.docsrc(3, "how to custom the params of `_funcs_kwargs` for a particular use with partial")
                ```
                
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m1[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                    def funcs_kwargs(as_method=False):                                                                                                                      (0)
                        "Replace methods in `cls._methods` with those from `kwargs`"========================================================================================(1)
                    [91;1mhow funcs_kwargs works; it is a wrapper around _funcs_kwargs; it offers two ways of running _funcs_kwargs; the first, default way, is to add a func to a class without using self; second way is to add func to class enabling self use;[0m
                        if callable(as_method): return _funcs_kwargs(as_method, False)                                                                                      (2)
                        return partial(_funcs_kwargs, as_method=as_method)                                                                                                  (3)
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m2[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                    def funcs_kwargs(as_method=False):                                                                                                                      (0)
                        "Replace methods in `cls._methods` with those from `kwargs`"                                                                                        (1)
                        if callable(as_method): return _funcs_kwargs(as_method, False)======================================================================================(2)
                                                                                           [91;1mhow to check whether an object is callable; how to return a result of running a func; [0m
                        return partial(_funcs_kwargs, as_method=as_method)                                                                                                  (3)
                                                                                                                                                                            (4)
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m3[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                        "Replace methods in `cls._methods` with those from `kwargs`"                                                                                        (1)
                        if callable(as_method): return _funcs_kwargs(as_method, False)                                                                                      (2)
                        return partial(_funcs_kwargs, as_method=as_method)==================================================================================================(3)
                                                                                                    [91;1mhow to custom the params of `_funcs_kwargs` for a particular use with partial[0m
                                                                                                                                                                            (4)
                
                
                
                ```
                #| column: screen
                fdb_.print()
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    def _funcs_kwargs(cls, as_method):========================================================(0)       
                        old_init = cls.__init__===============================================================(1)       
                        def _init(self, *args, **kwargs):=====================================================(2)       
                            for k in cls._methods:============================================================(3)       
                                arg = kwargs.pop(k,None)======================================================(4)       
                                if arg is not None:===========================================================(5)       
                                    if as_method: arg = method(arg)===========================================(6)       
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)=======(7)       
                                    setattr(self, k, arg)=====================================================(8)       
                            old_init(self, *args, **kwargs)===================================================(9)       
                        functools.update_wrapper(_init, old_init)=============================================(10)      
                        cls.__init__ = use_kwargs(cls._methods)(_init)========================================(11)      
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))                                                     (12)
                        return cls============================================================================(13)      
                                                                                                                                                                            (14)
                
                
                
                ```
                #| column: screen
                fdb_.docsrc(0, "how does _funcs_kwargs work: _funcs_kwargs is a decorator; it helps class e.g., T to add more methods; \
                I need to give the method a name, \
                and put the name e.g., 'b' inside a list called _methods=['b'] inside class T; \
                then after writing a func e.g., _new_func, I can add it by T(b = _new_func); if I want the func added to class to use self, \
                I shall write @funcs_kwargs(as_method=True)")
                fdb_.docsrc(2, "how to define a method which can use self and accept any parameters")
                fdb_.docsrc(3, "how to pop out the value of an item in a dict (with None as default), and if the item name is not found, pop out None instead; ")
                fdb_.docsrc(6, "how to turn a func into a method")
                fdb_.docsrc(7, "how to give a method a different instance, like self")
                fdb_.docsrc(8, "how to add a method to a class as an attribute")
                fdb_.docsrc(10, "how to wrap `_init` around `old_init`, so that `_init` can use `old_init` inside itself")
                fdb_.docsrc(11, "how to add a list of names with None as default value to function `_init` to repalce its kwargs param")
                fdb_.docsrc(12, "how to make a class.`__init__` signature to be the signature of the class using `__signature__` and `_rm_self`")
                
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m0[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                    def _funcs_kwargs(cls, as_method):======================================================================================================================(0)
                    [91;1mhow does _funcs_kwargs work: _funcs_kwargs is a decorator; it helps class e.g., T to add more methods; I need to give the method a name, and put the name e.g., 'b' inside a list called _methods=['b'] inside class T; then after writing a func e.g., _new_func, I can add it by T(b = _new_func); if I want the func added to class to use self, I shall write @funcs_kwargs(as_method=True)[0m
                        old_init = cls.__init__                                                                                                                             (1)
                        def _init(self, *args, **kwargs):                                                                                                                   (2)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m2[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                    def _funcs_kwargs(cls, as_method):                                                                                                                      (0)
                        old_init = cls.__init__                                                                                                                             (1)
                        def _init(self, *args, **kwargs):===================================================================================================================(2)
                                                                                                              [91;1mhow to define a method which can use self and accept any parameters[0m
                            for k in cls._methods:                                                                                                                          (3)
                                arg = kwargs.pop(k,None)                                                                                                                    (4)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m3[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                        old_init = cls.__init__                                                                                                                             (1)
                        def _init(self, *args, **kwargs):                                                                                                                   (2)
                            for k in cls._methods:==========================================================================================================================(3)
                                                  [91;1mhow to pop out the value of an item in a dict (with None as default), and if the item name is not found, pop out None instead; [0m
                                arg = kwargs.pop(k,None)                                                                                                                    (4)
                                if arg is not None:                                                                                                                         (5)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m6[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                                arg = kwargs.pop(k,None)                                                                                                                    (4)
                                if arg is not None:                                                                                                                         (5)
                                    if as_method: arg = method(arg)=========================================================================================================(6)
                                                                                                                                                 [91;1mhow to turn a func into a method[0m
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)                                                                     (7)
                                    setattr(self, k, arg)                                                                                                                   (8)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m7[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                                if arg is not None:                                                                                                                         (5)
                                    if as_method: arg = method(arg)                                                                                                         (6)
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)=====================================================================(7)
                                                                                                                             [91;1mhow to give a method a different instance, like self[0m
                                    setattr(self, k, arg)                                                                                                                   (8)
                            old_init(self, *args, **kwargs)                                                                                                                 (9)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m8[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                                    if as_method: arg = method(arg)                                                                                                         (6)
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)                                                                     (7)
                                    setattr(self, k, arg)===================================================================================================================(8)
                                                                                                                                   [91;1mhow to add a method to a class as an attribute[0m
                            old_init(self, *args, **kwargs)                                                                                                                 (9)
                        functools.update_wrapper(_init, old_init)                                                                                                           (10)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m10[0m     ===============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                                    setattr(self, k, arg)                                                                                                                   (8)
                            old_init(self, *args, **kwargs)                                                                                                                 (9)
                        functools.update_wrapper(_init, old_init)===========================================================================================================(10)
                                                                                          [91;1mhow to wrap `_init` around `old_init`, so that `_init` can use `old_init` inside itself[0m
                        cls.__init__ = use_kwargs(cls._methods)(_init)                                                                                                      (11)
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))                                                     (12)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m11[0m     ===============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                            old_init(self, *args, **kwargs)                                                                                                                 (9)
                        functools.update_wrapper(_init, old_init)                                                                                                           (10)
                        cls.__init__ = use_kwargs(cls._methods)(_init)======================================================================================================(11)
                                                                            [91;1mhow to add a list of names with None as default value to function `_init` to repalce its kwargs param[0m
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))                                                     (12)
                        return cls                                                                                                                                          (13)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m12[0m     ===============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                        functools.update_wrapper(_init, old_init)                                                                                                           (10)
                        cls.__init__ = use_kwargs(cls._methods)(_init)                                                                                                      (11)
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))=====================================================(12)
                                                                   [91;1mhow to make a class.`__init__` signature to be the signature of the class using `__signature__` and `_rm_self`[0m
                        return cls                                                                                                                                          (13)
                                                                                                                                                                            (14)
                
                
                
                ```
                #| column: screen
                fdb.snoop() # how to snoop together with docsrc: snoop first and docsrc above it
                ```
                
                    22:28:59.99 >>> Call to funcs_kwargs in File "/tmp/funcs_kwargs.py", line 3
                    22:28:59.99 ...... as_method = <class 'fastcore.meta.T'>
                    22:28:59.99    3 | def funcs_kwargs(as_method=False):
                    22:28:59.99    5 |     if callable(as_method): return _funcs_kwargs(as_method, False)
                        22:28:59.99 >>> Call to _funcs_kwargs in File "/tmp/_funcs_kwargs.py", line 3
                        22:28:59.99 ...... cls = <class 'fastcore.meta.T'>
                        22:28:59.99 ...... as_method = False
                        22:28:59.99    3 | def _funcs_kwargs(cls, as_method):
                        22:28:59.99    4 |     old_init = cls.__init__
                        22:28:59.99 .......... old_init = <function T.__init__>
                        22:28:59.99    5 |     import snoop
                        22:28:59.99 .......... snoop = <class 'snoop.configuration.Config.__init__.<locals>.ConfiguredTracer'>
                        22:28:59.99    6 |     @snoop
                        22:28:59.99    7 |     def _init(self, *args, **kwargs):
                        22:28:59.99 .......... _init = <function _funcs_kwargs.<locals>._init>
                        22:28:59.99   15 |     functools.update_wrapper(_init, old_init)
                        22:28:59.99 .......... _init = <function T.__init__>
                        22:28:59.99   16 |     cls.__init__ = use_kwargs(cls._methods)(_init)
                        22:28:59.99   17 |     if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))
                        22:28:59.99   18 |     return cls
                        22:28:59.99 <<< Return value from _funcs_kwargs: <class 'fastcore.meta.T'>
                    22:28:59.99    5 |     if callable(as_method): return _funcs_kwargs(as_method, False)
                    22:28:59.99 <<< Return value from funcs_kwargs: <class 'fastcore.meta.T'>
                    22:28:59.99 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:28:59.99 .......... self = <fastcore.meta.T object>
                    22:28:59.99 .......... args = ()
                    22:28:59.99 .......... kwargs = {}
                    22:28:59.99 .......... as_method = False
                    22:28:59.99 .......... cls = <class 'fastcore.meta.T'>
                    22:28:59.99 .......... old_init = <function T.__init__>
                    22:28:59.99    7 |     def _init(self, *args, **kwargs):
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00 .............. k = 'b'
                    22:29:00.00    9 |             arg = kwargs.pop(k,None)
                    22:29:00.00 .................. arg = None
                    22:29:00.00   10 |             if arg is not None:
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00   14 |         old_init(self, *args, **kwargs)
                    22:29:00.00 <<< Return value from _funcs_kwargs.<locals>._init: None
                    22:29:00.00 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:29:00.00 .......... self = <fastcore.meta.T object>
                    22:29:00.00 .......... args = ()
                    22:29:00.00 .......... kwargs = {'b': <function _new_func>}
                    22:29:00.00 .......... len(kwargs) = 1
                    22:29:00.00 .......... as_method = False
                    22:29:00.00 .......... cls = <class 'fastcore.meta.T'>
                    22:29:00.00 .......... old_init = <function T.__init__>
                    22:29:00.00    7 |     def _init(self, *args, **kwargs):
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00 .............. k = 'b'
                    22:29:00.00    9 |             arg = kwargs.pop(k,None)
                    22:29:00.00 .................. kwargs = {}
                    22:29:00.00 .................. arg = <function _new_func>
                    22:29:00.00   10 |             if arg is not None:
                    22:29:00.00   11 |                 if as_method: arg = method(arg)
                    22:29:00.00   12 |                 if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)
                    22:29:00.00   13 |                 setattr(self, k, arg)
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00   14 |         old_init(self, *args, **kwargs)
                    22:29:00.00 <<< Return value from _funcs_kwargs.<locals>._init: None
                    22:29:00.00 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:29:00.00 .......... self = <fastcore.meta.T object>
                    22:29:00.00 .......... args = ()
                    22:29:00.00 .......... kwargs = {'a': <function <lambda>>}
                    22:29:00.00 .......... len(kwargs) = 1
                    22:29:00.00 .......... as_method = False
                    22:29:00.00 .......... cls = <class 'fastcore.meta.T'>
                    22:29:00.00 .......... old_init = <function T.__init__>
                    22:29:00.00    7 |     def _init(self, *args, **kwargs):
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00 .............. k = 'b'
                    22:29:00.00    9 |             arg = kwargs.pop(k,None)
                    22:29:00.00 .................. arg = None
                    22:29:00.00   10 |             if arg is not None:
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00   14 |         old_init(self, *args, **kwargs)
                    22:29:00.00 <<< Return value from _funcs_kwargs.<locals>._init: None
                    22:29:00.00 >>> Call to funcs_kwargs in File "/tmp/funcs_kwargs.py", line 3
                    22:29:00.00 ...... as_method = True
                    22:29:00.00    3 | def funcs_kwargs(as_method=False):
                    22:29:00.00    5 |     if callable(as_method): return _funcs_kwargs(as_method, False)
                    22:29:00.00    6 |     return partial(_funcs_kwargs, as_method=as_method)
                    22:29:00.00 <<< Return value from funcs_kwargs: functools.partial(<function _funcs_kwargs>, as_method=True)
                    22:29:00.00 >>> Call to _funcs_kwargs in File "/tmp/_funcs_kwargs.py", line 3
                    22:29:00.00 ...... cls = <class 'fastcore.meta.T'>
                    22:29:00.00 ...... as_method = True
                    22:29:00.00    3 | def _funcs_kwargs(cls, as_method):
                    22:29:00.00    4 |     old_init = cls.__init__
                    22:29:00.00 .......... old_init = <slot wrapper '__init__' of 'object' objects>
                    22:29:00.00    5 |     import snoop
                    22:29:00.00 .......... snoop = <class 'snoop.configuration.Config.__init__.<locals>.ConfiguredTracer'>
                    22:29:00.00    6 |     @snoop
                    22:29:00.00    7 |     def _init(self, *args, **kwargs):
                    22:29:00.00 .......... _init = <function _funcs_kwargs.<locals>._init>
                    22:29:00.00   15 |     functools.update_wrapper(_init, old_init)
                    22:29:00.00 .......... _init = <function object.__init__>
                    22:29:00.00   16 |     cls.__init__ = use_kwargs(cls._methods)(_init)
                    22:29:00.01   17 |     if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))
                    22:29:00.01   18 |     return cls
                    22:29:00.01 <<< Return value from _funcs_kwargs: <class 'fastcore.meta.T'>
                    22:29:00.01 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:29:00.01 .......... self = <fastcore.meta.T object>
                    22:29:00.01 .......... args = ()
                    22:29:00.01 .......... kwargs = {'b': <function _f>}
                    22:29:00.01 .......... len(kwargs) = 1
                    22:29:00.01 .......... as_method = True
                    22:29:00.01 .......... cls = <class 'fastcore.meta.T'>
                    22:29:00.01 .......... old_init = <slot wrapper '__init__' of 'object' objects>
                    22:29:00.01    7 |     def _init(self, *args, **kwargs):
                    22:29:00.01    8 |         for k in cls._methods:
                    22:29:00.01 .............. k = 'b'
                    22:29:00.01    9 |             arg = kwargs.pop(k,None)
                    22:29:00.01 .................. kwargs = {}
                    22:29:00.01 .................. arg = <function _f>
                    22:29:00.01   10 |             if arg is not None:
                    22:29:00.01   11 |                 if as_method: arg = method(arg)
                    22:29:00.01 ...... arg = <bound method int._f of 1>
                    22:29:00.01   12 |                 if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)
                    22:29:00.01 ...... arg = <bound method T._f of <fastcore.meta.T object>>
                    22:29:00.01   13 |                 setattr(self, k, arg)
                    22:29:00.01    8 |         for k in cls._methods:
                    22:29:00.01   14 |         old_init(self, *args, **kwargs)
                    22:29:00.01 <<< Return value from _funcs_kwargs.<locals>._init: None
                    22:29:00.01 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:29:00.01 .......... self = <fastcore.meta.T2 object>
                    22:29:00.01 .......... args = ()
                    22:29:00.01 .......... kwargs = {'b': <function _f>}
                    22:29:00.01 .......... len(kwargs) = 1
                    22:29:00.01 .......... as_method = True
                    22:29:00.01 .......... cls = <class 'fastcore.meta.T'>
                    22:29:00.01 .......... old_init = <slot wrapper '__init__' of 'object' objects>
                    22:29:00.01    7 |     def _init(self, *args, **kwargs):
                    22:29:00.01    8 |         for k in cls._methods:
                    22:29:00.01 .............. k = 'b'
                    22:29:00.01    9 |             arg = kwargs.pop(k,None)
                    22:29:00.01 .................. kwargs = {}
                    22:29:00.01 .................. arg = <function _f>
                    22:29:00.01   10 |             if arg is not None:
                    22:29:00.01   11 |                 if as_method: arg = method(arg)
                    22:29:00.01 ...... arg = <bound method int._f of 1>
                    22:29:00.01   12 |                 if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)
                    22:29:00.01 ...... arg = <bound method T2._f of <fastcore.meta.T2 object>>
                    22:29:00.01   13 |                 setattr(self, k, arg)
                    22:29:00.01    8 |         for k in cls._methods:
                    22:29:00.01   14 |         old_init(self, *args, **kwargs)
                    22:29:00.01 <<< Return value from _funcs_kwargs.<locals>._init: None
                
                
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                
                
                
                ```
                fdb_.debug()
                ```
                
                    _funcs_kwargs's dbsrc code: ==============
                    import snoop
                    @snoop
                    def _funcs_kwargs(cls, as_method):
                        old_init = cls.__init__
                        import snoop
                        @snoop
                        def _init(self, *args, **kwargs):
                            for k in cls._methods:
                                arg = kwargs.pop(k,None)
                                if arg is not None:
                                    if as_method: arg = method(arg)
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)
                                    setattr(self, k, arg)
                            old_init(self, *args, **kwargs)
                        functools.update_wrapper(_init, old_init)
                        cls.__init__ = use_kwargs(cls._methods)(_init)
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))
                        return cls
                    
                    
                    
                    _funcs_kwargs's example processed with dbsrc: ===============
                    
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    
                
                
                
                ```
                #| column: screen
                fdb.print()
                ```
                
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    def funcs_kwargs(as_method=False):========================================================(0)       
                        "Replace methods in `cls._methods` with those from `kwargs`"==========================(1) # [93;1mhow funcs_kwargs works[0m; [93;1mit is a wrapper around _funcs_kwargs[0m; [91;1mit offers two ways of running _funcs_kwargs[0m; [37;1mthe first, default way, is to add a func to a class without using self[0m; [91;1msecond way is to add func to class enabling self use;[0m; 
                        if callable(as_method): return _funcs_kwargs(as_method, False)========================(2) # [37;1mhow to check whether an object is callable[0m; [93;1mhow to return a result of running a func[0m; [37;1m[0m; 
                        return partial(_funcs_kwargs, as_method=as_method)====================================(3) # [92;1mhow to custom the params of `_funcs_kwargs` for a particular use with partial[0m; 
                                                                                                                                                                            (4)
                
                
                
                ```
                #| column: screen
                fdb_.print()
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m12[0m     ===============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    def _funcs_kwargs(cls, as_method):========================================================(0) # [93;1mhow does _funcs_kwargs work: _funcs_kwargs is a decorator[0m; [35;1mit helps class e.g., T to add more methods[0m; [93;1mI need to give the method a name, and put the name e.g., 'b' inside a list called _methods=['b'] inside class T[0m; [36;1mthen after writing a func e.g., _new_func, I can add it by T(b = _new_func)[0m; [36;1mif I want the func added to class to use self, I shall write @funcs_kwargs(as_method=True)[0m; 
                        old_init = cls.__init__===============================================================(1)       
                        def _init(self, *args, **kwargs):=====================================================(2) # [37;1mhow to define a method which can use self and accept any parameters[0m; 
                            for k in cls._methods:============================================================(3) # [35;1mhow to pop out the value of an item in a dict (with None as default), and if the item name is not found, pop out None instead[0m; [91;1m[0m; 
                                arg = kwargs.pop(k,None)======================================================(4)       
                                if arg is not None:===========================================================(5)       
                                    if as_method: arg = method(arg)===========================================(6) # [36;1mhow to turn a func into a method[0m; 
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)=======(7) # [93;1mhow to give a method a different instance, like self[0m; 
                                    setattr(self, k, arg)=====================================================(8) # [36;1mhow to add a method to a class as an attribute[0m; 
                            old_init(self, *args, **kwargs)===================================================(9)       
                        functools.update_wrapper(_init, old_init)=============================================(10) # [34;1mhow to wrap `_init` around `old_init`, so that `_init` can use `old_init` inside itself[0m; 
                        cls.__init__ = use_kwargs(cls._methods)(_init)========================================(11) # [34;1mhow to add a list of names with None as default value to function `_init` to repalce its kwargs param[0m; 
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__)) # [35;1mhow to make a class.`__init__` signature to be the signature of the class using `__signature__` and `_rm_self`[0m;  (12)
                        return cls============================================================================(13)      
                                                                                                                                                                            (14)
                
                
                
                ```
                
                ```
                
                
            
            
            
            [Open `0009_funcs_kwargs` in Jupyter Notebook](http://localhost:8888/tree/nbs/demos/0009_funcs_kwargs.ipynb)
            
            
            
        
        
        
        [Open `utils` in Jupyter Notebook](http://localhost:8888/tree/nbs/lib/utils.ipynb)
        
        
        
        
    
    
    
    [Open `utils` in Jupyter Notebook](http://localhost:8888/tree/nbs/lib/utils.ipynb)
    
    
    
    



[Open `utils` in Jupyter Notebook locally](http://localhost:8888/tree/nbs/lib/utils.ipynb)



###  <mark style="background-color: #ffff00">snoop:</mark>   <mark style="background-color: #ffff00">from</mark>   <mark style="background-color: #ffff00">_ <mark style="background-color: #FFFF00">funcs_kwargs</mark> </mark>   <mark style="background-color: #ffff00">to</mark>   <mark style="background-color: #FFFF00">funcs_kwargs</mark> 



    
    
    
        
        
        
            
            
            
                
                how to snoop on two functions one wrap around another: `funcs_kwargs` is a wrapper around `_funcs_kwargs`, so I can first snoop on `_funcs_kwargs` and assign its snoop dbsrc to \
                `fm._funcs_kwargs` so that when I snoop on `funcs_kwargs`, it can use the snoop dbsrc of `_funcs_kwargs` and no example codes need to change.
                
                
                ```
                from fastcore.meta import _funcs_kwargs
                ```
                
                
                ```
                fdb_ = Fastdb(_funcs_kwargs)
                fdb_.eg = """
                @funcs_kwargs
                class T:
                    _methods=['b'] # allows you to add method b upon instantiation
                    def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                    def a(self): return 1
                    def b(self): return 2
                    
                t = T()
                test_eq(t.a(), 1)
                test_eq(t.b(), 2)
                
                test_sig(T, '(f=1, *, b=None)')
                inspect.signature(T)
                
                def _new_func(): return 5
                
                t = T(b = _new_func)
                test_eq(t.b(), 5)
                
                t = T(a = lambda:3)
                test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                """
                ```
                
                
                ```
                #| column: screen
                # no snoop result, it is expected, because the example is not calling _funcs_kwargs, but funcs_kwargs
                fdb_.snoop(deco=True) # how to snoop decorator: _funcs_kwargs is a decorator, so set deco=True to see running codes in inner f
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    [0m     
                    
                
                
                
                ```
                import fastcore.meta as fm
                ```
                
                
                ```
                fm._funcs_kwargs = fdb_.dbsrc # how to snoop on two functions one wrap around another
                ```
                
                
                ```
                fdb = Fastdb(funcs_kwargs)
                fdb.eg = """
                @funcs_kwargs
                class T:
                    _methods=['b'] # allows you to add method b upon instantiation
                    def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                    def a(self): return 1
                    def b(self): return 2
                    
                t = T()
                test_eq(t.a(), 1)
                test_eq(t.b(), 2)
                
                test_sig(T, '(f=1, *, b=None)')
                inspect.signature(T)
                
                def _new_func(): return 5
                
                t = T(b = _new_func)
                test_eq(t.b(), 5)
                
                t = T(a = lambda:3)
                test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                
                def _f(self,a=1): return self.num + a # access the num attribute from the instance
                
                @funcs_kwargs(as_method=True)
                class T: 
                    _methods=['b']
                    num = 5
                    
                t = T(b = _f) # adds method b
                test_eq(t.b(5), 10) # self.num + 5 = 10
                
                def _f(self,a=1): return self.num * a #multiply instead of add 
                
                class T2(T):
                    def __init__(self,num):
                        super().__init__(b = _f) # add method b from the super class
                        self.num=num
                        
                t = T2(num=3)
                test_eq(t.b(a=5), 15) # 3 * 5 = 15
                test_sig(T2, '(num)')
                """
                ```
                
                
                ```
                #| column: screen
                fdb.print()
                ```
                
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    def funcs_kwargs(as_method=False):========================================================(0)       
                        "Replace methods in `cls._methods` with those from `kwargs`"==========================(1)       
                        if callable(as_method): return _funcs_kwargs(as_method, False)========================(2)       
                        return partial(_funcs_kwargs, as_method=as_method)====================================(3)       
                                                                                                                                                                            (4)
                
                
                
                ```
                #| column: screen
                fdb_.print()
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    def _funcs_kwargs(cls, as_method):========================================================(0)       
                        old_init = cls.__init__===============================================================(1)       
                        def _init(self, *args, **kwargs):=====================================================(2)       
                            for k in cls._methods:============================================================(3)       
                                arg = kwargs.pop(k,None)======================================================(4)       
                                if arg is not None:===========================================================(5)       
                                    if as_method: arg = method(arg)===========================================(6)       
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)=======(7)       
                                    setattr(self, k, arg)=====================================================(8)       
                            old_init(self, *args, **kwargs)===================================================(9)       
                        functools.update_wrapper(_init, old_init)=============================================(10)      
                        cls.__init__ = use_kwargs(cls._methods)(_init)========================================(11)      
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))                                                     (12)
                        return cls============================================================================(13)      
                                                                                                                                                                            (14)
                
                
                
                ```
                #| column: screen
                fdb.docsrc(1, "how funcs_kwargs works; it is a wrapper around _funcs_kwargs; it offers two ways of running _funcs_kwargs; \
                the first, default way, is to add a func to a class without using self; second way is to add func to class enabling self use;")
                fdb.docsrc(2, "how to check whether an object is callable; how to return a result of running a func; ")
                fdb.docsrc(3, "how to custom the params of `_funcs_kwargs` for a particular use with partial")
                ```
                
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m1[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                    def funcs_kwargs(as_method=False):                                                                                                                      (0)
                        "Replace methods in `cls._methods` with those from `kwargs`"========================================================================================(1)
                    [91;1mhow funcs_kwargs works; it is a wrapper around _funcs_kwargs; it offers two ways of running _funcs_kwargs; the first, default way, is to add a func to a class without using self; second way is to add func to class enabling self use;[0m
                        if callable(as_method): return _funcs_kwargs(as_method, False)                                                                                      (2)
                        return partial(_funcs_kwargs, as_method=as_method)                                                                                                  (3)
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m2[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                    def funcs_kwargs(as_method=False):                                                                                                                      (0)
                        "Replace methods in `cls._methods` with those from `kwargs`"                                                                                        (1)
                        if callable(as_method): return _funcs_kwargs(as_method, False)======================================================================================(2)
                                                                                           [91;1mhow to check whether an object is callable; how to return a result of running a func; [0m
                        return partial(_funcs_kwargs, as_method=as_method)                                                                                                  (3)
                                                                                                                                                                            (4)
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m3[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                        "Replace methods in `cls._methods` with those from `kwargs`"                                                                                        (1)
                        if callable(as_method): return _funcs_kwargs(as_method, False)                                                                                      (2)
                        return partial(_funcs_kwargs, as_method=as_method)==================================================================================================(3)
                                                                                                    [91;1mhow to custom the params of `_funcs_kwargs` for a particular use with partial[0m
                                                                                                                                                                            (4)
                
                
                
                ```
                #| column: screen
                fdb_.print()
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    def _funcs_kwargs(cls, as_method):========================================================(0)       
                        old_init = cls.__init__===============================================================(1)       
                        def _init(self, *args, **kwargs):=====================================================(2)       
                            for k in cls._methods:============================================================(3)       
                                arg = kwargs.pop(k,None)======================================================(4)       
                                if arg is not None:===========================================================(5)       
                                    if as_method: arg = method(arg)===========================================(6)       
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)=======(7)       
                                    setattr(self, k, arg)=====================================================(8)       
                            old_init(self, *args, **kwargs)===================================================(9)       
                        functools.update_wrapper(_init, old_init)=============================================(10)      
                        cls.__init__ = use_kwargs(cls._methods)(_init)========================================(11)      
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))                                                     (12)
                        return cls============================================================================(13)      
                                                                                                                                                                            (14)
                
                
                
                ```
                #| column: screen
                fdb_.docsrc(0, "how does _funcs_kwargs work: _funcs_kwargs is a decorator; it helps class e.g., T to add more methods; \
                I need to give the method a name, \
                and put the name e.g., 'b' inside a list called _methods=['b'] inside class T; \
                then after writing a func e.g., _new_func, I can add it by T(b = _new_func); if I want the func added to class to use self, \
                I shall write @funcs_kwargs(as_method=True)")
                fdb_.docsrc(2, "how to define a method which can use self and accept any parameters")
                fdb_.docsrc(3, "how to pop out the value of an item in a dict (with None as default), and if the item name is not found, pop out None instead; ")
                fdb_.docsrc(6, "how to turn a func into a method")
                fdb_.docsrc(7, "how to give a method a different instance, like self")
                fdb_.docsrc(8, "how to add a method to a class as an attribute")
                fdb_.docsrc(10, "how to wrap `_init` around `old_init`, so that `_init` can use `old_init` inside itself")
                fdb_.docsrc(11, "how to add a list of names with None as default value to function `_init` to repalce its kwargs param")
                fdb_.docsrc(12, "how to make a class.`__init__` signature to be the signature of the class using `__signature__` and `_rm_self`")
                
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m0[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                    def _funcs_kwargs(cls, as_method):======================================================================================================================(0)
                    [91;1mhow does _funcs_kwargs work: _funcs_kwargs is a decorator; it helps class e.g., T to add more methods; I need to give the method a name, and put the name e.g., 'b' inside a list called _methods=['b'] inside class T; then after writing a func e.g., _new_func, I can add it by T(b = _new_func); if I want the func added to class to use self, I shall write @funcs_kwargs(as_method=True)[0m
                        old_init = cls.__init__                                                                                                                             (1)
                        def _init(self, *args, **kwargs):                                                                                                                   (2)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m2[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                    def _funcs_kwargs(cls, as_method):                                                                                                                      (0)
                        old_init = cls.__init__                                                                                                                             (1)
                        def _init(self, *args, **kwargs):===================================================================================================================(2)
                                                                                                              [91;1mhow to define a method which can use self and accept any parameters[0m
                            for k in cls._methods:                                                                                                                          (3)
                                arg = kwargs.pop(k,None)                                                                                                                    (4)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m3[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                        old_init = cls.__init__                                                                                                                             (1)
                        def _init(self, *args, **kwargs):                                                                                                                   (2)
                            for k in cls._methods:==========================================================================================================================(3)
                                                  [91;1mhow to pop out the value of an item in a dict (with None as default), and if the item name is not found, pop out None instead; [0m
                                arg = kwargs.pop(k,None)                                                                                                                    (4)
                                if arg is not None:                                                                                                                         (5)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m6[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                                arg = kwargs.pop(k,None)                                                                                                                    (4)
                                if arg is not None:                                                                                                                         (5)
                                    if as_method: arg = method(arg)=========================================================================================================(6)
                                                                                                                                                 [91;1mhow to turn a func into a method[0m
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)                                                                     (7)
                                    setattr(self, k, arg)                                                                                                                   (8)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m7[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                                if arg is not None:                                                                                                                         (5)
                                    if as_method: arg = method(arg)                                                                                                         (6)
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)=====================================================================(7)
                                                                                                                             [91;1mhow to give a method a different instance, like self[0m
                                    setattr(self, k, arg)                                                                                                                   (8)
                            old_init(self, *args, **kwargs)                                                                                                                 (9)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m8[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                                    if as_method: arg = method(arg)                                                                                                         (6)
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)                                                                     (7)
                                    setattr(self, k, arg)===================================================================================================================(8)
                                                                                                                                   [91;1mhow to add a method to a class as an attribute[0m
                            old_init(self, *args, **kwargs)                                                                                                                 (9)
                        functools.update_wrapper(_init, old_init)                                                                                                           (10)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m10[0m     ===============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                                    setattr(self, k, arg)                                                                                                                   (8)
                            old_init(self, *args, **kwargs)                                                                                                                 (9)
                        functools.update_wrapper(_init, old_init)===========================================================================================================(10)
                                                                                          [91;1mhow to wrap `_init` around `old_init`, so that `_init` can use `old_init` inside itself[0m
                        cls.__init__ = use_kwargs(cls._methods)(_init)                                                                                                      (11)
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))                                                     (12)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m11[0m     ===============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                            old_init(self, *args, **kwargs)                                                                                                                 (9)
                        functools.update_wrapper(_init, old_init)                                                                                                           (10)
                        cls.__init__ = use_kwargs(cls._methods)(_init)======================================================================================================(11)
                                                                            [91;1mhow to add a list of names with None as default value to function `_init` to repalce its kwargs param[0m
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))                                                     (12)
                        return cls                                                                                                                                          (13)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m12[0m     ===============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                        functools.update_wrapper(_init, old_init)                                                                                                           (10)
                        cls.__init__ = use_kwargs(cls._methods)(_init)                                                                                                      (11)
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))=====================================================(12)
                                                                   [91;1mhow to make a class.`__init__` signature to be the signature of the class using `__signature__` and `_rm_self`[0m
                        return cls                                                                                                                                          (13)
                                                                                                                                                                            (14)
                
                
                
                ```
                #| column: screen
                fdb.snoop() # how to snoop together with docsrc: snoop first and docsrc above it
                ```
                
                    22:28:59.99 >>> Call to funcs_kwargs in File "/tmp/funcs_kwargs.py", line 3
                    22:28:59.99 ...... as_method = <class 'fastcore.meta.T'>
                    22:28:59.99    3 | def funcs_kwargs(as_method=False):
                    22:28:59.99    5 |     if callable(as_method): return _funcs_kwargs(as_method, False)
                        22:28:59.99 >>> Call to _funcs_kwargs in File "/tmp/_funcs_kwargs.py", line 3
                        22:28:59.99 ...... cls = <class 'fastcore.meta.T'>
                        22:28:59.99 ...... as_method = False
                        22:28:59.99    3 | def _funcs_kwargs(cls, as_method):
                        22:28:59.99    4 |     old_init = cls.__init__
                        22:28:59.99 .......... old_init = <function T.__init__>
                        22:28:59.99    5 |     import snoop
                        22:28:59.99 .......... snoop = <class 'snoop.configuration.Config.__init__.<locals>.ConfiguredTracer'>
                        22:28:59.99    6 |     @snoop
                        22:28:59.99    7 |     def _init(self, *args, **kwargs):
                        22:28:59.99 .......... _init = <function _funcs_kwargs.<locals>._init>
                        22:28:59.99   15 |     functools.update_wrapper(_init, old_init)
                        22:28:59.99 .......... _init = <function T.__init__>
                        22:28:59.99   16 |     cls.__init__ = use_kwargs(cls._methods)(_init)
                        22:28:59.99   17 |     if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))
                        22:28:59.99   18 |     return cls
                        22:28:59.99 <<< Return value from _funcs_kwargs: <class 'fastcore.meta.T'>
                    22:28:59.99    5 |     if callable(as_method): return _funcs_kwargs(as_method, False)
                    22:28:59.99 <<< Return value from funcs_kwargs: <class 'fastcore.meta.T'>
                    22:28:59.99 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:28:59.99 .......... self = <fastcore.meta.T object>
                    22:28:59.99 .......... args = ()
                    22:28:59.99 .......... kwargs = {}
                    22:28:59.99 .......... as_method = False
                    22:28:59.99 .......... cls = <class 'fastcore.meta.T'>
                    22:28:59.99 .......... old_init = <function T.__init__>
                    22:28:59.99    7 |     def _init(self, *args, **kwargs):
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00 .............. k = 'b'
                    22:29:00.00    9 |             arg = kwargs.pop(k,None)
                    22:29:00.00 .................. arg = None
                    22:29:00.00   10 |             if arg is not None:
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00   14 |         old_init(self, *args, **kwargs)
                    22:29:00.00 <<< Return value from _funcs_kwargs.<locals>._init: None
                    22:29:00.00 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:29:00.00 .......... self = <fastcore.meta.T object>
                    22:29:00.00 .......... args = ()
                    22:29:00.00 .......... kwargs = {'b': <function _new_func>}
                    22:29:00.00 .......... len(kwargs) = 1
                    22:29:00.00 .......... as_method = False
                    22:29:00.00 .......... cls = <class 'fastcore.meta.T'>
                    22:29:00.00 .......... old_init = <function T.__init__>
                    22:29:00.00    7 |     def _init(self, *args, **kwargs):
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00 .............. k = 'b'
                    22:29:00.00    9 |             arg = kwargs.pop(k,None)
                    22:29:00.00 .................. kwargs = {}
                    22:29:00.00 .................. arg = <function _new_func>
                    22:29:00.00   10 |             if arg is not None:
                    22:29:00.00   11 |                 if as_method: arg = method(arg)
                    22:29:00.00   12 |                 if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)
                    22:29:00.00   13 |                 setattr(self, k, arg)
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00   14 |         old_init(self, *args, **kwargs)
                    22:29:00.00 <<< Return value from _funcs_kwargs.<locals>._init: None
                    22:29:00.00 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:29:00.00 .......... self = <fastcore.meta.T object>
                    22:29:00.00 .......... args = ()
                    22:29:00.00 .......... kwargs = {'a': <function <lambda>>}
                    22:29:00.00 .......... len(kwargs) = 1
                    22:29:00.00 .......... as_method = False
                    22:29:00.00 .......... cls = <class 'fastcore.meta.T'>
                    22:29:00.00 .......... old_init = <function T.__init__>
                    22:29:00.00    7 |     def _init(self, *args, **kwargs):
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00 .............. k = 'b'
                    22:29:00.00    9 |             arg = kwargs.pop(k,None)
                    22:29:00.00 .................. arg = None
                    22:29:00.00   10 |             if arg is not None:
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00   14 |         old_init(self, *args, **kwargs)
                    22:29:00.00 <<< Return value from _funcs_kwargs.<locals>._init: None
                    22:29:00.00 >>> Call to funcs_kwargs in File "/tmp/funcs_kwargs.py", line 3
                    22:29:00.00 ...... as_method = True
                    22:29:00.00    3 | def funcs_kwargs(as_method=False):
                    22:29:00.00    5 |     if callable(as_method): return _funcs_kwargs(as_method, False)
                    22:29:00.00    6 |     return partial(_funcs_kwargs, as_method=as_method)
                    22:29:00.00 <<< Return value from funcs_kwargs: functools.partial(<function _funcs_kwargs>, as_method=True)
                    22:29:00.00 >>> Call to _funcs_kwargs in File "/tmp/_funcs_kwargs.py", line 3
                    22:29:00.00 ...... cls = <class 'fastcore.meta.T'>
                    22:29:00.00 ...... as_method = True
                    22:29:00.00    3 | def _funcs_kwargs(cls, as_method):
                    22:29:00.00    4 |     old_init = cls.__init__
                    22:29:00.00 .......... old_init = <slot wrapper '__init__' of 'object' objects>
                    22:29:00.00    5 |     import snoop
                    22:29:00.00 .......... snoop = <class 'snoop.configuration.Config.__init__.<locals>.ConfiguredTracer'>
                    22:29:00.00    6 |     @snoop
                    22:29:00.00    7 |     def _init(self, *args, **kwargs):
                    22:29:00.00 .......... _init = <function _funcs_kwargs.<locals>._init>
                    22:29:00.00   15 |     functools.update_wrapper(_init, old_init)
                    22:29:00.00 .......... _init = <function object.__init__>
                    22:29:00.00   16 |     cls.__init__ = use_kwargs(cls._methods)(_init)
                    22:29:00.01   17 |     if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))
                    22:29:00.01   18 |     return cls
                    22:29:00.01 <<< Return value from _funcs_kwargs: <class 'fastcore.meta.T'>
                    22:29:00.01 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:29:00.01 .......... self = <fastcore.meta.T object>
                    22:29:00.01 .......... args = ()
                    22:29:00.01 .......... kwargs = {'b': <function _f>}
                    22:29:00.01 .......... len(kwargs) = 1
                    22:29:00.01 .......... as_method = True
                    22:29:00.01 .......... cls = <class 'fastcore.meta.T'>
                    22:29:00.01 .......... old_init = <slot wrapper '__init__' of 'object' objects>
                    22:29:00.01    7 |     def _init(self, *args, **kwargs):
                    22:29:00.01    8 |         for k in cls._methods:
                    22:29:00.01 .............. k = 'b'
                    22:29:00.01    9 |             arg = kwargs.pop(k,None)
                    22:29:00.01 .................. kwargs = {}
                    22:29:00.01 .................. arg = <function _f>
                    22:29:00.01   10 |             if arg is not None:
                    22:29:00.01   11 |                 if as_method: arg = method(arg)
                    22:29:00.01 ...... arg = <bound method int._f of 1>
                    22:29:00.01   12 |                 if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)
                    22:29:00.01 ...... arg = <bound method T._f of <fastcore.meta.T object>>
                    22:29:00.01   13 |                 setattr(self, k, arg)
                    22:29:00.01    8 |         for k in cls._methods:
                    22:29:00.01   14 |         old_init(self, *args, **kwargs)
                    22:29:00.01 <<< Return value from _funcs_kwargs.<locals>._init: None
                    22:29:00.01 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:29:00.01 .......... self = <fastcore.meta.T2 object>
                    22:29:00.01 .......... args = ()
                    22:29:00.01 .......... kwargs = {'b': <function _f>}
                    22:29:00.01 .......... len(kwargs) = 1
                    22:29:00.01 .......... as_method = True
                    22:29:00.01 .......... cls = <class 'fastcore.meta.T'>
                    22:29:00.01 .......... old_init = <slot wrapper '__init__' of 'object' objects>
                    22:29:00.01    7 |     def _init(self, *args, **kwargs):
                    22:29:00.01    8 |         for k in cls._methods:
                    22:29:00.01 .............. k = 'b'
                    22:29:00.01    9 |             arg = kwargs.pop(k,None)
                    22:29:00.01 .................. kwargs = {}
                    22:29:00.01 .................. arg = <function _f>
                    22:29:00.01   10 |             if arg is not None:
                    22:29:00.01   11 |                 if as_method: arg = method(arg)
                    22:29:00.01 ...... arg = <bound method int._f of 1>
                    22:29:00.01   12 |                 if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)
                    22:29:00.01 ...... arg = <bound method T2._f of <fastcore.meta.T2 object>>
                    22:29:00.01   13 |                 setattr(self, k, arg)
                    22:29:00.01    8 |         for k in cls._methods:
                    22:29:00.01   14 |         old_init(self, *args, **kwargs)
                    22:29:00.01 <<< Return value from _funcs_kwargs.<locals>._init: None
                
                
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                
                
                
                ```
                fdb_.debug()
                ```
                
                    _funcs_kwargs's dbsrc code: ==============
                    import snoop
                    @snoop
                    def _funcs_kwargs(cls, as_method):
                        old_init = cls.__init__
                        import snoop
                        @snoop
                        def _init(self, *args, **kwargs):
                            for k in cls._methods:
                                arg = kwargs.pop(k,None)
                                if arg is not None:
                                    if as_method: arg = method(arg)
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)
                                    setattr(self, k, arg)
                            old_init(self, *args, **kwargs)
                        functools.update_wrapper(_init, old_init)
                        cls.__init__ = use_kwargs(cls._methods)(_init)
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))
                        return cls
                    
                    
                    
                    _funcs_kwargs's example processed with dbsrc: ===============
                    
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    
                
                
                
                ```
                #| column: screen
                fdb.print()
                ```
                
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    def funcs_kwargs(as_method=False):========================================================(0)       
                        "Replace methods in `cls._methods` with those from `kwargs`"==========================(1) # [93;1mhow funcs_kwargs works[0m; [93;1mit is a wrapper around _funcs_kwargs[0m; [91;1mit offers two ways of running _funcs_kwargs[0m; [37;1mthe first, default way, is to add a func to a class without using self[0m; [91;1msecond way is to add func to class enabling self use;[0m; 
                        if callable(as_method): return _funcs_kwargs(as_method, False)========================(2) # [37;1mhow to check whether an object is callable[0m; [93;1mhow to return a result of running a func[0m; [37;1m[0m; 
                        return partial(_funcs_kwargs, as_method=as_method)====================================(3) # [92;1mhow to custom the params of `_funcs_kwargs` for a particular use with partial[0m; 
                                                                                                                                                                            (4)
                
                
                
                ```
                #| column: screen
                fdb_.print()
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m12[0m     ===============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    def _funcs_kwargs(cls, as_method):========================================================(0) # [93;1mhow does _funcs_kwargs work: _funcs_kwargs is a decorator[0m; [35;1mit helps class e.g., T to add more methods[0m; [93;1mI need to give the method a name, and put the name e.g., 'b' inside a list called _methods=['b'] inside class T[0m; [36;1mthen after writing a func e.g., _new_func, I can add it by T(b = _new_func)[0m; [36;1mif I want the func added to class to use self, I shall write @funcs_kwargs(as_method=True)[0m; 
                        old_init = cls.__init__===============================================================(1)       
                        def _init(self, *args, **kwargs):=====================================================(2) # [37;1mhow to define a method which can use self and accept any parameters[0m; 
                            for k in cls._methods:============================================================(3) # [35;1mhow to pop out the value of an item in a dict (with None as default), and if the item name is not found, pop out None instead[0m; [91;1m[0m; 
                                arg = kwargs.pop(k,None)======================================================(4)       
                                if arg is not None:===========================================================(5)       
                                    if as_method: arg = method(arg)===========================================(6) # [36;1mhow to turn a func into a method[0m; 
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)=======(7) # [93;1mhow to give a method a different instance, like self[0m; 
                                    setattr(self, k, arg)=====================================================(8) # [36;1mhow to add a method to a class as an attribute[0m; 
                            old_init(self, *args, **kwargs)===================================================(9)       
                        functools.update_wrapper(_init, old_init)=============================================(10) # [34;1mhow to wrap `_init` around `old_init`, so that `_init` can use `old_init` inside itself[0m; 
                        cls.__init__ = use_kwargs(cls._methods)(_init)========================================(11) # [34;1mhow to add a list of names with None as default value to function `_init` to repalce its kwargs param[0m; 
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__)) # [35;1mhow to make a class.`__init__` signature to be the signature of the class using `__signature__` and `_rm_self`[0m;  (12)
                        return cls============================================================================(13)      
                                                                                                                                                                            (14)
                
                
                
                ```
                
                ```
                
                
            
            
            
            [Open `0009_funcs_kwargs` in Jupyter Notebook](http://localhost:8888/tree/nbs/demos/0009_funcs_kwargs.ipynb)
            
            
            
        
        
        
        [Open `utils` in Jupyter Notebook](http://localhost:8888/tree/nbs/lib/utils.ipynb)
        
        
        
        
    
    
    
    [Open `utils` in Jupyter Notebook](http://localhost:8888/tree/nbs/lib/utils.ipynb)
    
    
    
    



[Open `utils` in Jupyter Notebook locally](http://localhost:8888/tree/nbs/lib/utils.ipynb)



###  <mark style="background-color: #ffff00">snoop:</mark>   <mark style="background-color: #ffff00">from</mark>   <mark style="background-color: #ffff00">_ <mark style="background-color: #FFFF00">funcs_kwargs</mark> </mark>   <mark style="background-color: #ffff00">to</mark>   <mark style="background-color: #FFFF00">funcs_kwargs</mark> 



    
    
    
        
        
        
            
            
            
                
                how to snoop on two functions one wrap around another: `funcs_kwargs` is a wrapper around `_funcs_kwargs`, so I can first snoop on `_funcs_kwargs` and assign its snoop dbsrc to \
                `fm._funcs_kwargs` so that when I snoop on `funcs_kwargs`, it can use the snoop dbsrc of `_funcs_kwargs` and no example codes need to change.
                
                
                ```
                from fastcore.meta import _funcs_kwargs
                ```
                
                
                ```
                fdb_ = Fastdb(_funcs_kwargs)
                fdb_.eg = """
                @funcs_kwargs
                class T:
                    _methods=['b'] # allows you to add method b upon instantiation
                    def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                    def a(self): return 1
                    def b(self): return 2
                    
                t = T()
                test_eq(t.a(), 1)
                test_eq(t.b(), 2)
                
                test_sig(T, '(f=1, *, b=None)')
                inspect.signature(T)
                
                def _new_func(): return 5
                
                t = T(b = _new_func)
                test_eq(t.b(), 5)
                
                t = T(a = lambda:3)
                test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                """
                ```
                
                
                ```
                #| column: screen
                # no snoop result, it is expected, because the example is not calling _funcs_kwargs, but funcs_kwargs
                fdb_.snoop(deco=True) # how to snoop decorator: _funcs_kwargs is a decorator, so set deco=True to see running codes in inner f
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    [0m     
                    
                
                
                
                ```
                import fastcore.meta as fm
                ```
                
                
                ```
                fm._funcs_kwargs = fdb_.dbsrc # how to snoop on two functions one wrap around another
                ```
                
                
                ```
                fdb = Fastdb(funcs_kwargs)
                fdb.eg = """
                @funcs_kwargs
                class T:
                    _methods=['b'] # allows you to add method b upon instantiation
                    def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                    def a(self): return 1
                    def b(self): return 2
                    
                t = T()
                test_eq(t.a(), 1)
                test_eq(t.b(), 2)
                
                test_sig(T, '(f=1, *, b=None)')
                inspect.signature(T)
                
                def _new_func(): return 5
                
                t = T(b = _new_func)
                test_eq(t.b(), 5)
                
                t = T(a = lambda:3)
                test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                
                def _f(self,a=1): return self.num + a # access the num attribute from the instance
                
                @funcs_kwargs(as_method=True)
                class T: 
                    _methods=['b']
                    num = 5
                    
                t = T(b = _f) # adds method b
                test_eq(t.b(5), 10) # self.num + 5 = 10
                
                def _f(self,a=1): return self.num * a #multiply instead of add 
                
                class T2(T):
                    def __init__(self,num):
                        super().__init__(b = _f) # add method b from the super class
                        self.num=num
                        
                t = T2(num=3)
                test_eq(t.b(a=5), 15) # 3 * 5 = 15
                test_sig(T2, '(num)')
                """
                ```
                
                
                ```
                #| column: screen
                fdb.print()
                ```
                
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    def funcs_kwargs(as_method=False):========================================================(0)       
                        "Replace methods in `cls._methods` with those from `kwargs`"==========================(1)       
                        if callable(as_method): return _funcs_kwargs(as_method, False)========================(2)       
                        return partial(_funcs_kwargs, as_method=as_method)====================================(3)       
                                                                                                                                                                            (4)
                
                
                
                ```
                #| column: screen
                fdb_.print()
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    def _funcs_kwargs(cls, as_method):========================================================(0)       
                        old_init = cls.__init__===============================================================(1)       
                        def _init(self, *args, **kwargs):=====================================================(2)       
                            for k in cls._methods:============================================================(3)       
                                arg = kwargs.pop(k,None)======================================================(4)       
                                if arg is not None:===========================================================(5)       
                                    if as_method: arg = method(arg)===========================================(6)       
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)=======(7)       
                                    setattr(self, k, arg)=====================================================(8)       
                            old_init(self, *args, **kwargs)===================================================(9)       
                        functools.update_wrapper(_init, old_init)=============================================(10)      
                        cls.__init__ = use_kwargs(cls._methods)(_init)========================================(11)      
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))                                                     (12)
                        return cls============================================================================(13)      
                                                                                                                                                                            (14)
                
                
                
                ```
                #| column: screen
                fdb.docsrc(1, "how funcs_kwargs works; it is a wrapper around _funcs_kwargs; it offers two ways of running _funcs_kwargs; \
                the first, default way, is to add a func to a class without using self; second way is to add func to class enabling self use;")
                fdb.docsrc(2, "how to check whether an object is callable; how to return a result of running a func; ")
                fdb.docsrc(3, "how to custom the params of `_funcs_kwargs` for a particular use with partial")
                ```
                
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m1[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                    def funcs_kwargs(as_method=False):                                                                                                                      (0)
                        "Replace methods in `cls._methods` with those from `kwargs`"========================================================================================(1)
                    [91;1mhow funcs_kwargs works; it is a wrapper around _funcs_kwargs; it offers two ways of running _funcs_kwargs; the first, default way, is to add a func to a class without using self; second way is to add func to class enabling self use;[0m
                        if callable(as_method): return _funcs_kwargs(as_method, False)                                                                                      (2)
                        return partial(_funcs_kwargs, as_method=as_method)                                                                                                  (3)
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m2[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                    def funcs_kwargs(as_method=False):                                                                                                                      (0)
                        "Replace methods in `cls._methods` with those from `kwargs`"                                                                                        (1)
                        if callable(as_method): return _funcs_kwargs(as_method, False)======================================================================================(2)
                                                                                           [91;1mhow to check whether an object is callable; how to return a result of running a func; [0m
                        return partial(_funcs_kwargs, as_method=as_method)                                                                                                  (3)
                                                                                                                                                                            (4)
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m3[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                        "Replace methods in `cls._methods` with those from `kwargs`"                                                                                        (1)
                        if callable(as_method): return _funcs_kwargs(as_method, False)                                                                                      (2)
                        return partial(_funcs_kwargs, as_method=as_method)==================================================================================================(3)
                                                                                                    [91;1mhow to custom the params of `_funcs_kwargs` for a particular use with partial[0m
                                                                                                                                                                            (4)
                
                
                
                ```
                #| column: screen
                fdb_.print()
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    def _funcs_kwargs(cls, as_method):========================================================(0)       
                        old_init = cls.__init__===============================================================(1)       
                        def _init(self, *args, **kwargs):=====================================================(2)       
                            for k in cls._methods:============================================================(3)       
                                arg = kwargs.pop(k,None)======================================================(4)       
                                if arg is not None:===========================================================(5)       
                                    if as_method: arg = method(arg)===========================================(6)       
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)=======(7)       
                                    setattr(self, k, arg)=====================================================(8)       
                            old_init(self, *args, **kwargs)===================================================(9)       
                        functools.update_wrapper(_init, old_init)=============================================(10)      
                        cls.__init__ = use_kwargs(cls._methods)(_init)========================================(11)      
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))                                                     (12)
                        return cls============================================================================(13)      
                                                                                                                                                                            (14)
                
                
                
                ```
                #| column: screen
                fdb_.docsrc(0, "how does _funcs_kwargs work: _funcs_kwargs is a decorator; it helps class e.g., T to add more methods; \
                I need to give the method a name, \
                and put the name e.g., 'b' inside a list called _methods=['b'] inside class T; \
                then after writing a func e.g., _new_func, I can add it by T(b = _new_func); if I want the func added to class to use self, \
                I shall write @funcs_kwargs(as_method=True)")
                fdb_.docsrc(2, "how to define a method which can use self and accept any parameters")
                fdb_.docsrc(3, "how to pop out the value of an item in a dict (with None as default), and if the item name is not found, pop out None instead; ")
                fdb_.docsrc(6, "how to turn a func into a method")
                fdb_.docsrc(7, "how to give a method a different instance, like self")
                fdb_.docsrc(8, "how to add a method to a class as an attribute")
                fdb_.docsrc(10, "how to wrap `_init` around `old_init`, so that `_init` can use `old_init` inside itself")
                fdb_.docsrc(11, "how to add a list of names with None as default value to function `_init` to repalce its kwargs param")
                fdb_.docsrc(12, "how to make a class.`__init__` signature to be the signature of the class using `__signature__` and `_rm_self`")
                
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m0[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                    def _funcs_kwargs(cls, as_method):======================================================================================================================(0)
                    [91;1mhow does _funcs_kwargs work: _funcs_kwargs is a decorator; it helps class e.g., T to add more methods; I need to give the method a name, and put the name e.g., 'b' inside a list called _methods=['b'] inside class T; then after writing a func e.g., _new_func, I can add it by T(b = _new_func); if I want the func added to class to use self, I shall write @funcs_kwargs(as_method=True)[0m
                        old_init = cls.__init__                                                                                                                             (1)
                        def _init(self, *args, **kwargs):                                                                                                                   (2)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m2[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                    def _funcs_kwargs(cls, as_method):                                                                                                                      (0)
                        old_init = cls.__init__                                                                                                                             (1)
                        def _init(self, *args, **kwargs):===================================================================================================================(2)
                                                                                                              [91;1mhow to define a method which can use self and accept any parameters[0m
                            for k in cls._methods:                                                                                                                          (3)
                                arg = kwargs.pop(k,None)                                                                                                                    (4)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m3[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                        old_init = cls.__init__                                                                                                                             (1)
                        def _init(self, *args, **kwargs):                                                                                                                   (2)
                            for k in cls._methods:==========================================================================================================================(3)
                                                  [91;1mhow to pop out the value of an item in a dict (with None as default), and if the item name is not found, pop out None instead; [0m
                                arg = kwargs.pop(k,None)                                                                                                                    (4)
                                if arg is not None:                                                                                                                         (5)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m6[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                                arg = kwargs.pop(k,None)                                                                                                                    (4)
                                if arg is not None:                                                                                                                         (5)
                                    if as_method: arg = method(arg)=========================================================================================================(6)
                                                                                                                                                 [91;1mhow to turn a func into a method[0m
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)                                                                     (7)
                                    setattr(self, k, arg)                                                                                                                   (8)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m7[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                                if arg is not None:                                                                                                                         (5)
                                    if as_method: arg = method(arg)                                                                                                         (6)
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)=====================================================================(7)
                                                                                                                             [91;1mhow to give a method a different instance, like self[0m
                                    setattr(self, k, arg)                                                                                                                   (8)
                            old_init(self, *args, **kwargs)                                                                                                                 (9)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m8[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                                    if as_method: arg = method(arg)                                                                                                         (6)
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)                                                                     (7)
                                    setattr(self, k, arg)===================================================================================================================(8)
                                                                                                                                   [91;1mhow to add a method to a class as an attribute[0m
                            old_init(self, *args, **kwargs)                                                                                                                 (9)
                        functools.update_wrapper(_init, old_init)                                                                                                           (10)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m10[0m     ===============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                                    setattr(self, k, arg)                                                                                                                   (8)
                            old_init(self, *args, **kwargs)                                                                                                                 (9)
                        functools.update_wrapper(_init, old_init)===========================================================================================================(10)
                                                                                          [91;1mhow to wrap `_init` around `old_init`, so that `_init` can use `old_init` inside itself[0m
                        cls.__init__ = use_kwargs(cls._methods)(_init)                                                                                                      (11)
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))                                                     (12)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m11[0m     ===============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                            old_init(self, *args, **kwargs)                                                                                                                 (9)
                        functools.update_wrapper(_init, old_init)                                                                                                           (10)
                        cls.__init__ = use_kwargs(cls._methods)(_init)======================================================================================================(11)
                                                                            [91;1mhow to add a list of names with None as default value to function `_init` to repalce its kwargs param[0m
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))                                                     (12)
                        return cls                                                                                                                                          (13)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m12[0m     ===============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                        functools.update_wrapper(_init, old_init)                                                                                                           (10)
                        cls.__init__ = use_kwargs(cls._methods)(_init)                                                                                                      (11)
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))=====================================================(12)
                                                                   [91;1mhow to make a class.`__init__` signature to be the signature of the class using `__signature__` and `_rm_self`[0m
                        return cls                                                                                                                                          (13)
                                                                                                                                                                            (14)
                
                
                
                ```
                #| column: screen
                fdb.snoop() # how to snoop together with docsrc: snoop first and docsrc above it
                ```
                
                    22:28:59.99 >>> Call to funcs_kwargs in File "/tmp/funcs_kwargs.py", line 3
                    22:28:59.99 ...... as_method = <class 'fastcore.meta.T'>
                    22:28:59.99    3 | def funcs_kwargs(as_method=False):
                    22:28:59.99    5 |     if callable(as_method): return _funcs_kwargs(as_method, False)
                        22:28:59.99 >>> Call to _funcs_kwargs in File "/tmp/_funcs_kwargs.py", line 3
                        22:28:59.99 ...... cls = <class 'fastcore.meta.T'>
                        22:28:59.99 ...... as_method = False
                        22:28:59.99    3 | def _funcs_kwargs(cls, as_method):
                        22:28:59.99    4 |     old_init = cls.__init__
                        22:28:59.99 .......... old_init = <function T.__init__>
                        22:28:59.99    5 |     import snoop
                        22:28:59.99 .......... snoop = <class 'snoop.configuration.Config.__init__.<locals>.ConfiguredTracer'>
                        22:28:59.99    6 |     @snoop
                        22:28:59.99    7 |     def _init(self, *args, **kwargs):
                        22:28:59.99 .......... _init = <function _funcs_kwargs.<locals>._init>
                        22:28:59.99   15 |     functools.update_wrapper(_init, old_init)
                        22:28:59.99 .......... _init = <function T.__init__>
                        22:28:59.99   16 |     cls.__init__ = use_kwargs(cls._methods)(_init)
                        22:28:59.99   17 |     if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))
                        22:28:59.99   18 |     return cls
                        22:28:59.99 <<< Return value from _funcs_kwargs: <class 'fastcore.meta.T'>
                    22:28:59.99    5 |     if callable(as_method): return _funcs_kwargs(as_method, False)
                    22:28:59.99 <<< Return value from funcs_kwargs: <class 'fastcore.meta.T'>
                    22:28:59.99 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:28:59.99 .......... self = <fastcore.meta.T object>
                    22:28:59.99 .......... args = ()
                    22:28:59.99 .......... kwargs = {}
                    22:28:59.99 .......... as_method = False
                    22:28:59.99 .......... cls = <class 'fastcore.meta.T'>
                    22:28:59.99 .......... old_init = <function T.__init__>
                    22:28:59.99    7 |     def _init(self, *args, **kwargs):
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00 .............. k = 'b'
                    22:29:00.00    9 |             arg = kwargs.pop(k,None)
                    22:29:00.00 .................. arg = None
                    22:29:00.00   10 |             if arg is not None:
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00   14 |         old_init(self, *args, **kwargs)
                    22:29:00.00 <<< Return value from _funcs_kwargs.<locals>._init: None
                    22:29:00.00 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:29:00.00 .......... self = <fastcore.meta.T object>
                    22:29:00.00 .......... args = ()
                    22:29:00.00 .......... kwargs = {'b': <function _new_func>}
                    22:29:00.00 .......... len(kwargs) = 1
                    22:29:00.00 .......... as_method = False
                    22:29:00.00 .......... cls = <class 'fastcore.meta.T'>
                    22:29:00.00 .......... old_init = <function T.__init__>
                    22:29:00.00    7 |     def _init(self, *args, **kwargs):
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00 .............. k = 'b'
                    22:29:00.00    9 |             arg = kwargs.pop(k,None)
                    22:29:00.00 .................. kwargs = {}
                    22:29:00.00 .................. arg = <function _new_func>
                    22:29:00.00   10 |             if arg is not None:
                    22:29:00.00   11 |                 if as_method: arg = method(arg)
                    22:29:00.00   12 |                 if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)
                    22:29:00.00   13 |                 setattr(self, k, arg)
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00   14 |         old_init(self, *args, **kwargs)
                    22:29:00.00 <<< Return value from _funcs_kwargs.<locals>._init: None
                    22:29:00.00 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:29:00.00 .......... self = <fastcore.meta.T object>
                    22:29:00.00 .......... args = ()
                    22:29:00.00 .......... kwargs = {'a': <function <lambda>>}
                    22:29:00.00 .......... len(kwargs) = 1
                    22:29:00.00 .......... as_method = False
                    22:29:00.00 .......... cls = <class 'fastcore.meta.T'>
                    22:29:00.00 .......... old_init = <function T.__init__>
                    22:29:00.00    7 |     def _init(self, *args, **kwargs):
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00 .............. k = 'b'
                    22:29:00.00    9 |             arg = kwargs.pop(k,None)
                    22:29:00.00 .................. arg = None
                    22:29:00.00   10 |             if arg is not None:
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00   14 |         old_init(self, *args, **kwargs)
                    22:29:00.00 <<< Return value from _funcs_kwargs.<locals>._init: None
                    22:29:00.00 >>> Call to funcs_kwargs in File "/tmp/funcs_kwargs.py", line 3
                    22:29:00.00 ...... as_method = True
                    22:29:00.00    3 | def funcs_kwargs(as_method=False):
                    22:29:00.00    5 |     if callable(as_method): return _funcs_kwargs(as_method, False)
                    22:29:00.00    6 |     return partial(_funcs_kwargs, as_method=as_method)
                    22:29:00.00 <<< Return value from funcs_kwargs: functools.partial(<function _funcs_kwargs>, as_method=True)
                    22:29:00.00 >>> Call to _funcs_kwargs in File "/tmp/_funcs_kwargs.py", line 3
                    22:29:00.00 ...... cls = <class 'fastcore.meta.T'>
                    22:29:00.00 ...... as_method = True
                    22:29:00.00    3 | def _funcs_kwargs(cls, as_method):
                    22:29:00.00    4 |     old_init = cls.__init__
                    22:29:00.00 .......... old_init = <slot wrapper '__init__' of 'object' objects>
                    22:29:00.00    5 |     import snoop
                    22:29:00.00 .......... snoop = <class 'snoop.configuration.Config.__init__.<locals>.ConfiguredTracer'>
                    22:29:00.00    6 |     @snoop
                    22:29:00.00    7 |     def _init(self, *args, **kwargs):
                    22:29:00.00 .......... _init = <function _funcs_kwargs.<locals>._init>
                    22:29:00.00   15 |     functools.update_wrapper(_init, old_init)
                    22:29:00.00 .......... _init = <function object.__init__>
                    22:29:00.00   16 |     cls.__init__ = use_kwargs(cls._methods)(_init)
                    22:29:00.01   17 |     if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))
                    22:29:00.01   18 |     return cls
                    22:29:00.01 <<< Return value from _funcs_kwargs: <class 'fastcore.meta.T'>
                    22:29:00.01 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:29:00.01 .......... self = <fastcore.meta.T object>
                    22:29:00.01 .......... args = ()
                    22:29:00.01 .......... kwargs = {'b': <function _f>}
                    22:29:00.01 .......... len(kwargs) = 1
                    22:29:00.01 .......... as_method = True
                    22:29:00.01 .......... cls = <class 'fastcore.meta.T'>
                    22:29:00.01 .......... old_init = <slot wrapper '__init__' of 'object' objects>
                    22:29:00.01    7 |     def _init(self, *args, **kwargs):
                    22:29:00.01    8 |         for k in cls._methods:
                    22:29:00.01 .............. k = 'b'
                    22:29:00.01    9 |             arg = kwargs.pop(k,None)
                    22:29:00.01 .................. kwargs = {}
                    22:29:00.01 .................. arg = <function _f>
                    22:29:00.01   10 |             if arg is not None:
                    22:29:00.01   11 |                 if as_method: arg = method(arg)
                    22:29:00.01 ...... arg = <bound method int._f of 1>
                    22:29:00.01   12 |                 if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)
                    22:29:00.01 ...... arg = <bound method T._f of <fastcore.meta.T object>>
                    22:29:00.01   13 |                 setattr(self, k, arg)
                    22:29:00.01    8 |         for k in cls._methods:
                    22:29:00.01   14 |         old_init(self, *args, **kwargs)
                    22:29:00.01 <<< Return value from _funcs_kwargs.<locals>._init: None
                    22:29:00.01 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:29:00.01 .......... self = <fastcore.meta.T2 object>
                    22:29:00.01 .......... args = ()
                    22:29:00.01 .......... kwargs = {'b': <function _f>}
                    22:29:00.01 .......... len(kwargs) = 1
                    22:29:00.01 .......... as_method = True
                    22:29:00.01 .......... cls = <class 'fastcore.meta.T'>
                    22:29:00.01 .......... old_init = <slot wrapper '__init__' of 'object' objects>
                    22:29:00.01    7 |     def _init(self, *args, **kwargs):
                    22:29:00.01    8 |         for k in cls._methods:
                    22:29:00.01 .............. k = 'b'
                    22:29:00.01    9 |             arg = kwargs.pop(k,None)
                    22:29:00.01 .................. kwargs = {}
                    22:29:00.01 .................. arg = <function _f>
                    22:29:00.01   10 |             if arg is not None:
                    22:29:00.01   11 |                 if as_method: arg = method(arg)
                    22:29:00.01 ...... arg = <bound method int._f of 1>
                    22:29:00.01   12 |                 if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)
                    22:29:00.01 ...... arg = <bound method T2._f of <fastcore.meta.T2 object>>
                    22:29:00.01   13 |                 setattr(self, k, arg)
                    22:29:00.01    8 |         for k in cls._methods:
                    22:29:00.01   14 |         old_init(self, *args, **kwargs)
                    22:29:00.01 <<< Return value from _funcs_kwargs.<locals>._init: None
                
                
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                
                
                
                ```
                fdb_.debug()
                ```
                
                    _funcs_kwargs's dbsrc code: ==============
                    import snoop
                    @snoop
                    def _funcs_kwargs(cls, as_method):
                        old_init = cls.__init__
                        import snoop
                        @snoop
                        def _init(self, *args, **kwargs):
                            for k in cls._methods:
                                arg = kwargs.pop(k,None)
                                if arg is not None:
                                    if as_method: arg = method(arg)
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)
                                    setattr(self, k, arg)
                            old_init(self, *args, **kwargs)
                        functools.update_wrapper(_init, old_init)
                        cls.__init__ = use_kwargs(cls._methods)(_init)
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))
                        return cls
                    
                    
                    
                    _funcs_kwargs's example processed with dbsrc: ===============
                    
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    
                
                
                
                ```
                #| column: screen
                fdb.print()
                ```
                
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    def funcs_kwargs(as_method=False):========================================================(0)       
                        "Replace methods in `cls._methods` with those from `kwargs`"==========================(1) # [93;1mhow funcs_kwargs works[0m; [93;1mit is a wrapper around _funcs_kwargs[0m; [91;1mit offers two ways of running _funcs_kwargs[0m; [37;1mthe first, default way, is to add a func to a class without using self[0m; [91;1msecond way is to add func to class enabling self use;[0m; 
                        if callable(as_method): return _funcs_kwargs(as_method, False)========================(2) # [37;1mhow to check whether an object is callable[0m; [93;1mhow to return a result of running a func[0m; [37;1m[0m; 
                        return partial(_funcs_kwargs, as_method=as_method)====================================(3) # [92;1mhow to custom the params of `_funcs_kwargs` for a particular use with partial[0m; 
                                                                                                                                                                            (4)
                
                
                
                ```
                #| column: screen
                fdb_.print()
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m12[0m     ===============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    def _funcs_kwargs(cls, as_method):========================================================(0) # [93;1mhow does _funcs_kwargs work: _funcs_kwargs is a decorator[0m; [35;1mit helps class e.g., T to add more methods[0m; [93;1mI need to give the method a name, and put the name e.g., 'b' inside a list called _methods=['b'] inside class T[0m; [36;1mthen after writing a func e.g., _new_func, I can add it by T(b = _new_func)[0m; [36;1mif I want the func added to class to use self, I shall write @funcs_kwargs(as_method=True)[0m; 
                        old_init = cls.__init__===============================================================(1)       
                        def _init(self, *args, **kwargs):=====================================================(2) # [37;1mhow to define a method which can use self and accept any parameters[0m; 
                            for k in cls._methods:============================================================(3) # [35;1mhow to pop out the value of an item in a dict (with None as default), and if the item name is not found, pop out None instead[0m; [91;1m[0m; 
                                arg = kwargs.pop(k,None)======================================================(4)       
                                if arg is not None:===========================================================(5)       
                                    if as_method: arg = method(arg)===========================================(6) # [36;1mhow to turn a func into a method[0m; 
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)=======(7) # [93;1mhow to give a method a different instance, like self[0m; 
                                    setattr(self, k, arg)=====================================================(8) # [36;1mhow to add a method to a class as an attribute[0m; 
                            old_init(self, *args, **kwargs)===================================================(9)       
                        functools.update_wrapper(_init, old_init)=============================================(10) # [34;1mhow to wrap `_init` around `old_init`, so that `_init` can use `old_init` inside itself[0m; 
                        cls.__init__ = use_kwargs(cls._methods)(_init)========================================(11) # [34;1mhow to add a list of names with None as default value to function `_init` to repalce its kwargs param[0m; 
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__)) # [35;1mhow to make a class.`__init__` signature to be the signature of the class using `__signature__` and `_rm_self`[0m;  (12)
                        return cls============================================================================(13)      
                                                                                                                                                                            (14)
                
                
                
                ```
                
                ```
                
                
            
            
            
            [Open `0009_funcs_kwargs` in Jupyter Notebook](http://localhost:8888/tree/nbs/demos/0009_funcs_kwargs.ipynb)
            
            
            
        
        
        
        [Open `utils` in Jupyter Notebook](http://localhost:8888/tree/nbs/lib/utils.ipynb)
        
        
        
        
    
    
    
    [Open `utils` in Jupyter Notebook](http://localhost:8888/tree/nbs/lib/utils.ipynb)
    
    
    
    



[Open `utils` in Jupyter Notebook locally](http://localhost:8888/tree/nbs/lib/utils.ipynb)



###  <mark style="background-color: #ffff00">snoop:</mark>   <mark style="background-color: #ffff00">from</mark>   <mark style="background-color: #ffff00">_ <mark style="background-color: #FFFF00">funcs_kwargs</mark> </mark>   <mark style="background-color: #ffff00">to</mark>   <mark style="background-color: #FFFF00">funcs_kwargs</mark> 



    
    
    
        
        
        
            
            
            
                
                how to snoop on two functions one wrap around another: `funcs_kwargs` is a wrapper around `_funcs_kwargs`, so I can first snoop on `_funcs_kwargs` and assign its snoop dbsrc to \
                `fm._funcs_kwargs` so that when I snoop on `funcs_kwargs`, it can use the snoop dbsrc of `_funcs_kwargs` and no example codes need to change.
                
                
                ```
                from fastcore.meta import _funcs_kwargs
                ```
                
                
                ```
                fdb_ = Fastdb(_funcs_kwargs)
                fdb_.eg = """
                @funcs_kwargs
                class T:
                    _methods=['b'] # allows you to add method b upon instantiation
                    def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                    def a(self): return 1
                    def b(self): return 2
                    
                t = T()
                test_eq(t.a(), 1)
                test_eq(t.b(), 2)
                
                test_sig(T, '(f=1, *, b=None)')
                inspect.signature(T)
                
                def _new_func(): return 5
                
                t = T(b = _new_func)
                test_eq(t.b(), 5)
                
                t = T(a = lambda:3)
                test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                """
                ```
                
                
                ```
                #| column: screen
                # no snoop result, it is expected, because the example is not calling _funcs_kwargs, but funcs_kwargs
                fdb_.snoop(deco=True) # how to snoop decorator: _funcs_kwargs is a decorator, so set deco=True to see running codes in inner f
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    [0m     
                    
                
                
                
                ```
                import fastcore.meta as fm
                ```
                
                
                ```
                fm._funcs_kwargs = fdb_.dbsrc # how to snoop on two functions one wrap around another
                ```
                
                
                ```
                fdb = Fastdb(funcs_kwargs)
                fdb.eg = """
                @funcs_kwargs
                class T:
                    _methods=['b'] # allows you to add method b upon instantiation
                    def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                    def a(self): return 1
                    def b(self): return 2
                    
                t = T()
                test_eq(t.a(), 1)
                test_eq(t.b(), 2)
                
                test_sig(T, '(f=1, *, b=None)')
                inspect.signature(T)
                
                def _new_func(): return 5
                
                t = T(b = _new_func)
                test_eq(t.b(), 5)
                
                t = T(a = lambda:3)
                test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                
                def _f(self,a=1): return self.num + a # access the num attribute from the instance
                
                @funcs_kwargs(as_method=True)
                class T: 
                    _methods=['b']
                    num = 5
                    
                t = T(b = _f) # adds method b
                test_eq(t.b(5), 10) # self.num + 5 = 10
                
                def _f(self,a=1): return self.num * a #multiply instead of add 
                
                class T2(T):
                    def __init__(self,num):
                        super().__init__(b = _f) # add method b from the super class
                        self.num=num
                        
                t = T2(num=3)
                test_eq(t.b(a=5), 15) # 3 * 5 = 15
                test_sig(T2, '(num)')
                """
                ```
                
                
                ```
                #| column: screen
                fdb.print()
                ```
                
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    def funcs_kwargs(as_method=False):========================================================(0)       
                        "Replace methods in `cls._methods` with those from `kwargs`"==========================(1)       
                        if callable(as_method): return _funcs_kwargs(as_method, False)========================(2)       
                        return partial(_funcs_kwargs, as_method=as_method)====================================(3)       
                                                                                                                                                                            (4)
                
                
                
                ```
                #| column: screen
                fdb_.print()
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    def _funcs_kwargs(cls, as_method):========================================================(0)       
                        old_init = cls.__init__===============================================================(1)       
                        def _init(self, *args, **kwargs):=====================================================(2)       
                            for k in cls._methods:============================================================(3)       
                                arg = kwargs.pop(k,None)======================================================(4)       
                                if arg is not None:===========================================================(5)       
                                    if as_method: arg = method(arg)===========================================(6)       
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)=======(7)       
                                    setattr(self, k, arg)=====================================================(8)       
                            old_init(self, *args, **kwargs)===================================================(9)       
                        functools.update_wrapper(_init, old_init)=============================================(10)      
                        cls.__init__ = use_kwargs(cls._methods)(_init)========================================(11)      
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))                                                     (12)
                        return cls============================================================================(13)      
                                                                                                                                                                            (14)
                
                
                
                ```
                #| column: screen
                fdb.docsrc(1, "how funcs_kwargs works; it is a wrapper around _funcs_kwargs; it offers two ways of running _funcs_kwargs; \
                the first, default way, is to add a func to a class without using self; second way is to add func to class enabling self use;")
                fdb.docsrc(2, "how to check whether an object is callable; how to return a result of running a func; ")
                fdb.docsrc(3, "how to custom the params of `_funcs_kwargs` for a particular use with partial")
                ```
                
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m1[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                    def funcs_kwargs(as_method=False):                                                                                                                      (0)
                        "Replace methods in `cls._methods` with those from `kwargs`"========================================================================================(1)
                    [91;1mhow funcs_kwargs works; it is a wrapper around _funcs_kwargs; it offers two ways of running _funcs_kwargs; the first, default way, is to add a func to a class without using self; second way is to add func to class enabling self use;[0m
                        if callable(as_method): return _funcs_kwargs(as_method, False)                                                                                      (2)
                        return partial(_funcs_kwargs, as_method=as_method)                                                                                                  (3)
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m2[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                    def funcs_kwargs(as_method=False):                                                                                                                      (0)
                        "Replace methods in `cls._methods` with those from `kwargs`"                                                                                        (1)
                        if callable(as_method): return _funcs_kwargs(as_method, False)======================================================================================(2)
                                                                                           [91;1mhow to check whether an object is callable; how to return a result of running a func; [0m
                        return partial(_funcs_kwargs, as_method=as_method)                                                                                                  (3)
                                                                                                                                                                            (4)
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m3[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                        "Replace methods in `cls._methods` with those from `kwargs`"                                                                                        (1)
                        if callable(as_method): return _funcs_kwargs(as_method, False)                                                                                      (2)
                        return partial(_funcs_kwargs, as_method=as_method)==================================================================================================(3)
                                                                                                    [91;1mhow to custom the params of `_funcs_kwargs` for a particular use with partial[0m
                                                                                                                                                                            (4)
                
                
                
                ```
                #| column: screen
                fdb_.print()
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    def _funcs_kwargs(cls, as_method):========================================================(0)       
                        old_init = cls.__init__===============================================================(1)       
                        def _init(self, *args, **kwargs):=====================================================(2)       
                            for k in cls._methods:============================================================(3)       
                                arg = kwargs.pop(k,None)======================================================(4)       
                                if arg is not None:===========================================================(5)       
                                    if as_method: arg = method(arg)===========================================(6)       
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)=======(7)       
                                    setattr(self, k, arg)=====================================================(8)       
                            old_init(self, *args, **kwargs)===================================================(9)       
                        functools.update_wrapper(_init, old_init)=============================================(10)      
                        cls.__init__ = use_kwargs(cls._methods)(_init)========================================(11)      
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))                                                     (12)
                        return cls============================================================================(13)      
                                                                                                                                                                            (14)
                
                
                
                ```
                #| column: screen
                fdb_.docsrc(0, "how does _funcs_kwargs work: _funcs_kwargs is a decorator; it helps class e.g., T to add more methods; \
                I need to give the method a name, \
                and put the name e.g., 'b' inside a list called _methods=['b'] inside class T; \
                then after writing a func e.g., _new_func, I can add it by T(b = _new_func); if I want the func added to class to use self, \
                I shall write @funcs_kwargs(as_method=True)")
                fdb_.docsrc(2, "how to define a method which can use self and accept any parameters")
                fdb_.docsrc(3, "how to pop out the value of an item in a dict (with None as default), and if the item name is not found, pop out None instead; ")
                fdb_.docsrc(6, "how to turn a func into a method")
                fdb_.docsrc(7, "how to give a method a different instance, like self")
                fdb_.docsrc(8, "how to add a method to a class as an attribute")
                fdb_.docsrc(10, "how to wrap `_init` around `old_init`, so that `_init` can use `old_init` inside itself")
                fdb_.docsrc(11, "how to add a list of names with None as default value to function `_init` to repalce its kwargs param")
                fdb_.docsrc(12, "how to make a class.`__init__` signature to be the signature of the class using `__signature__` and `_rm_self`")
                
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m0[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                    def _funcs_kwargs(cls, as_method):======================================================================================================================(0)
                    [91;1mhow does _funcs_kwargs work: _funcs_kwargs is a decorator; it helps class e.g., T to add more methods; I need to give the method a name, and put the name e.g., 'b' inside a list called _methods=['b'] inside class T; then after writing a func e.g., _new_func, I can add it by T(b = _new_func); if I want the func added to class to use self, I shall write @funcs_kwargs(as_method=True)[0m
                        old_init = cls.__init__                                                                                                                             (1)
                        def _init(self, *args, **kwargs):                                                                                                                   (2)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m2[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                    def _funcs_kwargs(cls, as_method):                                                                                                                      (0)
                        old_init = cls.__init__                                                                                                                             (1)
                        def _init(self, *args, **kwargs):===================================================================================================================(2)
                                                                                                              [91;1mhow to define a method which can use self and accept any parameters[0m
                            for k in cls._methods:                                                                                                                          (3)
                                arg = kwargs.pop(k,None)                                                                                                                    (4)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m3[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                        old_init = cls.__init__                                                                                                                             (1)
                        def _init(self, *args, **kwargs):                                                                                                                   (2)
                            for k in cls._methods:==========================================================================================================================(3)
                                                  [91;1mhow to pop out the value of an item in a dict (with None as default), and if the item name is not found, pop out None instead; [0m
                                arg = kwargs.pop(k,None)                                                                                                                    (4)
                                if arg is not None:                                                                                                                         (5)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m6[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                                arg = kwargs.pop(k,None)                                                                                                                    (4)
                                if arg is not None:                                                                                                                         (5)
                                    if as_method: arg = method(arg)=========================================================================================================(6)
                                                                                                                                                 [91;1mhow to turn a func into a method[0m
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)                                                                     (7)
                                    setattr(self, k, arg)                                                                                                                   (8)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m7[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                                if arg is not None:                                                                                                                         (5)
                                    if as_method: arg = method(arg)                                                                                                         (6)
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)=====================================================================(7)
                                                                                                                             [91;1mhow to give a method a different instance, like self[0m
                                    setattr(self, k, arg)                                                                                                                   (8)
                            old_init(self, *args, **kwargs)                                                                                                                 (9)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m8[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                                    if as_method: arg = method(arg)                                                                                                         (6)
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)                                                                     (7)
                                    setattr(self, k, arg)===================================================================================================================(8)
                                                                                                                                   [91;1mhow to add a method to a class as an attribute[0m
                            old_init(self, *args, **kwargs)                                                                                                                 (9)
                        functools.update_wrapper(_init, old_init)                                                                                                           (10)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m10[0m     ===============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                                    setattr(self, k, arg)                                                                                                                   (8)
                            old_init(self, *args, **kwargs)                                                                                                                 (9)
                        functools.update_wrapper(_init, old_init)===========================================================================================================(10)
                                                                                          [91;1mhow to wrap `_init` around `old_init`, so that `_init` can use `old_init` inside itself[0m
                        cls.__init__ = use_kwargs(cls._methods)(_init)                                                                                                      (11)
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))                                                     (12)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m11[0m     ===============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                            old_init(self, *args, **kwargs)                                                                                                                 (9)
                        functools.update_wrapper(_init, old_init)                                                                                                           (10)
                        cls.__init__ = use_kwargs(cls._methods)(_init)======================================================================================================(11)
                                                                            [91;1mhow to add a list of names with None as default value to function `_init` to repalce its kwargs param[0m
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))                                                     (12)
                        return cls                                                                                                                                          (13)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m12[0m     ===============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                        functools.update_wrapper(_init, old_init)                                                                                                           (10)
                        cls.__init__ = use_kwargs(cls._methods)(_init)                                                                                                      (11)
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))=====================================================(12)
                                                                   [91;1mhow to make a class.`__init__` signature to be the signature of the class using `__signature__` and `_rm_self`[0m
                        return cls                                                                                                                                          (13)
                                                                                                                                                                            (14)
                
                
                
                ```
                #| column: screen
                fdb.snoop() # how to snoop together with docsrc: snoop first and docsrc above it
                ```
                
                    22:28:59.99 >>> Call to funcs_kwargs in File "/tmp/funcs_kwargs.py", line 3
                    22:28:59.99 ...... as_method = <class 'fastcore.meta.T'>
                    22:28:59.99    3 | def funcs_kwargs(as_method=False):
                    22:28:59.99    5 |     if callable(as_method): return _funcs_kwargs(as_method, False)
                        22:28:59.99 >>> Call to _funcs_kwargs in File "/tmp/_funcs_kwargs.py", line 3
                        22:28:59.99 ...... cls = <class 'fastcore.meta.T'>
                        22:28:59.99 ...... as_method = False
                        22:28:59.99    3 | def _funcs_kwargs(cls, as_method):
                        22:28:59.99    4 |     old_init = cls.__init__
                        22:28:59.99 .......... old_init = <function T.__init__>
                        22:28:59.99    5 |     import snoop
                        22:28:59.99 .......... snoop = <class 'snoop.configuration.Config.__init__.<locals>.ConfiguredTracer'>
                        22:28:59.99    6 |     @snoop
                        22:28:59.99    7 |     def _init(self, *args, **kwargs):
                        22:28:59.99 .......... _init = <function _funcs_kwargs.<locals>._init>
                        22:28:59.99   15 |     functools.update_wrapper(_init, old_init)
                        22:28:59.99 .......... _init = <function T.__init__>
                        22:28:59.99   16 |     cls.__init__ = use_kwargs(cls._methods)(_init)
                        22:28:59.99   17 |     if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))
                        22:28:59.99   18 |     return cls
                        22:28:59.99 <<< Return value from _funcs_kwargs: <class 'fastcore.meta.T'>
                    22:28:59.99    5 |     if callable(as_method): return _funcs_kwargs(as_method, False)
                    22:28:59.99 <<< Return value from funcs_kwargs: <class 'fastcore.meta.T'>
                    22:28:59.99 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:28:59.99 .......... self = <fastcore.meta.T object>
                    22:28:59.99 .......... args = ()
                    22:28:59.99 .......... kwargs = {}
                    22:28:59.99 .......... as_method = False
                    22:28:59.99 .......... cls = <class 'fastcore.meta.T'>
                    22:28:59.99 .......... old_init = <function T.__init__>
                    22:28:59.99    7 |     def _init(self, *args, **kwargs):
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00 .............. k = 'b'
                    22:29:00.00    9 |             arg = kwargs.pop(k,None)
                    22:29:00.00 .................. arg = None
                    22:29:00.00   10 |             if arg is not None:
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00   14 |         old_init(self, *args, **kwargs)
                    22:29:00.00 <<< Return value from _funcs_kwargs.<locals>._init: None
                    22:29:00.00 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:29:00.00 .......... self = <fastcore.meta.T object>
                    22:29:00.00 .......... args = ()
                    22:29:00.00 .......... kwargs = {'b': <function _new_func>}
                    22:29:00.00 .......... len(kwargs) = 1
                    22:29:00.00 .......... as_method = False
                    22:29:00.00 .......... cls = <class 'fastcore.meta.T'>
                    22:29:00.00 .......... old_init = <function T.__init__>
                    22:29:00.00    7 |     def _init(self, *args, **kwargs):
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00 .............. k = 'b'
                    22:29:00.00    9 |             arg = kwargs.pop(k,None)
                    22:29:00.00 .................. kwargs = {}
                    22:29:00.00 .................. arg = <function _new_func>
                    22:29:00.00   10 |             if arg is not None:
                    22:29:00.00   11 |                 if as_method: arg = method(arg)
                    22:29:00.00   12 |                 if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)
                    22:29:00.00   13 |                 setattr(self, k, arg)
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00   14 |         old_init(self, *args, **kwargs)
                    22:29:00.00 <<< Return value from _funcs_kwargs.<locals>._init: None
                    22:29:00.00 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:29:00.00 .......... self = <fastcore.meta.T object>
                    22:29:00.00 .......... args = ()
                    22:29:00.00 .......... kwargs = {'a': <function <lambda>>}
                    22:29:00.00 .......... len(kwargs) = 1
                    22:29:00.00 .......... as_method = False
                    22:29:00.00 .......... cls = <class 'fastcore.meta.T'>
                    22:29:00.00 .......... old_init = <function T.__init__>
                    22:29:00.00    7 |     def _init(self, *args, **kwargs):
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00 .............. k = 'b'
                    22:29:00.00    9 |             arg = kwargs.pop(k,None)
                    22:29:00.00 .................. arg = None
                    22:29:00.00   10 |             if arg is not None:
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00   14 |         old_init(self, *args, **kwargs)
                    22:29:00.00 <<< Return value from _funcs_kwargs.<locals>._init: None
                    22:29:00.00 >>> Call to funcs_kwargs in File "/tmp/funcs_kwargs.py", line 3
                    22:29:00.00 ...... as_method = True
                    22:29:00.00    3 | def funcs_kwargs(as_method=False):
                    22:29:00.00    5 |     if callable(as_method): return _funcs_kwargs(as_method, False)
                    22:29:00.00    6 |     return partial(_funcs_kwargs, as_method=as_method)
                    22:29:00.00 <<< Return value from funcs_kwargs: functools.partial(<function _funcs_kwargs>, as_method=True)
                    22:29:00.00 >>> Call to _funcs_kwargs in File "/tmp/_funcs_kwargs.py", line 3
                    22:29:00.00 ...... cls = <class 'fastcore.meta.T'>
                    22:29:00.00 ...... as_method = True
                    22:29:00.00    3 | def _funcs_kwargs(cls, as_method):
                    22:29:00.00    4 |     old_init = cls.__init__
                    22:29:00.00 .......... old_init = <slot wrapper '__init__' of 'object' objects>
                    22:29:00.00    5 |     import snoop
                    22:29:00.00 .......... snoop = <class 'snoop.configuration.Config.__init__.<locals>.ConfiguredTracer'>
                    22:29:00.00    6 |     @snoop
                    22:29:00.00    7 |     def _init(self, *args, **kwargs):
                    22:29:00.00 .......... _init = <function _funcs_kwargs.<locals>._init>
                    22:29:00.00   15 |     functools.update_wrapper(_init, old_init)
                    22:29:00.00 .......... _init = <function object.__init__>
                    22:29:00.00   16 |     cls.__init__ = use_kwargs(cls._methods)(_init)
                    22:29:00.01   17 |     if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))
                    22:29:00.01   18 |     return cls
                    22:29:00.01 <<< Return value from _funcs_kwargs: <class 'fastcore.meta.T'>
                    22:29:00.01 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:29:00.01 .......... self = <fastcore.meta.T object>
                    22:29:00.01 .......... args = ()
                    22:29:00.01 .......... kwargs = {'b': <function _f>}
                    22:29:00.01 .......... len(kwargs) = 1
                    22:29:00.01 .......... as_method = True
                    22:29:00.01 .......... cls = <class 'fastcore.meta.T'>
                    22:29:00.01 .......... old_init = <slot wrapper '__init__' of 'object' objects>
                    22:29:00.01    7 |     def _init(self, *args, **kwargs):
                    22:29:00.01    8 |         for k in cls._methods:
                    22:29:00.01 .............. k = 'b'
                    22:29:00.01    9 |             arg = kwargs.pop(k,None)
                    22:29:00.01 .................. kwargs = {}
                    22:29:00.01 .................. arg = <function _f>
                    22:29:00.01   10 |             if arg is not None:
                    22:29:00.01   11 |                 if as_method: arg = method(arg)
                    22:29:00.01 ...... arg = <bound method int._f of 1>
                    22:29:00.01   12 |                 if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)
                    22:29:00.01 ...... arg = <bound method T._f of <fastcore.meta.T object>>
                    22:29:00.01   13 |                 setattr(self, k, arg)
                    22:29:00.01    8 |         for k in cls._methods:
                    22:29:00.01   14 |         old_init(self, *args, **kwargs)
                    22:29:00.01 <<< Return value from _funcs_kwargs.<locals>._init: None
                    22:29:00.01 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:29:00.01 .......... self = <fastcore.meta.T2 object>
                    22:29:00.01 .......... args = ()
                    22:29:00.01 .......... kwargs = {'b': <function _f>}
                    22:29:00.01 .......... len(kwargs) = 1
                    22:29:00.01 .......... as_method = True
                    22:29:00.01 .......... cls = <class 'fastcore.meta.T'>
                    22:29:00.01 .......... old_init = <slot wrapper '__init__' of 'object' objects>
                    22:29:00.01    7 |     def _init(self, *args, **kwargs):
                    22:29:00.01    8 |         for k in cls._methods:
                    22:29:00.01 .............. k = 'b'
                    22:29:00.01    9 |             arg = kwargs.pop(k,None)
                    22:29:00.01 .................. kwargs = {}
                    22:29:00.01 .................. arg = <function _f>
                    22:29:00.01   10 |             if arg is not None:
                    22:29:00.01   11 |                 if as_method: arg = method(arg)
                    22:29:00.01 ...... arg = <bound method int._f of 1>
                    22:29:00.01   12 |                 if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)
                    22:29:00.01 ...... arg = <bound method T2._f of <fastcore.meta.T2 object>>
                    22:29:00.01   13 |                 setattr(self, k, arg)
                    22:29:00.01    8 |         for k in cls._methods:
                    22:29:00.01   14 |         old_init(self, *args, **kwargs)
                    22:29:00.01 <<< Return value from _funcs_kwargs.<locals>._init: None
                
                
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                
                
                
                ```
                fdb_.debug()
                ```
                
                    _funcs_kwargs's dbsrc code: ==============
                    import snoop
                    @snoop
                    def _funcs_kwargs(cls, as_method):
                        old_init = cls.__init__
                        import snoop
                        @snoop
                        def _init(self, *args, **kwargs):
                            for k in cls._methods:
                                arg = kwargs.pop(k,None)
                                if arg is not None:
                                    if as_method: arg = method(arg)
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)
                                    setattr(self, k, arg)
                            old_init(self, *args, **kwargs)
                        functools.update_wrapper(_init, old_init)
                        cls.__init__ = use_kwargs(cls._methods)(_init)
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))
                        return cls
                    
                    
                    
                    _funcs_kwargs's example processed with dbsrc: ===============
                    
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    
                
                
                
                ```
                #| column: screen
                fdb.print()
                ```
                
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    def funcs_kwargs(as_method=False):========================================================(0)       
                        "Replace methods in `cls._methods` with those from `kwargs`"==========================(1) # [93;1mhow funcs_kwargs works[0m; [93;1mit is a wrapper around _funcs_kwargs[0m; [91;1mit offers two ways of running _funcs_kwargs[0m; [37;1mthe first, default way, is to add a func to a class without using self[0m; [91;1msecond way is to add func to class enabling self use;[0m; 
                        if callable(as_method): return _funcs_kwargs(as_method, False)========================(2) # [37;1mhow to check whether an object is callable[0m; [93;1mhow to return a result of running a func[0m; [37;1m[0m; 
                        return partial(_funcs_kwargs, as_method=as_method)====================================(3) # [92;1mhow to custom the params of `_funcs_kwargs` for a particular use with partial[0m; 
                                                                                                                                                                            (4)
                
                
                
                ```
                #| column: screen
                fdb_.print()
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m12[0m     ===============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    def _funcs_kwargs(cls, as_method):========================================================(0) # [93;1mhow does _funcs_kwargs work: _funcs_kwargs is a decorator[0m; [35;1mit helps class e.g., T to add more methods[0m; [93;1mI need to give the method a name, and put the name e.g., 'b' inside a list called _methods=['b'] inside class T[0m; [36;1mthen after writing a func e.g., _new_func, I can add it by T(b = _new_func)[0m; [36;1mif I want the func added to class to use self, I shall write @funcs_kwargs(as_method=True)[0m; 
                        old_init = cls.__init__===============================================================(1)       
                        def _init(self, *args, **kwargs):=====================================================(2) # [37;1mhow to define a method which can use self and accept any parameters[0m; 
                            for k in cls._methods:============================================================(3) # [35;1mhow to pop out the value of an item in a dict (with None as default), and if the item name is not found, pop out None instead[0m; [91;1m[0m; 
                                arg = kwargs.pop(k,None)======================================================(4)       
                                if arg is not None:===========================================================(5)       
                                    if as_method: arg = method(arg)===========================================(6) # [36;1mhow to turn a func into a method[0m; 
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)=======(7) # [93;1mhow to give a method a different instance, like self[0m; 
                                    setattr(self, k, arg)=====================================================(8) # [36;1mhow to add a method to a class as an attribute[0m; 
                            old_init(self, *args, **kwargs)===================================================(9)       
                        functools.update_wrapper(_init, old_init)=============================================(10) # [34;1mhow to wrap `_init` around `old_init`, so that `_init` can use `old_init` inside itself[0m; 
                        cls.__init__ = use_kwargs(cls._methods)(_init)========================================(11) # [34;1mhow to add a list of names with None as default value to function `_init` to repalce its kwargs param[0m; 
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__)) # [35;1mhow to make a class.`__init__` signature to be the signature of the class using `__signature__` and `_rm_self`[0m;  (12)
                        return cls============================================================================(13)      
                                                                                                                                                                            (14)
                
                
                
                ```
                
                ```
                
                
            
            
            
            [Open `0009_funcs_kwargs` in Jupyter Notebook](http://localhost:8888/tree/nbs/demos/0009_funcs_kwargs.ipynb)
            
            
            
        
        
        
        [Open `utils` in Jupyter Notebook](http://localhost:8888/tree/nbs/lib/utils.ipynb)
        
        
        
        
    
    
    
    [Open `utils` in Jupyter Notebook](http://localhost:8888/tree/nbs/lib/utils.ipynb)
    
    
    
    



[Open `utils` in Jupyter Notebook locally](http://localhost:8888/tree/nbs/lib/utils.ipynb)



###  <mark style="background-color: #ffff00">snoop:</mark>   <mark style="background-color: #ffff00">from</mark>   <mark style="background-color: #ffff00">_ <mark style="background-color: #FFFF00">funcs_kwargs</mark> </mark>   <mark style="background-color: #ffff00">to</mark>   <mark style="background-color: #FFFF00">funcs_kwargs</mark> 



    
    
    
        
        
        
            
            
            
                
                how to snoop on two functions one wrap around another: `funcs_kwargs` is a wrapper around `_funcs_kwargs`, so I can first snoop on `_funcs_kwargs` and assign its snoop dbsrc to \
                `fm._funcs_kwargs` so that when I snoop on `funcs_kwargs`, it can use the snoop dbsrc of `_funcs_kwargs` and no example codes need to change.
                
                
                ```
                from fastcore.meta import _funcs_kwargs
                ```
                
                
                ```
                fdb_ = Fastdb(_funcs_kwargs)
                fdb_.eg = """
                @funcs_kwargs
                class T:
                    _methods=['b'] # allows you to add method b upon instantiation
                    def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                    def a(self): return 1
                    def b(self): return 2
                    
                t = T()
                test_eq(t.a(), 1)
                test_eq(t.b(), 2)
                
                test_sig(T, '(f=1, *, b=None)')
                inspect.signature(T)
                
                def _new_func(): return 5
                
                t = T(b = _new_func)
                test_eq(t.b(), 5)
                
                t = T(a = lambda:3)
                test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                """
                ```
                
                
                ```
                #| column: screen
                # no snoop result, it is expected, because the example is not calling _funcs_kwargs, but funcs_kwargs
                fdb_.snoop(deco=True) # how to snoop decorator: _funcs_kwargs is a decorator, so set deco=True to see running codes in inner f
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    [0m     
                    
                
                
                
                ```
                import fastcore.meta as fm
                ```
                
                
                ```
                fm._funcs_kwargs = fdb_.dbsrc # how to snoop on two functions one wrap around another
                ```
                
                
                ```
                fdb = Fastdb(funcs_kwargs)
                fdb.eg = """
                @funcs_kwargs
                class T:
                    _methods=['b'] # allows you to add method b upon instantiation
                    def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                    def a(self): return 1
                    def b(self): return 2
                    
                t = T()
                test_eq(t.a(), 1)
                test_eq(t.b(), 2)
                
                test_sig(T, '(f=1, *, b=None)')
                inspect.signature(T)
                
                def _new_func(): return 5
                
                t = T(b = _new_func)
                test_eq(t.b(), 5)
                
                t = T(a = lambda:3)
                test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                
                def _f(self,a=1): return self.num + a # access the num attribute from the instance
                
                @funcs_kwargs(as_method=True)
                class T: 
                    _methods=['b']
                    num = 5
                    
                t = T(b = _f) # adds method b
                test_eq(t.b(5), 10) # self.num + 5 = 10
                
                def _f(self,a=1): return self.num * a #multiply instead of add 
                
                class T2(T):
                    def __init__(self,num):
                        super().__init__(b = _f) # add method b from the super class
                        self.num=num
                        
                t = T2(num=3)
                test_eq(t.b(a=5), 15) # 3 * 5 = 15
                test_sig(T2, '(num)')
                """
                ```
                
                
                ```
                #| column: screen
                fdb.print()
                ```
                
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    def funcs_kwargs(as_method=False):========================================================(0)       
                        "Replace methods in `cls._methods` with those from `kwargs`"==========================(1)       
                        if callable(as_method): return _funcs_kwargs(as_method, False)========================(2)       
                        return partial(_funcs_kwargs, as_method=as_method)====================================(3)       
                                                                                                                                                                            (4)
                
                
                
                ```
                #| column: screen
                fdb_.print()
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    def _funcs_kwargs(cls, as_method):========================================================(0)       
                        old_init = cls.__init__===============================================================(1)       
                        def _init(self, *args, **kwargs):=====================================================(2)       
                            for k in cls._methods:============================================================(3)       
                                arg = kwargs.pop(k,None)======================================================(4)       
                                if arg is not None:===========================================================(5)       
                                    if as_method: arg = method(arg)===========================================(6)       
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)=======(7)       
                                    setattr(self, k, arg)=====================================================(8)       
                            old_init(self, *args, **kwargs)===================================================(9)       
                        functools.update_wrapper(_init, old_init)=============================================(10)      
                        cls.__init__ = use_kwargs(cls._methods)(_init)========================================(11)      
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))                                                     (12)
                        return cls============================================================================(13)      
                                                                                                                                                                            (14)
                
                
                
                ```
                #| column: screen
                fdb.docsrc(1, "how funcs_kwargs works; it is a wrapper around _funcs_kwargs; it offers two ways of running _funcs_kwargs; \
                the first, default way, is to add a func to a class without using self; second way is to add func to class enabling self use;")
                fdb.docsrc(2, "how to check whether an object is callable; how to return a result of running a func; ")
                fdb.docsrc(3, "how to custom the params of `_funcs_kwargs` for a particular use with partial")
                ```
                
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m1[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                    def funcs_kwargs(as_method=False):                                                                                                                      (0)
                        "Replace methods in `cls._methods` with those from `kwargs`"========================================================================================(1)
                    [91;1mhow funcs_kwargs works; it is a wrapper around _funcs_kwargs; it offers two ways of running _funcs_kwargs; the first, default way, is to add a func to a class without using self; second way is to add func to class enabling self use;[0m
                        if callable(as_method): return _funcs_kwargs(as_method, False)                                                                                      (2)
                        return partial(_funcs_kwargs, as_method=as_method)                                                                                                  (3)
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m2[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                    def funcs_kwargs(as_method=False):                                                                                                                      (0)
                        "Replace methods in `cls._methods` with those from `kwargs`"                                                                                        (1)
                        if callable(as_method): return _funcs_kwargs(as_method, False)======================================================================================(2)
                                                                                           [91;1mhow to check whether an object is callable; how to return a result of running a func; [0m
                        return partial(_funcs_kwargs, as_method=as_method)                                                                                                  (3)
                                                                                                                                                                            (4)
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m3[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                        "Replace methods in `cls._methods` with those from `kwargs`"                                                                                        (1)
                        if callable(as_method): return _funcs_kwargs(as_method, False)                                                                                      (2)
                        return partial(_funcs_kwargs, as_method=as_method)==================================================================================================(3)
                                                                                                    [91;1mhow to custom the params of `_funcs_kwargs` for a particular use with partial[0m
                                                                                                                                                                            (4)
                
                
                
                ```
                #| column: screen
                fdb_.print()
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    def _funcs_kwargs(cls, as_method):========================================================(0)       
                        old_init = cls.__init__===============================================================(1)       
                        def _init(self, *args, **kwargs):=====================================================(2)       
                            for k in cls._methods:============================================================(3)       
                                arg = kwargs.pop(k,None)======================================================(4)       
                                if arg is not None:===========================================================(5)       
                                    if as_method: arg = method(arg)===========================================(6)       
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)=======(7)       
                                    setattr(self, k, arg)=====================================================(8)       
                            old_init(self, *args, **kwargs)===================================================(9)       
                        functools.update_wrapper(_init, old_init)=============================================(10)      
                        cls.__init__ = use_kwargs(cls._methods)(_init)========================================(11)      
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))                                                     (12)
                        return cls============================================================================(13)      
                                                                                                                                                                            (14)
                
                
                
                ```
                #| column: screen
                fdb_.docsrc(0, "how does _funcs_kwargs work: _funcs_kwargs is a decorator; it helps class e.g., T to add more methods; \
                I need to give the method a name, \
                and put the name e.g., 'b' inside a list called _methods=['b'] inside class T; \
                then after writing a func e.g., _new_func, I can add it by T(b = _new_func); if I want the func added to class to use self, \
                I shall write @funcs_kwargs(as_method=True)")
                fdb_.docsrc(2, "how to define a method which can use self and accept any parameters")
                fdb_.docsrc(3, "how to pop out the value of an item in a dict (with None as default), and if the item name is not found, pop out None instead; ")
                fdb_.docsrc(6, "how to turn a func into a method")
                fdb_.docsrc(7, "how to give a method a different instance, like self")
                fdb_.docsrc(8, "how to add a method to a class as an attribute")
                fdb_.docsrc(10, "how to wrap `_init` around `old_init`, so that `_init` can use `old_init` inside itself")
                fdb_.docsrc(11, "how to add a list of names with None as default value to function `_init` to repalce its kwargs param")
                fdb_.docsrc(12, "how to make a class.`__init__` signature to be the signature of the class using `__signature__` and `_rm_self`")
                
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m0[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                    def _funcs_kwargs(cls, as_method):======================================================================================================================(0)
                    [91;1mhow does _funcs_kwargs work: _funcs_kwargs is a decorator; it helps class e.g., T to add more methods; I need to give the method a name, and put the name e.g., 'b' inside a list called _methods=['b'] inside class T; then after writing a func e.g., _new_func, I can add it by T(b = _new_func); if I want the func added to class to use self, I shall write @funcs_kwargs(as_method=True)[0m
                        old_init = cls.__init__                                                                                                                             (1)
                        def _init(self, *args, **kwargs):                                                                                                                   (2)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m2[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                    def _funcs_kwargs(cls, as_method):                                                                                                                      (0)
                        old_init = cls.__init__                                                                                                                             (1)
                        def _init(self, *args, **kwargs):===================================================================================================================(2)
                                                                                                              [91;1mhow to define a method which can use self and accept any parameters[0m
                            for k in cls._methods:                                                                                                                          (3)
                                arg = kwargs.pop(k,None)                                                                                                                    (4)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m3[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                        old_init = cls.__init__                                                                                                                             (1)
                        def _init(self, *args, **kwargs):                                                                                                                   (2)
                            for k in cls._methods:==========================================================================================================================(3)
                                                  [91;1mhow to pop out the value of an item in a dict (with None as default), and if the item name is not found, pop out None instead; [0m
                                arg = kwargs.pop(k,None)                                                                                                                    (4)
                                if arg is not None:                                                                                                                         (5)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m6[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                                arg = kwargs.pop(k,None)                                                                                                                    (4)
                                if arg is not None:                                                                                                                         (5)
                                    if as_method: arg = method(arg)=========================================================================================================(6)
                                                                                                                                                 [91;1mhow to turn a func into a method[0m
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)                                                                     (7)
                                    setattr(self, k, arg)                                                                                                                   (8)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m7[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                                if arg is not None:                                                                                                                         (5)
                                    if as_method: arg = method(arg)                                                                                                         (6)
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)=====================================================================(7)
                                                                                                                             [91;1mhow to give a method a different instance, like self[0m
                                    setattr(self, k, arg)                                                                                                                   (8)
                            old_init(self, *args, **kwargs)                                                                                                                 (9)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m8[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                                    if as_method: arg = method(arg)                                                                                                         (6)
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)                                                                     (7)
                                    setattr(self, k, arg)===================================================================================================================(8)
                                                                                                                                   [91;1mhow to add a method to a class as an attribute[0m
                            old_init(self, *args, **kwargs)                                                                                                                 (9)
                        functools.update_wrapper(_init, old_init)                                                                                                           (10)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m10[0m     ===============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                                    setattr(self, k, arg)                                                                                                                   (8)
                            old_init(self, *args, **kwargs)                                                                                                                 (9)
                        functools.update_wrapper(_init, old_init)===========================================================================================================(10)
                                                                                          [91;1mhow to wrap `_init` around `old_init`, so that `_init` can use `old_init` inside itself[0m
                        cls.__init__ = use_kwargs(cls._methods)(_init)                                                                                                      (11)
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))                                                     (12)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m11[0m     ===============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                            old_init(self, *args, **kwargs)                                                                                                                 (9)
                        functools.update_wrapper(_init, old_init)                                                                                                           (10)
                        cls.__init__ = use_kwargs(cls._methods)(_init)======================================================================================================(11)
                                                                            [91;1mhow to add a list of names with None as default value to function `_init` to repalce its kwargs param[0m
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))                                                     (12)
                        return cls                                                                                                                                          (13)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m12[0m     ===============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                        functools.update_wrapper(_init, old_init)                                                                                                           (10)
                        cls.__init__ = use_kwargs(cls._methods)(_init)                                                                                                      (11)
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))=====================================================(12)
                                                                   [91;1mhow to make a class.`__init__` signature to be the signature of the class using `__signature__` and `_rm_self`[0m
                        return cls                                                                                                                                          (13)
                                                                                                                                                                            (14)
                
                
                
                ```
                #| column: screen
                fdb.snoop() # how to snoop together with docsrc: snoop first and docsrc above it
                ```
                
                    22:28:59.99 >>> Call to funcs_kwargs in File "/tmp/funcs_kwargs.py", line 3
                    22:28:59.99 ...... as_method = <class 'fastcore.meta.T'>
                    22:28:59.99    3 | def funcs_kwargs(as_method=False):
                    22:28:59.99    5 |     if callable(as_method): return _funcs_kwargs(as_method, False)
                        22:28:59.99 >>> Call to _funcs_kwargs in File "/tmp/_funcs_kwargs.py", line 3
                        22:28:59.99 ...... cls = <class 'fastcore.meta.T'>
                        22:28:59.99 ...... as_method = False
                        22:28:59.99    3 | def _funcs_kwargs(cls, as_method):
                        22:28:59.99    4 |     old_init = cls.__init__
                        22:28:59.99 .......... old_init = <function T.__init__>
                        22:28:59.99    5 |     import snoop
                        22:28:59.99 .......... snoop = <class 'snoop.configuration.Config.__init__.<locals>.ConfiguredTracer'>
                        22:28:59.99    6 |     @snoop
                        22:28:59.99    7 |     def _init(self, *args, **kwargs):
                        22:28:59.99 .......... _init = <function _funcs_kwargs.<locals>._init>
                        22:28:59.99   15 |     functools.update_wrapper(_init, old_init)
                        22:28:59.99 .......... _init = <function T.__init__>
                        22:28:59.99   16 |     cls.__init__ = use_kwargs(cls._methods)(_init)
                        22:28:59.99   17 |     if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))
                        22:28:59.99   18 |     return cls
                        22:28:59.99 <<< Return value from _funcs_kwargs: <class 'fastcore.meta.T'>
                    22:28:59.99    5 |     if callable(as_method): return _funcs_kwargs(as_method, False)
                    22:28:59.99 <<< Return value from funcs_kwargs: <class 'fastcore.meta.T'>
                    22:28:59.99 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:28:59.99 .......... self = <fastcore.meta.T object>
                    22:28:59.99 .......... args = ()
                    22:28:59.99 .......... kwargs = {}
                    22:28:59.99 .......... as_method = False
                    22:28:59.99 .......... cls = <class 'fastcore.meta.T'>
                    22:28:59.99 .......... old_init = <function T.__init__>
                    22:28:59.99    7 |     def _init(self, *args, **kwargs):
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00 .............. k = 'b'
                    22:29:00.00    9 |             arg = kwargs.pop(k,None)
                    22:29:00.00 .................. arg = None
                    22:29:00.00   10 |             if arg is not None:
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00   14 |         old_init(self, *args, **kwargs)
                    22:29:00.00 <<< Return value from _funcs_kwargs.<locals>._init: None
                    22:29:00.00 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:29:00.00 .......... self = <fastcore.meta.T object>
                    22:29:00.00 .......... args = ()
                    22:29:00.00 .......... kwargs = {'b': <function _new_func>}
                    22:29:00.00 .......... len(kwargs) = 1
                    22:29:00.00 .......... as_method = False
                    22:29:00.00 .......... cls = <class 'fastcore.meta.T'>
                    22:29:00.00 .......... old_init = <function T.__init__>
                    22:29:00.00    7 |     def _init(self, *args, **kwargs):
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00 .............. k = 'b'
                    22:29:00.00    9 |             arg = kwargs.pop(k,None)
                    22:29:00.00 .................. kwargs = {}
                    22:29:00.00 .................. arg = <function _new_func>
                    22:29:00.00   10 |             if arg is not None:
                    22:29:00.00   11 |                 if as_method: arg = method(arg)
                    22:29:00.00   12 |                 if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)
                    22:29:00.00   13 |                 setattr(self, k, arg)
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00   14 |         old_init(self, *args, **kwargs)
                    22:29:00.00 <<< Return value from _funcs_kwargs.<locals>._init: None
                    22:29:00.00 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:29:00.00 .......... self = <fastcore.meta.T object>
                    22:29:00.00 .......... args = ()
                    22:29:00.00 .......... kwargs = {'a': <function <lambda>>}
                    22:29:00.00 .......... len(kwargs) = 1
                    22:29:00.00 .......... as_method = False
                    22:29:00.00 .......... cls = <class 'fastcore.meta.T'>
                    22:29:00.00 .......... old_init = <function T.__init__>
                    22:29:00.00    7 |     def _init(self, *args, **kwargs):
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00 .............. k = 'b'
                    22:29:00.00    9 |             arg = kwargs.pop(k,None)
                    22:29:00.00 .................. arg = None
                    22:29:00.00   10 |             if arg is not None:
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00   14 |         old_init(self, *args, **kwargs)
                    22:29:00.00 <<< Return value from _funcs_kwargs.<locals>._init: None
                    22:29:00.00 >>> Call to funcs_kwargs in File "/tmp/funcs_kwargs.py", line 3
                    22:29:00.00 ...... as_method = True
                    22:29:00.00    3 | def funcs_kwargs(as_method=False):
                    22:29:00.00    5 |     if callable(as_method): return _funcs_kwargs(as_method, False)
                    22:29:00.00    6 |     return partial(_funcs_kwargs, as_method=as_method)
                    22:29:00.00 <<< Return value from funcs_kwargs: functools.partial(<function _funcs_kwargs>, as_method=True)
                    22:29:00.00 >>> Call to _funcs_kwargs in File "/tmp/_funcs_kwargs.py", line 3
                    22:29:00.00 ...... cls = <class 'fastcore.meta.T'>
                    22:29:00.00 ...... as_method = True
                    22:29:00.00    3 | def _funcs_kwargs(cls, as_method):
                    22:29:00.00    4 |     old_init = cls.__init__
                    22:29:00.00 .......... old_init = <slot wrapper '__init__' of 'object' objects>
                    22:29:00.00    5 |     import snoop
                    22:29:00.00 .......... snoop = <class 'snoop.configuration.Config.__init__.<locals>.ConfiguredTracer'>
                    22:29:00.00    6 |     @snoop
                    22:29:00.00    7 |     def _init(self, *args, **kwargs):
                    22:29:00.00 .......... _init = <function _funcs_kwargs.<locals>._init>
                    22:29:00.00   15 |     functools.update_wrapper(_init, old_init)
                    22:29:00.00 .......... _init = <function object.__init__>
                    22:29:00.00   16 |     cls.__init__ = use_kwargs(cls._methods)(_init)
                    22:29:00.01   17 |     if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))
                    22:29:00.01   18 |     return cls
                    22:29:00.01 <<< Return value from _funcs_kwargs: <class 'fastcore.meta.T'>
                    22:29:00.01 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:29:00.01 .......... self = <fastcore.meta.T object>
                    22:29:00.01 .......... args = ()
                    22:29:00.01 .......... kwargs = {'b': <function _f>}
                    22:29:00.01 .......... len(kwargs) = 1
                    22:29:00.01 .......... as_method = True
                    22:29:00.01 .......... cls = <class 'fastcore.meta.T'>
                    22:29:00.01 .......... old_init = <slot wrapper '__init__' of 'object' objects>
                    22:29:00.01    7 |     def _init(self, *args, **kwargs):
                    22:29:00.01    8 |         for k in cls._methods:
                    22:29:00.01 .............. k = 'b'
                    22:29:00.01    9 |             arg = kwargs.pop(k,None)
                    22:29:00.01 .................. kwargs = {}
                    22:29:00.01 .................. arg = <function _f>
                    22:29:00.01   10 |             if arg is not None:
                    22:29:00.01   11 |                 if as_method: arg = method(arg)
                    22:29:00.01 ...... arg = <bound method int._f of 1>
                    22:29:00.01   12 |                 if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)
                    22:29:00.01 ...... arg = <bound method T._f of <fastcore.meta.T object>>
                    22:29:00.01   13 |                 setattr(self, k, arg)
                    22:29:00.01    8 |         for k in cls._methods:
                    22:29:00.01   14 |         old_init(self, *args, **kwargs)
                    22:29:00.01 <<< Return value from _funcs_kwargs.<locals>._init: None
                    22:29:00.01 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:29:00.01 .......... self = <fastcore.meta.T2 object>
                    22:29:00.01 .......... args = ()
                    22:29:00.01 .......... kwargs = {'b': <function _f>}
                    22:29:00.01 .......... len(kwargs) = 1
                    22:29:00.01 .......... as_method = True
                    22:29:00.01 .......... cls = <class 'fastcore.meta.T'>
                    22:29:00.01 .......... old_init = <slot wrapper '__init__' of 'object' objects>
                    22:29:00.01    7 |     def _init(self, *args, **kwargs):
                    22:29:00.01    8 |         for k in cls._methods:
                    22:29:00.01 .............. k = 'b'
                    22:29:00.01    9 |             arg = kwargs.pop(k,None)
                    22:29:00.01 .................. kwargs = {}
                    22:29:00.01 .................. arg = <function _f>
                    22:29:00.01   10 |             if arg is not None:
                    22:29:00.01   11 |                 if as_method: arg = method(arg)
                    22:29:00.01 ...... arg = <bound method int._f of 1>
                    22:29:00.01   12 |                 if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)
                    22:29:00.01 ...... arg = <bound method T2._f of <fastcore.meta.T2 object>>
                    22:29:00.01   13 |                 setattr(self, k, arg)
                    22:29:00.01    8 |         for k in cls._methods:
                    22:29:00.01   14 |         old_init(self, *args, **kwargs)
                    22:29:00.01 <<< Return value from _funcs_kwargs.<locals>._init: None
                
                
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                
                
                
                ```
                fdb_.debug()
                ```
                
                    _funcs_kwargs's dbsrc code: ==============
                    import snoop
                    @snoop
                    def _funcs_kwargs(cls, as_method):
                        old_init = cls.__init__
                        import snoop
                        @snoop
                        def _init(self, *args, **kwargs):
                            for k in cls._methods:
                                arg = kwargs.pop(k,None)
                                if arg is not None:
                                    if as_method: arg = method(arg)
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)
                                    setattr(self, k, arg)
                            old_init(self, *args, **kwargs)
                        functools.update_wrapper(_init, old_init)
                        cls.__init__ = use_kwargs(cls._methods)(_init)
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))
                        return cls
                    
                    
                    
                    _funcs_kwargs's example processed with dbsrc: ===============
                    
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    
                
                
                
                ```
                #| column: screen
                fdb.print()
                ```
                
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    def funcs_kwargs(as_method=False):========================================================(0)       
                        "Replace methods in `cls._methods` with those from `kwargs`"==========================(1) # [93;1mhow funcs_kwargs works[0m; [93;1mit is a wrapper around _funcs_kwargs[0m; [91;1mit offers two ways of running _funcs_kwargs[0m; [37;1mthe first, default way, is to add a func to a class without using self[0m; [91;1msecond way is to add func to class enabling self use;[0m; 
                        if callable(as_method): return _funcs_kwargs(as_method, False)========================(2) # [37;1mhow to check whether an object is callable[0m; [93;1mhow to return a result of running a func[0m; [37;1m[0m; 
                        return partial(_funcs_kwargs, as_method=as_method)====================================(3) # [92;1mhow to custom the params of `_funcs_kwargs` for a particular use with partial[0m; 
                                                                                                                                                                            (4)
                
                
                
                ```
                #| column: screen
                fdb_.print()
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m12[0m     ===============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    def _funcs_kwargs(cls, as_method):========================================================(0) # [93;1mhow does _funcs_kwargs work: _funcs_kwargs is a decorator[0m; [35;1mit helps class e.g., T to add more methods[0m; [93;1mI need to give the method a name, and put the name e.g., 'b' inside a list called _methods=['b'] inside class T[0m; [36;1mthen after writing a func e.g., _new_func, I can add it by T(b = _new_func)[0m; [36;1mif I want the func added to class to use self, I shall write @funcs_kwargs(as_method=True)[0m; 
                        old_init = cls.__init__===============================================================(1)       
                        def _init(self, *args, **kwargs):=====================================================(2) # [37;1mhow to define a method which can use self and accept any parameters[0m; 
                            for k in cls._methods:============================================================(3) # [35;1mhow to pop out the value of an item in a dict (with None as default), and if the item name is not found, pop out None instead[0m; [91;1m[0m; 
                                arg = kwargs.pop(k,None)======================================================(4)       
                                if arg is not None:===========================================================(5)       
                                    if as_method: arg = method(arg)===========================================(6) # [36;1mhow to turn a func into a method[0m; 
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)=======(7) # [93;1mhow to give a method a different instance, like self[0m; 
                                    setattr(self, k, arg)=====================================================(8) # [36;1mhow to add a method to a class as an attribute[0m; 
                            old_init(self, *args, **kwargs)===================================================(9)       
                        functools.update_wrapper(_init, old_init)=============================================(10) # [34;1mhow to wrap `_init` around `old_init`, so that `_init` can use `old_init` inside itself[0m; 
                        cls.__init__ = use_kwargs(cls._methods)(_init)========================================(11) # [34;1mhow to add a list of names with None as default value to function `_init` to repalce its kwargs param[0m; 
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__)) # [35;1mhow to make a class.`__init__` signature to be the signature of the class using `__signature__` and `_rm_self`[0m;  (12)
                        return cls============================================================================(13)      
                                                                                                                                                                            (14)
                
                
                
                ```
                
                ```
                
                
            
            
            
            [Open `0009_funcs_kwargs` in Jupyter Notebook](http://localhost:8888/tree/nbs/demos/0009_funcs_kwargs.ipynb)
            
            
            
        
        
        
        [Open `utils` in Jupyter Notebook](http://localhost:8888/tree/nbs/lib/utils.ipynb)
        
        
        
        
    
    
    
    [Open `utils` in Jupyter Notebook](http://localhost:8888/tree/nbs/lib/utils.ipynb)
    
    
    
    



[Open `utils` in Jupyter Notebook locally](http://localhost:8888/tree/nbs/lib/utils.ipynb)



###  <mark style="background-color: #ffff00">snoop:</mark>   <mark style="background-color: #ffff00">from</mark>   <mark style="background-color: #ffff00">_ <mark style="background-color: #FFFF00">funcs_kwargs</mark> </mark>   <mark style="background-color: #ffff00">to</mark>   <mark style="background-color: #FFFF00">funcs_kwargs</mark> 



    
    
    
        
        
        
            
            
            
                
                how to snoop on two functions one wrap around another: `funcs_kwargs` is a wrapper around `_funcs_kwargs`, so I can first snoop on `_funcs_kwargs` and assign its snoop dbsrc to \
                `fm._funcs_kwargs` so that when I snoop on `funcs_kwargs`, it can use the snoop dbsrc of `_funcs_kwargs` and no example codes need to change.
                
                
                ```
                from fastcore.meta import _funcs_kwargs
                ```
                
                
                ```
                fdb_ = Fastdb(_funcs_kwargs)
                fdb_.eg = """
                @funcs_kwargs
                class T:
                    _methods=['b'] # allows you to add method b upon instantiation
                    def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                    def a(self): return 1
                    def b(self): return 2
                    
                t = T()
                test_eq(t.a(), 1)
                test_eq(t.b(), 2)
                
                test_sig(T, '(f=1, *, b=None)')
                inspect.signature(T)
                
                def _new_func(): return 5
                
                t = T(b = _new_func)
                test_eq(t.b(), 5)
                
                t = T(a = lambda:3)
                test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                """
                ```
                
                
                ```
                #| column: screen
                # no snoop result, it is expected, because the example is not calling _funcs_kwargs, but funcs_kwargs
                fdb_.snoop(deco=True) # how to snoop decorator: _funcs_kwargs is a decorator, so set deco=True to see running codes in inner f
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    [0m     
                    
                
                
                
                ```
                import fastcore.meta as fm
                ```
                
                
                ```
                fm._funcs_kwargs = fdb_.dbsrc # how to snoop on two functions one wrap around another
                ```
                
                
                ```
                fdb = Fastdb(funcs_kwargs)
                fdb.eg = """
                @funcs_kwargs
                class T:
                    _methods=['b'] # allows you to add method b upon instantiation
                    def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                    def a(self): return 1
                    def b(self): return 2
                    
                t = T()
                test_eq(t.a(), 1)
                test_eq(t.b(), 2)
                
                test_sig(T, '(f=1, *, b=None)')
                inspect.signature(T)
                
                def _new_func(): return 5
                
                t = T(b = _new_func)
                test_eq(t.b(), 5)
                
                t = T(a = lambda:3)
                test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                
                def _f(self,a=1): return self.num + a # access the num attribute from the instance
                
                @funcs_kwargs(as_method=True)
                class T: 
                    _methods=['b']
                    num = 5
                    
                t = T(b = _f) # adds method b
                test_eq(t.b(5), 10) # self.num + 5 = 10
                
                def _f(self,a=1): return self.num * a #multiply instead of add 
                
                class T2(T):
                    def __init__(self,num):
                        super().__init__(b = _f) # add method b from the super class
                        self.num=num
                        
                t = T2(num=3)
                test_eq(t.b(a=5), 15) # 3 * 5 = 15
                test_sig(T2, '(num)')
                """
                ```
                
                
                ```
                #| column: screen
                fdb.print()
                ```
                
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    def funcs_kwargs(as_method=False):========================================================(0)       
                        "Replace methods in `cls._methods` with those from `kwargs`"==========================(1)       
                        if callable(as_method): return _funcs_kwargs(as_method, False)========================(2)       
                        return partial(_funcs_kwargs, as_method=as_method)====================================(3)       
                                                                                                                                                                            (4)
                
                
                
                ```
                #| column: screen
                fdb_.print()
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    def _funcs_kwargs(cls, as_method):========================================================(0)       
                        old_init = cls.__init__===============================================================(1)       
                        def _init(self, *args, **kwargs):=====================================================(2)       
                            for k in cls._methods:============================================================(3)       
                                arg = kwargs.pop(k,None)======================================================(4)       
                                if arg is not None:===========================================================(5)       
                                    if as_method: arg = method(arg)===========================================(6)       
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)=======(7)       
                                    setattr(self, k, arg)=====================================================(8)       
                            old_init(self, *args, **kwargs)===================================================(9)       
                        functools.update_wrapper(_init, old_init)=============================================(10)      
                        cls.__init__ = use_kwargs(cls._methods)(_init)========================================(11)      
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))                                                     (12)
                        return cls============================================================================(13)      
                                                                                                                                                                            (14)
                
                
                
                ```
                #| column: screen
                fdb.docsrc(1, "how funcs_kwargs works; it is a wrapper around _funcs_kwargs; it offers two ways of running _funcs_kwargs; \
                the first, default way, is to add a func to a class without using self; second way is to add func to class enabling self use;")
                fdb.docsrc(2, "how to check whether an object is callable; how to return a result of running a func; ")
                fdb.docsrc(3, "how to custom the params of `_funcs_kwargs` for a particular use with partial")
                ```
                
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m1[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                    def funcs_kwargs(as_method=False):                                                                                                                      (0)
                        "Replace methods in `cls._methods` with those from `kwargs`"========================================================================================(1)
                    [91;1mhow funcs_kwargs works; it is a wrapper around _funcs_kwargs; it offers two ways of running _funcs_kwargs; the first, default way, is to add a func to a class without using self; second way is to add func to class enabling self use;[0m
                        if callable(as_method): return _funcs_kwargs(as_method, False)                                                                                      (2)
                        return partial(_funcs_kwargs, as_method=as_method)                                                                                                  (3)
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m2[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                    def funcs_kwargs(as_method=False):                                                                                                                      (0)
                        "Replace methods in `cls._methods` with those from `kwargs`"                                                                                        (1)
                        if callable(as_method): return _funcs_kwargs(as_method, False)======================================================================================(2)
                                                                                           [91;1mhow to check whether an object is callable; how to return a result of running a func; [0m
                        return partial(_funcs_kwargs, as_method=as_method)                                                                                                  (3)
                                                                                                                                                                            (4)
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m3[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                        "Replace methods in `cls._methods` with those from `kwargs`"                                                                                        (1)
                        if callable(as_method): return _funcs_kwargs(as_method, False)                                                                                      (2)
                        return partial(_funcs_kwargs, as_method=as_method)==================================================================================================(3)
                                                                                                    [91;1mhow to custom the params of `_funcs_kwargs` for a particular use with partial[0m
                                                                                                                                                                            (4)
                
                
                
                ```
                #| column: screen
                fdb_.print()
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    def _funcs_kwargs(cls, as_method):========================================================(0)       
                        old_init = cls.__init__===============================================================(1)       
                        def _init(self, *args, **kwargs):=====================================================(2)       
                            for k in cls._methods:============================================================(3)       
                                arg = kwargs.pop(k,None)======================================================(4)       
                                if arg is not None:===========================================================(5)       
                                    if as_method: arg = method(arg)===========================================(6)       
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)=======(7)       
                                    setattr(self, k, arg)=====================================================(8)       
                            old_init(self, *args, **kwargs)===================================================(9)       
                        functools.update_wrapper(_init, old_init)=============================================(10)      
                        cls.__init__ = use_kwargs(cls._methods)(_init)========================================(11)      
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))                                                     (12)
                        return cls============================================================================(13)      
                                                                                                                                                                            (14)
                
                
                
                ```
                #| column: screen
                fdb_.docsrc(0, "how does _funcs_kwargs work: _funcs_kwargs is a decorator; it helps class e.g., T to add more methods; \
                I need to give the method a name, \
                and put the name e.g., 'b' inside a list called _methods=['b'] inside class T; \
                then after writing a func e.g., _new_func, I can add it by T(b = _new_func); if I want the func added to class to use self, \
                I shall write @funcs_kwargs(as_method=True)")
                fdb_.docsrc(2, "how to define a method which can use self and accept any parameters")
                fdb_.docsrc(3, "how to pop out the value of an item in a dict (with None as default), and if the item name is not found, pop out None instead; ")
                fdb_.docsrc(6, "how to turn a func into a method")
                fdb_.docsrc(7, "how to give a method a different instance, like self")
                fdb_.docsrc(8, "how to add a method to a class as an attribute")
                fdb_.docsrc(10, "how to wrap `_init` around `old_init`, so that `_init` can use `old_init` inside itself")
                fdb_.docsrc(11, "how to add a list of names with None as default value to function `_init` to repalce its kwargs param")
                fdb_.docsrc(12, "how to make a class.`__init__` signature to be the signature of the class using `__signature__` and `_rm_self`")
                
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m0[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                    def _funcs_kwargs(cls, as_method):======================================================================================================================(0)
                    [91;1mhow does _funcs_kwargs work: _funcs_kwargs is a decorator; it helps class e.g., T to add more methods; I need to give the method a name, and put the name e.g., 'b' inside a list called _methods=['b'] inside class T; then after writing a func e.g., _new_func, I can add it by T(b = _new_func); if I want the func added to class to use self, I shall write @funcs_kwargs(as_method=True)[0m
                        old_init = cls.__init__                                                                                                                             (1)
                        def _init(self, *args, **kwargs):                                                                                                                   (2)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m2[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                    def _funcs_kwargs(cls, as_method):                                                                                                                      (0)
                        old_init = cls.__init__                                                                                                                             (1)
                        def _init(self, *args, **kwargs):===================================================================================================================(2)
                                                                                                              [91;1mhow to define a method which can use self and accept any parameters[0m
                            for k in cls._methods:                                                                                                                          (3)
                                arg = kwargs.pop(k,None)                                                                                                                    (4)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m3[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                        old_init = cls.__init__                                                                                                                             (1)
                        def _init(self, *args, **kwargs):                                                                                                                   (2)
                            for k in cls._methods:==========================================================================================================================(3)
                                                  [91;1mhow to pop out the value of an item in a dict (with None as default), and if the item name is not found, pop out None instead; [0m
                                arg = kwargs.pop(k,None)                                                                                                                    (4)
                                if arg is not None:                                                                                                                         (5)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m6[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                                arg = kwargs.pop(k,None)                                                                                                                    (4)
                                if arg is not None:                                                                                                                         (5)
                                    if as_method: arg = method(arg)=========================================================================================================(6)
                                                                                                                                                 [91;1mhow to turn a func into a method[0m
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)                                                                     (7)
                                    setattr(self, k, arg)                                                                                                                   (8)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m7[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                                if arg is not None:                                                                                                                         (5)
                                    if as_method: arg = method(arg)                                                                                                         (6)
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)=====================================================================(7)
                                                                                                                             [91;1mhow to give a method a different instance, like self[0m
                                    setattr(self, k, arg)                                                                                                                   (8)
                            old_init(self, *args, **kwargs)                                                                                                                 (9)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m8[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                                    if as_method: arg = method(arg)                                                                                                         (6)
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)                                                                     (7)
                                    setattr(self, k, arg)===================================================================================================================(8)
                                                                                                                                   [91;1mhow to add a method to a class as an attribute[0m
                            old_init(self, *args, **kwargs)                                                                                                                 (9)
                        functools.update_wrapper(_init, old_init)                                                                                                           (10)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m10[0m     ===============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                                    setattr(self, k, arg)                                                                                                                   (8)
                            old_init(self, *args, **kwargs)                                                                                                                 (9)
                        functools.update_wrapper(_init, old_init)===========================================================================================================(10)
                                                                                          [91;1mhow to wrap `_init` around `old_init`, so that `_init` can use `old_init` inside itself[0m
                        cls.__init__ = use_kwargs(cls._methods)(_init)                                                                                                      (11)
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))                                                     (12)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m11[0m     ===============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                            old_init(self, *args, **kwargs)                                                                                                                 (9)
                        functools.update_wrapper(_init, old_init)                                                                                                           (10)
                        cls.__init__ = use_kwargs(cls._methods)(_init)======================================================================================================(11)
                                                                            [91;1mhow to add a list of names with None as default value to function `_init` to repalce its kwargs param[0m
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))                                                     (12)
                        return cls                                                                                                                                          (13)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m12[0m     ===============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                        functools.update_wrapper(_init, old_init)                                                                                                           (10)
                        cls.__init__ = use_kwargs(cls._methods)(_init)                                                                                                      (11)
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))=====================================================(12)
                                                                   [91;1mhow to make a class.`__init__` signature to be the signature of the class using `__signature__` and `_rm_self`[0m
                        return cls                                                                                                                                          (13)
                                                                                                                                                                            (14)
                
                
                
                ```
                #| column: screen
                fdb.snoop() # how to snoop together with docsrc: snoop first and docsrc above it
                ```
                
                    22:28:59.99 >>> Call to funcs_kwargs in File "/tmp/funcs_kwargs.py", line 3
                    22:28:59.99 ...... as_method = <class 'fastcore.meta.T'>
                    22:28:59.99    3 | def funcs_kwargs(as_method=False):
                    22:28:59.99    5 |     if callable(as_method): return _funcs_kwargs(as_method, False)
                        22:28:59.99 >>> Call to _funcs_kwargs in File "/tmp/_funcs_kwargs.py", line 3
                        22:28:59.99 ...... cls = <class 'fastcore.meta.T'>
                        22:28:59.99 ...... as_method = False
                        22:28:59.99    3 | def _funcs_kwargs(cls, as_method):
                        22:28:59.99    4 |     old_init = cls.__init__
                        22:28:59.99 .......... old_init = <function T.__init__>
                        22:28:59.99    5 |     import snoop
                        22:28:59.99 .......... snoop = <class 'snoop.configuration.Config.__init__.<locals>.ConfiguredTracer'>
                        22:28:59.99    6 |     @snoop
                        22:28:59.99    7 |     def _init(self, *args, **kwargs):
                        22:28:59.99 .......... _init = <function _funcs_kwargs.<locals>._init>
                        22:28:59.99   15 |     functools.update_wrapper(_init, old_init)
                        22:28:59.99 .......... _init = <function T.__init__>
                        22:28:59.99   16 |     cls.__init__ = use_kwargs(cls._methods)(_init)
                        22:28:59.99   17 |     if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))
                        22:28:59.99   18 |     return cls
                        22:28:59.99 <<< Return value from _funcs_kwargs: <class 'fastcore.meta.T'>
                    22:28:59.99    5 |     if callable(as_method): return _funcs_kwargs(as_method, False)
                    22:28:59.99 <<< Return value from funcs_kwargs: <class 'fastcore.meta.T'>
                    22:28:59.99 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:28:59.99 .......... self = <fastcore.meta.T object>
                    22:28:59.99 .......... args = ()
                    22:28:59.99 .......... kwargs = {}
                    22:28:59.99 .......... as_method = False
                    22:28:59.99 .......... cls = <class 'fastcore.meta.T'>
                    22:28:59.99 .......... old_init = <function T.__init__>
                    22:28:59.99    7 |     def _init(self, *args, **kwargs):
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00 .............. k = 'b'
                    22:29:00.00    9 |             arg = kwargs.pop(k,None)
                    22:29:00.00 .................. arg = None
                    22:29:00.00   10 |             if arg is not None:
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00   14 |         old_init(self, *args, **kwargs)
                    22:29:00.00 <<< Return value from _funcs_kwargs.<locals>._init: None
                    22:29:00.00 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:29:00.00 .......... self = <fastcore.meta.T object>
                    22:29:00.00 .......... args = ()
                    22:29:00.00 .......... kwargs = {'b': <function _new_func>}
                    22:29:00.00 .......... len(kwargs) = 1
                    22:29:00.00 .......... as_method = False
                    22:29:00.00 .......... cls = <class 'fastcore.meta.T'>
                    22:29:00.00 .......... old_init = <function T.__init__>
                    22:29:00.00    7 |     def _init(self, *args, **kwargs):
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00 .............. k = 'b'
                    22:29:00.00    9 |             arg = kwargs.pop(k,None)
                    22:29:00.00 .................. kwargs = {}
                    22:29:00.00 .................. arg = <function _new_func>
                    22:29:00.00   10 |             if arg is not None:
                    22:29:00.00   11 |                 if as_method: arg = method(arg)
                    22:29:00.00   12 |                 if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)
                    22:29:00.00   13 |                 setattr(self, k, arg)
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00   14 |         old_init(self, *args, **kwargs)
                    22:29:00.00 <<< Return value from _funcs_kwargs.<locals>._init: None
                    22:29:00.00 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:29:00.00 .......... self = <fastcore.meta.T object>
                    22:29:00.00 .......... args = ()
                    22:29:00.00 .......... kwargs = {'a': <function <lambda>>}
                    22:29:00.00 .......... len(kwargs) = 1
                    22:29:00.00 .......... as_method = False
                    22:29:00.00 .......... cls = <class 'fastcore.meta.T'>
                    22:29:00.00 .......... old_init = <function T.__init__>
                    22:29:00.00    7 |     def _init(self, *args, **kwargs):
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00 .............. k = 'b'
                    22:29:00.00    9 |             arg = kwargs.pop(k,None)
                    22:29:00.00 .................. arg = None
                    22:29:00.00   10 |             if arg is not None:
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00   14 |         old_init(self, *args, **kwargs)
                    22:29:00.00 <<< Return value from _funcs_kwargs.<locals>._init: None
                    22:29:00.00 >>> Call to funcs_kwargs in File "/tmp/funcs_kwargs.py", line 3
                    22:29:00.00 ...... as_method = True
                    22:29:00.00    3 | def funcs_kwargs(as_method=False):
                    22:29:00.00    5 |     if callable(as_method): return _funcs_kwargs(as_method, False)
                    22:29:00.00    6 |     return partial(_funcs_kwargs, as_method=as_method)
                    22:29:00.00 <<< Return value from funcs_kwargs: functools.partial(<function _funcs_kwargs>, as_method=True)
                    22:29:00.00 >>> Call to _funcs_kwargs in File "/tmp/_funcs_kwargs.py", line 3
                    22:29:00.00 ...... cls = <class 'fastcore.meta.T'>
                    22:29:00.00 ...... as_method = True
                    22:29:00.00    3 | def _funcs_kwargs(cls, as_method):
                    22:29:00.00    4 |     old_init = cls.__init__
                    22:29:00.00 .......... old_init = <slot wrapper '__init__' of 'object' objects>
                    22:29:00.00    5 |     import snoop
                    22:29:00.00 .......... snoop = <class 'snoop.configuration.Config.__init__.<locals>.ConfiguredTracer'>
                    22:29:00.00    6 |     @snoop
                    22:29:00.00    7 |     def _init(self, *args, **kwargs):
                    22:29:00.00 .......... _init = <function _funcs_kwargs.<locals>._init>
                    22:29:00.00   15 |     functools.update_wrapper(_init, old_init)
                    22:29:00.00 .......... _init = <function object.__init__>
                    22:29:00.00   16 |     cls.__init__ = use_kwargs(cls._methods)(_init)
                    22:29:00.01   17 |     if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))
                    22:29:00.01   18 |     return cls
                    22:29:00.01 <<< Return value from _funcs_kwargs: <class 'fastcore.meta.T'>
                    22:29:00.01 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:29:00.01 .......... self = <fastcore.meta.T object>
                    22:29:00.01 .......... args = ()
                    22:29:00.01 .......... kwargs = {'b': <function _f>}
                    22:29:00.01 .......... len(kwargs) = 1
                    22:29:00.01 .......... as_method = True
                    22:29:00.01 .......... cls = <class 'fastcore.meta.T'>
                    22:29:00.01 .......... old_init = <slot wrapper '__init__' of 'object' objects>
                    22:29:00.01    7 |     def _init(self, *args, **kwargs):
                    22:29:00.01    8 |         for k in cls._methods:
                    22:29:00.01 .............. k = 'b'
                    22:29:00.01    9 |             arg = kwargs.pop(k,None)
                    22:29:00.01 .................. kwargs = {}
                    22:29:00.01 .................. arg = <function _f>
                    22:29:00.01   10 |             if arg is not None:
                    22:29:00.01   11 |                 if as_method: arg = method(arg)
                    22:29:00.01 ...... arg = <bound method int._f of 1>
                    22:29:00.01   12 |                 if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)
                    22:29:00.01 ...... arg = <bound method T._f of <fastcore.meta.T object>>
                    22:29:00.01   13 |                 setattr(self, k, arg)
                    22:29:00.01    8 |         for k in cls._methods:
                    22:29:00.01   14 |         old_init(self, *args, **kwargs)
                    22:29:00.01 <<< Return value from _funcs_kwargs.<locals>._init: None
                    22:29:00.01 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:29:00.01 .......... self = <fastcore.meta.T2 object>
                    22:29:00.01 .......... args = ()
                    22:29:00.01 .......... kwargs = {'b': <function _f>}
                    22:29:00.01 .......... len(kwargs) = 1
                    22:29:00.01 .......... as_method = True
                    22:29:00.01 .......... cls = <class 'fastcore.meta.T'>
                    22:29:00.01 .......... old_init = <slot wrapper '__init__' of 'object' objects>
                    22:29:00.01    7 |     def _init(self, *args, **kwargs):
                    22:29:00.01    8 |         for k in cls._methods:
                    22:29:00.01 .............. k = 'b'
                    22:29:00.01    9 |             arg = kwargs.pop(k,None)
                    22:29:00.01 .................. kwargs = {}
                    22:29:00.01 .................. arg = <function _f>
                    22:29:00.01   10 |             if arg is not None:
                    22:29:00.01   11 |                 if as_method: arg = method(arg)
                    22:29:00.01 ...... arg = <bound method int._f of 1>
                    22:29:00.01   12 |                 if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)
                    22:29:00.01 ...... arg = <bound method T2._f of <fastcore.meta.T2 object>>
                    22:29:00.01   13 |                 setattr(self, k, arg)
                    22:29:00.01    8 |         for k in cls._methods:
                    22:29:00.01   14 |         old_init(self, *args, **kwargs)
                    22:29:00.01 <<< Return value from _funcs_kwargs.<locals>._init: None
                
                
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                
                
                
                ```
                fdb_.debug()
                ```
                
                    _funcs_kwargs's dbsrc code: ==============
                    import snoop
                    @snoop
                    def _funcs_kwargs(cls, as_method):
                        old_init = cls.__init__
                        import snoop
                        @snoop
                        def _init(self, *args, **kwargs):
                            for k in cls._methods:
                                arg = kwargs.pop(k,None)
                                if arg is not None:
                                    if as_method: arg = method(arg)
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)
                                    setattr(self, k, arg)
                            old_init(self, *args, **kwargs)
                        functools.update_wrapper(_init, old_init)
                        cls.__init__ = use_kwargs(cls._methods)(_init)
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))
                        return cls
                    
                    
                    
                    _funcs_kwargs's example processed with dbsrc: ===============
                    
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    
                
                
                
                ```
                #| column: screen
                fdb.print()
                ```
                
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    def funcs_kwargs(as_method=False):========================================================(0)       
                        "Replace methods in `cls._methods` with those from `kwargs`"==========================(1) # [93;1mhow funcs_kwargs works[0m; [93;1mit is a wrapper around _funcs_kwargs[0m; [91;1mit offers two ways of running _funcs_kwargs[0m; [37;1mthe first, default way, is to add a func to a class without using self[0m; [91;1msecond way is to add func to class enabling self use;[0m; 
                        if callable(as_method): return _funcs_kwargs(as_method, False)========================(2) # [37;1mhow to check whether an object is callable[0m; [93;1mhow to return a result of running a func[0m; [37;1m[0m; 
                        return partial(_funcs_kwargs, as_method=as_method)====================================(3) # [92;1mhow to custom the params of `_funcs_kwargs` for a particular use with partial[0m; 
                                                                                                                                                                            (4)
                
                
                
                ```
                #| column: screen
                fdb_.print()
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m12[0m     ===============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    def _funcs_kwargs(cls, as_method):========================================================(0) # [93;1mhow does _funcs_kwargs work: _funcs_kwargs is a decorator[0m; [35;1mit helps class e.g., T to add more methods[0m; [93;1mI need to give the method a name, and put the name e.g., 'b' inside a list called _methods=['b'] inside class T[0m; [36;1mthen after writing a func e.g., _new_func, I can add it by T(b = _new_func)[0m; [36;1mif I want the func added to class to use self, I shall write @funcs_kwargs(as_method=True)[0m; 
                        old_init = cls.__init__===============================================================(1)       
                        def _init(self, *args, **kwargs):=====================================================(2) # [37;1mhow to define a method which can use self and accept any parameters[0m; 
                            for k in cls._methods:============================================================(3) # [35;1mhow to pop out the value of an item in a dict (with None as default), and if the item name is not found, pop out None instead[0m; [91;1m[0m; 
                                arg = kwargs.pop(k,None)======================================================(4)       
                                if arg is not None:===========================================================(5)       
                                    if as_method: arg = method(arg)===========================================(6) # [36;1mhow to turn a func into a method[0m; 
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)=======(7) # [93;1mhow to give a method a different instance, like self[0m; 
                                    setattr(self, k, arg)=====================================================(8) # [36;1mhow to add a method to a class as an attribute[0m; 
                            old_init(self, *args, **kwargs)===================================================(9)       
                        functools.update_wrapper(_init, old_init)=============================================(10) # [34;1mhow to wrap `_init` around `old_init`, so that `_init` can use `old_init` inside itself[0m; 
                        cls.__init__ = use_kwargs(cls._methods)(_init)========================================(11) # [34;1mhow to add a list of names with None as default value to function `_init` to repalce its kwargs param[0m; 
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__)) # [35;1mhow to make a class.`__init__` signature to be the signature of the class using `__signature__` and `_rm_self`[0m;  (12)
                        return cls============================================================================(13)      
                                                                                                                                                                            (14)
                
                
                
                ```
                
                ```
                
                
            
            
            
            [Open `0009_funcs_kwargs` in Jupyter Notebook](http://localhost:8888/tree/nbs/demos/0009_funcs_kwargs.ipynb)
            
            
            
        
        
        
        [Open `utils` in Jupyter Notebook](http://localhost:8888/tree/nbs/lib/utils.ipynb)
        
        
        
        
    
    
    
    [Open `utils` in Jupyter Notebook](http://localhost:8888/tree/nbs/lib/utils.ipynb)
    
    
    
    



[Open `utils` in Jupyter Notebook locally](http://localhost:8888/tree/nbs/lib/utils.ipynb)



###  <mark style="background-color: #ffff00">snoop:</mark>   <mark style="background-color: #ffff00">from</mark>   <mark style="background-color: #ffff00">_ <mark style="background-color: #FFFF00">funcs_kwargs</mark> </mark>   <mark style="background-color: #ffff00">to</mark>   <mark style="background-color: #FFFF00">funcs_kwargs</mark> 



    
    
    
        
        
        
            
            
            
                
                how to snoop on two functions one wrap around another: `funcs_kwargs` is a wrapper around `_funcs_kwargs`, so I can first snoop on `_funcs_kwargs` and assign its snoop dbsrc to \
                `fm._funcs_kwargs` so that when I snoop on `funcs_kwargs`, it can use the snoop dbsrc of `_funcs_kwargs` and no example codes need to change.
                
                
                ```
                from fastcore.meta import _funcs_kwargs
                ```
                
                
                ```
                fdb_ = Fastdb(_funcs_kwargs)
                fdb_.eg = """
                @funcs_kwargs
                class T:
                    _methods=['b'] # allows you to add method b upon instantiation
                    def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                    def a(self): return 1
                    def b(self): return 2
                    
                t = T()
                test_eq(t.a(), 1)
                test_eq(t.b(), 2)
                
                test_sig(T, '(f=1, *, b=None)')
                inspect.signature(T)
                
                def _new_func(): return 5
                
                t = T(b = _new_func)
                test_eq(t.b(), 5)
                
                t = T(a = lambda:3)
                test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                """
                ```
                
                
                ```
                #| column: screen
                # no snoop result, it is expected, because the example is not calling _funcs_kwargs, but funcs_kwargs
                fdb_.snoop(deco=True) # how to snoop decorator: _funcs_kwargs is a decorator, so set deco=True to see running codes in inner f
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    [0m     
                    
                
                
                
                ```
                import fastcore.meta as fm
                ```
                
                
                ```
                fm._funcs_kwargs = fdb_.dbsrc # how to snoop on two functions one wrap around another
                ```
                
                
                ```
                fdb = Fastdb(funcs_kwargs)
                fdb.eg = """
                @funcs_kwargs
                class T:
                    _methods=['b'] # allows you to add method b upon instantiation
                    def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                    def a(self): return 1
                    def b(self): return 2
                    
                t = T()
                test_eq(t.a(), 1)
                test_eq(t.b(), 2)
                
                test_sig(T, '(f=1, *, b=None)')
                inspect.signature(T)
                
                def _new_func(): return 5
                
                t = T(b = _new_func)
                test_eq(t.b(), 5)
                
                t = T(a = lambda:3)
                test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                
                def _f(self,a=1): return self.num + a # access the num attribute from the instance
                
                @funcs_kwargs(as_method=True)
                class T: 
                    _methods=['b']
                    num = 5
                    
                t = T(b = _f) # adds method b
                test_eq(t.b(5), 10) # self.num + 5 = 10
                
                def _f(self,a=1): return self.num * a #multiply instead of add 
                
                class T2(T):
                    def __init__(self,num):
                        super().__init__(b = _f) # add method b from the super class
                        self.num=num
                        
                t = T2(num=3)
                test_eq(t.b(a=5), 15) # 3 * 5 = 15
                test_sig(T2, '(num)')
                """
                ```
                
                
                ```
                #| column: screen
                fdb.print()
                ```
                
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    def funcs_kwargs(as_method=False):========================================================(0)       
                        "Replace methods in `cls._methods` with those from `kwargs`"==========================(1)       
                        if callable(as_method): return _funcs_kwargs(as_method, False)========================(2)       
                        return partial(_funcs_kwargs, as_method=as_method)====================================(3)       
                                                                                                                                                                            (4)
                
                
                
                ```
                #| column: screen
                fdb_.print()
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    def _funcs_kwargs(cls, as_method):========================================================(0)       
                        old_init = cls.__init__===============================================================(1)       
                        def _init(self, *args, **kwargs):=====================================================(2)       
                            for k in cls._methods:============================================================(3)       
                                arg = kwargs.pop(k,None)======================================================(4)       
                                if arg is not None:===========================================================(5)       
                                    if as_method: arg = method(arg)===========================================(6)       
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)=======(7)       
                                    setattr(self, k, arg)=====================================================(8)       
                            old_init(self, *args, **kwargs)===================================================(9)       
                        functools.update_wrapper(_init, old_init)=============================================(10)      
                        cls.__init__ = use_kwargs(cls._methods)(_init)========================================(11)      
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))                                                     (12)
                        return cls============================================================================(13)      
                                                                                                                                                                            (14)
                
                
                
                ```
                #| column: screen
                fdb.docsrc(1, "how funcs_kwargs works; it is a wrapper around _funcs_kwargs; it offers two ways of running _funcs_kwargs; \
                the first, default way, is to add a func to a class without using self; second way is to add func to class enabling self use;")
                fdb.docsrc(2, "how to check whether an object is callable; how to return a result of running a func; ")
                fdb.docsrc(3, "how to custom the params of `_funcs_kwargs` for a particular use with partial")
                ```
                
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m1[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                    def funcs_kwargs(as_method=False):                                                                                                                      (0)
                        "Replace methods in `cls._methods` with those from `kwargs`"========================================================================================(1)
                    [91;1mhow funcs_kwargs works; it is a wrapper around _funcs_kwargs; it offers two ways of running _funcs_kwargs; the first, default way, is to add a func to a class without using self; second way is to add func to class enabling self use;[0m
                        if callable(as_method): return _funcs_kwargs(as_method, False)                                                                                      (2)
                        return partial(_funcs_kwargs, as_method=as_method)                                                                                                  (3)
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m2[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                    def funcs_kwargs(as_method=False):                                                                                                                      (0)
                        "Replace methods in `cls._methods` with those from `kwargs`"                                                                                        (1)
                        if callable(as_method): return _funcs_kwargs(as_method, False)======================================================================================(2)
                                                                                           [91;1mhow to check whether an object is callable; how to return a result of running a func; [0m
                        return partial(_funcs_kwargs, as_method=as_method)                                                                                                  (3)
                                                                                                                                                                            (4)
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m3[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                        "Replace methods in `cls._methods` with those from `kwargs`"                                                                                        (1)
                        if callable(as_method): return _funcs_kwargs(as_method, False)                                                                                      (2)
                        return partial(_funcs_kwargs, as_method=as_method)==================================================================================================(3)
                                                                                                    [91;1mhow to custom the params of `_funcs_kwargs` for a particular use with partial[0m
                                                                                                                                                                            (4)
                
                
                
                ```
                #| column: screen
                fdb_.print()
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    def _funcs_kwargs(cls, as_method):========================================================(0)       
                        old_init = cls.__init__===============================================================(1)       
                        def _init(self, *args, **kwargs):=====================================================(2)       
                            for k in cls._methods:============================================================(3)       
                                arg = kwargs.pop(k,None)======================================================(4)       
                                if arg is not None:===========================================================(5)       
                                    if as_method: arg = method(arg)===========================================(6)       
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)=======(7)       
                                    setattr(self, k, arg)=====================================================(8)       
                            old_init(self, *args, **kwargs)===================================================(9)       
                        functools.update_wrapper(_init, old_init)=============================================(10)      
                        cls.__init__ = use_kwargs(cls._methods)(_init)========================================(11)      
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))                                                     (12)
                        return cls============================================================================(13)      
                                                                                                                                                                            (14)
                
                
                
                ```
                #| column: screen
                fdb_.docsrc(0, "how does _funcs_kwargs work: _funcs_kwargs is a decorator; it helps class e.g., T to add more methods; \
                I need to give the method a name, \
                and put the name e.g., 'b' inside a list called _methods=['b'] inside class T; \
                then after writing a func e.g., _new_func, I can add it by T(b = _new_func); if I want the func added to class to use self, \
                I shall write @funcs_kwargs(as_method=True)")
                fdb_.docsrc(2, "how to define a method which can use self and accept any parameters")
                fdb_.docsrc(3, "how to pop out the value of an item in a dict (with None as default), and if the item name is not found, pop out None instead; ")
                fdb_.docsrc(6, "how to turn a func into a method")
                fdb_.docsrc(7, "how to give a method a different instance, like self")
                fdb_.docsrc(8, "how to add a method to a class as an attribute")
                fdb_.docsrc(10, "how to wrap `_init` around `old_init`, so that `_init` can use `old_init` inside itself")
                fdb_.docsrc(11, "how to add a list of names with None as default value to function `_init` to repalce its kwargs param")
                fdb_.docsrc(12, "how to make a class.`__init__` signature to be the signature of the class using `__signature__` and `_rm_self`")
                
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m0[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                    def _funcs_kwargs(cls, as_method):======================================================================================================================(0)
                    [91;1mhow does _funcs_kwargs work: _funcs_kwargs is a decorator; it helps class e.g., T to add more methods; I need to give the method a name, and put the name e.g., 'b' inside a list called _methods=['b'] inside class T; then after writing a func e.g., _new_func, I can add it by T(b = _new_func); if I want the func added to class to use self, I shall write @funcs_kwargs(as_method=True)[0m
                        old_init = cls.__init__                                                                                                                             (1)
                        def _init(self, *args, **kwargs):                                                                                                                   (2)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m2[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                    def _funcs_kwargs(cls, as_method):                                                                                                                      (0)
                        old_init = cls.__init__                                                                                                                             (1)
                        def _init(self, *args, **kwargs):===================================================================================================================(2)
                                                                                                              [91;1mhow to define a method which can use self and accept any parameters[0m
                            for k in cls._methods:                                                                                                                          (3)
                                arg = kwargs.pop(k,None)                                                                                                                    (4)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m3[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                        old_init = cls.__init__                                                                                                                             (1)
                        def _init(self, *args, **kwargs):                                                                                                                   (2)
                            for k in cls._methods:==========================================================================================================================(3)
                                                  [91;1mhow to pop out the value of an item in a dict (with None as default), and if the item name is not found, pop out None instead; [0m
                                arg = kwargs.pop(k,None)                                                                                                                    (4)
                                if arg is not None:                                                                                                                         (5)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m6[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                                arg = kwargs.pop(k,None)                                                                                                                    (4)
                                if arg is not None:                                                                                                                         (5)
                                    if as_method: arg = method(arg)=========================================================================================================(6)
                                                                                                                                                 [91;1mhow to turn a func into a method[0m
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)                                                                     (7)
                                    setattr(self, k, arg)                                                                                                                   (8)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m7[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                                if arg is not None:                                                                                                                         (5)
                                    if as_method: arg = method(arg)                                                                                                         (6)
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)=====================================================================(7)
                                                                                                                             [91;1mhow to give a method a different instance, like self[0m
                                    setattr(self, k, arg)                                                                                                                   (8)
                            old_init(self, *args, **kwargs)                                                                                                                 (9)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m8[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                                    if as_method: arg = method(arg)                                                                                                         (6)
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)                                                                     (7)
                                    setattr(self, k, arg)===================================================================================================================(8)
                                                                                                                                   [91;1mhow to add a method to a class as an attribute[0m
                            old_init(self, *args, **kwargs)                                                                                                                 (9)
                        functools.update_wrapper(_init, old_init)                                                                                                           (10)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m10[0m     ===============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                                    setattr(self, k, arg)                                                                                                                   (8)
                            old_init(self, *args, **kwargs)                                                                                                                 (9)
                        functools.update_wrapper(_init, old_init)===========================================================================================================(10)
                                                                                          [91;1mhow to wrap `_init` around `old_init`, so that `_init` can use `old_init` inside itself[0m
                        cls.__init__ = use_kwargs(cls._methods)(_init)                                                                                                      (11)
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))                                                     (12)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m11[0m     ===============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                            old_init(self, *args, **kwargs)                                                                                                                 (9)
                        functools.update_wrapper(_init, old_init)                                                                                                           (10)
                        cls.__init__ = use_kwargs(cls._methods)(_init)======================================================================================================(11)
                                                                            [91;1mhow to add a list of names with None as default value to function `_init` to repalce its kwargs param[0m
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))                                                     (12)
                        return cls                                                                                                                                          (13)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m12[0m     ===============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                        functools.update_wrapper(_init, old_init)                                                                                                           (10)
                        cls.__init__ = use_kwargs(cls._methods)(_init)                                                                                                      (11)
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))=====================================================(12)
                                                                   [91;1mhow to make a class.`__init__` signature to be the signature of the class using `__signature__` and `_rm_self`[0m
                        return cls                                                                                                                                          (13)
                                                                                                                                                                            (14)
                
                
                
                ```
                #| column: screen
                fdb.snoop() # how to snoop together with docsrc: snoop first and docsrc above it
                ```
                
                    22:28:59.99 >>> Call to funcs_kwargs in File "/tmp/funcs_kwargs.py", line 3
                    22:28:59.99 ...... as_method = <class 'fastcore.meta.T'>
                    22:28:59.99    3 | def funcs_kwargs(as_method=False):
                    22:28:59.99    5 |     if callable(as_method): return _funcs_kwargs(as_method, False)
                        22:28:59.99 >>> Call to _funcs_kwargs in File "/tmp/_funcs_kwargs.py", line 3
                        22:28:59.99 ...... cls = <class 'fastcore.meta.T'>
                        22:28:59.99 ...... as_method = False
                        22:28:59.99    3 | def _funcs_kwargs(cls, as_method):
                        22:28:59.99    4 |     old_init = cls.__init__
                        22:28:59.99 .......... old_init = <function T.__init__>
                        22:28:59.99    5 |     import snoop
                        22:28:59.99 .......... snoop = <class 'snoop.configuration.Config.__init__.<locals>.ConfiguredTracer'>
                        22:28:59.99    6 |     @snoop
                        22:28:59.99    7 |     def _init(self, *args, **kwargs):
                        22:28:59.99 .......... _init = <function _funcs_kwargs.<locals>._init>
                        22:28:59.99   15 |     functools.update_wrapper(_init, old_init)
                        22:28:59.99 .......... _init = <function T.__init__>
                        22:28:59.99   16 |     cls.__init__ = use_kwargs(cls._methods)(_init)
                        22:28:59.99   17 |     if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))
                        22:28:59.99   18 |     return cls
                        22:28:59.99 <<< Return value from _funcs_kwargs: <class 'fastcore.meta.T'>
                    22:28:59.99    5 |     if callable(as_method): return _funcs_kwargs(as_method, False)
                    22:28:59.99 <<< Return value from funcs_kwargs: <class 'fastcore.meta.T'>
                    22:28:59.99 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:28:59.99 .......... self = <fastcore.meta.T object>
                    22:28:59.99 .......... args = ()
                    22:28:59.99 .......... kwargs = {}
                    22:28:59.99 .......... as_method = False
                    22:28:59.99 .......... cls = <class 'fastcore.meta.T'>
                    22:28:59.99 .......... old_init = <function T.__init__>
                    22:28:59.99    7 |     def _init(self, *args, **kwargs):
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00 .............. k = 'b'
                    22:29:00.00    9 |             arg = kwargs.pop(k,None)
                    22:29:00.00 .................. arg = None
                    22:29:00.00   10 |             if arg is not None:
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00   14 |         old_init(self, *args, **kwargs)
                    22:29:00.00 <<< Return value from _funcs_kwargs.<locals>._init: None
                    22:29:00.00 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:29:00.00 .......... self = <fastcore.meta.T object>
                    22:29:00.00 .......... args = ()
                    22:29:00.00 .......... kwargs = {'b': <function _new_func>}
                    22:29:00.00 .......... len(kwargs) = 1
                    22:29:00.00 .......... as_method = False
                    22:29:00.00 .......... cls = <class 'fastcore.meta.T'>
                    22:29:00.00 .......... old_init = <function T.__init__>
                    22:29:00.00    7 |     def _init(self, *args, **kwargs):
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00 .............. k = 'b'
                    22:29:00.00    9 |             arg = kwargs.pop(k,None)
                    22:29:00.00 .................. kwargs = {}
                    22:29:00.00 .................. arg = <function _new_func>
                    22:29:00.00   10 |             if arg is not None:
                    22:29:00.00   11 |                 if as_method: arg = method(arg)
                    22:29:00.00   12 |                 if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)
                    22:29:00.00   13 |                 setattr(self, k, arg)
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00   14 |         old_init(self, *args, **kwargs)
                    22:29:00.00 <<< Return value from _funcs_kwargs.<locals>._init: None
                    22:29:00.00 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:29:00.00 .......... self = <fastcore.meta.T object>
                    22:29:00.00 .......... args = ()
                    22:29:00.00 .......... kwargs = {'a': <function <lambda>>}
                    22:29:00.00 .......... len(kwargs) = 1
                    22:29:00.00 .......... as_method = False
                    22:29:00.00 .......... cls = <class 'fastcore.meta.T'>
                    22:29:00.00 .......... old_init = <function T.__init__>
                    22:29:00.00    7 |     def _init(self, *args, **kwargs):
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00 .............. k = 'b'
                    22:29:00.00    9 |             arg = kwargs.pop(k,None)
                    22:29:00.00 .................. arg = None
                    22:29:00.00   10 |             if arg is not None:
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00   14 |         old_init(self, *args, **kwargs)
                    22:29:00.00 <<< Return value from _funcs_kwargs.<locals>._init: None
                    22:29:00.00 >>> Call to funcs_kwargs in File "/tmp/funcs_kwargs.py", line 3
                    22:29:00.00 ...... as_method = True
                    22:29:00.00    3 | def funcs_kwargs(as_method=False):
                    22:29:00.00    5 |     if callable(as_method): return _funcs_kwargs(as_method, False)
                    22:29:00.00    6 |     return partial(_funcs_kwargs, as_method=as_method)
                    22:29:00.00 <<< Return value from funcs_kwargs: functools.partial(<function _funcs_kwargs>, as_method=True)
                    22:29:00.00 >>> Call to _funcs_kwargs in File "/tmp/_funcs_kwargs.py", line 3
                    22:29:00.00 ...... cls = <class 'fastcore.meta.T'>
                    22:29:00.00 ...... as_method = True
                    22:29:00.00    3 | def _funcs_kwargs(cls, as_method):
                    22:29:00.00    4 |     old_init = cls.__init__
                    22:29:00.00 .......... old_init = <slot wrapper '__init__' of 'object' objects>
                    22:29:00.00    5 |     import snoop
                    22:29:00.00 .......... snoop = <class 'snoop.configuration.Config.__init__.<locals>.ConfiguredTracer'>
                    22:29:00.00    6 |     @snoop
                    22:29:00.00    7 |     def _init(self, *args, **kwargs):
                    22:29:00.00 .......... _init = <function _funcs_kwargs.<locals>._init>
                    22:29:00.00   15 |     functools.update_wrapper(_init, old_init)
                    22:29:00.00 .......... _init = <function object.__init__>
                    22:29:00.00   16 |     cls.__init__ = use_kwargs(cls._methods)(_init)
                    22:29:00.01   17 |     if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))
                    22:29:00.01   18 |     return cls
                    22:29:00.01 <<< Return value from _funcs_kwargs: <class 'fastcore.meta.T'>
                    22:29:00.01 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:29:00.01 .......... self = <fastcore.meta.T object>
                    22:29:00.01 .......... args = ()
                    22:29:00.01 .......... kwargs = {'b': <function _f>}
                    22:29:00.01 .......... len(kwargs) = 1
                    22:29:00.01 .......... as_method = True
                    22:29:00.01 .......... cls = <class 'fastcore.meta.T'>
                    22:29:00.01 .......... old_init = <slot wrapper '__init__' of 'object' objects>
                    22:29:00.01    7 |     def _init(self, *args, **kwargs):
                    22:29:00.01    8 |         for k in cls._methods:
                    22:29:00.01 .............. k = 'b'
                    22:29:00.01    9 |             arg = kwargs.pop(k,None)
                    22:29:00.01 .................. kwargs = {}
                    22:29:00.01 .................. arg = <function _f>
                    22:29:00.01   10 |             if arg is not None:
                    22:29:00.01   11 |                 if as_method: arg = method(arg)
                    22:29:00.01 ...... arg = <bound method int._f of 1>
                    22:29:00.01   12 |                 if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)
                    22:29:00.01 ...... arg = <bound method T._f of <fastcore.meta.T object>>
                    22:29:00.01   13 |                 setattr(self, k, arg)
                    22:29:00.01    8 |         for k in cls._methods:
                    22:29:00.01   14 |         old_init(self, *args, **kwargs)
                    22:29:00.01 <<< Return value from _funcs_kwargs.<locals>._init: None
                    22:29:00.01 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:29:00.01 .......... self = <fastcore.meta.T2 object>
                    22:29:00.01 .......... args = ()
                    22:29:00.01 .......... kwargs = {'b': <function _f>}
                    22:29:00.01 .......... len(kwargs) = 1
                    22:29:00.01 .......... as_method = True
                    22:29:00.01 .......... cls = <class 'fastcore.meta.T'>
                    22:29:00.01 .......... old_init = <slot wrapper '__init__' of 'object' objects>
                    22:29:00.01    7 |     def _init(self, *args, **kwargs):
                    22:29:00.01    8 |         for k in cls._methods:
                    22:29:00.01 .............. k = 'b'
                    22:29:00.01    9 |             arg = kwargs.pop(k,None)
                    22:29:00.01 .................. kwargs = {}
                    22:29:00.01 .................. arg = <function _f>
                    22:29:00.01   10 |             if arg is not None:
                    22:29:00.01   11 |                 if as_method: arg = method(arg)
                    22:29:00.01 ...... arg = <bound method int._f of 1>
                    22:29:00.01   12 |                 if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)
                    22:29:00.01 ...... arg = <bound method T2._f of <fastcore.meta.T2 object>>
                    22:29:00.01   13 |                 setattr(self, k, arg)
                    22:29:00.01    8 |         for k in cls._methods:
                    22:29:00.01   14 |         old_init(self, *args, **kwargs)
                    22:29:00.01 <<< Return value from _funcs_kwargs.<locals>._init: None
                
                
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                
                
                
                ```
                fdb_.debug()
                ```
                
                    _funcs_kwargs's dbsrc code: ==============
                    import snoop
                    @snoop
                    def _funcs_kwargs(cls, as_method):
                        old_init = cls.__init__
                        import snoop
                        @snoop
                        def _init(self, *args, **kwargs):
                            for k in cls._methods:
                                arg = kwargs.pop(k,None)
                                if arg is not None:
                                    if as_method: arg = method(arg)
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)
                                    setattr(self, k, arg)
                            old_init(self, *args, **kwargs)
                        functools.update_wrapper(_init, old_init)
                        cls.__init__ = use_kwargs(cls._methods)(_init)
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))
                        return cls
                    
                    
                    
                    _funcs_kwargs's example processed with dbsrc: ===============
                    
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    
                
                
                
                ```
                #| column: screen
                fdb.print()
                ```
                
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    def funcs_kwargs(as_method=False):========================================================(0)       
                        "Replace methods in `cls._methods` with those from `kwargs`"==========================(1) # [93;1mhow funcs_kwargs works[0m; [93;1mit is a wrapper around _funcs_kwargs[0m; [91;1mit offers two ways of running _funcs_kwargs[0m; [37;1mthe first, default way, is to add a func to a class without using self[0m; [91;1msecond way is to add func to class enabling self use;[0m; 
                        if callable(as_method): return _funcs_kwargs(as_method, False)========================(2) # [37;1mhow to check whether an object is callable[0m; [93;1mhow to return a result of running a func[0m; [37;1m[0m; 
                        return partial(_funcs_kwargs, as_method=as_method)====================================(3) # [92;1mhow to custom the params of `_funcs_kwargs` for a particular use with partial[0m; 
                                                                                                                                                                            (4)
                
                
                
                ```
                #| column: screen
                fdb_.print()
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m12[0m     ===============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    def _funcs_kwargs(cls, as_method):========================================================(0) # [93;1mhow does _funcs_kwargs work: _funcs_kwargs is a decorator[0m; [35;1mit helps class e.g., T to add more methods[0m; [93;1mI need to give the method a name, and put the name e.g., 'b' inside a list called _methods=['b'] inside class T[0m; [36;1mthen after writing a func e.g., _new_func, I can add it by T(b = _new_func)[0m; [36;1mif I want the func added to class to use self, I shall write @funcs_kwargs(as_method=True)[0m; 
                        old_init = cls.__init__===============================================================(1)       
                        def _init(self, *args, **kwargs):=====================================================(2) # [37;1mhow to define a method which can use self and accept any parameters[0m; 
                            for k in cls._methods:============================================================(3) # [35;1mhow to pop out the value of an item in a dict (with None as default), and if the item name is not found, pop out None instead[0m; [91;1m[0m; 
                                arg = kwargs.pop(k,None)======================================================(4)       
                                if arg is not None:===========================================================(5)       
                                    if as_method: arg = method(arg)===========================================(6) # [36;1mhow to turn a func into a method[0m; 
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)=======(7) # [93;1mhow to give a method a different instance, like self[0m; 
                                    setattr(self, k, arg)=====================================================(8) # [36;1mhow to add a method to a class as an attribute[0m; 
                            old_init(self, *args, **kwargs)===================================================(9)       
                        functools.update_wrapper(_init, old_init)=============================================(10) # [34;1mhow to wrap `_init` around `old_init`, so that `_init` can use `old_init` inside itself[0m; 
                        cls.__init__ = use_kwargs(cls._methods)(_init)========================================(11) # [34;1mhow to add a list of names with None as default value to function `_init` to repalce its kwargs param[0m; 
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__)) # [35;1mhow to make a class.`__init__` signature to be the signature of the class using `__signature__` and `_rm_self`[0m;  (12)
                        return cls============================================================================(13)      
                                                                                                                                                                            (14)
                
                
                
                ```
                
                ```
                
                
            
            
            
            [Open `0009_funcs_kwargs` in Jupyter Notebook](http://localhost:8888/tree/nbs/demos/0009_funcs_kwargs.ipynb)
            
            
            
        
        
        
        [Open `utils` in Jupyter Notebook](http://localhost:8888/tree/nbs/lib/utils.ipynb)
        
        
        
        
    
    
    
    [Open `utils` in Jupyter Notebook](http://localhost:8888/tree/nbs/lib/utils.ipynb)
    
    
    
    



[Open `utils` in Jupyter Notebook locally](http://localhost:8888/tree/nbs/lib/utils.ipynb)



###  <mark style="background-color: #ffff00">snoop:</mark>   <mark style="background-color: #ffff00">from</mark>   <mark style="background-color: #ffff00">_ <mark style="background-color: #FFFF00">funcs_kwargs</mark> </mark>   <mark style="background-color: #ffff00">to</mark>   <mark style="background-color: #FFFF00">funcs_kwargs</mark> 



    
    
    
        
        
        
            
            
            
                
                how to snoop on two functions one wrap around another: `funcs_kwargs` is a wrapper around `_funcs_kwargs`, so I can first snoop on `_funcs_kwargs` and assign its snoop dbsrc to \
                `fm._funcs_kwargs` so that when I snoop on `funcs_kwargs`, it can use the snoop dbsrc of `_funcs_kwargs` and no example codes need to change.
                
                
                ```
                from fastcore.meta import _funcs_kwargs
                ```
                
                
                ```
                fdb_ = Fastdb(_funcs_kwargs)
                fdb_.eg = """
                @funcs_kwargs
                class T:
                    _methods=['b'] # allows you to add method b upon instantiation
                    def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                    def a(self): return 1
                    def b(self): return 2
                    
                t = T()
                test_eq(t.a(), 1)
                test_eq(t.b(), 2)
                
                test_sig(T, '(f=1, *, b=None)')
                inspect.signature(T)
                
                def _new_func(): return 5
                
                t = T(b = _new_func)
                test_eq(t.b(), 5)
                
                t = T(a = lambda:3)
                test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                """
                ```
                
                
                ```
                #| column: screen
                # no snoop result, it is expected, because the example is not calling _funcs_kwargs, but funcs_kwargs
                fdb_.snoop(deco=True) # how to snoop decorator: _funcs_kwargs is a decorator, so set deco=True to see running codes in inner f
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    [0m     
                    
                
                
                
                ```
                import fastcore.meta as fm
                ```
                
                
                ```
                fm._funcs_kwargs = fdb_.dbsrc # how to snoop on two functions one wrap around another
                ```
                
                
                ```
                fdb = Fastdb(funcs_kwargs)
                fdb.eg = """
                @funcs_kwargs
                class T:
                    _methods=['b'] # allows you to add method b upon instantiation
                    def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                    def a(self): return 1
                    def b(self): return 2
                    
                t = T()
                test_eq(t.a(), 1)
                test_eq(t.b(), 2)
                
                test_sig(T, '(f=1, *, b=None)')
                inspect.signature(T)
                
                def _new_func(): return 5
                
                t = T(b = _new_func)
                test_eq(t.b(), 5)
                
                t = T(a = lambda:3)
                test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                
                def _f(self,a=1): return self.num + a # access the num attribute from the instance
                
                @funcs_kwargs(as_method=True)
                class T: 
                    _methods=['b']
                    num = 5
                    
                t = T(b = _f) # adds method b
                test_eq(t.b(5), 10) # self.num + 5 = 10
                
                def _f(self,a=1): return self.num * a #multiply instead of add 
                
                class T2(T):
                    def __init__(self,num):
                        super().__init__(b = _f) # add method b from the super class
                        self.num=num
                        
                t = T2(num=3)
                test_eq(t.b(a=5), 15) # 3 * 5 = 15
                test_sig(T2, '(num)')
                """
                ```
                
                
                ```
                #| column: screen
                fdb.print()
                ```
                
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    def funcs_kwargs(as_method=False):========================================================(0)       
                        "Replace methods in `cls._methods` with those from `kwargs`"==========================(1)       
                        if callable(as_method): return _funcs_kwargs(as_method, False)========================(2)       
                        return partial(_funcs_kwargs, as_method=as_method)====================================(3)       
                                                                                                                                                                            (4)
                
                
                
                ```
                #| column: screen
                fdb_.print()
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    def _funcs_kwargs(cls, as_method):========================================================(0)       
                        old_init = cls.__init__===============================================================(1)       
                        def _init(self, *args, **kwargs):=====================================================(2)       
                            for k in cls._methods:============================================================(3)       
                                arg = kwargs.pop(k,None)======================================================(4)       
                                if arg is not None:===========================================================(5)       
                                    if as_method: arg = method(arg)===========================================(6)       
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)=======(7)       
                                    setattr(self, k, arg)=====================================================(8)       
                            old_init(self, *args, **kwargs)===================================================(9)       
                        functools.update_wrapper(_init, old_init)=============================================(10)      
                        cls.__init__ = use_kwargs(cls._methods)(_init)========================================(11)      
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))                                                     (12)
                        return cls============================================================================(13)      
                                                                                                                                                                            (14)
                
                
                
                ```
                #| column: screen
                fdb.docsrc(1, "how funcs_kwargs works; it is a wrapper around _funcs_kwargs; it offers two ways of running _funcs_kwargs; \
                the first, default way, is to add a func to a class without using self; second way is to add func to class enabling self use;")
                fdb.docsrc(2, "how to check whether an object is callable; how to return a result of running a func; ")
                fdb.docsrc(3, "how to custom the params of `_funcs_kwargs` for a particular use with partial")
                ```
                
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m1[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                    def funcs_kwargs(as_method=False):                                                                                                                      (0)
                        "Replace methods in `cls._methods` with those from `kwargs`"========================================================================================(1)
                    [91;1mhow funcs_kwargs works; it is a wrapper around _funcs_kwargs; it offers two ways of running _funcs_kwargs; the first, default way, is to add a func to a class without using self; second way is to add func to class enabling self use;[0m
                        if callable(as_method): return _funcs_kwargs(as_method, False)                                                                                      (2)
                        return partial(_funcs_kwargs, as_method=as_method)                                                                                                  (3)
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m2[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                    def funcs_kwargs(as_method=False):                                                                                                                      (0)
                        "Replace methods in `cls._methods` with those from `kwargs`"                                                                                        (1)
                        if callable(as_method): return _funcs_kwargs(as_method, False)======================================================================================(2)
                                                                                           [91;1mhow to check whether an object is callable; how to return a result of running a func; [0m
                        return partial(_funcs_kwargs, as_method=as_method)                                                                                                  (3)
                                                                                                                                                                            (4)
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m3[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                        "Replace methods in `cls._methods` with those from `kwargs`"                                                                                        (1)
                        if callable(as_method): return _funcs_kwargs(as_method, False)                                                                                      (2)
                        return partial(_funcs_kwargs, as_method=as_method)==================================================================================================(3)
                                                                                                    [91;1mhow to custom the params of `_funcs_kwargs` for a particular use with partial[0m
                                                                                                                                                                            (4)
                
                
                
                ```
                #| column: screen
                fdb_.print()
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    def _funcs_kwargs(cls, as_method):========================================================(0)       
                        old_init = cls.__init__===============================================================(1)       
                        def _init(self, *args, **kwargs):=====================================================(2)       
                            for k in cls._methods:============================================================(3)       
                                arg = kwargs.pop(k,None)======================================================(4)       
                                if arg is not None:===========================================================(5)       
                                    if as_method: arg = method(arg)===========================================(6)       
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)=======(7)       
                                    setattr(self, k, arg)=====================================================(8)       
                            old_init(self, *args, **kwargs)===================================================(9)       
                        functools.update_wrapper(_init, old_init)=============================================(10)      
                        cls.__init__ = use_kwargs(cls._methods)(_init)========================================(11)      
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))                                                     (12)
                        return cls============================================================================(13)      
                                                                                                                                                                            (14)
                
                
                
                ```
                #| column: screen
                fdb_.docsrc(0, "how does _funcs_kwargs work: _funcs_kwargs is a decorator; it helps class e.g., T to add more methods; \
                I need to give the method a name, \
                and put the name e.g., 'b' inside a list called _methods=['b'] inside class T; \
                then after writing a func e.g., _new_func, I can add it by T(b = _new_func); if I want the func added to class to use self, \
                I shall write @funcs_kwargs(as_method=True)")
                fdb_.docsrc(2, "how to define a method which can use self and accept any parameters")
                fdb_.docsrc(3, "how to pop out the value of an item in a dict (with None as default), and if the item name is not found, pop out None instead; ")
                fdb_.docsrc(6, "how to turn a func into a method")
                fdb_.docsrc(7, "how to give a method a different instance, like self")
                fdb_.docsrc(8, "how to add a method to a class as an attribute")
                fdb_.docsrc(10, "how to wrap `_init` around `old_init`, so that `_init` can use `old_init` inside itself")
                fdb_.docsrc(11, "how to add a list of names with None as default value to function `_init` to repalce its kwargs param")
                fdb_.docsrc(12, "how to make a class.`__init__` signature to be the signature of the class using `__signature__` and `_rm_self`")
                
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m0[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                    def _funcs_kwargs(cls, as_method):======================================================================================================================(0)
                    [91;1mhow does _funcs_kwargs work: _funcs_kwargs is a decorator; it helps class e.g., T to add more methods; I need to give the method a name, and put the name e.g., 'b' inside a list called _methods=['b'] inside class T; then after writing a func e.g., _new_func, I can add it by T(b = _new_func); if I want the func added to class to use self, I shall write @funcs_kwargs(as_method=True)[0m
                        old_init = cls.__init__                                                                                                                             (1)
                        def _init(self, *args, **kwargs):                                                                                                                   (2)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m2[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                    def _funcs_kwargs(cls, as_method):                                                                                                                      (0)
                        old_init = cls.__init__                                                                                                                             (1)
                        def _init(self, *args, **kwargs):===================================================================================================================(2)
                                                                                                              [91;1mhow to define a method which can use self and accept any parameters[0m
                            for k in cls._methods:                                                                                                                          (3)
                                arg = kwargs.pop(k,None)                                                                                                                    (4)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m3[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                        old_init = cls.__init__                                                                                                                             (1)
                        def _init(self, *args, **kwargs):                                                                                                                   (2)
                            for k in cls._methods:==========================================================================================================================(3)
                                                  [91;1mhow to pop out the value of an item in a dict (with None as default), and if the item name is not found, pop out None instead; [0m
                                arg = kwargs.pop(k,None)                                                                                                                    (4)
                                if arg is not None:                                                                                                                         (5)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m6[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                                arg = kwargs.pop(k,None)                                                                                                                    (4)
                                if arg is not None:                                                                                                                         (5)
                                    if as_method: arg = method(arg)=========================================================================================================(6)
                                                                                                                                                 [91;1mhow to turn a func into a method[0m
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)                                                                     (7)
                                    setattr(self, k, arg)                                                                                                                   (8)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m7[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                                if arg is not None:                                                                                                                         (5)
                                    if as_method: arg = method(arg)                                                                                                         (6)
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)=====================================================================(7)
                                                                                                                             [91;1mhow to give a method a different instance, like self[0m
                                    setattr(self, k, arg)                                                                                                                   (8)
                            old_init(self, *args, **kwargs)                                                                                                                 (9)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m8[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                                    if as_method: arg = method(arg)                                                                                                         (6)
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)                                                                     (7)
                                    setattr(self, k, arg)===================================================================================================================(8)
                                                                                                                                   [91;1mhow to add a method to a class as an attribute[0m
                            old_init(self, *args, **kwargs)                                                                                                                 (9)
                        functools.update_wrapper(_init, old_init)                                                                                                           (10)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m10[0m     ===============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                                    setattr(self, k, arg)                                                                                                                   (8)
                            old_init(self, *args, **kwargs)                                                                                                                 (9)
                        functools.update_wrapper(_init, old_init)===========================================================================================================(10)
                                                                                          [91;1mhow to wrap `_init` around `old_init`, so that `_init` can use `old_init` inside itself[0m
                        cls.__init__ = use_kwargs(cls._methods)(_init)                                                                                                      (11)
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))                                                     (12)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m11[0m     ===============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                            old_init(self, *args, **kwargs)                                                                                                                 (9)
                        functools.update_wrapper(_init, old_init)                                                                                                           (10)
                        cls.__init__ = use_kwargs(cls._methods)(_init)======================================================================================================(11)
                                                                            [91;1mhow to add a list of names with None as default value to function `_init` to repalce its kwargs param[0m
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))                                                     (12)
                        return cls                                                                                                                                          (13)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m12[0m     ===============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                        functools.update_wrapper(_init, old_init)                                                                                                           (10)
                        cls.__init__ = use_kwargs(cls._methods)(_init)                                                                                                      (11)
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))=====================================================(12)
                                                                   [91;1mhow to make a class.`__init__` signature to be the signature of the class using `__signature__` and `_rm_self`[0m
                        return cls                                                                                                                                          (13)
                                                                                                                                                                            (14)
                
                
                
                ```
                #| column: screen
                fdb.snoop() # how to snoop together with docsrc: snoop first and docsrc above it
                ```
                
                    22:28:59.99 >>> Call to funcs_kwargs in File "/tmp/funcs_kwargs.py", line 3
                    22:28:59.99 ...... as_method = <class 'fastcore.meta.T'>
                    22:28:59.99    3 | def funcs_kwargs(as_method=False):
                    22:28:59.99    5 |     if callable(as_method): return _funcs_kwargs(as_method, False)
                        22:28:59.99 >>> Call to _funcs_kwargs in File "/tmp/_funcs_kwargs.py", line 3
                        22:28:59.99 ...... cls = <class 'fastcore.meta.T'>
                        22:28:59.99 ...... as_method = False
                        22:28:59.99    3 | def _funcs_kwargs(cls, as_method):
                        22:28:59.99    4 |     old_init = cls.__init__
                        22:28:59.99 .......... old_init = <function T.__init__>
                        22:28:59.99    5 |     import snoop
                        22:28:59.99 .......... snoop = <class 'snoop.configuration.Config.__init__.<locals>.ConfiguredTracer'>
                        22:28:59.99    6 |     @snoop
                        22:28:59.99    7 |     def _init(self, *args, **kwargs):
                        22:28:59.99 .......... _init = <function _funcs_kwargs.<locals>._init>
                        22:28:59.99   15 |     functools.update_wrapper(_init, old_init)
                        22:28:59.99 .......... _init = <function T.__init__>
                        22:28:59.99   16 |     cls.__init__ = use_kwargs(cls._methods)(_init)
                        22:28:59.99   17 |     if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))
                        22:28:59.99   18 |     return cls
                        22:28:59.99 <<< Return value from _funcs_kwargs: <class 'fastcore.meta.T'>
                    22:28:59.99    5 |     if callable(as_method): return _funcs_kwargs(as_method, False)
                    22:28:59.99 <<< Return value from funcs_kwargs: <class 'fastcore.meta.T'>
                    22:28:59.99 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:28:59.99 .......... self = <fastcore.meta.T object>
                    22:28:59.99 .......... args = ()
                    22:28:59.99 .......... kwargs = {}
                    22:28:59.99 .......... as_method = False
                    22:28:59.99 .......... cls = <class 'fastcore.meta.T'>
                    22:28:59.99 .......... old_init = <function T.__init__>
                    22:28:59.99    7 |     def _init(self, *args, **kwargs):
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00 .............. k = 'b'
                    22:29:00.00    9 |             arg = kwargs.pop(k,None)
                    22:29:00.00 .................. arg = None
                    22:29:00.00   10 |             if arg is not None:
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00   14 |         old_init(self, *args, **kwargs)
                    22:29:00.00 <<< Return value from _funcs_kwargs.<locals>._init: None
                    22:29:00.00 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:29:00.00 .......... self = <fastcore.meta.T object>
                    22:29:00.00 .......... args = ()
                    22:29:00.00 .......... kwargs = {'b': <function _new_func>}
                    22:29:00.00 .......... len(kwargs) = 1
                    22:29:00.00 .......... as_method = False
                    22:29:00.00 .......... cls = <class 'fastcore.meta.T'>
                    22:29:00.00 .......... old_init = <function T.__init__>
                    22:29:00.00    7 |     def _init(self, *args, **kwargs):
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00 .............. k = 'b'
                    22:29:00.00    9 |             arg = kwargs.pop(k,None)
                    22:29:00.00 .................. kwargs = {}
                    22:29:00.00 .................. arg = <function _new_func>
                    22:29:00.00   10 |             if arg is not None:
                    22:29:00.00   11 |                 if as_method: arg = method(arg)
                    22:29:00.00   12 |                 if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)
                    22:29:00.00   13 |                 setattr(self, k, arg)
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00   14 |         old_init(self, *args, **kwargs)
                    22:29:00.00 <<< Return value from _funcs_kwargs.<locals>._init: None
                    22:29:00.00 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:29:00.00 .......... self = <fastcore.meta.T object>
                    22:29:00.00 .......... args = ()
                    22:29:00.00 .......... kwargs = {'a': <function <lambda>>}
                    22:29:00.00 .......... len(kwargs) = 1
                    22:29:00.00 .......... as_method = False
                    22:29:00.00 .......... cls = <class 'fastcore.meta.T'>
                    22:29:00.00 .......... old_init = <function T.__init__>
                    22:29:00.00    7 |     def _init(self, *args, **kwargs):
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00 .............. k = 'b'
                    22:29:00.00    9 |             arg = kwargs.pop(k,None)
                    22:29:00.00 .................. arg = None
                    22:29:00.00   10 |             if arg is not None:
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00   14 |         old_init(self, *args, **kwargs)
                    22:29:00.00 <<< Return value from _funcs_kwargs.<locals>._init: None
                    22:29:00.00 >>> Call to funcs_kwargs in File "/tmp/funcs_kwargs.py", line 3
                    22:29:00.00 ...... as_method = True
                    22:29:00.00    3 | def funcs_kwargs(as_method=False):
                    22:29:00.00    5 |     if callable(as_method): return _funcs_kwargs(as_method, False)
                    22:29:00.00    6 |     return partial(_funcs_kwargs, as_method=as_method)
                    22:29:00.00 <<< Return value from funcs_kwargs: functools.partial(<function _funcs_kwargs>, as_method=True)
                    22:29:00.00 >>> Call to _funcs_kwargs in File "/tmp/_funcs_kwargs.py", line 3
                    22:29:00.00 ...... cls = <class 'fastcore.meta.T'>
                    22:29:00.00 ...... as_method = True
                    22:29:00.00    3 | def _funcs_kwargs(cls, as_method):
                    22:29:00.00    4 |     old_init = cls.__init__
                    22:29:00.00 .......... old_init = <slot wrapper '__init__' of 'object' objects>
                    22:29:00.00    5 |     import snoop
                    22:29:00.00 .......... snoop = <class 'snoop.configuration.Config.__init__.<locals>.ConfiguredTracer'>
                    22:29:00.00    6 |     @snoop
                    22:29:00.00    7 |     def _init(self, *args, **kwargs):
                    22:29:00.00 .......... _init = <function _funcs_kwargs.<locals>._init>
                    22:29:00.00   15 |     functools.update_wrapper(_init, old_init)
                    22:29:00.00 .......... _init = <function object.__init__>
                    22:29:00.00   16 |     cls.__init__ = use_kwargs(cls._methods)(_init)
                    22:29:00.01   17 |     if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))
                    22:29:00.01   18 |     return cls
                    22:29:00.01 <<< Return value from _funcs_kwargs: <class 'fastcore.meta.T'>
                    22:29:00.01 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:29:00.01 .......... self = <fastcore.meta.T object>
                    22:29:00.01 .......... args = ()
                    22:29:00.01 .......... kwargs = {'b': <function _f>}
                    22:29:00.01 .......... len(kwargs) = 1
                    22:29:00.01 .......... as_method = True
                    22:29:00.01 .......... cls = <class 'fastcore.meta.T'>
                    22:29:00.01 .......... old_init = <slot wrapper '__init__' of 'object' objects>
                    22:29:00.01    7 |     def _init(self, *args, **kwargs):
                    22:29:00.01    8 |         for k in cls._methods:
                    22:29:00.01 .............. k = 'b'
                    22:29:00.01    9 |             arg = kwargs.pop(k,None)
                    22:29:00.01 .................. kwargs = {}
                    22:29:00.01 .................. arg = <function _f>
                    22:29:00.01   10 |             if arg is not None:
                    22:29:00.01   11 |                 if as_method: arg = method(arg)
                    22:29:00.01 ...... arg = <bound method int._f of 1>
                    22:29:00.01   12 |                 if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)
                    22:29:00.01 ...... arg = <bound method T._f of <fastcore.meta.T object>>
                    22:29:00.01   13 |                 setattr(self, k, arg)
                    22:29:00.01    8 |         for k in cls._methods:
                    22:29:00.01   14 |         old_init(self, *args, **kwargs)
                    22:29:00.01 <<< Return value from _funcs_kwargs.<locals>._init: None
                    22:29:00.01 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:29:00.01 .......... self = <fastcore.meta.T2 object>
                    22:29:00.01 .......... args = ()
                    22:29:00.01 .......... kwargs = {'b': <function _f>}
                    22:29:00.01 .......... len(kwargs) = 1
                    22:29:00.01 .......... as_method = True
                    22:29:00.01 .......... cls = <class 'fastcore.meta.T'>
                    22:29:00.01 .......... old_init = <slot wrapper '__init__' of 'object' objects>
                    22:29:00.01    7 |     def _init(self, *args, **kwargs):
                    22:29:00.01    8 |         for k in cls._methods:
                    22:29:00.01 .............. k = 'b'
                    22:29:00.01    9 |             arg = kwargs.pop(k,None)
                    22:29:00.01 .................. kwargs = {}
                    22:29:00.01 .................. arg = <function _f>
                    22:29:00.01   10 |             if arg is not None:
                    22:29:00.01   11 |                 if as_method: arg = method(arg)
                    22:29:00.01 ...... arg = <bound method int._f of 1>
                    22:29:00.01   12 |                 if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)
                    22:29:00.01 ...... arg = <bound method T2._f of <fastcore.meta.T2 object>>
                    22:29:00.01   13 |                 setattr(self, k, arg)
                    22:29:00.01    8 |         for k in cls._methods:
                    22:29:00.01   14 |         old_init(self, *args, **kwargs)
                    22:29:00.01 <<< Return value from _funcs_kwargs.<locals>._init: None
                
                
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                
                
                
                ```
                fdb_.debug()
                ```
                
                    _funcs_kwargs's dbsrc code: ==============
                    import snoop
                    @snoop
                    def _funcs_kwargs(cls, as_method):
                        old_init = cls.__init__
                        import snoop
                        @snoop
                        def _init(self, *args, **kwargs):
                            for k in cls._methods:
                                arg = kwargs.pop(k,None)
                                if arg is not None:
                                    if as_method: arg = method(arg)
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)
                                    setattr(self, k, arg)
                            old_init(self, *args, **kwargs)
                        functools.update_wrapper(_init, old_init)
                        cls.__init__ = use_kwargs(cls._methods)(_init)
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))
                        return cls
                    
                    
                    
                    _funcs_kwargs's example processed with dbsrc: ===============
                    
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    
                
                
                
                ```
                #| column: screen
                fdb.print()
                ```
                
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    def funcs_kwargs(as_method=False):========================================================(0)       
                        "Replace methods in `cls._methods` with those from `kwargs`"==========================(1) # [93;1mhow funcs_kwargs works[0m; [93;1mit is a wrapper around _funcs_kwargs[0m; [91;1mit offers two ways of running _funcs_kwargs[0m; [37;1mthe first, default way, is to add a func to a class without using self[0m; [91;1msecond way is to add func to class enabling self use;[0m; 
                        if callable(as_method): return _funcs_kwargs(as_method, False)========================(2) # [37;1mhow to check whether an object is callable[0m; [93;1mhow to return a result of running a func[0m; [37;1m[0m; 
                        return partial(_funcs_kwargs, as_method=as_method)====================================(3) # [92;1mhow to custom the params of `_funcs_kwargs` for a particular use with partial[0m; 
                                                                                                                                                                            (4)
                
                
                
                ```
                #| column: screen
                fdb_.print()
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m12[0m     ===============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    def _funcs_kwargs(cls, as_method):========================================================(0) # [93;1mhow does _funcs_kwargs work: _funcs_kwargs is a decorator[0m; [35;1mit helps class e.g., T to add more methods[0m; [93;1mI need to give the method a name, and put the name e.g., 'b' inside a list called _methods=['b'] inside class T[0m; [36;1mthen after writing a func e.g., _new_func, I can add it by T(b = _new_func)[0m; [36;1mif I want the func added to class to use self, I shall write @funcs_kwargs(as_method=True)[0m; 
                        old_init = cls.__init__===============================================================(1)       
                        def _init(self, *args, **kwargs):=====================================================(2) # [37;1mhow to define a method which can use self and accept any parameters[0m; 
                            for k in cls._methods:============================================================(3) # [35;1mhow to pop out the value of an item in a dict (with None as default), and if the item name is not found, pop out None instead[0m; [91;1m[0m; 
                                arg = kwargs.pop(k,None)======================================================(4)       
                                if arg is not None:===========================================================(5)       
                                    if as_method: arg = method(arg)===========================================(6) # [36;1mhow to turn a func into a method[0m; 
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)=======(7) # [93;1mhow to give a method a different instance, like self[0m; 
                                    setattr(self, k, arg)=====================================================(8) # [36;1mhow to add a method to a class as an attribute[0m; 
                            old_init(self, *args, **kwargs)===================================================(9)       
                        functools.update_wrapper(_init, old_init)=============================================(10) # [34;1mhow to wrap `_init` around `old_init`, so that `_init` can use `old_init` inside itself[0m; 
                        cls.__init__ = use_kwargs(cls._methods)(_init)========================================(11) # [34;1mhow to add a list of names with None as default value to function `_init` to repalce its kwargs param[0m; 
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__)) # [35;1mhow to make a class.`__init__` signature to be the signature of the class using `__signature__` and `_rm_self`[0m;  (12)
                        return cls============================================================================(13)      
                                                                                                                                                                            (14)
                
                
                
                ```
                
                ```
                
                
            
            
            
            [Open `0009_funcs_kwargs` in Jupyter Notebook](http://localhost:8888/tree/nbs/demos/0009_funcs_kwargs.ipynb)
            
            
            
        
        
        
        [Open `utils` in Jupyter Notebook](http://localhost:8888/tree/nbs/lib/utils.ipynb)
        
        
        
        
    
    
    
    [Open `utils` in Jupyter Notebook](http://localhost:8888/tree/nbs/lib/utils.ipynb)
    
    
    
    



[Open `utils` in Jupyter Notebook locally](http://localhost:8888/tree/nbs/lib/utils.ipynb)



###  <mark style="background-color: #ffff00">snoop:</mark>   <mark style="background-color: #ffff00">from</mark>   <mark style="background-color: #ffff00">_ <mark style="background-color: #FFFF00">funcs_kwargs</mark> </mark>   <mark style="background-color: #ffff00">to</mark>   <mark style="background-color: #FFFF00">funcs_kwargs</mark> 



    
    
    
        
        
        
            
            
            
                
                how to snoop on two functions one wrap around another: `funcs_kwargs` is a wrapper around `_funcs_kwargs`, so I can first snoop on `_funcs_kwargs` and assign its snoop dbsrc to \
                `fm._funcs_kwargs` so that when I snoop on `funcs_kwargs`, it can use the snoop dbsrc of `_funcs_kwargs` and no example codes need to change.
                
                
                ```
                from fastcore.meta import _funcs_kwargs
                ```
                
                
                ```
                fdb_ = Fastdb(_funcs_kwargs)
                fdb_.eg = """
                @funcs_kwargs
                class T:
                    _methods=['b'] # allows you to add method b upon instantiation
                    def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                    def a(self): return 1
                    def b(self): return 2
                    
                t = T()
                test_eq(t.a(), 1)
                test_eq(t.b(), 2)
                
                test_sig(T, '(f=1, *, b=None)')
                inspect.signature(T)
                
                def _new_func(): return 5
                
                t = T(b = _new_func)
                test_eq(t.b(), 5)
                
                t = T(a = lambda:3)
                test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                """
                ```
                
                
                ```
                #| column: screen
                # no snoop result, it is expected, because the example is not calling _funcs_kwargs, but funcs_kwargs
                fdb_.snoop(deco=True) # how to snoop decorator: _funcs_kwargs is a decorator, so set deco=True to see running codes in inner f
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    [0m     
                    
                
                
                
                ```
                import fastcore.meta as fm
                ```
                
                
                ```
                fm._funcs_kwargs = fdb_.dbsrc # how to snoop on two functions one wrap around another
                ```
                
                
                ```
                fdb = Fastdb(funcs_kwargs)
                fdb.eg = """
                @funcs_kwargs
                class T:
                    _methods=['b'] # allows you to add method b upon instantiation
                    def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                    def a(self): return 1
                    def b(self): return 2
                    
                t = T()
                test_eq(t.a(), 1)
                test_eq(t.b(), 2)
                
                test_sig(T, '(f=1, *, b=None)')
                inspect.signature(T)
                
                def _new_func(): return 5
                
                t = T(b = _new_func)
                test_eq(t.b(), 5)
                
                t = T(a = lambda:3)
                test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                
                def _f(self,a=1): return self.num + a # access the num attribute from the instance
                
                @funcs_kwargs(as_method=True)
                class T: 
                    _methods=['b']
                    num = 5
                    
                t = T(b = _f) # adds method b
                test_eq(t.b(5), 10) # self.num + 5 = 10
                
                def _f(self,a=1): return self.num * a #multiply instead of add 
                
                class T2(T):
                    def __init__(self,num):
                        super().__init__(b = _f) # add method b from the super class
                        self.num=num
                        
                t = T2(num=3)
                test_eq(t.b(a=5), 15) # 3 * 5 = 15
                test_sig(T2, '(num)')
                """
                ```
                
                
                ```
                #| column: screen
                fdb.print()
                ```
                
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    def funcs_kwargs(as_method=False):========================================================(0)       
                        "Replace methods in `cls._methods` with those from `kwargs`"==========================(1)       
                        if callable(as_method): return _funcs_kwargs(as_method, False)========================(2)       
                        return partial(_funcs_kwargs, as_method=as_method)====================================(3)       
                                                                                                                                                                            (4)
                
                
                
                ```
                #| column: screen
                fdb_.print()
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    def _funcs_kwargs(cls, as_method):========================================================(0)       
                        old_init = cls.__init__===============================================================(1)       
                        def _init(self, *args, **kwargs):=====================================================(2)       
                            for k in cls._methods:============================================================(3)       
                                arg = kwargs.pop(k,None)======================================================(4)       
                                if arg is not None:===========================================================(5)       
                                    if as_method: arg = method(arg)===========================================(6)       
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)=======(7)       
                                    setattr(self, k, arg)=====================================================(8)       
                            old_init(self, *args, **kwargs)===================================================(9)       
                        functools.update_wrapper(_init, old_init)=============================================(10)      
                        cls.__init__ = use_kwargs(cls._methods)(_init)========================================(11)      
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))                                                     (12)
                        return cls============================================================================(13)      
                                                                                                                                                                            (14)
                
                
                
                ```
                #| column: screen
                fdb.docsrc(1, "how funcs_kwargs works; it is a wrapper around _funcs_kwargs; it offers two ways of running _funcs_kwargs; \
                the first, default way, is to add a func to a class without using self; second way is to add func to class enabling self use;")
                fdb.docsrc(2, "how to check whether an object is callable; how to return a result of running a func; ")
                fdb.docsrc(3, "how to custom the params of `_funcs_kwargs` for a particular use with partial")
                ```
                
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m1[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                    def funcs_kwargs(as_method=False):                                                                                                                      (0)
                        "Replace methods in `cls._methods` with those from `kwargs`"========================================================================================(1)
                    [91;1mhow funcs_kwargs works; it is a wrapper around _funcs_kwargs; it offers two ways of running _funcs_kwargs; the first, default way, is to add a func to a class without using self; second way is to add func to class enabling self use;[0m
                        if callable(as_method): return _funcs_kwargs(as_method, False)                                                                                      (2)
                        return partial(_funcs_kwargs, as_method=as_method)                                                                                                  (3)
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m2[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                    def funcs_kwargs(as_method=False):                                                                                                                      (0)
                        "Replace methods in `cls._methods` with those from `kwargs`"                                                                                        (1)
                        if callable(as_method): return _funcs_kwargs(as_method, False)======================================================================================(2)
                                                                                           [91;1mhow to check whether an object is callable; how to return a result of running a func; [0m
                        return partial(_funcs_kwargs, as_method=as_method)                                                                                                  (3)
                                                                                                                                                                            (4)
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m3[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                        "Replace methods in `cls._methods` with those from `kwargs`"                                                                                        (1)
                        if callable(as_method): return _funcs_kwargs(as_method, False)                                                                                      (2)
                        return partial(_funcs_kwargs, as_method=as_method)==================================================================================================(3)
                                                                                                    [91;1mhow to custom the params of `_funcs_kwargs` for a particular use with partial[0m
                                                                                                                                                                            (4)
                
                
                
                ```
                #| column: screen
                fdb_.print()
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    def _funcs_kwargs(cls, as_method):========================================================(0)       
                        old_init = cls.__init__===============================================================(1)       
                        def _init(self, *args, **kwargs):=====================================================(2)       
                            for k in cls._methods:============================================================(3)       
                                arg = kwargs.pop(k,None)======================================================(4)       
                                if arg is not None:===========================================================(5)       
                                    if as_method: arg = method(arg)===========================================(6)       
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)=======(7)       
                                    setattr(self, k, arg)=====================================================(8)       
                            old_init(self, *args, **kwargs)===================================================(9)       
                        functools.update_wrapper(_init, old_init)=============================================(10)      
                        cls.__init__ = use_kwargs(cls._methods)(_init)========================================(11)      
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))                                                     (12)
                        return cls============================================================================(13)      
                                                                                                                                                                            (14)
                
                
                
                ```
                #| column: screen
                fdb_.docsrc(0, "how does _funcs_kwargs work: _funcs_kwargs is a decorator; it helps class e.g., T to add more methods; \
                I need to give the method a name, \
                and put the name e.g., 'b' inside a list called _methods=['b'] inside class T; \
                then after writing a func e.g., _new_func, I can add it by T(b = _new_func); if I want the func added to class to use self, \
                I shall write @funcs_kwargs(as_method=True)")
                fdb_.docsrc(2, "how to define a method which can use self and accept any parameters")
                fdb_.docsrc(3, "how to pop out the value of an item in a dict (with None as default), and if the item name is not found, pop out None instead; ")
                fdb_.docsrc(6, "how to turn a func into a method")
                fdb_.docsrc(7, "how to give a method a different instance, like self")
                fdb_.docsrc(8, "how to add a method to a class as an attribute")
                fdb_.docsrc(10, "how to wrap `_init` around `old_init`, so that `_init` can use `old_init` inside itself")
                fdb_.docsrc(11, "how to add a list of names with None as default value to function `_init` to repalce its kwargs param")
                fdb_.docsrc(12, "how to make a class.`__init__` signature to be the signature of the class using `__signature__` and `_rm_self`")
                
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m0[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                    def _funcs_kwargs(cls, as_method):======================================================================================================================(0)
                    [91;1mhow does _funcs_kwargs work: _funcs_kwargs is a decorator; it helps class e.g., T to add more methods; I need to give the method a name, and put the name e.g., 'b' inside a list called _methods=['b'] inside class T; then after writing a func e.g., _new_func, I can add it by T(b = _new_func); if I want the func added to class to use self, I shall write @funcs_kwargs(as_method=True)[0m
                        old_init = cls.__init__                                                                                                                             (1)
                        def _init(self, *args, **kwargs):                                                                                                                   (2)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m2[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                    def _funcs_kwargs(cls, as_method):                                                                                                                      (0)
                        old_init = cls.__init__                                                                                                                             (1)
                        def _init(self, *args, **kwargs):===================================================================================================================(2)
                                                                                                              [91;1mhow to define a method which can use self and accept any parameters[0m
                            for k in cls._methods:                                                                                                                          (3)
                                arg = kwargs.pop(k,None)                                                                                                                    (4)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m3[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                        old_init = cls.__init__                                                                                                                             (1)
                        def _init(self, *args, **kwargs):                                                                                                                   (2)
                            for k in cls._methods:==========================================================================================================================(3)
                                                  [91;1mhow to pop out the value of an item in a dict (with None as default), and if the item name is not found, pop out None instead; [0m
                                arg = kwargs.pop(k,None)                                                                                                                    (4)
                                if arg is not None:                                                                                                                         (5)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m6[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                                arg = kwargs.pop(k,None)                                                                                                                    (4)
                                if arg is not None:                                                                                                                         (5)
                                    if as_method: arg = method(arg)=========================================================================================================(6)
                                                                                                                                                 [91;1mhow to turn a func into a method[0m
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)                                                                     (7)
                                    setattr(self, k, arg)                                                                                                                   (8)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m7[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                                if arg is not None:                                                                                                                         (5)
                                    if as_method: arg = method(arg)                                                                                                         (6)
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)=====================================================================(7)
                                                                                                                             [91;1mhow to give a method a different instance, like self[0m
                                    setattr(self, k, arg)                                                                                                                   (8)
                            old_init(self, *args, **kwargs)                                                                                                                 (9)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m8[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                                    if as_method: arg = method(arg)                                                                                                         (6)
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)                                                                     (7)
                                    setattr(self, k, arg)===================================================================================================================(8)
                                                                                                                                   [91;1mhow to add a method to a class as an attribute[0m
                            old_init(self, *args, **kwargs)                                                                                                                 (9)
                        functools.update_wrapper(_init, old_init)                                                                                                           (10)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m10[0m     ===============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                                    setattr(self, k, arg)                                                                                                                   (8)
                            old_init(self, *args, **kwargs)                                                                                                                 (9)
                        functools.update_wrapper(_init, old_init)===========================================================================================================(10)
                                                                                          [91;1mhow to wrap `_init` around `old_init`, so that `_init` can use `old_init` inside itself[0m
                        cls.__init__ = use_kwargs(cls._methods)(_init)                                                                                                      (11)
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))                                                     (12)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m11[0m     ===============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                            old_init(self, *args, **kwargs)                                                                                                                 (9)
                        functools.update_wrapper(_init, old_init)                                                                                                           (10)
                        cls.__init__ = use_kwargs(cls._methods)(_init)======================================================================================================(11)
                                                                            [91;1mhow to add a list of names with None as default value to function `_init` to repalce its kwargs param[0m
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))                                                     (12)
                        return cls                                                                                                                                          (13)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m12[0m     ===============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                        functools.update_wrapper(_init, old_init)                                                                                                           (10)
                        cls.__init__ = use_kwargs(cls._methods)(_init)                                                                                                      (11)
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))=====================================================(12)
                                                                   [91;1mhow to make a class.`__init__` signature to be the signature of the class using `__signature__` and `_rm_self`[0m
                        return cls                                                                                                                                          (13)
                                                                                                                                                                            (14)
                
                
                
                ```
                #| column: screen
                fdb.snoop() # how to snoop together with docsrc: snoop first and docsrc above it
                ```
                
                    22:28:59.99 >>> Call to funcs_kwargs in File "/tmp/funcs_kwargs.py", line 3
                    22:28:59.99 ...... as_method = <class 'fastcore.meta.T'>
                    22:28:59.99    3 | def funcs_kwargs(as_method=False):
                    22:28:59.99    5 |     if callable(as_method): return _funcs_kwargs(as_method, False)
                        22:28:59.99 >>> Call to _funcs_kwargs in File "/tmp/_funcs_kwargs.py", line 3
                        22:28:59.99 ...... cls = <class 'fastcore.meta.T'>
                        22:28:59.99 ...... as_method = False
                        22:28:59.99    3 | def _funcs_kwargs(cls, as_method):
                        22:28:59.99    4 |     old_init = cls.__init__
                        22:28:59.99 .......... old_init = <function T.__init__>
                        22:28:59.99    5 |     import snoop
                        22:28:59.99 .......... snoop = <class 'snoop.configuration.Config.__init__.<locals>.ConfiguredTracer'>
                        22:28:59.99    6 |     @snoop
                        22:28:59.99    7 |     def _init(self, *args, **kwargs):
                        22:28:59.99 .......... _init = <function _funcs_kwargs.<locals>._init>
                        22:28:59.99   15 |     functools.update_wrapper(_init, old_init)
                        22:28:59.99 .......... _init = <function T.__init__>
                        22:28:59.99   16 |     cls.__init__ = use_kwargs(cls._methods)(_init)
                        22:28:59.99   17 |     if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))
                        22:28:59.99   18 |     return cls
                        22:28:59.99 <<< Return value from _funcs_kwargs: <class 'fastcore.meta.T'>
                    22:28:59.99    5 |     if callable(as_method): return _funcs_kwargs(as_method, False)
                    22:28:59.99 <<< Return value from funcs_kwargs: <class 'fastcore.meta.T'>
                    22:28:59.99 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:28:59.99 .......... self = <fastcore.meta.T object>
                    22:28:59.99 .......... args = ()
                    22:28:59.99 .......... kwargs = {}
                    22:28:59.99 .......... as_method = False
                    22:28:59.99 .......... cls = <class 'fastcore.meta.T'>
                    22:28:59.99 .......... old_init = <function T.__init__>
                    22:28:59.99    7 |     def _init(self, *args, **kwargs):
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00 .............. k = 'b'
                    22:29:00.00    9 |             arg = kwargs.pop(k,None)
                    22:29:00.00 .................. arg = None
                    22:29:00.00   10 |             if arg is not None:
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00   14 |         old_init(self, *args, **kwargs)
                    22:29:00.00 <<< Return value from _funcs_kwargs.<locals>._init: None
                    22:29:00.00 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:29:00.00 .......... self = <fastcore.meta.T object>
                    22:29:00.00 .......... args = ()
                    22:29:00.00 .......... kwargs = {'b': <function _new_func>}
                    22:29:00.00 .......... len(kwargs) = 1
                    22:29:00.00 .......... as_method = False
                    22:29:00.00 .......... cls = <class 'fastcore.meta.T'>
                    22:29:00.00 .......... old_init = <function T.__init__>
                    22:29:00.00    7 |     def _init(self, *args, **kwargs):
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00 .............. k = 'b'
                    22:29:00.00    9 |             arg = kwargs.pop(k,None)
                    22:29:00.00 .................. kwargs = {}
                    22:29:00.00 .................. arg = <function _new_func>
                    22:29:00.00   10 |             if arg is not None:
                    22:29:00.00   11 |                 if as_method: arg = method(arg)
                    22:29:00.00   12 |                 if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)
                    22:29:00.00   13 |                 setattr(self, k, arg)
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00   14 |         old_init(self, *args, **kwargs)
                    22:29:00.00 <<< Return value from _funcs_kwargs.<locals>._init: None
                    22:29:00.00 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:29:00.00 .......... self = <fastcore.meta.T object>
                    22:29:00.00 .......... args = ()
                    22:29:00.00 .......... kwargs = {'a': <function <lambda>>}
                    22:29:00.00 .......... len(kwargs) = 1
                    22:29:00.00 .......... as_method = False
                    22:29:00.00 .......... cls = <class 'fastcore.meta.T'>
                    22:29:00.00 .......... old_init = <function T.__init__>
                    22:29:00.00    7 |     def _init(self, *args, **kwargs):
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00 .............. k = 'b'
                    22:29:00.00    9 |             arg = kwargs.pop(k,None)
                    22:29:00.00 .................. arg = None
                    22:29:00.00   10 |             if arg is not None:
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00   14 |         old_init(self, *args, **kwargs)
                    22:29:00.00 <<< Return value from _funcs_kwargs.<locals>._init: None
                    22:29:00.00 >>> Call to funcs_kwargs in File "/tmp/funcs_kwargs.py", line 3
                    22:29:00.00 ...... as_method = True
                    22:29:00.00    3 | def funcs_kwargs(as_method=False):
                    22:29:00.00    5 |     if callable(as_method): return _funcs_kwargs(as_method, False)
                    22:29:00.00    6 |     return partial(_funcs_kwargs, as_method=as_method)
                    22:29:00.00 <<< Return value from funcs_kwargs: functools.partial(<function _funcs_kwargs>, as_method=True)
                    22:29:00.00 >>> Call to _funcs_kwargs in File "/tmp/_funcs_kwargs.py", line 3
                    22:29:00.00 ...... cls = <class 'fastcore.meta.T'>
                    22:29:00.00 ...... as_method = True
                    22:29:00.00    3 | def _funcs_kwargs(cls, as_method):
                    22:29:00.00    4 |     old_init = cls.__init__
                    22:29:00.00 .......... old_init = <slot wrapper '__init__' of 'object' objects>
                    22:29:00.00    5 |     import snoop
                    22:29:00.00 .......... snoop = <class 'snoop.configuration.Config.__init__.<locals>.ConfiguredTracer'>
                    22:29:00.00    6 |     @snoop
                    22:29:00.00    7 |     def _init(self, *args, **kwargs):
                    22:29:00.00 .......... _init = <function _funcs_kwargs.<locals>._init>
                    22:29:00.00   15 |     functools.update_wrapper(_init, old_init)
                    22:29:00.00 .......... _init = <function object.__init__>
                    22:29:00.00   16 |     cls.__init__ = use_kwargs(cls._methods)(_init)
                    22:29:00.01   17 |     if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))
                    22:29:00.01   18 |     return cls
                    22:29:00.01 <<< Return value from _funcs_kwargs: <class 'fastcore.meta.T'>
                    22:29:00.01 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:29:00.01 .......... self = <fastcore.meta.T object>
                    22:29:00.01 .......... args = ()
                    22:29:00.01 .......... kwargs = {'b': <function _f>}
                    22:29:00.01 .......... len(kwargs) = 1
                    22:29:00.01 .......... as_method = True
                    22:29:00.01 .......... cls = <class 'fastcore.meta.T'>
                    22:29:00.01 .......... old_init = <slot wrapper '__init__' of 'object' objects>
                    22:29:00.01    7 |     def _init(self, *args, **kwargs):
                    22:29:00.01    8 |         for k in cls._methods:
                    22:29:00.01 .............. k = 'b'
                    22:29:00.01    9 |             arg = kwargs.pop(k,None)
                    22:29:00.01 .................. kwargs = {}
                    22:29:00.01 .................. arg = <function _f>
                    22:29:00.01   10 |             if arg is not None:
                    22:29:00.01   11 |                 if as_method: arg = method(arg)
                    22:29:00.01 ...... arg = <bound method int._f of 1>
                    22:29:00.01   12 |                 if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)
                    22:29:00.01 ...... arg = <bound method T._f of <fastcore.meta.T object>>
                    22:29:00.01   13 |                 setattr(self, k, arg)
                    22:29:00.01    8 |         for k in cls._methods:
                    22:29:00.01   14 |         old_init(self, *args, **kwargs)
                    22:29:00.01 <<< Return value from _funcs_kwargs.<locals>._init: None
                    22:29:00.01 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:29:00.01 .......... self = <fastcore.meta.T2 object>
                    22:29:00.01 .......... args = ()
                    22:29:00.01 .......... kwargs = {'b': <function _f>}
                    22:29:00.01 .......... len(kwargs) = 1
                    22:29:00.01 .......... as_method = True
                    22:29:00.01 .......... cls = <class 'fastcore.meta.T'>
                    22:29:00.01 .......... old_init = <slot wrapper '__init__' of 'object' objects>
                    22:29:00.01    7 |     def _init(self, *args, **kwargs):
                    22:29:00.01    8 |         for k in cls._methods:
                    22:29:00.01 .............. k = 'b'
                    22:29:00.01    9 |             arg = kwargs.pop(k,None)
                    22:29:00.01 .................. kwargs = {}
                    22:29:00.01 .................. arg = <function _f>
                    22:29:00.01   10 |             if arg is not None:
                    22:29:00.01   11 |                 if as_method: arg = method(arg)
                    22:29:00.01 ...... arg = <bound method int._f of 1>
                    22:29:00.01   12 |                 if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)
                    22:29:00.01 ...... arg = <bound method T2._f of <fastcore.meta.T2 object>>
                    22:29:00.01   13 |                 setattr(self, k, arg)
                    22:29:00.01    8 |         for k in cls._methods:
                    22:29:00.01   14 |         old_init(self, *args, **kwargs)
                    22:29:00.01 <<< Return value from _funcs_kwargs.<locals>._init: None
                
                
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                
                
                
                ```
                fdb_.debug()
                ```
                
                    _funcs_kwargs's dbsrc code: ==============
                    import snoop
                    @snoop
                    def _funcs_kwargs(cls, as_method):
                        old_init = cls.__init__
                        import snoop
                        @snoop
                        def _init(self, *args, **kwargs):
                            for k in cls._methods:
                                arg = kwargs.pop(k,None)
                                if arg is not None:
                                    if as_method: arg = method(arg)
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)
                                    setattr(self, k, arg)
                            old_init(self, *args, **kwargs)
                        functools.update_wrapper(_init, old_init)
                        cls.__init__ = use_kwargs(cls._methods)(_init)
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))
                        return cls
                    
                    
                    
                    _funcs_kwargs's example processed with dbsrc: ===============
                    
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    
                
                
                
                ```
                #| column: screen
                fdb.print()
                ```
                
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    def funcs_kwargs(as_method=False):========================================================(0)       
                        "Replace methods in `cls._methods` with those from `kwargs`"==========================(1) # [93;1mhow funcs_kwargs works[0m; [93;1mit is a wrapper around _funcs_kwargs[0m; [91;1mit offers two ways of running _funcs_kwargs[0m; [37;1mthe first, default way, is to add a func to a class without using self[0m; [91;1msecond way is to add func to class enabling self use;[0m; 
                        if callable(as_method): return _funcs_kwargs(as_method, False)========================(2) # [37;1mhow to check whether an object is callable[0m; [93;1mhow to return a result of running a func[0m; [37;1m[0m; 
                        return partial(_funcs_kwargs, as_method=as_method)====================================(3) # [92;1mhow to custom the params of `_funcs_kwargs` for a particular use with partial[0m; 
                                                                                                                                                                            (4)
                
                
                
                ```
                #| column: screen
                fdb_.print()
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m12[0m     ===============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    def _funcs_kwargs(cls, as_method):========================================================(0) # [93;1mhow does _funcs_kwargs work: _funcs_kwargs is a decorator[0m; [35;1mit helps class e.g., T to add more methods[0m; [93;1mI need to give the method a name, and put the name e.g., 'b' inside a list called _methods=['b'] inside class T[0m; [36;1mthen after writing a func e.g., _new_func, I can add it by T(b = _new_func)[0m; [36;1mif I want the func added to class to use self, I shall write @funcs_kwargs(as_method=True)[0m; 
                        old_init = cls.__init__===============================================================(1)       
                        def _init(self, *args, **kwargs):=====================================================(2) # [37;1mhow to define a method which can use self and accept any parameters[0m; 
                            for k in cls._methods:============================================================(3) # [35;1mhow to pop out the value of an item in a dict (with None as default), and if the item name is not found, pop out None instead[0m; [91;1m[0m; 
                                arg = kwargs.pop(k,None)======================================================(4)       
                                if arg is not None:===========================================================(5)       
                                    if as_method: arg = method(arg)===========================================(6) # [36;1mhow to turn a func into a method[0m; 
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)=======(7) # [93;1mhow to give a method a different instance, like self[0m; 
                                    setattr(self, k, arg)=====================================================(8) # [36;1mhow to add a method to a class as an attribute[0m; 
                            old_init(self, *args, **kwargs)===================================================(9)       
                        functools.update_wrapper(_init, old_init)=============================================(10) # [34;1mhow to wrap `_init` around `old_init`, so that `_init` can use `old_init` inside itself[0m; 
                        cls.__init__ = use_kwargs(cls._methods)(_init)========================================(11) # [34;1mhow to add a list of names with None as default value to function `_init` to repalce its kwargs param[0m; 
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__)) # [35;1mhow to make a class.`__init__` signature to be the signature of the class using `__signature__` and `_rm_self`[0m;  (12)
                        return cls============================================================================(13)      
                                                                                                                                                                            (14)
                
                
                
                ```
                
                ```
                
                
            
            
            
            [Open `0009_funcs_kwargs` in Jupyter Notebook](http://localhost:8888/tree/nbs/demos/0009_funcs_kwargs.ipynb)
            
            
            
        
        
        
        [Open `utils` in Jupyter Notebook](http://localhost:8888/tree/nbs/lib/utils.ipynb)
        
        
        
        
    
    
    
    [Open `utils` in Jupyter Notebook](http://localhost:8888/tree/nbs/lib/utils.ipynb)
    
    
    
    



[Open `utils` in Jupyter Notebook locally](http://localhost:8888/tree/nbs/lib/utils.ipynb)



###  <mark style="background-color: #ffff00">snoop:</mark>   <mark style="background-color: #ffff00">from</mark>   <mark style="background-color: #ffff00">_ <mark style="background-color: #FFFF00">funcs_kwargs</mark> </mark>   <mark style="background-color: #ffff00">to</mark>   <mark style="background-color: #FFFF00">funcs_kwargs</mark> 



    
    
    
        
        
        
            
            
            
                
                how to snoop on two functions one wrap around another: `funcs_kwargs` is a wrapper around `_funcs_kwargs`, so I can first snoop on `_funcs_kwargs` and assign its snoop dbsrc to \
                `fm._funcs_kwargs` so that when I snoop on `funcs_kwargs`, it can use the snoop dbsrc of `_funcs_kwargs` and no example codes need to change.
                
                
                ```
                from fastcore.meta import _funcs_kwargs
                ```
                
                
                ```
                fdb_ = Fastdb(_funcs_kwargs)
                fdb_.eg = """
                @funcs_kwargs
                class T:
                    _methods=['b'] # allows you to add method b upon instantiation
                    def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                    def a(self): return 1
                    def b(self): return 2
                    
                t = T()
                test_eq(t.a(), 1)
                test_eq(t.b(), 2)
                
                test_sig(T, '(f=1, *, b=None)')
                inspect.signature(T)
                
                def _new_func(): return 5
                
                t = T(b = _new_func)
                test_eq(t.b(), 5)
                
                t = T(a = lambda:3)
                test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                """
                ```
                
                
                ```
                #| column: screen
                # no snoop result, it is expected, because the example is not calling _funcs_kwargs, but funcs_kwargs
                fdb_.snoop(deco=True) # how to snoop decorator: _funcs_kwargs is a decorator, so set deco=True to see running codes in inner f
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    [0m     
                    
                
                
                
                ```
                import fastcore.meta as fm
                ```
                
                
                ```
                fm._funcs_kwargs = fdb_.dbsrc # how to snoop on two functions one wrap around another
                ```
                
                
                ```
                fdb = Fastdb(funcs_kwargs)
                fdb.eg = """
                @funcs_kwargs
                class T:
                    _methods=['b'] # allows you to add method b upon instantiation
                    def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                    def a(self): return 1
                    def b(self): return 2
                    
                t = T()
                test_eq(t.a(), 1)
                test_eq(t.b(), 2)
                
                test_sig(T, '(f=1, *, b=None)')
                inspect.signature(T)
                
                def _new_func(): return 5
                
                t = T(b = _new_func)
                test_eq(t.b(), 5)
                
                t = T(a = lambda:3)
                test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                
                def _f(self,a=1): return self.num + a # access the num attribute from the instance
                
                @funcs_kwargs(as_method=True)
                class T: 
                    _methods=['b']
                    num = 5
                    
                t = T(b = _f) # adds method b
                test_eq(t.b(5), 10) # self.num + 5 = 10
                
                def _f(self,a=1): return self.num * a #multiply instead of add 
                
                class T2(T):
                    def __init__(self,num):
                        super().__init__(b = _f) # add method b from the super class
                        self.num=num
                        
                t = T2(num=3)
                test_eq(t.b(a=5), 15) # 3 * 5 = 15
                test_sig(T2, '(num)')
                """
                ```
                
                
                ```
                #| column: screen
                fdb.print()
                ```
                
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    def funcs_kwargs(as_method=False):========================================================(0)       
                        "Replace methods in `cls._methods` with those from `kwargs`"==========================(1)       
                        if callable(as_method): return _funcs_kwargs(as_method, False)========================(2)       
                        return partial(_funcs_kwargs, as_method=as_method)====================================(3)       
                                                                                                                                                                            (4)
                
                
                
                ```
                #| column: screen
                fdb_.print()
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    def _funcs_kwargs(cls, as_method):========================================================(0)       
                        old_init = cls.__init__===============================================================(1)       
                        def _init(self, *args, **kwargs):=====================================================(2)       
                            for k in cls._methods:============================================================(3)       
                                arg = kwargs.pop(k,None)======================================================(4)       
                                if arg is not None:===========================================================(5)       
                                    if as_method: arg = method(arg)===========================================(6)       
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)=======(7)       
                                    setattr(self, k, arg)=====================================================(8)       
                            old_init(self, *args, **kwargs)===================================================(9)       
                        functools.update_wrapper(_init, old_init)=============================================(10)      
                        cls.__init__ = use_kwargs(cls._methods)(_init)========================================(11)      
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))                                                     (12)
                        return cls============================================================================(13)      
                                                                                                                                                                            (14)
                
                
                
                ```
                #| column: screen
                fdb.docsrc(1, "how funcs_kwargs works; it is a wrapper around _funcs_kwargs; it offers two ways of running _funcs_kwargs; \
                the first, default way, is to add a func to a class without using self; second way is to add func to class enabling self use;")
                fdb.docsrc(2, "how to check whether an object is callable; how to return a result of running a func; ")
                fdb.docsrc(3, "how to custom the params of `_funcs_kwargs` for a particular use with partial")
                ```
                
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m1[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                    def funcs_kwargs(as_method=False):                                                                                                                      (0)
                        "Replace methods in `cls._methods` with those from `kwargs`"========================================================================================(1)
                    [91;1mhow funcs_kwargs works; it is a wrapper around _funcs_kwargs; it offers two ways of running _funcs_kwargs; the first, default way, is to add a func to a class without using self; second way is to add func to class enabling self use;[0m
                        if callable(as_method): return _funcs_kwargs(as_method, False)                                                                                      (2)
                        return partial(_funcs_kwargs, as_method=as_method)                                                                                                  (3)
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m2[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                    def funcs_kwargs(as_method=False):                                                                                                                      (0)
                        "Replace methods in `cls._methods` with those from `kwargs`"                                                                                        (1)
                        if callable(as_method): return _funcs_kwargs(as_method, False)======================================================================================(2)
                                                                                           [91;1mhow to check whether an object is callable; how to return a result of running a func; [0m
                        return partial(_funcs_kwargs, as_method=as_method)                                                                                                  (3)
                                                                                                                                                                            (4)
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m3[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                        "Replace methods in `cls._methods` with those from `kwargs`"                                                                                        (1)
                        if callable(as_method): return _funcs_kwargs(as_method, False)                                                                                      (2)
                        return partial(_funcs_kwargs, as_method=as_method)==================================================================================================(3)
                                                                                                    [91;1mhow to custom the params of `_funcs_kwargs` for a particular use with partial[0m
                                                                                                                                                                            (4)
                
                
                
                ```
                #| column: screen
                fdb_.print()
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    def _funcs_kwargs(cls, as_method):========================================================(0)       
                        old_init = cls.__init__===============================================================(1)       
                        def _init(self, *args, **kwargs):=====================================================(2)       
                            for k in cls._methods:============================================================(3)       
                                arg = kwargs.pop(k,None)======================================================(4)       
                                if arg is not None:===========================================================(5)       
                                    if as_method: arg = method(arg)===========================================(6)       
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)=======(7)       
                                    setattr(self, k, arg)=====================================================(8)       
                            old_init(self, *args, **kwargs)===================================================(9)       
                        functools.update_wrapper(_init, old_init)=============================================(10)      
                        cls.__init__ = use_kwargs(cls._methods)(_init)========================================(11)      
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))                                                     (12)
                        return cls============================================================================(13)      
                                                                                                                                                                            (14)
                
                
                
                ```
                #| column: screen
                fdb_.docsrc(0, "how does _funcs_kwargs work: _funcs_kwargs is a decorator; it helps class e.g., T to add more methods; \
                I need to give the method a name, \
                and put the name e.g., 'b' inside a list called _methods=['b'] inside class T; \
                then after writing a func e.g., _new_func, I can add it by T(b = _new_func); if I want the func added to class to use self, \
                I shall write @funcs_kwargs(as_method=True)")
                fdb_.docsrc(2, "how to define a method which can use self and accept any parameters")
                fdb_.docsrc(3, "how to pop out the value of an item in a dict (with None as default), and if the item name is not found, pop out None instead; ")
                fdb_.docsrc(6, "how to turn a func into a method")
                fdb_.docsrc(7, "how to give a method a different instance, like self")
                fdb_.docsrc(8, "how to add a method to a class as an attribute")
                fdb_.docsrc(10, "how to wrap `_init` around `old_init`, so that `_init` can use `old_init` inside itself")
                fdb_.docsrc(11, "how to add a list of names with None as default value to function `_init` to repalce its kwargs param")
                fdb_.docsrc(12, "how to make a class.`__init__` signature to be the signature of the class using `__signature__` and `_rm_self`")
                
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m0[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                    def _funcs_kwargs(cls, as_method):======================================================================================================================(0)
                    [91;1mhow does _funcs_kwargs work: _funcs_kwargs is a decorator; it helps class e.g., T to add more methods; I need to give the method a name, and put the name e.g., 'b' inside a list called _methods=['b'] inside class T; then after writing a func e.g., _new_func, I can add it by T(b = _new_func); if I want the func added to class to use self, I shall write @funcs_kwargs(as_method=True)[0m
                        old_init = cls.__init__                                                                                                                             (1)
                        def _init(self, *args, **kwargs):                                                                                                                   (2)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m2[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                    def _funcs_kwargs(cls, as_method):                                                                                                                      (0)
                        old_init = cls.__init__                                                                                                                             (1)
                        def _init(self, *args, **kwargs):===================================================================================================================(2)
                                                                                                              [91;1mhow to define a method which can use self and accept any parameters[0m
                            for k in cls._methods:                                                                                                                          (3)
                                arg = kwargs.pop(k,None)                                                                                                                    (4)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m3[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                        old_init = cls.__init__                                                                                                                             (1)
                        def _init(self, *args, **kwargs):                                                                                                                   (2)
                            for k in cls._methods:==========================================================================================================================(3)
                                                  [91;1mhow to pop out the value of an item in a dict (with None as default), and if the item name is not found, pop out None instead; [0m
                                arg = kwargs.pop(k,None)                                                                                                                    (4)
                                if arg is not None:                                                                                                                         (5)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m6[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                                arg = kwargs.pop(k,None)                                                                                                                    (4)
                                if arg is not None:                                                                                                                         (5)
                                    if as_method: arg = method(arg)=========================================================================================================(6)
                                                                                                                                                 [91;1mhow to turn a func into a method[0m
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)                                                                     (7)
                                    setattr(self, k, arg)                                                                                                                   (8)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m7[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                                if arg is not None:                                                                                                                         (5)
                                    if as_method: arg = method(arg)                                                                                                         (6)
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)=====================================================================(7)
                                                                                                                             [91;1mhow to give a method a different instance, like self[0m
                                    setattr(self, k, arg)                                                                                                                   (8)
                            old_init(self, *args, **kwargs)                                                                                                                 (9)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m8[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                                    if as_method: arg = method(arg)                                                                                                         (6)
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)                                                                     (7)
                                    setattr(self, k, arg)===================================================================================================================(8)
                                                                                                                                   [91;1mhow to add a method to a class as an attribute[0m
                            old_init(self, *args, **kwargs)                                                                                                                 (9)
                        functools.update_wrapper(_init, old_init)                                                                                                           (10)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m10[0m     ===============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                                    setattr(self, k, arg)                                                                                                                   (8)
                            old_init(self, *args, **kwargs)                                                                                                                 (9)
                        functools.update_wrapper(_init, old_init)===========================================================================================================(10)
                                                                                          [91;1mhow to wrap `_init` around `old_init`, so that `_init` can use `old_init` inside itself[0m
                        cls.__init__ = use_kwargs(cls._methods)(_init)                                                                                                      (11)
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))                                                     (12)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m11[0m     ===============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                            old_init(self, *args, **kwargs)                                                                                                                 (9)
                        functools.update_wrapper(_init, old_init)                                                                                                           (10)
                        cls.__init__ = use_kwargs(cls._methods)(_init)======================================================================================================(11)
                                                                            [91;1mhow to add a list of names with None as default value to function `_init` to repalce its kwargs param[0m
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))                                                     (12)
                        return cls                                                                                                                                          (13)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m12[0m     ===============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                        functools.update_wrapper(_init, old_init)                                                                                                           (10)
                        cls.__init__ = use_kwargs(cls._methods)(_init)                                                                                                      (11)
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))=====================================================(12)
                                                                   [91;1mhow to make a class.`__init__` signature to be the signature of the class using `__signature__` and `_rm_self`[0m
                        return cls                                                                                                                                          (13)
                                                                                                                                                                            (14)
                
                
                
                ```
                #| column: screen
                fdb.snoop() # how to snoop together with docsrc: snoop first and docsrc above it
                ```
                
                    22:28:59.99 >>> Call to funcs_kwargs in File "/tmp/funcs_kwargs.py", line 3
                    22:28:59.99 ...... as_method = <class 'fastcore.meta.T'>
                    22:28:59.99    3 | def funcs_kwargs(as_method=False):
                    22:28:59.99    5 |     if callable(as_method): return _funcs_kwargs(as_method, False)
                        22:28:59.99 >>> Call to _funcs_kwargs in File "/tmp/_funcs_kwargs.py", line 3
                        22:28:59.99 ...... cls = <class 'fastcore.meta.T'>
                        22:28:59.99 ...... as_method = False
                        22:28:59.99    3 | def _funcs_kwargs(cls, as_method):
                        22:28:59.99    4 |     old_init = cls.__init__
                        22:28:59.99 .......... old_init = <function T.__init__>
                        22:28:59.99    5 |     import snoop
                        22:28:59.99 .......... snoop = <class 'snoop.configuration.Config.__init__.<locals>.ConfiguredTracer'>
                        22:28:59.99    6 |     @snoop
                        22:28:59.99    7 |     def _init(self, *args, **kwargs):
                        22:28:59.99 .......... _init = <function _funcs_kwargs.<locals>._init>
                        22:28:59.99   15 |     functools.update_wrapper(_init, old_init)
                        22:28:59.99 .......... _init = <function T.__init__>
                        22:28:59.99   16 |     cls.__init__ = use_kwargs(cls._methods)(_init)
                        22:28:59.99   17 |     if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))
                        22:28:59.99   18 |     return cls
                        22:28:59.99 <<< Return value from _funcs_kwargs: <class 'fastcore.meta.T'>
                    22:28:59.99    5 |     if callable(as_method): return _funcs_kwargs(as_method, False)
                    22:28:59.99 <<< Return value from funcs_kwargs: <class 'fastcore.meta.T'>
                    22:28:59.99 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:28:59.99 .......... self = <fastcore.meta.T object>
                    22:28:59.99 .......... args = ()
                    22:28:59.99 .......... kwargs = {}
                    22:28:59.99 .......... as_method = False
                    22:28:59.99 .......... cls = <class 'fastcore.meta.T'>
                    22:28:59.99 .......... old_init = <function T.__init__>
                    22:28:59.99    7 |     def _init(self, *args, **kwargs):
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00 .............. k = 'b'
                    22:29:00.00    9 |             arg = kwargs.pop(k,None)
                    22:29:00.00 .................. arg = None
                    22:29:00.00   10 |             if arg is not None:
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00   14 |         old_init(self, *args, **kwargs)
                    22:29:00.00 <<< Return value from _funcs_kwargs.<locals>._init: None
                    22:29:00.00 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:29:00.00 .......... self = <fastcore.meta.T object>
                    22:29:00.00 .......... args = ()
                    22:29:00.00 .......... kwargs = {'b': <function _new_func>}
                    22:29:00.00 .......... len(kwargs) = 1
                    22:29:00.00 .......... as_method = False
                    22:29:00.00 .......... cls = <class 'fastcore.meta.T'>
                    22:29:00.00 .......... old_init = <function T.__init__>
                    22:29:00.00    7 |     def _init(self, *args, **kwargs):
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00 .............. k = 'b'
                    22:29:00.00    9 |             arg = kwargs.pop(k,None)
                    22:29:00.00 .................. kwargs = {}
                    22:29:00.00 .................. arg = <function _new_func>
                    22:29:00.00   10 |             if arg is not None:
                    22:29:00.00   11 |                 if as_method: arg = method(arg)
                    22:29:00.00   12 |                 if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)
                    22:29:00.00   13 |                 setattr(self, k, arg)
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00   14 |         old_init(self, *args, **kwargs)
                    22:29:00.00 <<< Return value from _funcs_kwargs.<locals>._init: None
                    22:29:00.00 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:29:00.00 .......... self = <fastcore.meta.T object>
                    22:29:00.00 .......... args = ()
                    22:29:00.00 .......... kwargs = {'a': <function <lambda>>}
                    22:29:00.00 .......... len(kwargs) = 1
                    22:29:00.00 .......... as_method = False
                    22:29:00.00 .......... cls = <class 'fastcore.meta.T'>
                    22:29:00.00 .......... old_init = <function T.__init__>
                    22:29:00.00    7 |     def _init(self, *args, **kwargs):
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00 .............. k = 'b'
                    22:29:00.00    9 |             arg = kwargs.pop(k,None)
                    22:29:00.00 .................. arg = None
                    22:29:00.00   10 |             if arg is not None:
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00   14 |         old_init(self, *args, **kwargs)
                    22:29:00.00 <<< Return value from _funcs_kwargs.<locals>._init: None
                    22:29:00.00 >>> Call to funcs_kwargs in File "/tmp/funcs_kwargs.py", line 3
                    22:29:00.00 ...... as_method = True
                    22:29:00.00    3 | def funcs_kwargs(as_method=False):
                    22:29:00.00    5 |     if callable(as_method): return _funcs_kwargs(as_method, False)
                    22:29:00.00    6 |     return partial(_funcs_kwargs, as_method=as_method)
                    22:29:00.00 <<< Return value from funcs_kwargs: functools.partial(<function _funcs_kwargs>, as_method=True)
                    22:29:00.00 >>> Call to _funcs_kwargs in File "/tmp/_funcs_kwargs.py", line 3
                    22:29:00.00 ...... cls = <class 'fastcore.meta.T'>
                    22:29:00.00 ...... as_method = True
                    22:29:00.00    3 | def _funcs_kwargs(cls, as_method):
                    22:29:00.00    4 |     old_init = cls.__init__
                    22:29:00.00 .......... old_init = <slot wrapper '__init__' of 'object' objects>
                    22:29:00.00    5 |     import snoop
                    22:29:00.00 .......... snoop = <class 'snoop.configuration.Config.__init__.<locals>.ConfiguredTracer'>
                    22:29:00.00    6 |     @snoop
                    22:29:00.00    7 |     def _init(self, *args, **kwargs):
                    22:29:00.00 .......... _init = <function _funcs_kwargs.<locals>._init>
                    22:29:00.00   15 |     functools.update_wrapper(_init, old_init)
                    22:29:00.00 .......... _init = <function object.__init__>
                    22:29:00.00   16 |     cls.__init__ = use_kwargs(cls._methods)(_init)
                    22:29:00.01   17 |     if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))
                    22:29:00.01   18 |     return cls
                    22:29:00.01 <<< Return value from _funcs_kwargs: <class 'fastcore.meta.T'>
                    22:29:00.01 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:29:00.01 .......... self = <fastcore.meta.T object>
                    22:29:00.01 .......... args = ()
                    22:29:00.01 .......... kwargs = {'b': <function _f>}
                    22:29:00.01 .......... len(kwargs) = 1
                    22:29:00.01 .......... as_method = True
                    22:29:00.01 .......... cls = <class 'fastcore.meta.T'>
                    22:29:00.01 .......... old_init = <slot wrapper '__init__' of 'object' objects>
                    22:29:00.01    7 |     def _init(self, *args, **kwargs):
                    22:29:00.01    8 |         for k in cls._methods:
                    22:29:00.01 .............. k = 'b'
                    22:29:00.01    9 |             arg = kwargs.pop(k,None)
                    22:29:00.01 .................. kwargs = {}
                    22:29:00.01 .................. arg = <function _f>
                    22:29:00.01   10 |             if arg is not None:
                    22:29:00.01   11 |                 if as_method: arg = method(arg)
                    22:29:00.01 ...... arg = <bound method int._f of 1>
                    22:29:00.01   12 |                 if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)
                    22:29:00.01 ...... arg = <bound method T._f of <fastcore.meta.T object>>
                    22:29:00.01   13 |                 setattr(self, k, arg)
                    22:29:00.01    8 |         for k in cls._methods:
                    22:29:00.01   14 |         old_init(self, *args, **kwargs)
                    22:29:00.01 <<< Return value from _funcs_kwargs.<locals>._init: None
                    22:29:00.01 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:29:00.01 .......... self = <fastcore.meta.T2 object>
                    22:29:00.01 .......... args = ()
                    22:29:00.01 .......... kwargs = {'b': <function _f>}
                    22:29:00.01 .......... len(kwargs) = 1
                    22:29:00.01 .......... as_method = True
                    22:29:00.01 .......... cls = <class 'fastcore.meta.T'>
                    22:29:00.01 .......... old_init = <slot wrapper '__init__' of 'object' objects>
                    22:29:00.01    7 |     def _init(self, *args, **kwargs):
                    22:29:00.01    8 |         for k in cls._methods:
                    22:29:00.01 .............. k = 'b'
                    22:29:00.01    9 |             arg = kwargs.pop(k,None)
                    22:29:00.01 .................. kwargs = {}
                    22:29:00.01 .................. arg = <function _f>
                    22:29:00.01   10 |             if arg is not None:
                    22:29:00.01   11 |                 if as_method: arg = method(arg)
                    22:29:00.01 ...... arg = <bound method int._f of 1>
                    22:29:00.01   12 |                 if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)
                    22:29:00.01 ...... arg = <bound method T2._f of <fastcore.meta.T2 object>>
                    22:29:00.01   13 |                 setattr(self, k, arg)
                    22:29:00.01    8 |         for k in cls._methods:
                    22:29:00.01   14 |         old_init(self, *args, **kwargs)
                    22:29:00.01 <<< Return value from _funcs_kwargs.<locals>._init: None
                
                
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                
                
                
                ```
                fdb_.debug()
                ```
                
                    _funcs_kwargs's dbsrc code: ==============
                    import snoop
                    @snoop
                    def _funcs_kwargs(cls, as_method):
                        old_init = cls.__init__
                        import snoop
                        @snoop
                        def _init(self, *args, **kwargs):
                            for k in cls._methods:
                                arg = kwargs.pop(k,None)
                                if arg is not None:
                                    if as_method: arg = method(arg)
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)
                                    setattr(self, k, arg)
                            old_init(self, *args, **kwargs)
                        functools.update_wrapper(_init, old_init)
                        cls.__init__ = use_kwargs(cls._methods)(_init)
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))
                        return cls
                    
                    
                    
                    _funcs_kwargs's example processed with dbsrc: ===============
                    
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    
                
                
                
                ```
                #| column: screen
                fdb.print()
                ```
                
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    def funcs_kwargs(as_method=False):========================================================(0)       
                        "Replace methods in `cls._methods` with those from `kwargs`"==========================(1) # [93;1mhow funcs_kwargs works[0m; [93;1mit is a wrapper around _funcs_kwargs[0m; [91;1mit offers two ways of running _funcs_kwargs[0m; [37;1mthe first, default way, is to add a func to a class without using self[0m; [91;1msecond way is to add func to class enabling self use;[0m; 
                        if callable(as_method): return _funcs_kwargs(as_method, False)========================(2) # [37;1mhow to check whether an object is callable[0m; [93;1mhow to return a result of running a func[0m; [37;1m[0m; 
                        return partial(_funcs_kwargs, as_method=as_method)====================================(3) # [92;1mhow to custom the params of `_funcs_kwargs` for a particular use with partial[0m; 
                                                                                                                                                                            (4)
                
                
                
                ```
                #| column: screen
                fdb_.print()
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m12[0m     ===============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    def _funcs_kwargs(cls, as_method):========================================================(0) # [93;1mhow does _funcs_kwargs work: _funcs_kwargs is a decorator[0m; [35;1mit helps class e.g., T to add more methods[0m; [93;1mI need to give the method a name, and put the name e.g., 'b' inside a list called _methods=['b'] inside class T[0m; [36;1mthen after writing a func e.g., _new_func, I can add it by T(b = _new_func)[0m; [36;1mif I want the func added to class to use self, I shall write @funcs_kwargs(as_method=True)[0m; 
                        old_init = cls.__init__===============================================================(1)       
                        def _init(self, *args, **kwargs):=====================================================(2) # [37;1mhow to define a method which can use self and accept any parameters[0m; 
                            for k in cls._methods:============================================================(3) # [35;1mhow to pop out the value of an item in a dict (with None as default), and if the item name is not found, pop out None instead[0m; [91;1m[0m; 
                                arg = kwargs.pop(k,None)======================================================(4)       
                                if arg is not None:===========================================================(5)       
                                    if as_method: arg = method(arg)===========================================(6) # [36;1mhow to turn a func into a method[0m; 
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)=======(7) # [93;1mhow to give a method a different instance, like self[0m; 
                                    setattr(self, k, arg)=====================================================(8) # [36;1mhow to add a method to a class as an attribute[0m; 
                            old_init(self, *args, **kwargs)===================================================(9)       
                        functools.update_wrapper(_init, old_init)=============================================(10) # [34;1mhow to wrap `_init` around `old_init`, so that `_init` can use `old_init` inside itself[0m; 
                        cls.__init__ = use_kwargs(cls._methods)(_init)========================================(11) # [34;1mhow to add a list of names with None as default value to function `_init` to repalce its kwargs param[0m; 
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__)) # [35;1mhow to make a class.`__init__` signature to be the signature of the class using `__signature__` and `_rm_self`[0m;  (12)
                        return cls============================================================================(13)      
                                                                                                                                                                            (14)
                
                
                
                ```
                
                ```
                
                
            
            
            
            [Open `0009_funcs_kwargs` in Jupyter Notebook](http://localhost:8888/tree/nbs/demos/0009_funcs_kwargs.ipynb)
            
            
            
        
        
        
        [Open `utils` in Jupyter Notebook](http://localhost:8888/tree/nbs/lib/utils.ipynb)
        
        
        
        
    
    
    
    [Open `utils` in Jupyter Notebook](http://localhost:8888/tree/nbs/lib/utils.ipynb)
    
    
    
    



[Open `utils` in Jupyter Notebook locally](http://localhost:8888/tree/nbs/lib/utils.ipynb)



###  <mark style="background-color: #ffff00">snoop:</mark>   <mark style="background-color: #ffff00">from</mark>   <mark style="background-color: #ffff00">_ <mark style="background-color: #FFFF00">funcs_kwargs</mark> </mark>   <mark style="background-color: #ffff00">to</mark>   <mark style="background-color: #FFFF00">funcs_kwargs</mark> 



    
    
    
        
        
        
            
            
            
                
                how to snoop on two functions one wrap around another: `funcs_kwargs` is a wrapper around `_funcs_kwargs`, so I can first snoop on `_funcs_kwargs` and assign its snoop dbsrc to \
                `fm._funcs_kwargs` so that when I snoop on `funcs_kwargs`, it can use the snoop dbsrc of `_funcs_kwargs` and no example codes need to change.
                
                
                ```
                from fastcore.meta import _funcs_kwargs
                ```
                
                
                ```
                fdb_ = Fastdb(_funcs_kwargs)
                fdb_.eg = """
                @funcs_kwargs
                class T:
                    _methods=['b'] # allows you to add method b upon instantiation
                    def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                    def a(self): return 1
                    def b(self): return 2
                    
                t = T()
                test_eq(t.a(), 1)
                test_eq(t.b(), 2)
                
                test_sig(T, '(f=1, *, b=None)')
                inspect.signature(T)
                
                def _new_func(): return 5
                
                t = T(b = _new_func)
                test_eq(t.b(), 5)
                
                t = T(a = lambda:3)
                test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                """
                ```
                
                
                ```
                #| column: screen
                # no snoop result, it is expected, because the example is not calling _funcs_kwargs, but funcs_kwargs
                fdb_.snoop(deco=True) # how to snoop decorator: _funcs_kwargs is a decorator, so set deco=True to see running codes in inner f
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    [0m     
                    
                
                
                
                ```
                import fastcore.meta as fm
                ```
                
                
                ```
                fm._funcs_kwargs = fdb_.dbsrc # how to snoop on two functions one wrap around another
                ```
                
                
                ```
                fdb = Fastdb(funcs_kwargs)
                fdb.eg = """
                @funcs_kwargs
                class T:
                    _methods=['b'] # allows you to add method b upon instantiation
                    def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                    def a(self): return 1
                    def b(self): return 2
                    
                t = T()
                test_eq(t.a(), 1)
                test_eq(t.b(), 2)
                
                test_sig(T, '(f=1, *, b=None)')
                inspect.signature(T)
                
                def _new_func(): return 5
                
                t = T(b = _new_func)
                test_eq(t.b(), 5)
                
                t = T(a = lambda:3)
                test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                
                def _f(self,a=1): return self.num + a # access the num attribute from the instance
                
                @funcs_kwargs(as_method=True)
                class T: 
                    _methods=['b']
                    num = 5
                    
                t = T(b = _f) # adds method b
                test_eq(t.b(5), 10) # self.num + 5 = 10
                
                def _f(self,a=1): return self.num * a #multiply instead of add 
                
                class T2(T):
                    def __init__(self,num):
                        super().__init__(b = _f) # add method b from the super class
                        self.num=num
                        
                t = T2(num=3)
                test_eq(t.b(a=5), 15) # 3 * 5 = 15
                test_sig(T2, '(num)')
                """
                ```
                
                
                ```
                #| column: screen
                fdb.print()
                ```
                
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    def funcs_kwargs(as_method=False):========================================================(0)       
                        "Replace methods in `cls._methods` with those from `kwargs`"==========================(1)       
                        if callable(as_method): return _funcs_kwargs(as_method, False)========================(2)       
                        return partial(_funcs_kwargs, as_method=as_method)====================================(3)       
                                                                                                                                                                            (4)
                
                
                
                ```
                #| column: screen
                fdb_.print()
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    def _funcs_kwargs(cls, as_method):========================================================(0)       
                        old_init = cls.__init__===============================================================(1)       
                        def _init(self, *args, **kwargs):=====================================================(2)       
                            for k in cls._methods:============================================================(3)       
                                arg = kwargs.pop(k,None)======================================================(4)       
                                if arg is not None:===========================================================(5)       
                                    if as_method: arg = method(arg)===========================================(6)       
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)=======(7)       
                                    setattr(self, k, arg)=====================================================(8)       
                            old_init(self, *args, **kwargs)===================================================(9)       
                        functools.update_wrapper(_init, old_init)=============================================(10)      
                        cls.__init__ = use_kwargs(cls._methods)(_init)========================================(11)      
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))                                                     (12)
                        return cls============================================================================(13)      
                                                                                                                                                                            (14)
                
                
                
                ```
                #| column: screen
                fdb.docsrc(1, "how funcs_kwargs works; it is a wrapper around _funcs_kwargs; it offers two ways of running _funcs_kwargs; \
                the first, default way, is to add a func to a class without using self; second way is to add func to class enabling self use;")
                fdb.docsrc(2, "how to check whether an object is callable; how to return a result of running a func; ")
                fdb.docsrc(3, "how to custom the params of `_funcs_kwargs` for a particular use with partial")
                ```
                
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m1[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                    def funcs_kwargs(as_method=False):                                                                                                                      (0)
                        "Replace methods in `cls._methods` with those from `kwargs`"========================================================================================(1)
                    [91;1mhow funcs_kwargs works; it is a wrapper around _funcs_kwargs; it offers two ways of running _funcs_kwargs; the first, default way, is to add a func to a class without using self; second way is to add func to class enabling self use;[0m
                        if callable(as_method): return _funcs_kwargs(as_method, False)                                                                                      (2)
                        return partial(_funcs_kwargs, as_method=as_method)                                                                                                  (3)
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m2[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                    def funcs_kwargs(as_method=False):                                                                                                                      (0)
                        "Replace methods in `cls._methods` with those from `kwargs`"                                                                                        (1)
                        if callable(as_method): return _funcs_kwargs(as_method, False)======================================================================================(2)
                                                                                           [91;1mhow to check whether an object is callable; how to return a result of running a func; [0m
                        return partial(_funcs_kwargs, as_method=as_method)                                                                                                  (3)
                                                                                                                                                                            (4)
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m3[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                        "Replace methods in `cls._methods` with those from `kwargs`"                                                                                        (1)
                        if callable(as_method): return _funcs_kwargs(as_method, False)                                                                                      (2)
                        return partial(_funcs_kwargs, as_method=as_method)==================================================================================================(3)
                                                                                                    [91;1mhow to custom the params of `_funcs_kwargs` for a particular use with partial[0m
                                                                                                                                                                            (4)
                
                
                
                ```
                #| column: screen
                fdb_.print()
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    def _funcs_kwargs(cls, as_method):========================================================(0)       
                        old_init = cls.__init__===============================================================(1)       
                        def _init(self, *args, **kwargs):=====================================================(2)       
                            for k in cls._methods:============================================================(3)       
                                arg = kwargs.pop(k,None)======================================================(4)       
                                if arg is not None:===========================================================(5)       
                                    if as_method: arg = method(arg)===========================================(6)       
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)=======(7)       
                                    setattr(self, k, arg)=====================================================(8)       
                            old_init(self, *args, **kwargs)===================================================(9)       
                        functools.update_wrapper(_init, old_init)=============================================(10)      
                        cls.__init__ = use_kwargs(cls._methods)(_init)========================================(11)      
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))                                                     (12)
                        return cls============================================================================(13)      
                                                                                                                                                                            (14)
                
                
                
                ```
                #| column: screen
                fdb_.docsrc(0, "how does _funcs_kwargs work: _funcs_kwargs is a decorator; it helps class e.g., T to add more methods; \
                I need to give the method a name, \
                and put the name e.g., 'b' inside a list called _methods=['b'] inside class T; \
                then after writing a func e.g., _new_func, I can add it by T(b = _new_func); if I want the func added to class to use self, \
                I shall write @funcs_kwargs(as_method=True)")
                fdb_.docsrc(2, "how to define a method which can use self and accept any parameters")
                fdb_.docsrc(3, "how to pop out the value of an item in a dict (with None as default), and if the item name is not found, pop out None instead; ")
                fdb_.docsrc(6, "how to turn a func into a method")
                fdb_.docsrc(7, "how to give a method a different instance, like self")
                fdb_.docsrc(8, "how to add a method to a class as an attribute")
                fdb_.docsrc(10, "how to wrap `_init` around `old_init`, so that `_init` can use `old_init` inside itself")
                fdb_.docsrc(11, "how to add a list of names with None as default value to function `_init` to repalce its kwargs param")
                fdb_.docsrc(12, "how to make a class.`__init__` signature to be the signature of the class using `__signature__` and `_rm_self`")
                
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m0[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                    def _funcs_kwargs(cls, as_method):======================================================================================================================(0)
                    [91;1mhow does _funcs_kwargs work: _funcs_kwargs is a decorator; it helps class e.g., T to add more methods; I need to give the method a name, and put the name e.g., 'b' inside a list called _methods=['b'] inside class T; then after writing a func e.g., _new_func, I can add it by T(b = _new_func); if I want the func added to class to use self, I shall write @funcs_kwargs(as_method=True)[0m
                        old_init = cls.__init__                                                                                                                             (1)
                        def _init(self, *args, **kwargs):                                                                                                                   (2)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m2[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                    def _funcs_kwargs(cls, as_method):                                                                                                                      (0)
                        old_init = cls.__init__                                                                                                                             (1)
                        def _init(self, *args, **kwargs):===================================================================================================================(2)
                                                                                                              [91;1mhow to define a method which can use self and accept any parameters[0m
                            for k in cls._methods:                                                                                                                          (3)
                                arg = kwargs.pop(k,None)                                                                                                                    (4)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m3[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                        old_init = cls.__init__                                                                                                                             (1)
                        def _init(self, *args, **kwargs):                                                                                                                   (2)
                            for k in cls._methods:==========================================================================================================================(3)
                                                  [91;1mhow to pop out the value of an item in a dict (with None as default), and if the item name is not found, pop out None instead; [0m
                                arg = kwargs.pop(k,None)                                                                                                                    (4)
                                if arg is not None:                                                                                                                         (5)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m6[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                                arg = kwargs.pop(k,None)                                                                                                                    (4)
                                if arg is not None:                                                                                                                         (5)
                                    if as_method: arg = method(arg)=========================================================================================================(6)
                                                                                                                                                 [91;1mhow to turn a func into a method[0m
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)                                                                     (7)
                                    setattr(self, k, arg)                                                                                                                   (8)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m7[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                                if arg is not None:                                                                                                                         (5)
                                    if as_method: arg = method(arg)                                                                                                         (6)
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)=====================================================================(7)
                                                                                                                             [91;1mhow to give a method a different instance, like self[0m
                                    setattr(self, k, arg)                                                                                                                   (8)
                            old_init(self, *args, **kwargs)                                                                                                                 (9)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m8[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                                    if as_method: arg = method(arg)                                                                                                         (6)
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)                                                                     (7)
                                    setattr(self, k, arg)===================================================================================================================(8)
                                                                                                                                   [91;1mhow to add a method to a class as an attribute[0m
                            old_init(self, *args, **kwargs)                                                                                                                 (9)
                        functools.update_wrapper(_init, old_init)                                                                                                           (10)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m10[0m     ===============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                                    setattr(self, k, arg)                                                                                                                   (8)
                            old_init(self, *args, **kwargs)                                                                                                                 (9)
                        functools.update_wrapper(_init, old_init)===========================================================================================================(10)
                                                                                          [91;1mhow to wrap `_init` around `old_init`, so that `_init` can use `old_init` inside itself[0m
                        cls.__init__ = use_kwargs(cls._methods)(_init)                                                                                                      (11)
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))                                                     (12)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m11[0m     ===============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                            old_init(self, *args, **kwargs)                                                                                                                 (9)
                        functools.update_wrapper(_init, old_init)                                                                                                           (10)
                        cls.__init__ = use_kwargs(cls._methods)(_init)======================================================================================================(11)
                                                                            [91;1mhow to add a list of names with None as default value to function `_init` to repalce its kwargs param[0m
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))                                                     (12)
                        return cls                                                                                                                                          (13)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m12[0m     ===============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                        functools.update_wrapper(_init, old_init)                                                                                                           (10)
                        cls.__init__ = use_kwargs(cls._methods)(_init)                                                                                                      (11)
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))=====================================================(12)
                                                                   [91;1mhow to make a class.`__init__` signature to be the signature of the class using `__signature__` and `_rm_self`[0m
                        return cls                                                                                                                                          (13)
                                                                                                                                                                            (14)
                
                
                
                ```
                #| column: screen
                fdb.snoop() # how to snoop together with docsrc: snoop first and docsrc above it
                ```
                
                    22:28:59.99 >>> Call to funcs_kwargs in File "/tmp/funcs_kwargs.py", line 3
                    22:28:59.99 ...... as_method = <class 'fastcore.meta.T'>
                    22:28:59.99    3 | def funcs_kwargs(as_method=False):
                    22:28:59.99    5 |     if callable(as_method): return _funcs_kwargs(as_method, False)
                        22:28:59.99 >>> Call to _funcs_kwargs in File "/tmp/_funcs_kwargs.py", line 3
                        22:28:59.99 ...... cls = <class 'fastcore.meta.T'>
                        22:28:59.99 ...... as_method = False
                        22:28:59.99    3 | def _funcs_kwargs(cls, as_method):
                        22:28:59.99    4 |     old_init = cls.__init__
                        22:28:59.99 .......... old_init = <function T.__init__>
                        22:28:59.99    5 |     import snoop
                        22:28:59.99 .......... snoop = <class 'snoop.configuration.Config.__init__.<locals>.ConfiguredTracer'>
                        22:28:59.99    6 |     @snoop
                        22:28:59.99    7 |     def _init(self, *args, **kwargs):
                        22:28:59.99 .......... _init = <function _funcs_kwargs.<locals>._init>
                        22:28:59.99   15 |     functools.update_wrapper(_init, old_init)
                        22:28:59.99 .......... _init = <function T.__init__>
                        22:28:59.99   16 |     cls.__init__ = use_kwargs(cls._methods)(_init)
                        22:28:59.99   17 |     if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))
                        22:28:59.99   18 |     return cls
                        22:28:59.99 <<< Return value from _funcs_kwargs: <class 'fastcore.meta.T'>
                    22:28:59.99    5 |     if callable(as_method): return _funcs_kwargs(as_method, False)
                    22:28:59.99 <<< Return value from funcs_kwargs: <class 'fastcore.meta.T'>
                    22:28:59.99 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:28:59.99 .......... self = <fastcore.meta.T object>
                    22:28:59.99 .......... args = ()
                    22:28:59.99 .......... kwargs = {}
                    22:28:59.99 .......... as_method = False
                    22:28:59.99 .......... cls = <class 'fastcore.meta.T'>
                    22:28:59.99 .......... old_init = <function T.__init__>
                    22:28:59.99    7 |     def _init(self, *args, **kwargs):
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00 .............. k = 'b'
                    22:29:00.00    9 |             arg = kwargs.pop(k,None)
                    22:29:00.00 .................. arg = None
                    22:29:00.00   10 |             if arg is not None:
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00   14 |         old_init(self, *args, **kwargs)
                    22:29:00.00 <<< Return value from _funcs_kwargs.<locals>._init: None
                    22:29:00.00 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:29:00.00 .......... self = <fastcore.meta.T object>
                    22:29:00.00 .......... args = ()
                    22:29:00.00 .......... kwargs = {'b': <function _new_func>}
                    22:29:00.00 .......... len(kwargs) = 1
                    22:29:00.00 .......... as_method = False
                    22:29:00.00 .......... cls = <class 'fastcore.meta.T'>
                    22:29:00.00 .......... old_init = <function T.__init__>
                    22:29:00.00    7 |     def _init(self, *args, **kwargs):
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00 .............. k = 'b'
                    22:29:00.00    9 |             arg = kwargs.pop(k,None)
                    22:29:00.00 .................. kwargs = {}
                    22:29:00.00 .................. arg = <function _new_func>
                    22:29:00.00   10 |             if arg is not None:
                    22:29:00.00   11 |                 if as_method: arg = method(arg)
                    22:29:00.00   12 |                 if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)
                    22:29:00.00   13 |                 setattr(self, k, arg)
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00   14 |         old_init(self, *args, **kwargs)
                    22:29:00.00 <<< Return value from _funcs_kwargs.<locals>._init: None
                    22:29:00.00 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:29:00.00 .......... self = <fastcore.meta.T object>
                    22:29:00.00 .......... args = ()
                    22:29:00.00 .......... kwargs = {'a': <function <lambda>>}
                    22:29:00.00 .......... len(kwargs) = 1
                    22:29:00.00 .......... as_method = False
                    22:29:00.00 .......... cls = <class 'fastcore.meta.T'>
                    22:29:00.00 .......... old_init = <function T.__init__>
                    22:29:00.00    7 |     def _init(self, *args, **kwargs):
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00 .............. k = 'b'
                    22:29:00.00    9 |             arg = kwargs.pop(k,None)
                    22:29:00.00 .................. arg = None
                    22:29:00.00   10 |             if arg is not None:
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00   14 |         old_init(self, *args, **kwargs)
                    22:29:00.00 <<< Return value from _funcs_kwargs.<locals>._init: None
                    22:29:00.00 >>> Call to funcs_kwargs in File "/tmp/funcs_kwargs.py", line 3
                    22:29:00.00 ...... as_method = True
                    22:29:00.00    3 | def funcs_kwargs(as_method=False):
                    22:29:00.00    5 |     if callable(as_method): return _funcs_kwargs(as_method, False)
                    22:29:00.00    6 |     return partial(_funcs_kwargs, as_method=as_method)
                    22:29:00.00 <<< Return value from funcs_kwargs: functools.partial(<function _funcs_kwargs>, as_method=True)
                    22:29:00.00 >>> Call to _funcs_kwargs in File "/tmp/_funcs_kwargs.py", line 3
                    22:29:00.00 ...... cls = <class 'fastcore.meta.T'>
                    22:29:00.00 ...... as_method = True
                    22:29:00.00    3 | def _funcs_kwargs(cls, as_method):
                    22:29:00.00    4 |     old_init = cls.__init__
                    22:29:00.00 .......... old_init = <slot wrapper '__init__' of 'object' objects>
                    22:29:00.00    5 |     import snoop
                    22:29:00.00 .......... snoop = <class 'snoop.configuration.Config.__init__.<locals>.ConfiguredTracer'>
                    22:29:00.00    6 |     @snoop
                    22:29:00.00    7 |     def _init(self, *args, **kwargs):
                    22:29:00.00 .......... _init = <function _funcs_kwargs.<locals>._init>
                    22:29:00.00   15 |     functools.update_wrapper(_init, old_init)
                    22:29:00.00 .......... _init = <function object.__init__>
                    22:29:00.00   16 |     cls.__init__ = use_kwargs(cls._methods)(_init)
                    22:29:00.01   17 |     if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))
                    22:29:00.01   18 |     return cls
                    22:29:00.01 <<< Return value from _funcs_kwargs: <class 'fastcore.meta.T'>
                    22:29:00.01 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:29:00.01 .......... self = <fastcore.meta.T object>
                    22:29:00.01 .......... args = ()
                    22:29:00.01 .......... kwargs = {'b': <function _f>}
                    22:29:00.01 .......... len(kwargs) = 1
                    22:29:00.01 .......... as_method = True
                    22:29:00.01 .......... cls = <class 'fastcore.meta.T'>
                    22:29:00.01 .......... old_init = <slot wrapper '__init__' of 'object' objects>
                    22:29:00.01    7 |     def _init(self, *args, **kwargs):
                    22:29:00.01    8 |         for k in cls._methods:
                    22:29:00.01 .............. k = 'b'
                    22:29:00.01    9 |             arg = kwargs.pop(k,None)
                    22:29:00.01 .................. kwargs = {}
                    22:29:00.01 .................. arg = <function _f>
                    22:29:00.01   10 |             if arg is not None:
                    22:29:00.01   11 |                 if as_method: arg = method(arg)
                    22:29:00.01 ...... arg = <bound method int._f of 1>
                    22:29:00.01   12 |                 if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)
                    22:29:00.01 ...... arg = <bound method T._f of <fastcore.meta.T object>>
                    22:29:00.01   13 |                 setattr(self, k, arg)
                    22:29:00.01    8 |         for k in cls._methods:
                    22:29:00.01   14 |         old_init(self, *args, **kwargs)
                    22:29:00.01 <<< Return value from _funcs_kwargs.<locals>._init: None
                    22:29:00.01 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:29:00.01 .......... self = <fastcore.meta.T2 object>
                    22:29:00.01 .......... args = ()
                    22:29:00.01 .......... kwargs = {'b': <function _f>}
                    22:29:00.01 .......... len(kwargs) = 1
                    22:29:00.01 .......... as_method = True
                    22:29:00.01 .......... cls = <class 'fastcore.meta.T'>
                    22:29:00.01 .......... old_init = <slot wrapper '__init__' of 'object' objects>
                    22:29:00.01    7 |     def _init(self, *args, **kwargs):
                    22:29:00.01    8 |         for k in cls._methods:
                    22:29:00.01 .............. k = 'b'
                    22:29:00.01    9 |             arg = kwargs.pop(k,None)
                    22:29:00.01 .................. kwargs = {}
                    22:29:00.01 .................. arg = <function _f>
                    22:29:00.01   10 |             if arg is not None:
                    22:29:00.01   11 |                 if as_method: arg = method(arg)
                    22:29:00.01 ...... arg = <bound method int._f of 1>
                    22:29:00.01   12 |                 if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)
                    22:29:00.01 ...... arg = <bound method T2._f of <fastcore.meta.T2 object>>
                    22:29:00.01   13 |                 setattr(self, k, arg)
                    22:29:00.01    8 |         for k in cls._methods:
                    22:29:00.01   14 |         old_init(self, *args, **kwargs)
                    22:29:00.01 <<< Return value from _funcs_kwargs.<locals>._init: None
                
                
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                
                
                
                ```
                fdb_.debug()
                ```
                
                    _funcs_kwargs's dbsrc code: ==============
                    import snoop
                    @snoop
                    def _funcs_kwargs(cls, as_method):
                        old_init = cls.__init__
                        import snoop
                        @snoop
                        def _init(self, *args, **kwargs):
                            for k in cls._methods:
                                arg = kwargs.pop(k,None)
                                if arg is not None:
                                    if as_method: arg = method(arg)
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)
                                    setattr(self, k, arg)
                            old_init(self, *args, **kwargs)
                        functools.update_wrapper(_init, old_init)
                        cls.__init__ = use_kwargs(cls._methods)(_init)
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))
                        return cls
                    
                    
                    
                    _funcs_kwargs's example processed with dbsrc: ===============
                    
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    
                
                
                
                ```
                #| column: screen
                fdb.print()
                ```
                
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    def funcs_kwargs(as_method=False):========================================================(0)       
                        "Replace methods in `cls._methods` with those from `kwargs`"==========================(1) # [93;1mhow funcs_kwargs works[0m; [93;1mit is a wrapper around _funcs_kwargs[0m; [91;1mit offers two ways of running _funcs_kwargs[0m; [37;1mthe first, default way, is to add a func to a class without using self[0m; [91;1msecond way is to add func to class enabling self use;[0m; 
                        if callable(as_method): return _funcs_kwargs(as_method, False)========================(2) # [37;1mhow to check whether an object is callable[0m; [93;1mhow to return a result of running a func[0m; [37;1m[0m; 
                        return partial(_funcs_kwargs, as_method=as_method)====================================(3) # [92;1mhow to custom the params of `_funcs_kwargs` for a particular use with partial[0m; 
                                                                                                                                                                            (4)
                
                
                
                ```
                #| column: screen
                fdb_.print()
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m12[0m     ===============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    def _funcs_kwargs(cls, as_method):========================================================(0) # [93;1mhow does _funcs_kwargs work: _funcs_kwargs is a decorator[0m; [35;1mit helps class e.g., T to add more methods[0m; [93;1mI need to give the method a name, and put the name e.g., 'b' inside a list called _methods=['b'] inside class T[0m; [36;1mthen after writing a func e.g., _new_func, I can add it by T(b = _new_func)[0m; [36;1mif I want the func added to class to use self, I shall write @funcs_kwargs(as_method=True)[0m; 
                        old_init = cls.__init__===============================================================(1)       
                        def _init(self, *args, **kwargs):=====================================================(2) # [37;1mhow to define a method which can use self and accept any parameters[0m; 
                            for k in cls._methods:============================================================(3) # [35;1mhow to pop out the value of an item in a dict (with None as default), and if the item name is not found, pop out None instead[0m; [91;1m[0m; 
                                arg = kwargs.pop(k,None)======================================================(4)       
                                if arg is not None:===========================================================(5)       
                                    if as_method: arg = method(arg)===========================================(6) # [36;1mhow to turn a func into a method[0m; 
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)=======(7) # [93;1mhow to give a method a different instance, like self[0m; 
                                    setattr(self, k, arg)=====================================================(8) # [36;1mhow to add a method to a class as an attribute[0m; 
                            old_init(self, *args, **kwargs)===================================================(9)       
                        functools.update_wrapper(_init, old_init)=============================================(10) # [34;1mhow to wrap `_init` around `old_init`, so that `_init` can use `old_init` inside itself[0m; 
                        cls.__init__ = use_kwargs(cls._methods)(_init)========================================(11) # [34;1mhow to add a list of names with None as default value to function `_init` to repalce its kwargs param[0m; 
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__)) # [35;1mhow to make a class.`__init__` signature to be the signature of the class using `__signature__` and `_rm_self`[0m;  (12)
                        return cls============================================================================(13)      
                                                                                                                                                                            (14)
                
                
                
                ```
                
                ```
                
                
            
            
            
            [Open `0009_funcs_kwargs` in Jupyter Notebook](http://localhost:8888/tree/nbs/demos/0009_funcs_kwargs.ipynb)
            
            
            
        
        
        
        [Open `utils` in Jupyter Notebook](http://localhost:8888/tree/nbs/lib/utils.ipynb)
        
        
        
        
    
    
    
    [Open `utils` in Jupyter Notebook](http://localhost:8888/tree/nbs/lib/utils.ipynb)
    
    
    
    



[Open `utils` in Jupyter Notebook locally](http://localhost:8888/tree/nbs/lib/utils.ipynb)



###  <mark style="background-color: #ffff00">snoop:</mark>   <mark style="background-color: #ffff00">from</mark>   <mark style="background-color: #ffff00">_ <mark style="background-color: #FFFF00">funcs_kwargs</mark> </mark>   <mark style="background-color: #ffff00">to</mark>   <mark style="background-color: #FFFF00">funcs_kwargs</mark> 



    
    
    
        
        
        
            
            
            
                
                how to snoop on two functions one wrap around another: `funcs_kwargs` is a wrapper around `_funcs_kwargs`, so I can first snoop on `_funcs_kwargs` and assign its snoop dbsrc to \
                `fm._funcs_kwargs` so that when I snoop on `funcs_kwargs`, it can use the snoop dbsrc of `_funcs_kwargs` and no example codes need to change.
                
                
                ```
                from fastcore.meta import _funcs_kwargs
                ```
                
                
                ```
                fdb_ = Fastdb(_funcs_kwargs)
                fdb_.eg = """
                @funcs_kwargs
                class T:
                    _methods=['b'] # allows you to add method b upon instantiation
                    def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                    def a(self): return 1
                    def b(self): return 2
                    
                t = T()
                test_eq(t.a(), 1)
                test_eq(t.b(), 2)
                
                test_sig(T, '(f=1, *, b=None)')
                inspect.signature(T)
                
                def _new_func(): return 5
                
                t = T(b = _new_func)
                test_eq(t.b(), 5)
                
                t = T(a = lambda:3)
                test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                """
                ```
                
                
                ```
                #| column: screen
                # no snoop result, it is expected, because the example is not calling _funcs_kwargs, but funcs_kwargs
                fdb_.snoop(deco=True) # how to snoop decorator: _funcs_kwargs is a decorator, so set deco=True to see running codes in inner f
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    [0m     
                    
                
                
                
                ```
                import fastcore.meta as fm
                ```
                
                
                ```
                fm._funcs_kwargs = fdb_.dbsrc # how to snoop on two functions one wrap around another
                ```
                
                
                ```
                fdb = Fastdb(funcs_kwargs)
                fdb.eg = """
                @funcs_kwargs
                class T:
                    _methods=['b'] # allows you to add method b upon instantiation
                    def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                    def a(self): return 1
                    def b(self): return 2
                    
                t = T()
                test_eq(t.a(), 1)
                test_eq(t.b(), 2)
                
                test_sig(T, '(f=1, *, b=None)')
                inspect.signature(T)
                
                def _new_func(): return 5
                
                t = T(b = _new_func)
                test_eq(t.b(), 5)
                
                t = T(a = lambda:3)
                test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                
                def _f(self,a=1): return self.num + a # access the num attribute from the instance
                
                @funcs_kwargs(as_method=True)
                class T: 
                    _methods=['b']
                    num = 5
                    
                t = T(b = _f) # adds method b
                test_eq(t.b(5), 10) # self.num + 5 = 10
                
                def _f(self,a=1): return self.num * a #multiply instead of add 
                
                class T2(T):
                    def __init__(self,num):
                        super().__init__(b = _f) # add method b from the super class
                        self.num=num
                        
                t = T2(num=3)
                test_eq(t.b(a=5), 15) # 3 * 5 = 15
                test_sig(T2, '(num)')
                """
                ```
                
                
                ```
                #| column: screen
                fdb.print()
                ```
                
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    def funcs_kwargs(as_method=False):========================================================(0)       
                        "Replace methods in `cls._methods` with those from `kwargs`"==========================(1)       
                        if callable(as_method): return _funcs_kwargs(as_method, False)========================(2)       
                        return partial(_funcs_kwargs, as_method=as_method)====================================(3)       
                                                                                                                                                                            (4)
                
                
                
                ```
                #| column: screen
                fdb_.print()
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    def _funcs_kwargs(cls, as_method):========================================================(0)       
                        old_init = cls.__init__===============================================================(1)       
                        def _init(self, *args, **kwargs):=====================================================(2)       
                            for k in cls._methods:============================================================(3)       
                                arg = kwargs.pop(k,None)======================================================(4)       
                                if arg is not None:===========================================================(5)       
                                    if as_method: arg = method(arg)===========================================(6)       
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)=======(7)       
                                    setattr(self, k, arg)=====================================================(8)       
                            old_init(self, *args, **kwargs)===================================================(9)       
                        functools.update_wrapper(_init, old_init)=============================================(10)      
                        cls.__init__ = use_kwargs(cls._methods)(_init)========================================(11)      
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))                                                     (12)
                        return cls============================================================================(13)      
                                                                                                                                                                            (14)
                
                
                
                ```
                #| column: screen
                fdb.docsrc(1, "how funcs_kwargs works; it is a wrapper around _funcs_kwargs; it offers two ways of running _funcs_kwargs; \
                the first, default way, is to add a func to a class without using self; second way is to add func to class enabling self use;")
                fdb.docsrc(2, "how to check whether an object is callable; how to return a result of running a func; ")
                fdb.docsrc(3, "how to custom the params of `_funcs_kwargs` for a particular use with partial")
                ```
                
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m1[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                    def funcs_kwargs(as_method=False):                                                                                                                      (0)
                        "Replace methods in `cls._methods` with those from `kwargs`"========================================================================================(1)
                    [91;1mhow funcs_kwargs works; it is a wrapper around _funcs_kwargs; it offers two ways of running _funcs_kwargs; the first, default way, is to add a func to a class without using self; second way is to add func to class enabling self use;[0m
                        if callable(as_method): return _funcs_kwargs(as_method, False)                                                                                      (2)
                        return partial(_funcs_kwargs, as_method=as_method)                                                                                                  (3)
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m2[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                    def funcs_kwargs(as_method=False):                                                                                                                      (0)
                        "Replace methods in `cls._methods` with those from `kwargs`"                                                                                        (1)
                        if callable(as_method): return _funcs_kwargs(as_method, False)======================================================================================(2)
                                                                                           [91;1mhow to check whether an object is callable; how to return a result of running a func; [0m
                        return partial(_funcs_kwargs, as_method=as_method)                                                                                                  (3)
                                                                                                                                                                            (4)
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m3[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                        "Replace methods in `cls._methods` with those from `kwargs`"                                                                                        (1)
                        if callable(as_method): return _funcs_kwargs(as_method, False)                                                                                      (2)
                        return partial(_funcs_kwargs, as_method=as_method)==================================================================================================(3)
                                                                                                    [91;1mhow to custom the params of `_funcs_kwargs` for a particular use with partial[0m
                                                                                                                                                                            (4)
                
                
                
                ```
                #| column: screen
                fdb_.print()
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    def _funcs_kwargs(cls, as_method):========================================================(0)       
                        old_init = cls.__init__===============================================================(1)       
                        def _init(self, *args, **kwargs):=====================================================(2)       
                            for k in cls._methods:============================================================(3)       
                                arg = kwargs.pop(k,None)======================================================(4)       
                                if arg is not None:===========================================================(5)       
                                    if as_method: arg = method(arg)===========================================(6)       
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)=======(7)       
                                    setattr(self, k, arg)=====================================================(8)       
                            old_init(self, *args, **kwargs)===================================================(9)       
                        functools.update_wrapper(_init, old_init)=============================================(10)      
                        cls.__init__ = use_kwargs(cls._methods)(_init)========================================(11)      
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))                                                     (12)
                        return cls============================================================================(13)      
                                                                                                                                                                            (14)
                
                
                
                ```
                #| column: screen
                fdb_.docsrc(0, "how does _funcs_kwargs work: _funcs_kwargs is a decorator; it helps class e.g., T to add more methods; \
                I need to give the method a name, \
                and put the name e.g., 'b' inside a list called _methods=['b'] inside class T; \
                then after writing a func e.g., _new_func, I can add it by T(b = _new_func); if I want the func added to class to use self, \
                I shall write @funcs_kwargs(as_method=True)")
                fdb_.docsrc(2, "how to define a method which can use self and accept any parameters")
                fdb_.docsrc(3, "how to pop out the value of an item in a dict (with None as default), and if the item name is not found, pop out None instead; ")
                fdb_.docsrc(6, "how to turn a func into a method")
                fdb_.docsrc(7, "how to give a method a different instance, like self")
                fdb_.docsrc(8, "how to add a method to a class as an attribute")
                fdb_.docsrc(10, "how to wrap `_init` around `old_init`, so that `_init` can use `old_init` inside itself")
                fdb_.docsrc(11, "how to add a list of names with None as default value to function `_init` to repalce its kwargs param")
                fdb_.docsrc(12, "how to make a class.`__init__` signature to be the signature of the class using `__signature__` and `_rm_self`")
                
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m0[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                    def _funcs_kwargs(cls, as_method):======================================================================================================================(0)
                    [91;1mhow does _funcs_kwargs work: _funcs_kwargs is a decorator; it helps class e.g., T to add more methods; I need to give the method a name, and put the name e.g., 'b' inside a list called _methods=['b'] inside class T; then after writing a func e.g., _new_func, I can add it by T(b = _new_func); if I want the func added to class to use self, I shall write @funcs_kwargs(as_method=True)[0m
                        old_init = cls.__init__                                                                                                                             (1)
                        def _init(self, *args, **kwargs):                                                                                                                   (2)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m2[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                    def _funcs_kwargs(cls, as_method):                                                                                                                      (0)
                        old_init = cls.__init__                                                                                                                             (1)
                        def _init(self, *args, **kwargs):===================================================================================================================(2)
                                                                                                              [91;1mhow to define a method which can use self and accept any parameters[0m
                            for k in cls._methods:                                                                                                                          (3)
                                arg = kwargs.pop(k,None)                                                                                                                    (4)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m3[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                        old_init = cls.__init__                                                                                                                             (1)
                        def _init(self, *args, **kwargs):                                                                                                                   (2)
                            for k in cls._methods:==========================================================================================================================(3)
                                                  [91;1mhow to pop out the value of an item in a dict (with None as default), and if the item name is not found, pop out None instead; [0m
                                arg = kwargs.pop(k,None)                                                                                                                    (4)
                                if arg is not None:                                                                                                                         (5)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m6[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                                arg = kwargs.pop(k,None)                                                                                                                    (4)
                                if arg is not None:                                                                                                                         (5)
                                    if as_method: arg = method(arg)=========================================================================================================(6)
                                                                                                                                                 [91;1mhow to turn a func into a method[0m
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)                                                                     (7)
                                    setattr(self, k, arg)                                                                                                                   (8)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m7[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                                if arg is not None:                                                                                                                         (5)
                                    if as_method: arg = method(arg)                                                                                                         (6)
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)=====================================================================(7)
                                                                                                                             [91;1mhow to give a method a different instance, like self[0m
                                    setattr(self, k, arg)                                                                                                                   (8)
                            old_init(self, *args, **kwargs)                                                                                                                 (9)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m8[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                                    if as_method: arg = method(arg)                                                                                                         (6)
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)                                                                     (7)
                                    setattr(self, k, arg)===================================================================================================================(8)
                                                                                                                                   [91;1mhow to add a method to a class as an attribute[0m
                            old_init(self, *args, **kwargs)                                                                                                                 (9)
                        functools.update_wrapper(_init, old_init)                                                                                                           (10)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m10[0m     ===============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                                    setattr(self, k, arg)                                                                                                                   (8)
                            old_init(self, *args, **kwargs)                                                                                                                 (9)
                        functools.update_wrapper(_init, old_init)===========================================================================================================(10)
                                                                                          [91;1mhow to wrap `_init` around `old_init`, so that `_init` can use `old_init` inside itself[0m
                        cls.__init__ = use_kwargs(cls._methods)(_init)                                                                                                      (11)
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))                                                     (12)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m11[0m     ===============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                            old_init(self, *args, **kwargs)                                                                                                                 (9)
                        functools.update_wrapper(_init, old_init)                                                                                                           (10)
                        cls.__init__ = use_kwargs(cls._methods)(_init)======================================================================================================(11)
                                                                            [91;1mhow to add a list of names with None as default value to function `_init` to repalce its kwargs param[0m
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))                                                     (12)
                        return cls                                                                                                                                          (13)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m12[0m     ===============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                        functools.update_wrapper(_init, old_init)                                                                                                           (10)
                        cls.__init__ = use_kwargs(cls._methods)(_init)                                                                                                      (11)
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))=====================================================(12)
                                                                   [91;1mhow to make a class.`__init__` signature to be the signature of the class using `__signature__` and `_rm_self`[0m
                        return cls                                                                                                                                          (13)
                                                                                                                                                                            (14)
                
                
                
                ```
                #| column: screen
                fdb.snoop() # how to snoop together with docsrc: snoop first and docsrc above it
                ```
                
                    22:28:59.99 >>> Call to funcs_kwargs in File "/tmp/funcs_kwargs.py", line 3
                    22:28:59.99 ...... as_method = <class 'fastcore.meta.T'>
                    22:28:59.99    3 | def funcs_kwargs(as_method=False):
                    22:28:59.99    5 |     if callable(as_method): return _funcs_kwargs(as_method, False)
                        22:28:59.99 >>> Call to _funcs_kwargs in File "/tmp/_funcs_kwargs.py", line 3
                        22:28:59.99 ...... cls = <class 'fastcore.meta.T'>
                        22:28:59.99 ...... as_method = False
                        22:28:59.99    3 | def _funcs_kwargs(cls, as_method):
                        22:28:59.99    4 |     old_init = cls.__init__
                        22:28:59.99 .......... old_init = <function T.__init__>
                        22:28:59.99    5 |     import snoop
                        22:28:59.99 .......... snoop = <class 'snoop.configuration.Config.__init__.<locals>.ConfiguredTracer'>
                        22:28:59.99    6 |     @snoop
                        22:28:59.99    7 |     def _init(self, *args, **kwargs):
                        22:28:59.99 .......... _init = <function _funcs_kwargs.<locals>._init>
                        22:28:59.99   15 |     functools.update_wrapper(_init, old_init)
                        22:28:59.99 .......... _init = <function T.__init__>
                        22:28:59.99   16 |     cls.__init__ = use_kwargs(cls._methods)(_init)
                        22:28:59.99   17 |     if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))
                        22:28:59.99   18 |     return cls
                        22:28:59.99 <<< Return value from _funcs_kwargs: <class 'fastcore.meta.T'>
                    22:28:59.99    5 |     if callable(as_method): return _funcs_kwargs(as_method, False)
                    22:28:59.99 <<< Return value from funcs_kwargs: <class 'fastcore.meta.T'>
                    22:28:59.99 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:28:59.99 .......... self = <fastcore.meta.T object>
                    22:28:59.99 .......... args = ()
                    22:28:59.99 .......... kwargs = {}
                    22:28:59.99 .......... as_method = False
                    22:28:59.99 .......... cls = <class 'fastcore.meta.T'>
                    22:28:59.99 .......... old_init = <function T.__init__>
                    22:28:59.99    7 |     def _init(self, *args, **kwargs):
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00 .............. k = 'b'
                    22:29:00.00    9 |             arg = kwargs.pop(k,None)
                    22:29:00.00 .................. arg = None
                    22:29:00.00   10 |             if arg is not None:
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00   14 |         old_init(self, *args, **kwargs)
                    22:29:00.00 <<< Return value from _funcs_kwargs.<locals>._init: None
                    22:29:00.00 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:29:00.00 .......... self = <fastcore.meta.T object>
                    22:29:00.00 .......... args = ()
                    22:29:00.00 .......... kwargs = {'b': <function _new_func>}
                    22:29:00.00 .......... len(kwargs) = 1
                    22:29:00.00 .......... as_method = False
                    22:29:00.00 .......... cls = <class 'fastcore.meta.T'>
                    22:29:00.00 .......... old_init = <function T.__init__>
                    22:29:00.00    7 |     def _init(self, *args, **kwargs):
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00 .............. k = 'b'
                    22:29:00.00    9 |             arg = kwargs.pop(k,None)
                    22:29:00.00 .................. kwargs = {}
                    22:29:00.00 .................. arg = <function _new_func>
                    22:29:00.00   10 |             if arg is not None:
                    22:29:00.00   11 |                 if as_method: arg = method(arg)
                    22:29:00.00   12 |                 if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)
                    22:29:00.00   13 |                 setattr(self, k, arg)
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00   14 |         old_init(self, *args, **kwargs)
                    22:29:00.00 <<< Return value from _funcs_kwargs.<locals>._init: None
                    22:29:00.00 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:29:00.00 .......... self = <fastcore.meta.T object>
                    22:29:00.00 .......... args = ()
                    22:29:00.00 .......... kwargs = {'a': <function <lambda>>}
                    22:29:00.00 .......... len(kwargs) = 1
                    22:29:00.00 .......... as_method = False
                    22:29:00.00 .......... cls = <class 'fastcore.meta.T'>
                    22:29:00.00 .......... old_init = <function T.__init__>
                    22:29:00.00    7 |     def _init(self, *args, **kwargs):
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00 .............. k = 'b'
                    22:29:00.00    9 |             arg = kwargs.pop(k,None)
                    22:29:00.00 .................. arg = None
                    22:29:00.00   10 |             if arg is not None:
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00   14 |         old_init(self, *args, **kwargs)
                    22:29:00.00 <<< Return value from _funcs_kwargs.<locals>._init: None
                    22:29:00.00 >>> Call to funcs_kwargs in File "/tmp/funcs_kwargs.py", line 3
                    22:29:00.00 ...... as_method = True
                    22:29:00.00    3 | def funcs_kwargs(as_method=False):
                    22:29:00.00    5 |     if callable(as_method): return _funcs_kwargs(as_method, False)
                    22:29:00.00    6 |     return partial(_funcs_kwargs, as_method=as_method)
                    22:29:00.00 <<< Return value from funcs_kwargs: functools.partial(<function _funcs_kwargs>, as_method=True)
                    22:29:00.00 >>> Call to _funcs_kwargs in File "/tmp/_funcs_kwargs.py", line 3
                    22:29:00.00 ...... cls = <class 'fastcore.meta.T'>
                    22:29:00.00 ...... as_method = True
                    22:29:00.00    3 | def _funcs_kwargs(cls, as_method):
                    22:29:00.00    4 |     old_init = cls.__init__
                    22:29:00.00 .......... old_init = <slot wrapper '__init__' of 'object' objects>
                    22:29:00.00    5 |     import snoop
                    22:29:00.00 .......... snoop = <class 'snoop.configuration.Config.__init__.<locals>.ConfiguredTracer'>
                    22:29:00.00    6 |     @snoop
                    22:29:00.00    7 |     def _init(self, *args, **kwargs):
                    22:29:00.00 .......... _init = <function _funcs_kwargs.<locals>._init>
                    22:29:00.00   15 |     functools.update_wrapper(_init, old_init)
                    22:29:00.00 .......... _init = <function object.__init__>
                    22:29:00.00   16 |     cls.__init__ = use_kwargs(cls._methods)(_init)
                    22:29:00.01   17 |     if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))
                    22:29:00.01   18 |     return cls
                    22:29:00.01 <<< Return value from _funcs_kwargs: <class 'fastcore.meta.T'>
                    22:29:00.01 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:29:00.01 .......... self = <fastcore.meta.T object>
                    22:29:00.01 .......... args = ()
                    22:29:00.01 .......... kwargs = {'b': <function _f>}
                    22:29:00.01 .......... len(kwargs) = 1
                    22:29:00.01 .......... as_method = True
                    22:29:00.01 .......... cls = <class 'fastcore.meta.T'>
                    22:29:00.01 .......... old_init = <slot wrapper '__init__' of 'object' objects>
                    22:29:00.01    7 |     def _init(self, *args, **kwargs):
                    22:29:00.01    8 |         for k in cls._methods:
                    22:29:00.01 .............. k = 'b'
                    22:29:00.01    9 |             arg = kwargs.pop(k,None)
                    22:29:00.01 .................. kwargs = {}
                    22:29:00.01 .................. arg = <function _f>
                    22:29:00.01   10 |             if arg is not None:
                    22:29:00.01   11 |                 if as_method: arg = method(arg)
                    22:29:00.01 ...... arg = <bound method int._f of 1>
                    22:29:00.01   12 |                 if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)
                    22:29:00.01 ...... arg = <bound method T._f of <fastcore.meta.T object>>
                    22:29:00.01   13 |                 setattr(self, k, arg)
                    22:29:00.01    8 |         for k in cls._methods:
                    22:29:00.01   14 |         old_init(self, *args, **kwargs)
                    22:29:00.01 <<< Return value from _funcs_kwargs.<locals>._init: None
                    22:29:00.01 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:29:00.01 .......... self = <fastcore.meta.T2 object>
                    22:29:00.01 .......... args = ()
                    22:29:00.01 .......... kwargs = {'b': <function _f>}
                    22:29:00.01 .......... len(kwargs) = 1
                    22:29:00.01 .......... as_method = True
                    22:29:00.01 .......... cls = <class 'fastcore.meta.T'>
                    22:29:00.01 .......... old_init = <slot wrapper '__init__' of 'object' objects>
                    22:29:00.01    7 |     def _init(self, *args, **kwargs):
                    22:29:00.01    8 |         for k in cls._methods:
                    22:29:00.01 .............. k = 'b'
                    22:29:00.01    9 |             arg = kwargs.pop(k,None)
                    22:29:00.01 .................. kwargs = {}
                    22:29:00.01 .................. arg = <function _f>
                    22:29:00.01   10 |             if arg is not None:
                    22:29:00.01   11 |                 if as_method: arg = method(arg)
                    22:29:00.01 ...... arg = <bound method int._f of 1>
                    22:29:00.01   12 |                 if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)
                    22:29:00.01 ...... arg = <bound method T2._f of <fastcore.meta.T2 object>>
                    22:29:00.01   13 |                 setattr(self, k, arg)
                    22:29:00.01    8 |         for k in cls._methods:
                    22:29:00.01   14 |         old_init(self, *args, **kwargs)
                    22:29:00.01 <<< Return value from _funcs_kwargs.<locals>._init: None
                
                
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                
                
                
                ```
                fdb_.debug()
                ```
                
                    _funcs_kwargs's dbsrc code: ==============
                    import snoop
                    @snoop
                    def _funcs_kwargs(cls, as_method):
                        old_init = cls.__init__
                        import snoop
                        @snoop
                        def _init(self, *args, **kwargs):
                            for k in cls._methods:
                                arg = kwargs.pop(k,None)
                                if arg is not None:
                                    if as_method: arg = method(arg)
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)
                                    setattr(self, k, arg)
                            old_init(self, *args, **kwargs)
                        functools.update_wrapper(_init, old_init)
                        cls.__init__ = use_kwargs(cls._methods)(_init)
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))
                        return cls
                    
                    
                    
                    _funcs_kwargs's example processed with dbsrc: ===============
                    
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    
                
                
                
                ```
                #| column: screen
                fdb.print()
                ```
                
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    def funcs_kwargs(as_method=False):========================================================(0)       
                        "Replace methods in `cls._methods` with those from `kwargs`"==========================(1) # [93;1mhow funcs_kwargs works[0m; [93;1mit is a wrapper around _funcs_kwargs[0m; [91;1mit offers two ways of running _funcs_kwargs[0m; [37;1mthe first, default way, is to add a func to a class without using self[0m; [91;1msecond way is to add func to class enabling self use;[0m; 
                        if callable(as_method): return _funcs_kwargs(as_method, False)========================(2) # [37;1mhow to check whether an object is callable[0m; [93;1mhow to return a result of running a func[0m; [37;1m[0m; 
                        return partial(_funcs_kwargs, as_method=as_method)====================================(3) # [92;1mhow to custom the params of `_funcs_kwargs` for a particular use with partial[0m; 
                                                                                                                                                                            (4)
                
                
                
                ```
                #| column: screen
                fdb_.print()
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m12[0m     ===============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    def _funcs_kwargs(cls, as_method):========================================================(0) # [93;1mhow does _funcs_kwargs work: _funcs_kwargs is a decorator[0m; [35;1mit helps class e.g., T to add more methods[0m; [93;1mI need to give the method a name, and put the name e.g., 'b' inside a list called _methods=['b'] inside class T[0m; [36;1mthen after writing a func e.g., _new_func, I can add it by T(b = _new_func)[0m; [36;1mif I want the func added to class to use self, I shall write @funcs_kwargs(as_method=True)[0m; 
                        old_init = cls.__init__===============================================================(1)       
                        def _init(self, *args, **kwargs):=====================================================(2) # [37;1mhow to define a method which can use self and accept any parameters[0m; 
                            for k in cls._methods:============================================================(3) # [35;1mhow to pop out the value of an item in a dict (with None as default), and if the item name is not found, pop out None instead[0m; [91;1m[0m; 
                                arg = kwargs.pop(k,None)======================================================(4)       
                                if arg is not None:===========================================================(5)       
                                    if as_method: arg = method(arg)===========================================(6) # [36;1mhow to turn a func into a method[0m; 
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)=======(7) # [93;1mhow to give a method a different instance, like self[0m; 
                                    setattr(self, k, arg)=====================================================(8) # [36;1mhow to add a method to a class as an attribute[0m; 
                            old_init(self, *args, **kwargs)===================================================(9)       
                        functools.update_wrapper(_init, old_init)=============================================(10) # [34;1mhow to wrap `_init` around `old_init`, so that `_init` can use `old_init` inside itself[0m; 
                        cls.__init__ = use_kwargs(cls._methods)(_init)========================================(11) # [34;1mhow to add a list of names with None as default value to function `_init` to repalce its kwargs param[0m; 
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__)) # [35;1mhow to make a class.`__init__` signature to be the signature of the class using `__signature__` and `_rm_self`[0m;  (12)
                        return cls============================================================================(13)      
                                                                                                                                                                            (14)
                
                
                
                ```
                
                ```
                
                
            
            
            
            [Open `0009_funcs_kwargs` in Jupyter Notebook](http://localhost:8888/tree/nbs/demos/0009_funcs_kwargs.ipynb)
            
            
            
        
        
        
        [Open `utils` in Jupyter Notebook](http://localhost:8888/tree/nbs/lib/utils.ipynb)
        
        
        
        
    
    
    
    [Open `utils` in Jupyter Notebook](http://localhost:8888/tree/nbs/lib/utils.ipynb)
    
    
    
    



[Open `utils` in Jupyter Notebook locally](http://localhost:8888/tree/nbs/lib/utils.ipynb)



###  <mark style="background-color: #ffff00">snoop:</mark>   <mark style="background-color: #ffff00">from</mark>   <mark style="background-color: #ffff00">_ <mark style="background-color: #FFFF00">funcs_kwargs</mark> </mark>   <mark style="background-color: #ffff00">to</mark>   <mark style="background-color: #FFFF00">funcs_kwargs</mark> 



    
    how to snoop on two functions one wrap around another: `funcs_kwargs` is a wrapper around `_funcs_kwargs`, so I can first snoop on `_funcs_kwargs` and assign its snoop dbsrc to \
    `fm._funcs_kwargs` so that when I snoop on `funcs_kwargs`, it can use the snoop dbsrc of `_funcs_kwargs` and no example codes need to change.
    
    
    ```
    from fastcore.meta import _funcs_kwargs
    ```
    
    
    ```
    fdb_ = Fastdb(_funcs_kwargs)
    fdb_.eg = """
    @funcs_kwargs
    class T:
        _methods=['b'] # allows you to add method b upon instantiation
        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
        def a(self): return 1
        def b(self): return 2
        
    t = T()
    test_eq(t.a(), 1)
    test_eq(t.b(), 2)
    
    test_sig(T, '(f=1, *, b=None)')
    inspect.signature(T)
    
    def _new_func(): return 5
    
    t = T(b = _new_func)
    test_eq(t.b(), 5)
    
    t = T(a = lambda:3)
    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
    """
    ```
    
    
    ```
    #| column: screen
    # no snoop result, it is expected, because the example is not calling _funcs_kwargs, but funcs_kwargs
    fdb_.snoop(deco=True) # how to snoop decorator: _funcs_kwargs is a decorator, so set deco=True to see running codes in inner f
    ```
    
        ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
        ==============================================================     on line [91;1mNone[0m     ==============================================================
             with example [91;1m
        @funcs_kwargs
        class T:
            _methods=['b'] # allows you to add method b upon instantiation
            def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
            def a(self): return 1
            def b(self): return 2
            
        t = T()
        test_eq(t.a(), 1)
        test_eq(t.b(), 2)
        
        test_sig(T, '(f=1, *, b=None)')
        inspect.signature(T)
        
        def _new_func(): return 5
        
        t = T(b = _new_func)
        test_eq(t.b(), 5)
        
        t = T(a = lambda:3)
        test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
        [0m     
        
    
    
    
    ```
    import fastcore.meta as fm
    ```
    
    
    ```
    fm._funcs_kwargs = fdb_.dbsrc # how to snoop on two functions one wrap around another
    ```
    
    
    ```
    fdb = Fastdb(funcs_kwargs)
    fdb.eg = """
    @funcs_kwargs
    class T:
        _methods=['b'] # allows you to add method b upon instantiation
        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
        def a(self): return 1
        def b(self): return 2
        
    t = T()
    test_eq(t.a(), 1)
    test_eq(t.b(), 2)
    
    test_sig(T, '(f=1, *, b=None)')
    inspect.signature(T)
    
    def _new_func(): return 5
    
    t = T(b = _new_func)
    test_eq(t.b(), 5)
    
    t = T(a = lambda:3)
    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
    
    def _f(self,a=1): return self.num + a # access the num attribute from the instance
    
    @funcs_kwargs(as_method=True)
    class T: 
        _methods=['b']
        num = 5
        
    t = T(b = _f) # adds method b
    test_eq(t.b(5), 10) # self.num + 5 = 10
    
    def _f(self,a=1): return self.num * a #multiply instead of add 
    
    class T2(T):
        def __init__(self,num):
            super().__init__(b = _f) # add method b from the super class
            self.num=num
            
    t = T2(num=3)
    test_eq(t.b(a=5), 15) # 3 * 5 = 15
    test_sig(T2, '(num)')
    """
    ```
    
    
    ```
    #| column: screen
    fdb.print()
    ```
    
        =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
        ==============================================================     on line [91;1mNone[0m     ==============================================================
             with example [91;1m
        @funcs_kwargs
        class T:
            _methods=['b'] # allows you to add method b upon instantiation
            def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
            def a(self): return 1
            def b(self): return 2
            
        t = T()
        test_eq(t.a(), 1)
        test_eq(t.b(), 2)
        
        test_sig(T, '(f=1, *, b=None)')
        inspect.signature(T)
        
        def _new_func(): return 5
        
        t = T(b = _new_func)
        test_eq(t.b(), 5)
        
        t = T(a = lambda:3)
        test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
        
        def _f(self,a=1): return self.num + a # access the num attribute from the instance
        
        @funcs_kwargs(as_method=True)
        class T: 
            _methods=['b']
            num = 5
            
        t = T(b = _f) # adds method b
        test_eq(t.b(5), 10) # self.num + 5 = 10
        
        def _f(self,a=1): return self.num * a #multiply instead of add 
        
        class T2(T):
            def __init__(self,num):
                super().__init__(b = _f) # add method b from the super class
                self.num=num
                
        t = T2(num=3)
        test_eq(t.b(a=5), 15) # 3 * 5 = 15
        test_sig(T2, '(num)')
        [0m     
        
        def funcs_kwargs(as_method=False):========================================================(0)       
            "Replace methods in `cls._methods` with those from `kwargs`"==========================(1)       
            if callable(as_method): return _funcs_kwargs(as_method, False)========================(2)       
            return partial(_funcs_kwargs, as_method=as_method)====================================(3)       
                                                                                                                                                                (4)
    
    
    
    ```
    #| column: screen
    fdb_.print()
    ```
    
        ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
        ==============================================================     on line [91;1mNone[0m     ==============================================================
             with example [91;1m
        @funcs_kwargs
        class T:
            _methods=['b'] # allows you to add method b upon instantiation
            def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
            def a(self): return 1
            def b(self): return 2
            
        t = T()
        test_eq(t.a(), 1)
        test_eq(t.b(), 2)
        
        test_sig(T, '(f=1, *, b=None)')
        inspect.signature(T)
        
        def _new_func(): return 5
        
        t = T(b = _new_func)
        test_eq(t.b(), 5)
        
        t = T(a = lambda:3)
        test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
        
        [0m     
        
        def _funcs_kwargs(cls, as_method):========================================================(0)       
            old_init = cls.__init__===============================================================(1)       
            def _init(self, *args, **kwargs):=====================================================(2)       
                for k in cls._methods:============================================================(3)       
                    arg = kwargs.pop(k,None)======================================================(4)       
                    if arg is not None:===========================================================(5)       
                        if as_method: arg = method(arg)===========================================(6)       
                        if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)=======(7)       
                        setattr(self, k, arg)=====================================================(8)       
                old_init(self, *args, **kwargs)===================================================(9)       
            functools.update_wrapper(_init, old_init)=============================================(10)      
            cls.__init__ = use_kwargs(cls._methods)(_init)========================================(11)      
            if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))                                                     (12)
            return cls============================================================================(13)      
                                                                                                                                                                (14)
    
    
    
    ```
    #| column: screen
    fdb.docsrc(1, "how funcs_kwargs works; it is a wrapper around _funcs_kwargs; it offers two ways of running _funcs_kwargs; \
    the first, default way, is to add a func to a class without using self; second way is to add func to class enabling self use;")
    fdb.docsrc(2, "how to check whether an object is callable; how to return a result of running a func; ")
    fdb.docsrc(3, "how to custom the params of `_funcs_kwargs` for a particular use with partial")
    ```
    
        =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
        ===============================================================     on line [91;1m1[0m     ================================================================
             with example [91;1m
        @funcs_kwargs
        class T:
            _methods=['b'] # allows you to add method b upon instantiation
            def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
            def a(self): return 1
            def b(self): return 2
            
        t = T()
        test_eq(t.a(), 1)
        test_eq(t.b(), 2)
        
        test_sig(T, '(f=1, *, b=None)')
        inspect.signature(T)
        
        def _new_func(): return 5
        
        t = T(b = _new_func)
        test_eq(t.b(), 5)
        
        t = T(a = lambda:3)
        test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
        
        def _f(self,a=1): return self.num + a # access the num attribute from the instance
        
        @funcs_kwargs(as_method=True)
        class T: 
            _methods=['b']
            num = 5
            
        t = T(b = _f) # adds method b
        test_eq(t.b(5), 10) # self.num + 5 = 10
        
        def _f(self,a=1): return self.num * a #multiply instead of add 
        
        class T2(T):
            def __init__(self,num):
                super().__init__(b = _f) # add method b from the super class
                self.num=num
                
        t = T2(num=3)
        test_eq(t.b(a=5), 15) # 3 * 5 = 15
        test_sig(T2, '(num)')
        [0m     
        
        [93;1mprint selected srcline with expands below[0m--------
        def funcs_kwargs(as_method=False):                                                                                                                      (0)
            "Replace methods in `cls._methods` with those from `kwargs`"========================================================================================(1)
        [91;1mhow funcs_kwargs works; it is a wrapper around _funcs_kwargs; it offers two ways of running _funcs_kwargs; the first, default way, is to add a func to a class without using self; second way is to add func to class enabling self use;[0m
            if callable(as_method): return _funcs_kwargs(as_method, False)                                                                                      (2)
            return partial(_funcs_kwargs, as_method=as_method)                                                                                                  (3)
        =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
        ===============================================================     on line [91;1m2[0m     ================================================================
             with example [91;1m
        @funcs_kwargs
        class T:
            _methods=['b'] # allows you to add method b upon instantiation
            def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
            def a(self): return 1
            def b(self): return 2
            
        t = T()
        test_eq(t.a(), 1)
        test_eq(t.b(), 2)
        
        test_sig(T, '(f=1, *, b=None)')
        inspect.signature(T)
        
        def _new_func(): return 5
        
        t = T(b = _new_func)
        test_eq(t.b(), 5)
        
        t = T(a = lambda:3)
        test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
        
        def _f(self,a=1): return self.num + a # access the num attribute from the instance
        
        @funcs_kwargs(as_method=True)
        class T: 
            _methods=['b']
            num = 5
            
        t = T(b = _f) # adds method b
        test_eq(t.b(5), 10) # self.num + 5 = 10
        
        def _f(self,a=1): return self.num * a #multiply instead of add 
        
        class T2(T):
            def __init__(self,num):
                super().__init__(b = _f) # add method b from the super class
                self.num=num
                
        t = T2(num=3)
        test_eq(t.b(a=5), 15) # 3 * 5 = 15
        test_sig(T2, '(num)')
        [0m     
        
        [93;1mprint selected srcline with expands below[0m--------
        def funcs_kwargs(as_method=False):                                                                                                                      (0)
            "Replace methods in `cls._methods` with those from `kwargs`"                                                                                        (1)
            if callable(as_method): return _funcs_kwargs(as_method, False)======================================================================================(2)
                                                                               [91;1mhow to check whether an object is callable; how to return a result of running a func; [0m
            return partial(_funcs_kwargs, as_method=as_method)                                                                                                  (3)
                                                                                                                                                                (4)
        =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
        ===============================================================     on line [91;1m3[0m     ================================================================
             with example [91;1m
        @funcs_kwargs
        class T:
            _methods=['b'] # allows you to add method b upon instantiation
            def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
            def a(self): return 1
            def b(self): return 2
            
        t = T()
        test_eq(t.a(), 1)
        test_eq(t.b(), 2)
        
        test_sig(T, '(f=1, *, b=None)')
        inspect.signature(T)
        
        def _new_func(): return 5
        
        t = T(b = _new_func)
        test_eq(t.b(), 5)
        
        t = T(a = lambda:3)
        test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
        
        def _f(self,a=1): return self.num + a # access the num attribute from the instance
        
        @funcs_kwargs(as_method=True)
        class T: 
            _methods=['b']
            num = 5
            
        t = T(b = _f) # adds method b
        test_eq(t.b(5), 10) # self.num + 5 = 10
        
        def _f(self,a=1): return self.num * a #multiply instead of add 
        
        class T2(T):
            def __init__(self,num):
                super().__init__(b = _f) # add method b from the super class
                self.num=num
                
        t = T2(num=3)
        test_eq(t.b(a=5), 15) # 3 * 5 = 15
        test_sig(T2, '(num)')
        [0m     
        
        [93;1mprint selected srcline with expands below[0m--------
            "Replace methods in `cls._methods` with those from `kwargs`"                                                                                        (1)
            if callable(as_method): return _funcs_kwargs(as_method, False)                                                                                      (2)
            return partial(_funcs_kwargs, as_method=as_method)==================================================================================================(3)
                                                                                        [91;1mhow to custom the params of `_funcs_kwargs` for a particular use with partial[0m
                                                                                                                                                                (4)
    
    
    
    ```
    #| column: screen
    fdb_.print()
    ```
    
        ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
        ==============================================================     on line [91;1mNone[0m     ==============================================================
             with example [91;1m
        @funcs_kwargs
        class T:
            _methods=['b'] # allows you to add method b upon instantiation
            def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
            def a(self): return 1
            def b(self): return 2
            
        t = T()
        test_eq(t.a(), 1)
        test_eq(t.b(), 2)
        
        test_sig(T, '(f=1, *, b=None)')
        inspect.signature(T)
        
        def _new_func(): return 5
        
        t = T(b = _new_func)
        test_eq(t.b(), 5)
        
        t = T(a = lambda:3)
        test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
        
        [0m     
        
        def _funcs_kwargs(cls, as_method):========================================================(0)       
            old_init = cls.__init__===============================================================(1)       
            def _init(self, *args, **kwargs):=====================================================(2)       
                for k in cls._methods:============================================================(3)       
                    arg = kwargs.pop(k,None)======================================================(4)       
                    if arg is not None:===========================================================(5)       
                        if as_method: arg = method(arg)===========================================(6)       
                        if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)=======(7)       
                        setattr(self, k, arg)=====================================================(8)       
                old_init(self, *args, **kwargs)===================================================(9)       
            functools.update_wrapper(_init, old_init)=============================================(10)      
            cls.__init__ = use_kwargs(cls._methods)(_init)========================================(11)      
            if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))                                                     (12)
            return cls============================================================================(13)      
                                                                                                                                                                (14)
    
    
    
    ```
    #| column: screen
    fdb_.docsrc(0, "how does _funcs_kwargs work: _funcs_kwargs is a decorator; it helps class e.g., T to add more methods; \
    I need to give the method a name, \
    and put the name e.g., 'b' inside a list called _methods=['b'] inside class T; \
    then after writing a func e.g., _new_func, I can add it by T(b = _new_func); if I want the func added to class to use self, \
    I shall write @funcs_kwargs(as_method=True)")
    fdb_.docsrc(2, "how to define a method which can use self and accept any parameters")
    fdb_.docsrc(3, "how to pop out the value of an item in a dict (with None as default), and if the item name is not found, pop out None instead; ")
    fdb_.docsrc(6, "how to turn a func into a method")
    fdb_.docsrc(7, "how to give a method a different instance, like self")
    fdb_.docsrc(8, "how to add a method to a class as an attribute")
    fdb_.docsrc(10, "how to wrap `_init` around `old_init`, so that `_init` can use `old_init` inside itself")
    fdb_.docsrc(11, "how to add a list of names with None as default value to function `_init` to repalce its kwargs param")
    fdb_.docsrc(12, "how to make a class.`__init__` signature to be the signature of the class using `__signature__` and `_rm_self`")
    
    ```
    
        ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
        ===============================================================     on line [91;1m0[0m     ================================================================
             with example [91;1m
        @funcs_kwargs
        class T:
            _methods=['b'] # allows you to add method b upon instantiation
            def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
            def a(self): return 1
            def b(self): return 2
            
        t = T()
        test_eq(t.a(), 1)
        test_eq(t.b(), 2)
        
        test_sig(T, '(f=1, *, b=None)')
        inspect.signature(T)
        
        def _new_func(): return 5
        
        t = T(b = _new_func)
        test_eq(t.b(), 5)
        
        t = T(a = lambda:3)
        test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
        
        [0m     
        
        [93;1mprint selected srcline with expands below[0m--------
        def _funcs_kwargs(cls, as_method):======================================================================================================================(0)
        [91;1mhow does _funcs_kwargs work: _funcs_kwargs is a decorator; it helps class e.g., T to add more methods; I need to give the method a name, and put the name e.g., 'b' inside a list called _methods=['b'] inside class T; then after writing a func e.g., _new_func, I can add it by T(b = _new_func); if I want the func added to class to use self, I shall write @funcs_kwargs(as_method=True)[0m
            old_init = cls.__init__                                                                                                                             (1)
            def _init(self, *args, **kwargs):                                                                                                                   (2)
        ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
        ===============================================================     on line [91;1m2[0m     ================================================================
             with example [91;1m
        @funcs_kwargs
        class T:
            _methods=['b'] # allows you to add method b upon instantiation
            def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
            def a(self): return 1
            def b(self): return 2
            
        t = T()
        test_eq(t.a(), 1)
        test_eq(t.b(), 2)
        
        test_sig(T, '(f=1, *, b=None)')
        inspect.signature(T)
        
        def _new_func(): return 5
        
        t = T(b = _new_func)
        test_eq(t.b(), 5)
        
        t = T(a = lambda:3)
        test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
        
        [0m     
        
        [93;1mprint selected srcline with expands below[0m--------
        def _funcs_kwargs(cls, as_method):                                                                                                                      (0)
            old_init = cls.__init__                                                                                                                             (1)
            def _init(self, *args, **kwargs):===================================================================================================================(2)
                                                                                                  [91;1mhow to define a method which can use self and accept any parameters[0m
                for k in cls._methods:                                                                                                                          (3)
                    arg = kwargs.pop(k,None)                                                                                                                    (4)
        ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
        ===============================================================     on line [91;1m3[0m     ================================================================
             with example [91;1m
        @funcs_kwargs
        class T:
            _methods=['b'] # allows you to add method b upon instantiation
            def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
            def a(self): return 1
            def b(self): return 2
            
        t = T()
        test_eq(t.a(), 1)
        test_eq(t.b(), 2)
        
        test_sig(T, '(f=1, *, b=None)')
        inspect.signature(T)
        
        def _new_func(): return 5
        
        t = T(b = _new_func)
        test_eq(t.b(), 5)
        
        t = T(a = lambda:3)
        test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
        
        [0m     
        
        [93;1mprint selected srcline with expands below[0m--------
            old_init = cls.__init__                                                                                                                             (1)
            def _init(self, *args, **kwargs):                                                                                                                   (2)
                for k in cls._methods:==========================================================================================================================(3)
                                      [91;1mhow to pop out the value of an item in a dict (with None as default), and if the item name is not found, pop out None instead; [0m
                    arg = kwargs.pop(k,None)                                                                                                                    (4)
                    if arg is not None:                                                                                                                         (5)
        ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
        ===============================================================     on line [91;1m6[0m     ================================================================
             with example [91;1m
        @funcs_kwargs
        class T:
            _methods=['b'] # allows you to add method b upon instantiation
            def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
            def a(self): return 1
            def b(self): return 2
            
        t = T()
        test_eq(t.a(), 1)
        test_eq(t.b(), 2)
        
        test_sig(T, '(f=1, *, b=None)')
        inspect.signature(T)
        
        def _new_func(): return 5
        
        t = T(b = _new_func)
        test_eq(t.b(), 5)
        
        t = T(a = lambda:3)
        test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
        
        [0m     
        
        [93;1mprint selected srcline with expands below[0m--------
                    arg = kwargs.pop(k,None)                                                                                                                    (4)
                    if arg is not None:                                                                                                                         (5)
                        if as_method: arg = method(arg)=========================================================================================================(6)
                                                                                                                                     [91;1mhow to turn a func into a method[0m
                        if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)                                                                     (7)
                        setattr(self, k, arg)                                                                                                                   (8)
        ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
        ===============================================================     on line [91;1m7[0m     ================================================================
             with example [91;1m
        @funcs_kwargs
        class T:
            _methods=['b'] # allows you to add method b upon instantiation
            def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
            def a(self): return 1
            def b(self): return 2
            
        t = T()
        test_eq(t.a(), 1)
        test_eq(t.b(), 2)
        
        test_sig(T, '(f=1, *, b=None)')
        inspect.signature(T)
        
        def _new_func(): return 5
        
        t = T(b = _new_func)
        test_eq(t.b(), 5)
        
        t = T(a = lambda:3)
        test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
        
        [0m     
        
        [93;1mprint selected srcline with expands below[0m--------
                    if arg is not None:                                                                                                                         (5)
                        if as_method: arg = method(arg)                                                                                                         (6)
                        if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)=====================================================================(7)
                                                                                                                 [91;1mhow to give a method a different instance, like self[0m
                        setattr(self, k, arg)                                                                                                                   (8)
                old_init(self, *args, **kwargs)                                                                                                                 (9)
        ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
        ===============================================================     on line [91;1m8[0m     ================================================================
             with example [91;1m
        @funcs_kwargs
        class T:
            _methods=['b'] # allows you to add method b upon instantiation
            def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
            def a(self): return 1
            def b(self): return 2
            
        t = T()
        test_eq(t.a(), 1)
        test_eq(t.b(), 2)
        
        test_sig(T, '(f=1, *, b=None)')
        inspect.signature(T)
        
        def _new_func(): return 5
        
        t = T(b = _new_func)
        test_eq(t.b(), 5)
        
        t = T(a = lambda:3)
        test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
        
        [0m     
        
        [93;1mprint selected srcline with expands below[0m--------
                        if as_method: arg = method(arg)                                                                                                         (6)
                        if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)                                                                     (7)
                        setattr(self, k, arg)===================================================================================================================(8)
                                                                                                                       [91;1mhow to add a method to a class as an attribute[0m
                old_init(self, *args, **kwargs)                                                                                                                 (9)
            functools.update_wrapper(_init, old_init)                                                                                                           (10)
        ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
        ===============================================================     on line [91;1m10[0m     ===============================================================
             with example [91;1m
        @funcs_kwargs
        class T:
            _methods=['b'] # allows you to add method b upon instantiation
            def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
            def a(self): return 1
            def b(self): return 2
            
        t = T()
        test_eq(t.a(), 1)
        test_eq(t.b(), 2)
        
        test_sig(T, '(f=1, *, b=None)')
        inspect.signature(T)
        
        def _new_func(): return 5
        
        t = T(b = _new_func)
        test_eq(t.b(), 5)
        
        t = T(a = lambda:3)
        test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
        
        [0m     
        
        [93;1mprint selected srcline with expands below[0m--------
                        setattr(self, k, arg)                                                                                                                   (8)
                old_init(self, *args, **kwargs)                                                                                                                 (9)
            functools.update_wrapper(_init, old_init)===========================================================================================================(10)
                                                                              [91;1mhow to wrap `_init` around `old_init`, so that `_init` can use `old_init` inside itself[0m
            cls.__init__ = use_kwargs(cls._methods)(_init)                                                                                                      (11)
            if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))                                                     (12)
        ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
        ===============================================================     on line [91;1m11[0m     ===============================================================
             with example [91;1m
        @funcs_kwargs
        class T:
            _methods=['b'] # allows you to add method b upon instantiation
            def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
            def a(self): return 1
            def b(self): return 2
            
        t = T()
        test_eq(t.a(), 1)
        test_eq(t.b(), 2)
        
        test_sig(T, '(f=1, *, b=None)')
        inspect.signature(T)
        
        def _new_func(): return 5
        
        t = T(b = _new_func)
        test_eq(t.b(), 5)
        
        t = T(a = lambda:3)
        test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
        
        [0m     
        
        [93;1mprint selected srcline with expands below[0m--------
                old_init(self, *args, **kwargs)                                                                                                                 (9)
            functools.update_wrapper(_init, old_init)                                                                                                           (10)
            cls.__init__ = use_kwargs(cls._methods)(_init)======================================================================================================(11)
                                                                [91;1mhow to add a list of names with None as default value to function `_init` to repalce its kwargs param[0m
            if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))                                                     (12)
            return cls                                                                                                                                          (13)
        ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
        ===============================================================     on line [91;1m12[0m     ===============================================================
             with example [91;1m
        @funcs_kwargs
        class T:
            _methods=['b'] # allows you to add method b upon instantiation
            def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
            def a(self): return 1
            def b(self): return 2
            
        t = T()
        test_eq(t.a(), 1)
        test_eq(t.b(), 2)
        
        test_sig(T, '(f=1, *, b=None)')
        inspect.signature(T)
        
        def _new_func(): return 5
        
        t = T(b = _new_func)
        test_eq(t.b(), 5)
        
        t = T(a = lambda:3)
        test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
        
        [0m     
        
        [93;1mprint selected srcline with expands below[0m--------
            functools.update_wrapper(_init, old_init)                                                                                                           (10)
            cls.__init__ = use_kwargs(cls._methods)(_init)                                                                                                      (11)
            if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))=====================================================(12)
                                                       [91;1mhow to make a class.`__init__` signature to be the signature of the class using `__signature__` and `_rm_self`[0m
            return cls                                                                                                                                          (13)
                                                                                                                                                                (14)
    
    
    
    ```
    #| column: screen
    fdb.snoop() # how to snoop together with docsrc: snoop first and docsrc above it
    ```
    
        22:28:59.99 >>> Call to funcs_kwargs in File "/tmp/funcs_kwargs.py", line 3
        22:28:59.99 ...... as_method = <class 'fastcore.meta.T'>
        22:28:59.99    3 | def funcs_kwargs(as_method=False):
        22:28:59.99    5 |     if callable(as_method): return _funcs_kwargs(as_method, False)
            22:28:59.99 >>> Call to _funcs_kwargs in File "/tmp/_funcs_kwargs.py", line 3
            22:28:59.99 ...... cls = <class 'fastcore.meta.T'>
            22:28:59.99 ...... as_method = False
            22:28:59.99    3 | def _funcs_kwargs(cls, as_method):
            22:28:59.99    4 |     old_init = cls.__init__
            22:28:59.99 .......... old_init = <function T.__init__>
            22:28:59.99    5 |     import snoop
            22:28:59.99 .......... snoop = <class 'snoop.configuration.Config.__init__.<locals>.ConfiguredTracer'>
            22:28:59.99    6 |     @snoop
            22:28:59.99    7 |     def _init(self, *args, **kwargs):
            22:28:59.99 .......... _init = <function _funcs_kwargs.<locals>._init>
            22:28:59.99   15 |     functools.update_wrapper(_init, old_init)
            22:28:59.99 .......... _init = <function T.__init__>
            22:28:59.99   16 |     cls.__init__ = use_kwargs(cls._methods)(_init)
            22:28:59.99   17 |     if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))
            22:28:59.99   18 |     return cls
            22:28:59.99 <<< Return value from _funcs_kwargs: <class 'fastcore.meta.T'>
        22:28:59.99    5 |     if callable(as_method): return _funcs_kwargs(as_method, False)
        22:28:59.99 <<< Return value from funcs_kwargs: <class 'fastcore.meta.T'>
        22:28:59.99 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
        22:28:59.99 .......... self = <fastcore.meta.T object>
        22:28:59.99 .......... args = ()
        22:28:59.99 .......... kwargs = {}
        22:28:59.99 .......... as_method = False
        22:28:59.99 .......... cls = <class 'fastcore.meta.T'>
        22:28:59.99 .......... old_init = <function T.__init__>
        22:28:59.99    7 |     def _init(self, *args, **kwargs):
        22:29:00.00    8 |         for k in cls._methods:
        22:29:00.00 .............. k = 'b'
        22:29:00.00    9 |             arg = kwargs.pop(k,None)
        22:29:00.00 .................. arg = None
        22:29:00.00   10 |             if arg is not None:
        22:29:00.00    8 |         for k in cls._methods:
        22:29:00.00   14 |         old_init(self, *args, **kwargs)
        22:29:00.00 <<< Return value from _funcs_kwargs.<locals>._init: None
        22:29:00.00 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
        22:29:00.00 .......... self = <fastcore.meta.T object>
        22:29:00.00 .......... args = ()
        22:29:00.00 .......... kwargs = {'b': <function _new_func>}
        22:29:00.00 .......... len(kwargs) = 1
        22:29:00.00 .......... as_method = False
        22:29:00.00 .......... cls = <class 'fastcore.meta.T'>
        22:29:00.00 .......... old_init = <function T.__init__>
        22:29:00.00    7 |     def _init(self, *args, **kwargs):
        22:29:00.00    8 |         for k in cls._methods:
        22:29:00.00 .............. k = 'b'
        22:29:00.00    9 |             arg = kwargs.pop(k,None)
        22:29:00.00 .................. kwargs = {}
        22:29:00.00 .................. arg = <function _new_func>
        22:29:00.00   10 |             if arg is not None:
        22:29:00.00   11 |                 if as_method: arg = method(arg)
        22:29:00.00   12 |                 if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)
        22:29:00.00   13 |                 setattr(self, k, arg)
        22:29:00.00    8 |         for k in cls._methods:
        22:29:00.00   14 |         old_init(self, *args, **kwargs)
        22:29:00.00 <<< Return value from _funcs_kwargs.<locals>._init: None
        22:29:00.00 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
        22:29:00.00 .......... self = <fastcore.meta.T object>
        22:29:00.00 .......... args = ()
        22:29:00.00 .......... kwargs = {'a': <function <lambda>>}
        22:29:00.00 .......... len(kwargs) = 1
        22:29:00.00 .......... as_method = False
        22:29:00.00 .......... cls = <class 'fastcore.meta.T'>
        22:29:00.00 .......... old_init = <function T.__init__>
        22:29:00.00    7 |     def _init(self, *args, **kwargs):
        22:29:00.00    8 |         for k in cls._methods:
        22:29:00.00 .............. k = 'b'
        22:29:00.00    9 |             arg = kwargs.pop(k,None)
        22:29:00.00 .................. arg = None
        22:29:00.00   10 |             if arg is not None:
        22:29:00.00    8 |         for k in cls._methods:
        22:29:00.00   14 |         old_init(self, *args, **kwargs)
        22:29:00.00 <<< Return value from _funcs_kwargs.<locals>._init: None
        22:29:00.00 >>> Call to funcs_kwargs in File "/tmp/funcs_kwargs.py", line 3
        22:29:00.00 ...... as_method = True
        22:29:00.00    3 | def funcs_kwargs(as_method=False):
        22:29:00.00    5 |     if callable(as_method): return _funcs_kwargs(as_method, False)
        22:29:00.00    6 |     return partial(_funcs_kwargs, as_method=as_method)
        22:29:00.00 <<< Return value from funcs_kwargs: functools.partial(<function _funcs_kwargs>, as_method=True)
        22:29:00.00 >>> Call to _funcs_kwargs in File "/tmp/_funcs_kwargs.py", line 3
        22:29:00.00 ...... cls = <class 'fastcore.meta.T'>
        22:29:00.00 ...... as_method = True
        22:29:00.00    3 | def _funcs_kwargs(cls, as_method):
        22:29:00.00    4 |     old_init = cls.__init__
        22:29:00.00 .......... old_init = <slot wrapper '__init__' of 'object' objects>
        22:29:00.00    5 |     import snoop
        22:29:00.00 .......... snoop = <class 'snoop.configuration.Config.__init__.<locals>.ConfiguredTracer'>
        22:29:00.00    6 |     @snoop
        22:29:00.00    7 |     def _init(self, *args, **kwargs):
        22:29:00.00 .......... _init = <function _funcs_kwargs.<locals>._init>
        22:29:00.00   15 |     functools.update_wrapper(_init, old_init)
        22:29:00.00 .......... _init = <function object.__init__>
        22:29:00.00   16 |     cls.__init__ = use_kwargs(cls._methods)(_init)
        22:29:00.01   17 |     if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))
        22:29:00.01   18 |     return cls
        22:29:00.01 <<< Return value from _funcs_kwargs: <class 'fastcore.meta.T'>
        22:29:00.01 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
        22:29:00.01 .......... self = <fastcore.meta.T object>
        22:29:00.01 .......... args = ()
        22:29:00.01 .......... kwargs = {'b': <function _f>}
        22:29:00.01 .......... len(kwargs) = 1
        22:29:00.01 .......... as_method = True
        22:29:00.01 .......... cls = <class 'fastcore.meta.T'>
        22:29:00.01 .......... old_init = <slot wrapper '__init__' of 'object' objects>
        22:29:00.01    7 |     def _init(self, *args, **kwargs):
        22:29:00.01    8 |         for k in cls._methods:
        22:29:00.01 .............. k = 'b'
        22:29:00.01    9 |             arg = kwargs.pop(k,None)
        22:29:00.01 .................. kwargs = {}
        22:29:00.01 .................. arg = <function _f>
        22:29:00.01   10 |             if arg is not None:
        22:29:00.01   11 |                 if as_method: arg = method(arg)
        22:29:00.01 ...... arg = <bound method int._f of 1>
        22:29:00.01   12 |                 if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)
        22:29:00.01 ...... arg = <bound method T._f of <fastcore.meta.T object>>
        22:29:00.01   13 |                 setattr(self, k, arg)
        22:29:00.01    8 |         for k in cls._methods:
        22:29:00.01   14 |         old_init(self, *args, **kwargs)
        22:29:00.01 <<< Return value from _funcs_kwargs.<locals>._init: None
        22:29:00.01 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
        22:29:00.01 .......... self = <fastcore.meta.T2 object>
        22:29:00.01 .......... args = ()
        22:29:00.01 .......... kwargs = {'b': <function _f>}
        22:29:00.01 .......... len(kwargs) = 1
        22:29:00.01 .......... as_method = True
        22:29:00.01 .......... cls = <class 'fastcore.meta.T'>
        22:29:00.01 .......... old_init = <slot wrapper '__init__' of 'object' objects>
        22:29:00.01    7 |     def _init(self, *args, **kwargs):
        22:29:00.01    8 |         for k in cls._methods:
        22:29:00.01 .............. k = 'b'
        22:29:00.01    9 |             arg = kwargs.pop(k,None)
        22:29:00.01 .................. kwargs = {}
        22:29:00.01 .................. arg = <function _f>
        22:29:00.01   10 |             if arg is not None:
        22:29:00.01   11 |                 if as_method: arg = method(arg)
        22:29:00.01 ...... arg = <bound method int._f of 1>
        22:29:00.01   12 |                 if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)
        22:29:00.01 ...... arg = <bound method T2._f of <fastcore.meta.T2 object>>
        22:29:00.01   13 |                 setattr(self, k, arg)
        22:29:00.01    8 |         for k in cls._methods:
        22:29:00.01   14 |         old_init(self, *args, **kwargs)
        22:29:00.01 <<< Return value from _funcs_kwargs.<locals>._init: None
    
    
        =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
        ==============================================================     on line [91;1mNone[0m     ==============================================================
             with example [91;1m
        @funcs_kwargs
        class T:
            _methods=['b'] # allows you to add method b upon instantiation
            def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
            def a(self): return 1
            def b(self): return 2
            
        t = T()
        test_eq(t.a(), 1)
        test_eq(t.b(), 2)
        
        test_sig(T, '(f=1, *, b=None)')
        inspect.signature(T)
        
        def _new_func(): return 5
        
        t = T(b = _new_func)
        test_eq(t.b(), 5)
        
        t = T(a = lambda:3)
        test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
        
        def _f(self,a=1): return self.num + a # access the num attribute from the instance
        
        @funcs_kwargs(as_method=True)
        class T: 
            _methods=['b']
            num = 5
            
        t = T(b = _f) # adds method b
        test_eq(t.b(5), 10) # self.num + 5 = 10
        
        def _f(self,a=1): return self.num * a #multiply instead of add 
        
        class T2(T):
            def __init__(self,num):
                super().__init__(b = _f) # add method b from the super class
                self.num=num
                
        t = T2(num=3)
        test_eq(t.b(a=5), 15) # 3 * 5 = 15
        test_sig(T2, '(num)')
        [0m     
        
    
    
    
    ```
    fdb_.debug()
    ```
    
        _funcs_kwargs's dbsrc code: ==============
        import snoop
        @snoop
        def _funcs_kwargs(cls, as_method):
            old_init = cls.__init__
            import snoop
            @snoop
            def _init(self, *args, **kwargs):
                for k in cls._methods:
                    arg = kwargs.pop(k,None)
                    if arg is not None:
                        if as_method: arg = method(arg)
                        if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)
                        setattr(self, k, arg)
                old_init(self, *args, **kwargs)
            functools.update_wrapper(_init, old_init)
            cls.__init__ = use_kwargs(cls._methods)(_init)
            if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))
            return cls
        
        
        
        _funcs_kwargs's example processed with dbsrc: ===============
        
        @funcs_kwargs
        class T:
            _methods=['b'] # allows you to add method b upon instantiation
            def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
            def a(self): return 1
            def b(self): return 2
            
        t = T()
        test_eq(t.a(), 1)
        test_eq(t.b(), 2)
        
        test_sig(T, '(f=1, *, b=None)')
        inspect.signature(T)
        
        def _new_func(): return 5
        
        t = T(b = _new_func)
        test_eq(t.b(), 5)
        
        t = T(a = lambda:3)
        test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
        
        
    
    
    
    ```
    #| column: screen
    fdb.print()
    ```
    
        =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
        ==============================================================     on line [91;1mNone[0m     ==============================================================
             with example [91;1m
        @funcs_kwargs
        class T:
            _methods=['b'] # allows you to add method b upon instantiation
            def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
            def a(self): return 1
            def b(self): return 2
            
        t = T()
        test_eq(t.a(), 1)
        test_eq(t.b(), 2)
        
        test_sig(T, '(f=1, *, b=None)')
        inspect.signature(T)
        
        def _new_func(): return 5
        
        t = T(b = _new_func)
        test_eq(t.b(), 5)
        
        t = T(a = lambda:3)
        test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
        
        def _f(self,a=1): return self.num + a # access the num attribute from the instance
        
        @funcs_kwargs(as_method=True)
        class T: 
            _methods=['b']
            num = 5
            
        t = T(b = _f) # adds method b
        test_eq(t.b(5), 10) # self.num + 5 = 10
        
        def _f(self,a=1): return self.num * a #multiply instead of add 
        
        class T2(T):
            def __init__(self,num):
                super().__init__(b = _f) # add method b from the super class
                self.num=num
                
        t = T2(num=3)
        test_eq(t.b(a=5), 15) # 3 * 5 = 15
        test_sig(T2, '(num)')
        [0m     
        
        def funcs_kwargs(as_method=False):========================================================(0)       
            "Replace methods in `cls._methods` with those from `kwargs`"==========================(1) # [93;1mhow funcs_kwargs works[0m; [93;1mit is a wrapper around _funcs_kwargs[0m; [91;1mit offers two ways of running _funcs_kwargs[0m; [37;1mthe first, default way, is to add a func to a class without using self[0m; [91;1msecond way is to add func to class enabling self use;[0m; 
            if callable(as_method): return _funcs_kwargs(as_method, False)========================(2) # [37;1mhow to check whether an object is callable[0m; [93;1mhow to return a result of running a func[0m; [37;1m[0m; 
            return partial(_funcs_kwargs, as_method=as_method)====================================(3) # [92;1mhow to custom the params of `_funcs_kwargs` for a particular use with partial[0m; 
                                                                                                                                                                (4)
    
    
    
    ```
    #| column: screen
    fdb_.print()
    ```
    
        ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
        ===============================================================     on line [91;1m12[0m     ===============================================================
             with example [91;1m
        @funcs_kwargs
        class T:
            _methods=['b'] # allows you to add method b upon instantiation
            def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
            def a(self): return 1
            def b(self): return 2
            
        t = T()
        test_eq(t.a(), 1)
        test_eq(t.b(), 2)
        
        test_sig(T, '(f=1, *, b=None)')
        inspect.signature(T)
        
        def _new_func(): return 5
        
        t = T(b = _new_func)
        test_eq(t.b(), 5)
        
        t = T(a = lambda:3)
        test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
        
        [0m     
        
        def _funcs_kwargs(cls, as_method):========================================================(0) # [93;1mhow does _funcs_kwargs work: _funcs_kwargs is a decorator[0m; [35;1mit helps class e.g., T to add more methods[0m; [93;1mI need to give the method a name, and put the name e.g., 'b' inside a list called _methods=['b'] inside class T[0m; [36;1mthen after writing a func e.g., _new_func, I can add it by T(b = _new_func)[0m; [36;1mif I want the func added to class to use self, I shall write @funcs_kwargs(as_method=True)[0m; 
            old_init = cls.__init__===============================================================(1)       
            def _init(self, *args, **kwargs):=====================================================(2) # [37;1mhow to define a method which can use self and accept any parameters[0m; 
                for k in cls._methods:============================================================(3) # [35;1mhow to pop out the value of an item in a dict (with None as default), and if the item name is not found, pop out None instead[0m; [91;1m[0m; 
                    arg = kwargs.pop(k,None)======================================================(4)       
                    if arg is not None:===========================================================(5)       
                        if as_method: arg = method(arg)===========================================(6) # [36;1mhow to turn a func into a method[0m; 
                        if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)=======(7) # [93;1mhow to give a method a different instance, like self[0m; 
                        setattr(self, k, arg)=====================================================(8) # [36;1mhow to add a method to a class as an attribute[0m; 
                old_init(self, *args, **kwargs)===================================================(9)       
            functools.update_wrapper(_init, old_init)=============================================(10) # [34;1mhow to wrap `_init` around `old_init`, so that `_init` can use `old_init` inside itself[0m; 
            cls.__init__ = use_kwargs(cls._methods)(_init)========================================(11) # [34;1mhow to add a list of names with None as default value to function `_init` to repalce its kwargs param[0m; 
            if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__)) # [35;1mhow to make a class.`__init__` signature to be the signature of the class using `__signature__` and `_rm_self`[0m;  (12)
            return cls============================================================================(13)      
                                                                                                                                                                (14)
    
    
    
    ```
    
    ```
    
    



[Open `0009_funcs_kwargs` in Jupyter Notebook locally](http://localhost:8888/tree/nbs/demos/0009_funcs_kwargs.ipynb)


## Best practice of fastdebug.utils


```
import fastdebug.utils as fu
import fastcore.meta as fm
```


<style>.container { width:100% !important; }</style>


**When looking for previous documented learning points**

Run `fastlistnbs()` to check and search for the interesting titles

Then run `fastnbs(...)` on the cell above `fastlistnbs()` to have a better view

Run `fastnbs(query, output=True)` to view the output with input together for notebooks on srcodes


```
fastnbs("snoop: from _funcs_kwargs to funcs_kwargs", output=True)
```


###  <mark style="background-color: #ffff00">snoop:</mark>   <mark style="background-color: #ffff00">from</mark>   <mark style="background-color: #ffff00">_ <mark style="background-color: #FFFF00">funcs_kwargs</mark> </mark>   <mark style="background-color: #ffff00">to</mark>   <mark style="background-color: #FFFF00">funcs_kwargs</mark> 



    
    
    
        
        
        
            
            
            
                
                how to snoop on two functions one wrap around another: `funcs_kwargs` is a wrapper around `_funcs_kwargs`, so I can first snoop on `_funcs_kwargs` and assign its snoop dbsrc to \
                `fm._funcs_kwargs` so that when I snoop on `funcs_kwargs`, it can use the snoop dbsrc of `_funcs_kwargs` and no example codes need to change.
                
                
                ```
                from fastcore.meta import _funcs_kwargs
                ```
                
                
                ```
                fdb_ = Fastdb(_funcs_kwargs)
                fdb_.eg = """
                @funcs_kwargs
                class T:
                    _methods=['b'] # allows you to add method b upon instantiation
                    def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                    def a(self): return 1
                    def b(self): return 2
                    
                t = T()
                test_eq(t.a(), 1)
                test_eq(t.b(), 2)
                
                test_sig(T, '(f=1, *, b=None)')
                inspect.signature(T)
                
                def _new_func(): return 5
                
                t = T(b = _new_func)
                test_eq(t.b(), 5)
                
                t = T(a = lambda:3)
                test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                """
                ```
                
                
                ```
                #| column: screen
                # no snoop result, it is expected, because the example is not calling _funcs_kwargs, but funcs_kwargs
                fdb_.snoop(deco=True) # how to snoop decorator: _funcs_kwargs is a decorator, so set deco=True to see running codes in inner f
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    [0m     
                    
                
                
                
                ```
                import fastcore.meta as fm
                ```
                
                
                ```
                fm._funcs_kwargs = fdb_.dbsrc # how to snoop on two functions one wrap around another
                ```
                
                
                ```
                fdb = Fastdb(funcs_kwargs)
                fdb.eg = """
                @funcs_kwargs
                class T:
                    _methods=['b'] # allows you to add method b upon instantiation
                    def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                    def a(self): return 1
                    def b(self): return 2
                    
                t = T()
                test_eq(t.a(), 1)
                test_eq(t.b(), 2)
                
                test_sig(T, '(f=1, *, b=None)')
                inspect.signature(T)
                
                def _new_func(): return 5
                
                t = T(b = _new_func)
                test_eq(t.b(), 5)
                
                t = T(a = lambda:3)
                test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                
                def _f(self,a=1): return self.num + a # access the num attribute from the instance
                
                @funcs_kwargs(as_method=True)
                class T: 
                    _methods=['b']
                    num = 5
                    
                t = T(b = _f) # adds method b
                test_eq(t.b(5), 10) # self.num + 5 = 10
                
                def _f(self,a=1): return self.num * a #multiply instead of add 
                
                class T2(T):
                    def __init__(self,num):
                        super().__init__(b = _f) # add method b from the super class
                        self.num=num
                        
                t = T2(num=3)
                test_eq(t.b(a=5), 15) # 3 * 5 = 15
                test_sig(T2, '(num)')
                """
                ```
                
                
                ```
                #| column: screen
                fdb.print()
                ```
                
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    def funcs_kwargs(as_method=False):========================================================(0)       
                        "Replace methods in `cls._methods` with those from `kwargs`"==========================(1)       
                        if callable(as_method): return _funcs_kwargs(as_method, False)========================(2)       
                        return partial(_funcs_kwargs, as_method=as_method)====================================(3)       
                                                                                                                                                                            (4)
                
                
                
                ```
                #| column: screen
                fdb_.print()
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    def _funcs_kwargs(cls, as_method):========================================================(0)       
                        old_init = cls.__init__===============================================================(1)       
                        def _init(self, *args, **kwargs):=====================================================(2)       
                            for k in cls._methods:============================================================(3)       
                                arg = kwargs.pop(k,None)======================================================(4)       
                                if arg is not None:===========================================================(5)       
                                    if as_method: arg = method(arg)===========================================(6)       
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)=======(7)       
                                    setattr(self, k, arg)=====================================================(8)       
                            old_init(self, *args, **kwargs)===================================================(9)       
                        functools.update_wrapper(_init, old_init)=============================================(10)      
                        cls.__init__ = use_kwargs(cls._methods)(_init)========================================(11)      
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))                                                     (12)
                        return cls============================================================================(13)      
                                                                                                                                                                            (14)
                
                
                
                ```
                #| column: screen
                fdb.docsrc(1, "how funcs_kwargs works; it is a wrapper around _funcs_kwargs; it offers two ways of running _funcs_kwargs; \
                the first, default way, is to add a func to a class without using self; second way is to add func to class enabling self use;")
                fdb.docsrc(2, "how to check whether an object is callable; how to return a result of running a func; ")
                fdb.docsrc(3, "how to custom the params of `_funcs_kwargs` for a particular use with partial")
                ```
                
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m1[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                    def funcs_kwargs(as_method=False):                                                                                                                      (0)
                        "Replace methods in `cls._methods` with those from `kwargs`"========================================================================================(1)
                    [91;1mhow funcs_kwargs works; it is a wrapper around _funcs_kwargs; it offers two ways of running _funcs_kwargs; the first, default way, is to add a func to a class without using self; second way is to add func to class enabling self use;[0m
                        if callable(as_method): return _funcs_kwargs(as_method, False)                                                                                      (2)
                        return partial(_funcs_kwargs, as_method=as_method)                                                                                                  (3)
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m2[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                    def funcs_kwargs(as_method=False):                                                                                                                      (0)
                        "Replace methods in `cls._methods` with those from `kwargs`"                                                                                        (1)
                        if callable(as_method): return _funcs_kwargs(as_method, False)======================================================================================(2)
                                                                                           [91;1mhow to check whether an object is callable; how to return a result of running a func; [0m
                        return partial(_funcs_kwargs, as_method=as_method)                                                                                                  (3)
                                                                                                                                                                            (4)
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m3[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                        "Replace methods in `cls._methods` with those from `kwargs`"                                                                                        (1)
                        if callable(as_method): return _funcs_kwargs(as_method, False)                                                                                      (2)
                        return partial(_funcs_kwargs, as_method=as_method)==================================================================================================(3)
                                                                                                    [91;1mhow to custom the params of `_funcs_kwargs` for a particular use with partial[0m
                                                                                                                                                                            (4)
                
                
                
                ```
                #| column: screen
                fdb_.print()
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    def _funcs_kwargs(cls, as_method):========================================================(0)       
                        old_init = cls.__init__===============================================================(1)       
                        def _init(self, *args, **kwargs):=====================================================(2)       
                            for k in cls._methods:============================================================(3)       
                                arg = kwargs.pop(k,None)======================================================(4)       
                                if arg is not None:===========================================================(5)       
                                    if as_method: arg = method(arg)===========================================(6)       
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)=======(7)       
                                    setattr(self, k, arg)=====================================================(8)       
                            old_init(self, *args, **kwargs)===================================================(9)       
                        functools.update_wrapper(_init, old_init)=============================================(10)      
                        cls.__init__ = use_kwargs(cls._methods)(_init)========================================(11)      
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))                                                     (12)
                        return cls============================================================================(13)      
                                                                                                                                                                            (14)
                
                
                
                ```
                #| column: screen
                fdb_.docsrc(0, "how does _funcs_kwargs work: _funcs_kwargs is a decorator; it helps class e.g., T to add more methods; \
                I need to give the method a name, \
                and put the name e.g., 'b' inside a list called _methods=['b'] inside class T; \
                then after writing a func e.g., _new_func, I can add it by T(b = _new_func); if I want the func added to class to use self, \
                I shall write @funcs_kwargs(as_method=True)")
                fdb_.docsrc(2, "how to define a method which can use self and accept any parameters")
                fdb_.docsrc(3, "how to pop out the value of an item in a dict (with None as default), and if the item name is not found, pop out None instead; ")
                fdb_.docsrc(6, "how to turn a func into a method")
                fdb_.docsrc(7, "how to give a method a different instance, like self")
                fdb_.docsrc(8, "how to add a method to a class as an attribute")
                fdb_.docsrc(10, "how to wrap `_init` around `old_init`, so that `_init` can use `old_init` inside itself")
                fdb_.docsrc(11, "how to add a list of names with None as default value to function `_init` to repalce its kwargs param")
                fdb_.docsrc(12, "how to make a class.`__init__` signature to be the signature of the class using `__signature__` and `_rm_self`")
                
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m0[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                    def _funcs_kwargs(cls, as_method):======================================================================================================================(0)
                    [91;1mhow does _funcs_kwargs work: _funcs_kwargs is a decorator; it helps class e.g., T to add more methods; I need to give the method a name, and put the name e.g., 'b' inside a list called _methods=['b'] inside class T; then after writing a func e.g., _new_func, I can add it by T(b = _new_func); if I want the func added to class to use self, I shall write @funcs_kwargs(as_method=True)[0m
                        old_init = cls.__init__                                                                                                                             (1)
                        def _init(self, *args, **kwargs):                                                                                                                   (2)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m2[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                    def _funcs_kwargs(cls, as_method):                                                                                                                      (0)
                        old_init = cls.__init__                                                                                                                             (1)
                        def _init(self, *args, **kwargs):===================================================================================================================(2)
                                                                                                              [91;1mhow to define a method which can use self and accept any parameters[0m
                            for k in cls._methods:                                                                                                                          (3)
                                arg = kwargs.pop(k,None)                                                                                                                    (4)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m3[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                        old_init = cls.__init__                                                                                                                             (1)
                        def _init(self, *args, **kwargs):                                                                                                                   (2)
                            for k in cls._methods:==========================================================================================================================(3)
                                                  [91;1mhow to pop out the value of an item in a dict (with None as default), and if the item name is not found, pop out None instead; [0m
                                arg = kwargs.pop(k,None)                                                                                                                    (4)
                                if arg is not None:                                                                                                                         (5)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m6[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                                arg = kwargs.pop(k,None)                                                                                                                    (4)
                                if arg is not None:                                                                                                                         (5)
                                    if as_method: arg = method(arg)=========================================================================================================(6)
                                                                                                                                                 [91;1mhow to turn a func into a method[0m
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)                                                                     (7)
                                    setattr(self, k, arg)                                                                                                                   (8)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m7[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                                if arg is not None:                                                                                                                         (5)
                                    if as_method: arg = method(arg)                                                                                                         (6)
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)=====================================================================(7)
                                                                                                                             [91;1mhow to give a method a different instance, like self[0m
                                    setattr(self, k, arg)                                                                                                                   (8)
                            old_init(self, *args, **kwargs)                                                                                                                 (9)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m8[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                                    if as_method: arg = method(arg)                                                                                                         (6)
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)                                                                     (7)
                                    setattr(self, k, arg)===================================================================================================================(8)
                                                                                                                                   [91;1mhow to add a method to a class as an attribute[0m
                            old_init(self, *args, **kwargs)                                                                                                                 (9)
                        functools.update_wrapper(_init, old_init)                                                                                                           (10)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m10[0m     ===============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                                    setattr(self, k, arg)                                                                                                                   (8)
                            old_init(self, *args, **kwargs)                                                                                                                 (9)
                        functools.update_wrapper(_init, old_init)===========================================================================================================(10)
                                                                                          [91;1mhow to wrap `_init` around `old_init`, so that `_init` can use `old_init` inside itself[0m
                        cls.__init__ = use_kwargs(cls._methods)(_init)                                                                                                      (11)
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))                                                     (12)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m11[0m     ===============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                            old_init(self, *args, **kwargs)                                                                                                                 (9)
                        functools.update_wrapper(_init, old_init)                                                                                                           (10)
                        cls.__init__ = use_kwargs(cls._methods)(_init)======================================================================================================(11)
                                                                            [91;1mhow to add a list of names with None as default value to function `_init` to repalce its kwargs param[0m
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))                                                     (12)
                        return cls                                                                                                                                          (13)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m12[0m     ===============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                        functools.update_wrapper(_init, old_init)                                                                                                           (10)
                        cls.__init__ = use_kwargs(cls._methods)(_init)                                                                                                      (11)
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))=====================================================(12)
                                                                   [91;1mhow to make a class.`__init__` signature to be the signature of the class using `__signature__` and `_rm_self`[0m
                        return cls                                                                                                                                          (13)
                                                                                                                                                                            (14)
                
                
                
                ```
                #| column: screen
                fdb.snoop() # how to snoop together with docsrc: snoop first and docsrc above it
                ```
                
                    22:28:59.99 >>> Call to funcs_kwargs in File "/tmp/funcs_kwargs.py", line 3
                    22:28:59.99 ...... as_method = <class 'fastcore.meta.T'>
                    22:28:59.99    3 | def funcs_kwargs(as_method=False):
                    22:28:59.99    5 |     if callable(as_method): return _funcs_kwargs(as_method, False)
                        22:28:59.99 >>> Call to _funcs_kwargs in File "/tmp/_funcs_kwargs.py", line 3
                        22:28:59.99 ...... cls = <class 'fastcore.meta.T'>
                        22:28:59.99 ...... as_method = False
                        22:28:59.99    3 | def _funcs_kwargs(cls, as_method):
                        22:28:59.99    4 |     old_init = cls.__init__
                        22:28:59.99 .......... old_init = <function T.__init__>
                        22:28:59.99    5 |     import snoop
                        22:28:59.99 .......... snoop = <class 'snoop.configuration.Config.__init__.<locals>.ConfiguredTracer'>
                        22:28:59.99    6 |     @snoop
                        22:28:59.99    7 |     def _init(self, *args, **kwargs):
                        22:28:59.99 .......... _init = <function _funcs_kwargs.<locals>._init>
                        22:28:59.99   15 |     functools.update_wrapper(_init, old_init)
                        22:28:59.99 .......... _init = <function T.__init__>
                        22:28:59.99   16 |     cls.__init__ = use_kwargs(cls._methods)(_init)
                        22:28:59.99   17 |     if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))
                        22:28:59.99   18 |     return cls
                        22:28:59.99 <<< Return value from _funcs_kwargs: <class 'fastcore.meta.T'>
                    22:28:59.99    5 |     if callable(as_method): return _funcs_kwargs(as_method, False)
                    22:28:59.99 <<< Return value from funcs_kwargs: <class 'fastcore.meta.T'>
                    22:28:59.99 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:28:59.99 .......... self = <fastcore.meta.T object>
                    22:28:59.99 .......... args = ()
                    22:28:59.99 .......... kwargs = {}
                    22:28:59.99 .......... as_method = False
                    22:28:59.99 .......... cls = <class 'fastcore.meta.T'>
                    22:28:59.99 .......... old_init = <function T.__init__>
                    22:28:59.99    7 |     def _init(self, *args, **kwargs):
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00 .............. k = 'b'
                    22:29:00.00    9 |             arg = kwargs.pop(k,None)
                    22:29:00.00 .................. arg = None
                    22:29:00.00   10 |             if arg is not None:
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00   14 |         old_init(self, *args, **kwargs)
                    22:29:00.00 <<< Return value from _funcs_kwargs.<locals>._init: None
                    22:29:00.00 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:29:00.00 .......... self = <fastcore.meta.T object>
                    22:29:00.00 .......... args = ()
                    22:29:00.00 .......... kwargs = {'b': <function _new_func>}
                    22:29:00.00 .......... len(kwargs) = 1
                    22:29:00.00 .......... as_method = False
                    22:29:00.00 .......... cls = <class 'fastcore.meta.T'>
                    22:29:00.00 .......... old_init = <function T.__init__>
                    22:29:00.00    7 |     def _init(self, *args, **kwargs):
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00 .............. k = 'b'
                    22:29:00.00    9 |             arg = kwargs.pop(k,None)
                    22:29:00.00 .................. kwargs = {}
                    22:29:00.00 .................. arg = <function _new_func>
                    22:29:00.00   10 |             if arg is not None:
                    22:29:00.00   11 |                 if as_method: arg = method(arg)
                    22:29:00.00   12 |                 if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)
                    22:29:00.00   13 |                 setattr(self, k, arg)
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00   14 |         old_init(self, *args, **kwargs)
                    22:29:00.00 <<< Return value from _funcs_kwargs.<locals>._init: None
                    22:29:00.00 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:29:00.00 .......... self = <fastcore.meta.T object>
                    22:29:00.00 .......... args = ()
                    22:29:00.00 .......... kwargs = {'a': <function <lambda>>}
                    22:29:00.00 .......... len(kwargs) = 1
                    22:29:00.00 .......... as_method = False
                    22:29:00.00 .......... cls = <class 'fastcore.meta.T'>
                    22:29:00.00 .......... old_init = <function T.__init__>
                    22:29:00.00    7 |     def _init(self, *args, **kwargs):
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00 .............. k = 'b'
                    22:29:00.00    9 |             arg = kwargs.pop(k,None)
                    22:29:00.00 .................. arg = None
                    22:29:00.00   10 |             if arg is not None:
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00   14 |         old_init(self, *args, **kwargs)
                    22:29:00.00 <<< Return value from _funcs_kwargs.<locals>._init: None
                    22:29:00.00 >>> Call to funcs_kwargs in File "/tmp/funcs_kwargs.py", line 3
                    22:29:00.00 ...... as_method = True
                    22:29:00.00    3 | def funcs_kwargs(as_method=False):
                    22:29:00.00    5 |     if callable(as_method): return _funcs_kwargs(as_method, False)
                    22:29:00.00    6 |     return partial(_funcs_kwargs, as_method=as_method)
                    22:29:00.00 <<< Return value from funcs_kwargs: functools.partial(<function _funcs_kwargs>, as_method=True)
                    22:29:00.00 >>> Call to _funcs_kwargs in File "/tmp/_funcs_kwargs.py", line 3
                    22:29:00.00 ...... cls = <class 'fastcore.meta.T'>
                    22:29:00.00 ...... as_method = True
                    22:29:00.00    3 | def _funcs_kwargs(cls, as_method):
                    22:29:00.00    4 |     old_init = cls.__init__
                    22:29:00.00 .......... old_init = <slot wrapper '__init__' of 'object' objects>
                    22:29:00.00    5 |     import snoop
                    22:29:00.00 .......... snoop = <class 'snoop.configuration.Config.__init__.<locals>.ConfiguredTracer'>
                    22:29:00.00    6 |     @snoop
                    22:29:00.00    7 |     def _init(self, *args, **kwargs):
                    22:29:00.00 .......... _init = <function _funcs_kwargs.<locals>._init>
                    22:29:00.00   15 |     functools.update_wrapper(_init, old_init)
                    22:29:00.00 .......... _init = <function object.__init__>
                    22:29:00.00   16 |     cls.__init__ = use_kwargs(cls._methods)(_init)
                    22:29:00.01   17 |     if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))
                    22:29:00.01   18 |     return cls
                    22:29:00.01 <<< Return value from _funcs_kwargs: <class 'fastcore.meta.T'>
                    22:29:00.01 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:29:00.01 .......... self = <fastcore.meta.T object>
                    22:29:00.01 .......... args = ()
                    22:29:00.01 .......... kwargs = {'b': <function _f>}
                    22:29:00.01 .......... len(kwargs) = 1
                    22:29:00.01 .......... as_method = True
                    22:29:00.01 .......... cls = <class 'fastcore.meta.T'>
                    22:29:00.01 .......... old_init = <slot wrapper '__init__' of 'object' objects>
                    22:29:00.01    7 |     def _init(self, *args, **kwargs):
                    22:29:00.01    8 |         for k in cls._methods:
                    22:29:00.01 .............. k = 'b'
                    22:29:00.01    9 |             arg = kwargs.pop(k,None)
                    22:29:00.01 .................. kwargs = {}
                    22:29:00.01 .................. arg = <function _f>
                    22:29:00.01   10 |             if arg is not None:
                    22:29:00.01   11 |                 if as_method: arg = method(arg)
                    22:29:00.01 ...... arg = <bound method int._f of 1>
                    22:29:00.01   12 |                 if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)
                    22:29:00.01 ...... arg = <bound method T._f of <fastcore.meta.T object>>
                    22:29:00.01   13 |                 setattr(self, k, arg)
                    22:29:00.01    8 |         for k in cls._methods:
                    22:29:00.01   14 |         old_init(self, *args, **kwargs)
                    22:29:00.01 <<< Return value from _funcs_kwargs.<locals>._init: None
                    22:29:00.01 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:29:00.01 .......... self = <fastcore.meta.T2 object>
                    22:29:00.01 .......... args = ()
                    22:29:00.01 .......... kwargs = {'b': <function _f>}
                    22:29:00.01 .......... len(kwargs) = 1
                    22:29:00.01 .......... as_method = True
                    22:29:00.01 .......... cls = <class 'fastcore.meta.T'>
                    22:29:00.01 .......... old_init = <slot wrapper '__init__' of 'object' objects>
                    22:29:00.01    7 |     def _init(self, *args, **kwargs):
                    22:29:00.01    8 |         for k in cls._methods:
                    22:29:00.01 .............. k = 'b'
                    22:29:00.01    9 |             arg = kwargs.pop(k,None)
                    22:29:00.01 .................. kwargs = {}
                    22:29:00.01 .................. arg = <function _f>
                    22:29:00.01   10 |             if arg is not None:
                    22:29:00.01   11 |                 if as_method: arg = method(arg)
                    22:29:00.01 ...... arg = <bound method int._f of 1>
                    22:29:00.01   12 |                 if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)
                    22:29:00.01 ...... arg = <bound method T2._f of <fastcore.meta.T2 object>>
                    22:29:00.01   13 |                 setattr(self, k, arg)
                    22:29:00.01    8 |         for k in cls._methods:
                    22:29:00.01   14 |         old_init(self, *args, **kwargs)
                    22:29:00.01 <<< Return value from _funcs_kwargs.<locals>._init: None
                
                
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                
                
                
                ```
                fdb_.debug()
                ```
                
                    _funcs_kwargs's dbsrc code: ==============
                    import snoop
                    @snoop
                    def _funcs_kwargs(cls, as_method):
                        old_init = cls.__init__
                        import snoop
                        @snoop
                        def _init(self, *args, **kwargs):
                            for k in cls._methods:
                                arg = kwargs.pop(k,None)
                                if arg is not None:
                                    if as_method: arg = method(arg)
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)
                                    setattr(self, k, arg)
                            old_init(self, *args, **kwargs)
                        functools.update_wrapper(_init, old_init)
                        cls.__init__ = use_kwargs(cls._methods)(_init)
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))
                        return cls
                    
                    
                    
                    _funcs_kwargs's example processed with dbsrc: ===============
                    
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    
                
                
                
                ```
                #| column: screen
                fdb.print()
                ```
                
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    def funcs_kwargs(as_method=False):========================================================(0)       
                        "Replace methods in `cls._methods` with those from `kwargs`"==========================(1) # [93;1mhow funcs_kwargs works[0m; [93;1mit is a wrapper around _funcs_kwargs[0m; [91;1mit offers two ways of running _funcs_kwargs[0m; [37;1mthe first, default way, is to add a func to a class without using self[0m; [91;1msecond way is to add func to class enabling self use;[0m; 
                        if callable(as_method): return _funcs_kwargs(as_method, False)========================(2) # [37;1mhow to check whether an object is callable[0m; [93;1mhow to return a result of running a func[0m; [37;1m[0m; 
                        return partial(_funcs_kwargs, as_method=as_method)====================================(3) # [92;1mhow to custom the params of `_funcs_kwargs` for a particular use with partial[0m; 
                                                                                                                                                                            (4)
                
                
                
                ```
                #| column: screen
                fdb_.print()
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m12[0m     ===============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    def _funcs_kwargs(cls, as_method):========================================================(0) # [93;1mhow does _funcs_kwargs work: _funcs_kwargs is a decorator[0m; [35;1mit helps class e.g., T to add more methods[0m; [93;1mI need to give the method a name, and put the name e.g., 'b' inside a list called _methods=['b'] inside class T[0m; [36;1mthen after writing a func e.g., _new_func, I can add it by T(b = _new_func)[0m; [36;1mif I want the func added to class to use self, I shall write @funcs_kwargs(as_method=True)[0m; 
                        old_init = cls.__init__===============================================================(1)       
                        def _init(self, *args, **kwargs):=====================================================(2) # [37;1mhow to define a method which can use self and accept any parameters[0m; 
                            for k in cls._methods:============================================================(3) # [35;1mhow to pop out the value of an item in a dict (with None as default), and if the item name is not found, pop out None instead[0m; [91;1m[0m; 
                                arg = kwargs.pop(k,None)======================================================(4)       
                                if arg is not None:===========================================================(5)       
                                    if as_method: arg = method(arg)===========================================(6) # [36;1mhow to turn a func into a method[0m; 
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)=======(7) # [93;1mhow to give a method a different instance, like self[0m; 
                                    setattr(self, k, arg)=====================================================(8) # [36;1mhow to add a method to a class as an attribute[0m; 
                            old_init(self, *args, **kwargs)===================================================(9)       
                        functools.update_wrapper(_init, old_init)=============================================(10) # [34;1mhow to wrap `_init` around `old_init`, so that `_init` can use `old_init` inside itself[0m; 
                        cls.__init__ = use_kwargs(cls._methods)(_init)========================================(11) # [34;1mhow to add a list of names with None as default value to function `_init` to repalce its kwargs param[0m; 
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__)) # [35;1mhow to make a class.`__init__` signature to be the signature of the class using `__signature__` and `_rm_self`[0m;  (12)
                        return cls============================================================================(13)      
                                                                                                                                                                            (14)
                
                
                
                ```
                
                ```
                
                
            
            
            
            [Open `0009_funcs_kwargs` in Jupyter Notebook](http://localhost:8888/tree/nbs/demos/0009_funcs_kwargs.ipynb)
            
            
            
        
        
        
        [Open `utils` in Jupyter Notebook](http://localhost:8888/tree/nbs/lib/utils.ipynb)
        
        
        
        
    
    
    
    [Open `utils` in Jupyter Notebook](http://localhost:8888/tree/nbs/lib/utils.ipynb)
    
    
    
    



[Open `utils` in Jupyter Notebook locally](http://localhost:8888/tree/nbs/lib/utils.ipynb)



###  <mark style="background-color: #ffff00">snoop:</mark>   <mark style="background-color: #ffff00">from</mark>   <mark style="background-color: #ffff00">_ <mark style="background-color: #FFFF00">funcs_kwargs</mark> </mark>   <mark style="background-color: #ffff00">to</mark>   <mark style="background-color: #FFFF00">funcs_kwargs</mark> 



    
    
    
        
        
        
            
            
            
                
                how to snoop on two functions one wrap around another: `funcs_kwargs` is a wrapper around `_funcs_kwargs`, so I can first snoop on `_funcs_kwargs` and assign its snoop dbsrc to \
                `fm._funcs_kwargs` so that when I snoop on `funcs_kwargs`, it can use the snoop dbsrc of `_funcs_kwargs` and no example codes need to change.
                
                
                ```
                from fastcore.meta import _funcs_kwargs
                ```
                
                
                ```
                fdb_ = Fastdb(_funcs_kwargs)
                fdb_.eg = """
                @funcs_kwargs
                class T:
                    _methods=['b'] # allows you to add method b upon instantiation
                    def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                    def a(self): return 1
                    def b(self): return 2
                    
                t = T()
                test_eq(t.a(), 1)
                test_eq(t.b(), 2)
                
                test_sig(T, '(f=1, *, b=None)')
                inspect.signature(T)
                
                def _new_func(): return 5
                
                t = T(b = _new_func)
                test_eq(t.b(), 5)
                
                t = T(a = lambda:3)
                test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                """
                ```
                
                
                ```
                #| column: screen
                # no snoop result, it is expected, because the example is not calling _funcs_kwargs, but funcs_kwargs
                fdb_.snoop(deco=True) # how to snoop decorator: _funcs_kwargs is a decorator, so set deco=True to see running codes in inner f
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    [0m     
                    
                
                
                
                ```
                import fastcore.meta as fm
                ```
                
                
                ```
                fm._funcs_kwargs = fdb_.dbsrc # how to snoop on two functions one wrap around another
                ```
                
                
                ```
                fdb = Fastdb(funcs_kwargs)
                fdb.eg = """
                @funcs_kwargs
                class T:
                    _methods=['b'] # allows you to add method b upon instantiation
                    def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                    def a(self): return 1
                    def b(self): return 2
                    
                t = T()
                test_eq(t.a(), 1)
                test_eq(t.b(), 2)
                
                test_sig(T, '(f=1, *, b=None)')
                inspect.signature(T)
                
                def _new_func(): return 5
                
                t = T(b = _new_func)
                test_eq(t.b(), 5)
                
                t = T(a = lambda:3)
                test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                
                def _f(self,a=1): return self.num + a # access the num attribute from the instance
                
                @funcs_kwargs(as_method=True)
                class T: 
                    _methods=['b']
                    num = 5
                    
                t = T(b = _f) # adds method b
                test_eq(t.b(5), 10) # self.num + 5 = 10
                
                def _f(self,a=1): return self.num * a #multiply instead of add 
                
                class T2(T):
                    def __init__(self,num):
                        super().__init__(b = _f) # add method b from the super class
                        self.num=num
                        
                t = T2(num=3)
                test_eq(t.b(a=5), 15) # 3 * 5 = 15
                test_sig(T2, '(num)')
                """
                ```
                
                
                ```
                #| column: screen
                fdb.print()
                ```
                
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    def funcs_kwargs(as_method=False):========================================================(0)       
                        "Replace methods in `cls._methods` with those from `kwargs`"==========================(1)       
                        if callable(as_method): return _funcs_kwargs(as_method, False)========================(2)       
                        return partial(_funcs_kwargs, as_method=as_method)====================================(3)       
                                                                                                                                                                            (4)
                
                
                
                ```
                #| column: screen
                fdb_.print()
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    def _funcs_kwargs(cls, as_method):========================================================(0)       
                        old_init = cls.__init__===============================================================(1)       
                        def _init(self, *args, **kwargs):=====================================================(2)       
                            for k in cls._methods:============================================================(3)       
                                arg = kwargs.pop(k,None)======================================================(4)       
                                if arg is not None:===========================================================(5)       
                                    if as_method: arg = method(arg)===========================================(6)       
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)=======(7)       
                                    setattr(self, k, arg)=====================================================(8)       
                            old_init(self, *args, **kwargs)===================================================(9)       
                        functools.update_wrapper(_init, old_init)=============================================(10)      
                        cls.__init__ = use_kwargs(cls._methods)(_init)========================================(11)      
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))                                                     (12)
                        return cls============================================================================(13)      
                                                                                                                                                                            (14)
                
                
                
                ```
                #| column: screen
                fdb.docsrc(1, "how funcs_kwargs works; it is a wrapper around _funcs_kwargs; it offers two ways of running _funcs_kwargs; \
                the first, default way, is to add a func to a class without using self; second way is to add func to class enabling self use;")
                fdb.docsrc(2, "how to check whether an object is callable; how to return a result of running a func; ")
                fdb.docsrc(3, "how to custom the params of `_funcs_kwargs` for a particular use with partial")
                ```
                
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m1[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                    def funcs_kwargs(as_method=False):                                                                                                                      (0)
                        "Replace methods in `cls._methods` with those from `kwargs`"========================================================================================(1)
                    [91;1mhow funcs_kwargs works; it is a wrapper around _funcs_kwargs; it offers two ways of running _funcs_kwargs; the first, default way, is to add a func to a class without using self; second way is to add func to class enabling self use;[0m
                        if callable(as_method): return _funcs_kwargs(as_method, False)                                                                                      (2)
                        return partial(_funcs_kwargs, as_method=as_method)                                                                                                  (3)
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m2[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                    def funcs_kwargs(as_method=False):                                                                                                                      (0)
                        "Replace methods in `cls._methods` with those from `kwargs`"                                                                                        (1)
                        if callable(as_method): return _funcs_kwargs(as_method, False)======================================================================================(2)
                                                                                           [91;1mhow to check whether an object is callable; how to return a result of running a func; [0m
                        return partial(_funcs_kwargs, as_method=as_method)                                                                                                  (3)
                                                                                                                                                                            (4)
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m3[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                        "Replace methods in `cls._methods` with those from `kwargs`"                                                                                        (1)
                        if callable(as_method): return _funcs_kwargs(as_method, False)                                                                                      (2)
                        return partial(_funcs_kwargs, as_method=as_method)==================================================================================================(3)
                                                                                                    [91;1mhow to custom the params of `_funcs_kwargs` for a particular use with partial[0m
                                                                                                                                                                            (4)
                
                
                
                ```
                #| column: screen
                fdb_.print()
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    def _funcs_kwargs(cls, as_method):========================================================(0)       
                        old_init = cls.__init__===============================================================(1)       
                        def _init(self, *args, **kwargs):=====================================================(2)       
                            for k in cls._methods:============================================================(3)       
                                arg = kwargs.pop(k,None)======================================================(4)       
                                if arg is not None:===========================================================(5)       
                                    if as_method: arg = method(arg)===========================================(6)       
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)=======(7)       
                                    setattr(self, k, arg)=====================================================(8)       
                            old_init(self, *args, **kwargs)===================================================(9)       
                        functools.update_wrapper(_init, old_init)=============================================(10)      
                        cls.__init__ = use_kwargs(cls._methods)(_init)========================================(11)      
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))                                                     (12)
                        return cls============================================================================(13)      
                                                                                                                                                                            (14)
                
                
                
                ```
                #| column: screen
                fdb_.docsrc(0, "how does _funcs_kwargs work: _funcs_kwargs is a decorator; it helps class e.g., T to add more methods; \
                I need to give the method a name, \
                and put the name e.g., 'b' inside a list called _methods=['b'] inside class T; \
                then after writing a func e.g., _new_func, I can add it by T(b = _new_func); if I want the func added to class to use self, \
                I shall write @funcs_kwargs(as_method=True)")
                fdb_.docsrc(2, "how to define a method which can use self and accept any parameters")
                fdb_.docsrc(3, "how to pop out the value of an item in a dict (with None as default), and if the item name is not found, pop out None instead; ")
                fdb_.docsrc(6, "how to turn a func into a method")
                fdb_.docsrc(7, "how to give a method a different instance, like self")
                fdb_.docsrc(8, "how to add a method to a class as an attribute")
                fdb_.docsrc(10, "how to wrap `_init` around `old_init`, so that `_init` can use `old_init` inside itself")
                fdb_.docsrc(11, "how to add a list of names with None as default value to function `_init` to repalce its kwargs param")
                fdb_.docsrc(12, "how to make a class.`__init__` signature to be the signature of the class using `__signature__` and `_rm_self`")
                
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m0[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                    def _funcs_kwargs(cls, as_method):======================================================================================================================(0)
                    [91;1mhow does _funcs_kwargs work: _funcs_kwargs is a decorator; it helps class e.g., T to add more methods; I need to give the method a name, and put the name e.g., 'b' inside a list called _methods=['b'] inside class T; then after writing a func e.g., _new_func, I can add it by T(b = _new_func); if I want the func added to class to use self, I shall write @funcs_kwargs(as_method=True)[0m
                        old_init = cls.__init__                                                                                                                             (1)
                        def _init(self, *args, **kwargs):                                                                                                                   (2)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m2[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                    def _funcs_kwargs(cls, as_method):                                                                                                                      (0)
                        old_init = cls.__init__                                                                                                                             (1)
                        def _init(self, *args, **kwargs):===================================================================================================================(2)
                                                                                                              [91;1mhow to define a method which can use self and accept any parameters[0m
                            for k in cls._methods:                                                                                                                          (3)
                                arg = kwargs.pop(k,None)                                                                                                                    (4)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m3[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                        old_init = cls.__init__                                                                                                                             (1)
                        def _init(self, *args, **kwargs):                                                                                                                   (2)
                            for k in cls._methods:==========================================================================================================================(3)
                                                  [91;1mhow to pop out the value of an item in a dict (with None as default), and if the item name is not found, pop out None instead; [0m
                                arg = kwargs.pop(k,None)                                                                                                                    (4)
                                if arg is not None:                                                                                                                         (5)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m6[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                                arg = kwargs.pop(k,None)                                                                                                                    (4)
                                if arg is not None:                                                                                                                         (5)
                                    if as_method: arg = method(arg)=========================================================================================================(6)
                                                                                                                                                 [91;1mhow to turn a func into a method[0m
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)                                                                     (7)
                                    setattr(self, k, arg)                                                                                                                   (8)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m7[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                                if arg is not None:                                                                                                                         (5)
                                    if as_method: arg = method(arg)                                                                                                         (6)
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)=====================================================================(7)
                                                                                                                             [91;1mhow to give a method a different instance, like self[0m
                                    setattr(self, k, arg)                                                                                                                   (8)
                            old_init(self, *args, **kwargs)                                                                                                                 (9)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m8[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                                    if as_method: arg = method(arg)                                                                                                         (6)
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)                                                                     (7)
                                    setattr(self, k, arg)===================================================================================================================(8)
                                                                                                                                   [91;1mhow to add a method to a class as an attribute[0m
                            old_init(self, *args, **kwargs)                                                                                                                 (9)
                        functools.update_wrapper(_init, old_init)                                                                                                           (10)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m10[0m     ===============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                                    setattr(self, k, arg)                                                                                                                   (8)
                            old_init(self, *args, **kwargs)                                                                                                                 (9)
                        functools.update_wrapper(_init, old_init)===========================================================================================================(10)
                                                                                          [91;1mhow to wrap `_init` around `old_init`, so that `_init` can use `old_init` inside itself[0m
                        cls.__init__ = use_kwargs(cls._methods)(_init)                                                                                                      (11)
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))                                                     (12)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m11[0m     ===============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                            old_init(self, *args, **kwargs)                                                                                                                 (9)
                        functools.update_wrapper(_init, old_init)                                                                                                           (10)
                        cls.__init__ = use_kwargs(cls._methods)(_init)======================================================================================================(11)
                                                                            [91;1mhow to add a list of names with None as default value to function `_init` to repalce its kwargs param[0m
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))                                                     (12)
                        return cls                                                                                                                                          (13)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m12[0m     ===============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                        functools.update_wrapper(_init, old_init)                                                                                                           (10)
                        cls.__init__ = use_kwargs(cls._methods)(_init)                                                                                                      (11)
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))=====================================================(12)
                                                                   [91;1mhow to make a class.`__init__` signature to be the signature of the class using `__signature__` and `_rm_self`[0m
                        return cls                                                                                                                                          (13)
                                                                                                                                                                            (14)
                
                
                
                ```
                #| column: screen
                fdb.snoop() # how to snoop together with docsrc: snoop first and docsrc above it
                ```
                
                    22:28:59.99 >>> Call to funcs_kwargs in File "/tmp/funcs_kwargs.py", line 3
                    22:28:59.99 ...... as_method = <class 'fastcore.meta.T'>
                    22:28:59.99    3 | def funcs_kwargs(as_method=False):
                    22:28:59.99    5 |     if callable(as_method): return _funcs_kwargs(as_method, False)
                        22:28:59.99 >>> Call to _funcs_kwargs in File "/tmp/_funcs_kwargs.py", line 3
                        22:28:59.99 ...... cls = <class 'fastcore.meta.T'>
                        22:28:59.99 ...... as_method = False
                        22:28:59.99    3 | def _funcs_kwargs(cls, as_method):
                        22:28:59.99    4 |     old_init = cls.__init__
                        22:28:59.99 .......... old_init = <function T.__init__>
                        22:28:59.99    5 |     import snoop
                        22:28:59.99 .......... snoop = <class 'snoop.configuration.Config.__init__.<locals>.ConfiguredTracer'>
                        22:28:59.99    6 |     @snoop
                        22:28:59.99    7 |     def _init(self, *args, **kwargs):
                        22:28:59.99 .......... _init = <function _funcs_kwargs.<locals>._init>
                        22:28:59.99   15 |     functools.update_wrapper(_init, old_init)
                        22:28:59.99 .......... _init = <function T.__init__>
                        22:28:59.99   16 |     cls.__init__ = use_kwargs(cls._methods)(_init)
                        22:28:59.99   17 |     if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))
                        22:28:59.99   18 |     return cls
                        22:28:59.99 <<< Return value from _funcs_kwargs: <class 'fastcore.meta.T'>
                    22:28:59.99    5 |     if callable(as_method): return _funcs_kwargs(as_method, False)
                    22:28:59.99 <<< Return value from funcs_kwargs: <class 'fastcore.meta.T'>
                    22:28:59.99 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:28:59.99 .......... self = <fastcore.meta.T object>
                    22:28:59.99 .......... args = ()
                    22:28:59.99 .......... kwargs = {}
                    22:28:59.99 .......... as_method = False
                    22:28:59.99 .......... cls = <class 'fastcore.meta.T'>
                    22:28:59.99 .......... old_init = <function T.__init__>
                    22:28:59.99    7 |     def _init(self, *args, **kwargs):
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00 .............. k = 'b'
                    22:29:00.00    9 |             arg = kwargs.pop(k,None)
                    22:29:00.00 .................. arg = None
                    22:29:00.00   10 |             if arg is not None:
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00   14 |         old_init(self, *args, **kwargs)
                    22:29:00.00 <<< Return value from _funcs_kwargs.<locals>._init: None
                    22:29:00.00 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:29:00.00 .......... self = <fastcore.meta.T object>
                    22:29:00.00 .......... args = ()
                    22:29:00.00 .......... kwargs = {'b': <function _new_func>}
                    22:29:00.00 .......... len(kwargs) = 1
                    22:29:00.00 .......... as_method = False
                    22:29:00.00 .......... cls = <class 'fastcore.meta.T'>
                    22:29:00.00 .......... old_init = <function T.__init__>
                    22:29:00.00    7 |     def _init(self, *args, **kwargs):
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00 .............. k = 'b'
                    22:29:00.00    9 |             arg = kwargs.pop(k,None)
                    22:29:00.00 .................. kwargs = {}
                    22:29:00.00 .................. arg = <function _new_func>
                    22:29:00.00   10 |             if arg is not None:
                    22:29:00.00   11 |                 if as_method: arg = method(arg)
                    22:29:00.00   12 |                 if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)
                    22:29:00.00   13 |                 setattr(self, k, arg)
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00   14 |         old_init(self, *args, **kwargs)
                    22:29:00.00 <<< Return value from _funcs_kwargs.<locals>._init: None
                    22:29:00.00 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:29:00.00 .......... self = <fastcore.meta.T object>
                    22:29:00.00 .......... args = ()
                    22:29:00.00 .......... kwargs = {'a': <function <lambda>>}
                    22:29:00.00 .......... len(kwargs) = 1
                    22:29:00.00 .......... as_method = False
                    22:29:00.00 .......... cls = <class 'fastcore.meta.T'>
                    22:29:00.00 .......... old_init = <function T.__init__>
                    22:29:00.00    7 |     def _init(self, *args, **kwargs):
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00 .............. k = 'b'
                    22:29:00.00    9 |             arg = kwargs.pop(k,None)
                    22:29:00.00 .................. arg = None
                    22:29:00.00   10 |             if arg is not None:
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00   14 |         old_init(self, *args, **kwargs)
                    22:29:00.00 <<< Return value from _funcs_kwargs.<locals>._init: None
                    22:29:00.00 >>> Call to funcs_kwargs in File "/tmp/funcs_kwargs.py", line 3
                    22:29:00.00 ...... as_method = True
                    22:29:00.00    3 | def funcs_kwargs(as_method=False):
                    22:29:00.00    5 |     if callable(as_method): return _funcs_kwargs(as_method, False)
                    22:29:00.00    6 |     return partial(_funcs_kwargs, as_method=as_method)
                    22:29:00.00 <<< Return value from funcs_kwargs: functools.partial(<function _funcs_kwargs>, as_method=True)
                    22:29:00.00 >>> Call to _funcs_kwargs in File "/tmp/_funcs_kwargs.py", line 3
                    22:29:00.00 ...... cls = <class 'fastcore.meta.T'>
                    22:29:00.00 ...... as_method = True
                    22:29:00.00    3 | def _funcs_kwargs(cls, as_method):
                    22:29:00.00    4 |     old_init = cls.__init__
                    22:29:00.00 .......... old_init = <slot wrapper '__init__' of 'object' objects>
                    22:29:00.00    5 |     import snoop
                    22:29:00.00 .......... snoop = <class 'snoop.configuration.Config.__init__.<locals>.ConfiguredTracer'>
                    22:29:00.00    6 |     @snoop
                    22:29:00.00    7 |     def _init(self, *args, **kwargs):
                    22:29:00.00 .......... _init = <function _funcs_kwargs.<locals>._init>
                    22:29:00.00   15 |     functools.update_wrapper(_init, old_init)
                    22:29:00.00 .......... _init = <function object.__init__>
                    22:29:00.00   16 |     cls.__init__ = use_kwargs(cls._methods)(_init)
                    22:29:00.01   17 |     if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))
                    22:29:00.01   18 |     return cls
                    22:29:00.01 <<< Return value from _funcs_kwargs: <class 'fastcore.meta.T'>
                    22:29:00.01 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:29:00.01 .......... self = <fastcore.meta.T object>
                    22:29:00.01 .......... args = ()
                    22:29:00.01 .......... kwargs = {'b': <function _f>}
                    22:29:00.01 .......... len(kwargs) = 1
                    22:29:00.01 .......... as_method = True
                    22:29:00.01 .......... cls = <class 'fastcore.meta.T'>
                    22:29:00.01 .......... old_init = <slot wrapper '__init__' of 'object' objects>
                    22:29:00.01    7 |     def _init(self, *args, **kwargs):
                    22:29:00.01    8 |         for k in cls._methods:
                    22:29:00.01 .............. k = 'b'
                    22:29:00.01    9 |             arg = kwargs.pop(k,None)
                    22:29:00.01 .................. kwargs = {}
                    22:29:00.01 .................. arg = <function _f>
                    22:29:00.01   10 |             if arg is not None:
                    22:29:00.01   11 |                 if as_method: arg = method(arg)
                    22:29:00.01 ...... arg = <bound method int._f of 1>
                    22:29:00.01   12 |                 if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)
                    22:29:00.01 ...... arg = <bound method T._f of <fastcore.meta.T object>>
                    22:29:00.01   13 |                 setattr(self, k, arg)
                    22:29:00.01    8 |         for k in cls._methods:
                    22:29:00.01   14 |         old_init(self, *args, **kwargs)
                    22:29:00.01 <<< Return value from _funcs_kwargs.<locals>._init: None
                    22:29:00.01 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:29:00.01 .......... self = <fastcore.meta.T2 object>
                    22:29:00.01 .......... args = ()
                    22:29:00.01 .......... kwargs = {'b': <function _f>}
                    22:29:00.01 .......... len(kwargs) = 1
                    22:29:00.01 .......... as_method = True
                    22:29:00.01 .......... cls = <class 'fastcore.meta.T'>
                    22:29:00.01 .......... old_init = <slot wrapper '__init__' of 'object' objects>
                    22:29:00.01    7 |     def _init(self, *args, **kwargs):
                    22:29:00.01    8 |         for k in cls._methods:
                    22:29:00.01 .............. k = 'b'
                    22:29:00.01    9 |             arg = kwargs.pop(k,None)
                    22:29:00.01 .................. kwargs = {}
                    22:29:00.01 .................. arg = <function _f>
                    22:29:00.01   10 |             if arg is not None:
                    22:29:00.01   11 |                 if as_method: arg = method(arg)
                    22:29:00.01 ...... arg = <bound method int._f of 1>
                    22:29:00.01   12 |                 if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)
                    22:29:00.01 ...... arg = <bound method T2._f of <fastcore.meta.T2 object>>
                    22:29:00.01   13 |                 setattr(self, k, arg)
                    22:29:00.01    8 |         for k in cls._methods:
                    22:29:00.01   14 |         old_init(self, *args, **kwargs)
                    22:29:00.01 <<< Return value from _funcs_kwargs.<locals>._init: None
                
                
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                
                
                
                ```
                fdb_.debug()
                ```
                
                    _funcs_kwargs's dbsrc code: ==============
                    import snoop
                    @snoop
                    def _funcs_kwargs(cls, as_method):
                        old_init = cls.__init__
                        import snoop
                        @snoop
                        def _init(self, *args, **kwargs):
                            for k in cls._methods:
                                arg = kwargs.pop(k,None)
                                if arg is not None:
                                    if as_method: arg = method(arg)
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)
                                    setattr(self, k, arg)
                            old_init(self, *args, **kwargs)
                        functools.update_wrapper(_init, old_init)
                        cls.__init__ = use_kwargs(cls._methods)(_init)
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))
                        return cls
                    
                    
                    
                    _funcs_kwargs's example processed with dbsrc: ===============
                    
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    
                
                
                
                ```
                #| column: screen
                fdb.print()
                ```
                
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    def funcs_kwargs(as_method=False):========================================================(0)       
                        "Replace methods in `cls._methods` with those from `kwargs`"==========================(1) # [93;1mhow funcs_kwargs works[0m; [93;1mit is a wrapper around _funcs_kwargs[0m; [91;1mit offers two ways of running _funcs_kwargs[0m; [37;1mthe first, default way, is to add a func to a class without using self[0m; [91;1msecond way is to add func to class enabling self use;[0m; 
                        if callable(as_method): return _funcs_kwargs(as_method, False)========================(2) # [37;1mhow to check whether an object is callable[0m; [93;1mhow to return a result of running a func[0m; [37;1m[0m; 
                        return partial(_funcs_kwargs, as_method=as_method)====================================(3) # [92;1mhow to custom the params of `_funcs_kwargs` for a particular use with partial[0m; 
                                                                                                                                                                            (4)
                
                
                
                ```
                #| column: screen
                fdb_.print()
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m12[0m     ===============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    def _funcs_kwargs(cls, as_method):========================================================(0) # [93;1mhow does _funcs_kwargs work: _funcs_kwargs is a decorator[0m; [35;1mit helps class e.g., T to add more methods[0m; [93;1mI need to give the method a name, and put the name e.g., 'b' inside a list called _methods=['b'] inside class T[0m; [36;1mthen after writing a func e.g., _new_func, I can add it by T(b = _new_func)[0m; [36;1mif I want the func added to class to use self, I shall write @funcs_kwargs(as_method=True)[0m; 
                        old_init = cls.__init__===============================================================(1)       
                        def _init(self, *args, **kwargs):=====================================================(2) # [37;1mhow to define a method which can use self and accept any parameters[0m; 
                            for k in cls._methods:============================================================(3) # [35;1mhow to pop out the value of an item in a dict (with None as default), and if the item name is not found, pop out None instead[0m; [91;1m[0m; 
                                arg = kwargs.pop(k,None)======================================================(4)       
                                if arg is not None:===========================================================(5)       
                                    if as_method: arg = method(arg)===========================================(6) # [36;1mhow to turn a func into a method[0m; 
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)=======(7) # [93;1mhow to give a method a different instance, like self[0m; 
                                    setattr(self, k, arg)=====================================================(8) # [36;1mhow to add a method to a class as an attribute[0m; 
                            old_init(self, *args, **kwargs)===================================================(9)       
                        functools.update_wrapper(_init, old_init)=============================================(10) # [34;1mhow to wrap `_init` around `old_init`, so that `_init` can use `old_init` inside itself[0m; 
                        cls.__init__ = use_kwargs(cls._methods)(_init)========================================(11) # [34;1mhow to add a list of names with None as default value to function `_init` to repalce its kwargs param[0m; 
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__)) # [35;1mhow to make a class.`__init__` signature to be the signature of the class using `__signature__` and `_rm_self`[0m;  (12)
                        return cls============================================================================(13)      
                                                                                                                                                                            (14)
                
                
                
                ```
                
                ```
                
                
            
            
            
            [Open `0009_funcs_kwargs` in Jupyter Notebook](http://localhost:8888/tree/nbs/demos/0009_funcs_kwargs.ipynb)
            
            
            
        
        
        
        [Open `utils` in Jupyter Notebook](http://localhost:8888/tree/nbs/lib/utils.ipynb)
        
        
        
        
    
    
    
    [Open `utils` in Jupyter Notebook](http://localhost:8888/tree/nbs/lib/utils.ipynb)
    
    
    
    



[Open `utils` in Jupyter Notebook locally](http://localhost:8888/tree/nbs/lib/utils.ipynb)



###  <mark style="background-color: #ffff00">snoop:</mark>   <mark style="background-color: #ffff00">from</mark>   <mark style="background-color: #ffff00">_ <mark style="background-color: #FFFF00">funcs_kwargs</mark> </mark>   <mark style="background-color: #ffff00">to</mark>   <mark style="background-color: #FFFF00">funcs_kwargs</mark> 



    
    
    
        
        
        
            
            
            
                
                how to snoop on two functions one wrap around another: `funcs_kwargs` is a wrapper around `_funcs_kwargs`, so I can first snoop on `_funcs_kwargs` and assign its snoop dbsrc to \
                `fm._funcs_kwargs` so that when I snoop on `funcs_kwargs`, it can use the snoop dbsrc of `_funcs_kwargs` and no example codes need to change.
                
                
                ```
                from fastcore.meta import _funcs_kwargs
                ```
                
                
                ```
                fdb_ = Fastdb(_funcs_kwargs)
                fdb_.eg = """
                @funcs_kwargs
                class T:
                    _methods=['b'] # allows you to add method b upon instantiation
                    def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                    def a(self): return 1
                    def b(self): return 2
                    
                t = T()
                test_eq(t.a(), 1)
                test_eq(t.b(), 2)
                
                test_sig(T, '(f=1, *, b=None)')
                inspect.signature(T)
                
                def _new_func(): return 5
                
                t = T(b = _new_func)
                test_eq(t.b(), 5)
                
                t = T(a = lambda:3)
                test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                """
                ```
                
                
                ```
                #| column: screen
                # no snoop result, it is expected, because the example is not calling _funcs_kwargs, but funcs_kwargs
                fdb_.snoop(deco=True) # how to snoop decorator: _funcs_kwargs is a decorator, so set deco=True to see running codes in inner f
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    [0m     
                    
                
                
                
                ```
                import fastcore.meta as fm
                ```
                
                
                ```
                fm._funcs_kwargs = fdb_.dbsrc # how to snoop on two functions one wrap around another
                ```
                
                
                ```
                fdb = Fastdb(funcs_kwargs)
                fdb.eg = """
                @funcs_kwargs
                class T:
                    _methods=['b'] # allows you to add method b upon instantiation
                    def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                    def a(self): return 1
                    def b(self): return 2
                    
                t = T()
                test_eq(t.a(), 1)
                test_eq(t.b(), 2)
                
                test_sig(T, '(f=1, *, b=None)')
                inspect.signature(T)
                
                def _new_func(): return 5
                
                t = T(b = _new_func)
                test_eq(t.b(), 5)
                
                t = T(a = lambda:3)
                test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                
                def _f(self,a=1): return self.num + a # access the num attribute from the instance
                
                @funcs_kwargs(as_method=True)
                class T: 
                    _methods=['b']
                    num = 5
                    
                t = T(b = _f) # adds method b
                test_eq(t.b(5), 10) # self.num + 5 = 10
                
                def _f(self,a=1): return self.num * a #multiply instead of add 
                
                class T2(T):
                    def __init__(self,num):
                        super().__init__(b = _f) # add method b from the super class
                        self.num=num
                        
                t = T2(num=3)
                test_eq(t.b(a=5), 15) # 3 * 5 = 15
                test_sig(T2, '(num)')
                """
                ```
                
                
                ```
                #| column: screen
                fdb.print()
                ```
                
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    def funcs_kwargs(as_method=False):========================================================(0)       
                        "Replace methods in `cls._methods` with those from `kwargs`"==========================(1)       
                        if callable(as_method): return _funcs_kwargs(as_method, False)========================(2)       
                        return partial(_funcs_kwargs, as_method=as_method)====================================(3)       
                                                                                                                                                                            (4)
                
                
                
                ```
                #| column: screen
                fdb_.print()
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    def _funcs_kwargs(cls, as_method):========================================================(0)       
                        old_init = cls.__init__===============================================================(1)       
                        def _init(self, *args, **kwargs):=====================================================(2)       
                            for k in cls._methods:============================================================(3)       
                                arg = kwargs.pop(k,None)======================================================(4)       
                                if arg is not None:===========================================================(5)       
                                    if as_method: arg = method(arg)===========================================(6)       
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)=======(7)       
                                    setattr(self, k, arg)=====================================================(8)       
                            old_init(self, *args, **kwargs)===================================================(9)       
                        functools.update_wrapper(_init, old_init)=============================================(10)      
                        cls.__init__ = use_kwargs(cls._methods)(_init)========================================(11)      
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))                                                     (12)
                        return cls============================================================================(13)      
                                                                                                                                                                            (14)
                
                
                
                ```
                #| column: screen
                fdb.docsrc(1, "how funcs_kwargs works; it is a wrapper around _funcs_kwargs; it offers two ways of running _funcs_kwargs; \
                the first, default way, is to add a func to a class without using self; second way is to add func to class enabling self use;")
                fdb.docsrc(2, "how to check whether an object is callable; how to return a result of running a func; ")
                fdb.docsrc(3, "how to custom the params of `_funcs_kwargs` for a particular use with partial")
                ```
                
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m1[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                    def funcs_kwargs(as_method=False):                                                                                                                      (0)
                        "Replace methods in `cls._methods` with those from `kwargs`"========================================================================================(1)
                    [91;1mhow funcs_kwargs works; it is a wrapper around _funcs_kwargs; it offers two ways of running _funcs_kwargs; the first, default way, is to add a func to a class without using self; second way is to add func to class enabling self use;[0m
                        if callable(as_method): return _funcs_kwargs(as_method, False)                                                                                      (2)
                        return partial(_funcs_kwargs, as_method=as_method)                                                                                                  (3)
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m2[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                    def funcs_kwargs(as_method=False):                                                                                                                      (0)
                        "Replace methods in `cls._methods` with those from `kwargs`"                                                                                        (1)
                        if callable(as_method): return _funcs_kwargs(as_method, False)======================================================================================(2)
                                                                                           [91;1mhow to check whether an object is callable; how to return a result of running a func; [0m
                        return partial(_funcs_kwargs, as_method=as_method)                                                                                                  (3)
                                                                                                                                                                            (4)
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m3[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                        "Replace methods in `cls._methods` with those from `kwargs`"                                                                                        (1)
                        if callable(as_method): return _funcs_kwargs(as_method, False)                                                                                      (2)
                        return partial(_funcs_kwargs, as_method=as_method)==================================================================================================(3)
                                                                                                    [91;1mhow to custom the params of `_funcs_kwargs` for a particular use with partial[0m
                                                                                                                                                                            (4)
                
                
                
                ```
                #| column: screen
                fdb_.print()
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    def _funcs_kwargs(cls, as_method):========================================================(0)       
                        old_init = cls.__init__===============================================================(1)       
                        def _init(self, *args, **kwargs):=====================================================(2)       
                            for k in cls._methods:============================================================(3)       
                                arg = kwargs.pop(k,None)======================================================(4)       
                                if arg is not None:===========================================================(5)       
                                    if as_method: arg = method(arg)===========================================(6)       
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)=======(7)       
                                    setattr(self, k, arg)=====================================================(8)       
                            old_init(self, *args, **kwargs)===================================================(9)       
                        functools.update_wrapper(_init, old_init)=============================================(10)      
                        cls.__init__ = use_kwargs(cls._methods)(_init)========================================(11)      
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))                                                     (12)
                        return cls============================================================================(13)      
                                                                                                                                                                            (14)
                
                
                
                ```
                #| column: screen
                fdb_.docsrc(0, "how does _funcs_kwargs work: _funcs_kwargs is a decorator; it helps class e.g., T to add more methods; \
                I need to give the method a name, \
                and put the name e.g., 'b' inside a list called _methods=['b'] inside class T; \
                then after writing a func e.g., _new_func, I can add it by T(b = _new_func); if I want the func added to class to use self, \
                I shall write @funcs_kwargs(as_method=True)")
                fdb_.docsrc(2, "how to define a method which can use self and accept any parameters")
                fdb_.docsrc(3, "how to pop out the value of an item in a dict (with None as default), and if the item name is not found, pop out None instead; ")
                fdb_.docsrc(6, "how to turn a func into a method")
                fdb_.docsrc(7, "how to give a method a different instance, like self")
                fdb_.docsrc(8, "how to add a method to a class as an attribute")
                fdb_.docsrc(10, "how to wrap `_init` around `old_init`, so that `_init` can use `old_init` inside itself")
                fdb_.docsrc(11, "how to add a list of names with None as default value to function `_init` to repalce its kwargs param")
                fdb_.docsrc(12, "how to make a class.`__init__` signature to be the signature of the class using `__signature__` and `_rm_self`")
                
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m0[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                    def _funcs_kwargs(cls, as_method):======================================================================================================================(0)
                    [91;1mhow does _funcs_kwargs work: _funcs_kwargs is a decorator; it helps class e.g., T to add more methods; I need to give the method a name, and put the name e.g., 'b' inside a list called _methods=['b'] inside class T; then after writing a func e.g., _new_func, I can add it by T(b = _new_func); if I want the func added to class to use self, I shall write @funcs_kwargs(as_method=True)[0m
                        old_init = cls.__init__                                                                                                                             (1)
                        def _init(self, *args, **kwargs):                                                                                                                   (2)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m2[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                    def _funcs_kwargs(cls, as_method):                                                                                                                      (0)
                        old_init = cls.__init__                                                                                                                             (1)
                        def _init(self, *args, **kwargs):===================================================================================================================(2)
                                                                                                              [91;1mhow to define a method which can use self and accept any parameters[0m
                            for k in cls._methods:                                                                                                                          (3)
                                arg = kwargs.pop(k,None)                                                                                                                    (4)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m3[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                        old_init = cls.__init__                                                                                                                             (1)
                        def _init(self, *args, **kwargs):                                                                                                                   (2)
                            for k in cls._methods:==========================================================================================================================(3)
                                                  [91;1mhow to pop out the value of an item in a dict (with None as default), and if the item name is not found, pop out None instead; [0m
                                arg = kwargs.pop(k,None)                                                                                                                    (4)
                                if arg is not None:                                                                                                                         (5)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m6[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                                arg = kwargs.pop(k,None)                                                                                                                    (4)
                                if arg is not None:                                                                                                                         (5)
                                    if as_method: arg = method(arg)=========================================================================================================(6)
                                                                                                                                                 [91;1mhow to turn a func into a method[0m
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)                                                                     (7)
                                    setattr(self, k, arg)                                                                                                                   (8)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m7[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                                if arg is not None:                                                                                                                         (5)
                                    if as_method: arg = method(arg)                                                                                                         (6)
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)=====================================================================(7)
                                                                                                                             [91;1mhow to give a method a different instance, like self[0m
                                    setattr(self, k, arg)                                                                                                                   (8)
                            old_init(self, *args, **kwargs)                                                                                                                 (9)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m8[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                                    if as_method: arg = method(arg)                                                                                                         (6)
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)                                                                     (7)
                                    setattr(self, k, arg)===================================================================================================================(8)
                                                                                                                                   [91;1mhow to add a method to a class as an attribute[0m
                            old_init(self, *args, **kwargs)                                                                                                                 (9)
                        functools.update_wrapper(_init, old_init)                                                                                                           (10)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m10[0m     ===============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                                    setattr(self, k, arg)                                                                                                                   (8)
                            old_init(self, *args, **kwargs)                                                                                                                 (9)
                        functools.update_wrapper(_init, old_init)===========================================================================================================(10)
                                                                                          [91;1mhow to wrap `_init` around `old_init`, so that `_init` can use `old_init` inside itself[0m
                        cls.__init__ = use_kwargs(cls._methods)(_init)                                                                                                      (11)
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))                                                     (12)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m11[0m     ===============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                            old_init(self, *args, **kwargs)                                                                                                                 (9)
                        functools.update_wrapper(_init, old_init)                                                                                                           (10)
                        cls.__init__ = use_kwargs(cls._methods)(_init)======================================================================================================(11)
                                                                            [91;1mhow to add a list of names with None as default value to function `_init` to repalce its kwargs param[0m
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))                                                     (12)
                        return cls                                                                                                                                          (13)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m12[0m     ===============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                        functools.update_wrapper(_init, old_init)                                                                                                           (10)
                        cls.__init__ = use_kwargs(cls._methods)(_init)                                                                                                      (11)
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))=====================================================(12)
                                                                   [91;1mhow to make a class.`__init__` signature to be the signature of the class using `__signature__` and `_rm_self`[0m
                        return cls                                                                                                                                          (13)
                                                                                                                                                                            (14)
                
                
                
                ```
                #| column: screen
                fdb.snoop() # how to snoop together with docsrc: snoop first and docsrc above it
                ```
                
                    22:28:59.99 >>> Call to funcs_kwargs in File "/tmp/funcs_kwargs.py", line 3
                    22:28:59.99 ...... as_method = <class 'fastcore.meta.T'>
                    22:28:59.99    3 | def funcs_kwargs(as_method=False):
                    22:28:59.99    5 |     if callable(as_method): return _funcs_kwargs(as_method, False)
                        22:28:59.99 >>> Call to _funcs_kwargs in File "/tmp/_funcs_kwargs.py", line 3
                        22:28:59.99 ...... cls = <class 'fastcore.meta.T'>
                        22:28:59.99 ...... as_method = False
                        22:28:59.99    3 | def _funcs_kwargs(cls, as_method):
                        22:28:59.99    4 |     old_init = cls.__init__
                        22:28:59.99 .......... old_init = <function T.__init__>
                        22:28:59.99    5 |     import snoop
                        22:28:59.99 .......... snoop = <class 'snoop.configuration.Config.__init__.<locals>.ConfiguredTracer'>
                        22:28:59.99    6 |     @snoop
                        22:28:59.99    7 |     def _init(self, *args, **kwargs):
                        22:28:59.99 .......... _init = <function _funcs_kwargs.<locals>._init>
                        22:28:59.99   15 |     functools.update_wrapper(_init, old_init)
                        22:28:59.99 .......... _init = <function T.__init__>
                        22:28:59.99   16 |     cls.__init__ = use_kwargs(cls._methods)(_init)
                        22:28:59.99   17 |     if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))
                        22:28:59.99   18 |     return cls
                        22:28:59.99 <<< Return value from _funcs_kwargs: <class 'fastcore.meta.T'>
                    22:28:59.99    5 |     if callable(as_method): return _funcs_kwargs(as_method, False)
                    22:28:59.99 <<< Return value from funcs_kwargs: <class 'fastcore.meta.T'>
                    22:28:59.99 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:28:59.99 .......... self = <fastcore.meta.T object>
                    22:28:59.99 .......... args = ()
                    22:28:59.99 .......... kwargs = {}
                    22:28:59.99 .......... as_method = False
                    22:28:59.99 .......... cls = <class 'fastcore.meta.T'>
                    22:28:59.99 .......... old_init = <function T.__init__>
                    22:28:59.99    7 |     def _init(self, *args, **kwargs):
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00 .............. k = 'b'
                    22:29:00.00    9 |             arg = kwargs.pop(k,None)
                    22:29:00.00 .................. arg = None
                    22:29:00.00   10 |             if arg is not None:
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00   14 |         old_init(self, *args, **kwargs)
                    22:29:00.00 <<< Return value from _funcs_kwargs.<locals>._init: None
                    22:29:00.00 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:29:00.00 .......... self = <fastcore.meta.T object>
                    22:29:00.00 .......... args = ()
                    22:29:00.00 .......... kwargs = {'b': <function _new_func>}
                    22:29:00.00 .......... len(kwargs) = 1
                    22:29:00.00 .......... as_method = False
                    22:29:00.00 .......... cls = <class 'fastcore.meta.T'>
                    22:29:00.00 .......... old_init = <function T.__init__>
                    22:29:00.00    7 |     def _init(self, *args, **kwargs):
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00 .............. k = 'b'
                    22:29:00.00    9 |             arg = kwargs.pop(k,None)
                    22:29:00.00 .................. kwargs = {}
                    22:29:00.00 .................. arg = <function _new_func>
                    22:29:00.00   10 |             if arg is not None:
                    22:29:00.00   11 |                 if as_method: arg = method(arg)
                    22:29:00.00   12 |                 if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)
                    22:29:00.00   13 |                 setattr(self, k, arg)
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00   14 |         old_init(self, *args, **kwargs)
                    22:29:00.00 <<< Return value from _funcs_kwargs.<locals>._init: None
                    22:29:00.00 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:29:00.00 .......... self = <fastcore.meta.T object>
                    22:29:00.00 .......... args = ()
                    22:29:00.00 .......... kwargs = {'a': <function <lambda>>}
                    22:29:00.00 .......... len(kwargs) = 1
                    22:29:00.00 .......... as_method = False
                    22:29:00.00 .......... cls = <class 'fastcore.meta.T'>
                    22:29:00.00 .......... old_init = <function T.__init__>
                    22:29:00.00    7 |     def _init(self, *args, **kwargs):
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00 .............. k = 'b'
                    22:29:00.00    9 |             arg = kwargs.pop(k,None)
                    22:29:00.00 .................. arg = None
                    22:29:00.00   10 |             if arg is not None:
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00   14 |         old_init(self, *args, **kwargs)
                    22:29:00.00 <<< Return value from _funcs_kwargs.<locals>._init: None
                    22:29:00.00 >>> Call to funcs_kwargs in File "/tmp/funcs_kwargs.py", line 3
                    22:29:00.00 ...... as_method = True
                    22:29:00.00    3 | def funcs_kwargs(as_method=False):
                    22:29:00.00    5 |     if callable(as_method): return _funcs_kwargs(as_method, False)
                    22:29:00.00    6 |     return partial(_funcs_kwargs, as_method=as_method)
                    22:29:00.00 <<< Return value from funcs_kwargs: functools.partial(<function _funcs_kwargs>, as_method=True)
                    22:29:00.00 >>> Call to _funcs_kwargs in File "/tmp/_funcs_kwargs.py", line 3
                    22:29:00.00 ...... cls = <class 'fastcore.meta.T'>
                    22:29:00.00 ...... as_method = True
                    22:29:00.00    3 | def _funcs_kwargs(cls, as_method):
                    22:29:00.00    4 |     old_init = cls.__init__
                    22:29:00.00 .......... old_init = <slot wrapper '__init__' of 'object' objects>
                    22:29:00.00    5 |     import snoop
                    22:29:00.00 .......... snoop = <class 'snoop.configuration.Config.__init__.<locals>.ConfiguredTracer'>
                    22:29:00.00    6 |     @snoop
                    22:29:00.00    7 |     def _init(self, *args, **kwargs):
                    22:29:00.00 .......... _init = <function _funcs_kwargs.<locals>._init>
                    22:29:00.00   15 |     functools.update_wrapper(_init, old_init)
                    22:29:00.00 .......... _init = <function object.__init__>
                    22:29:00.00   16 |     cls.__init__ = use_kwargs(cls._methods)(_init)
                    22:29:00.01   17 |     if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))
                    22:29:00.01   18 |     return cls
                    22:29:00.01 <<< Return value from _funcs_kwargs: <class 'fastcore.meta.T'>
                    22:29:00.01 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:29:00.01 .......... self = <fastcore.meta.T object>
                    22:29:00.01 .......... args = ()
                    22:29:00.01 .......... kwargs = {'b': <function _f>}
                    22:29:00.01 .......... len(kwargs) = 1
                    22:29:00.01 .......... as_method = True
                    22:29:00.01 .......... cls = <class 'fastcore.meta.T'>
                    22:29:00.01 .......... old_init = <slot wrapper '__init__' of 'object' objects>
                    22:29:00.01    7 |     def _init(self, *args, **kwargs):
                    22:29:00.01    8 |         for k in cls._methods:
                    22:29:00.01 .............. k = 'b'
                    22:29:00.01    9 |             arg = kwargs.pop(k,None)
                    22:29:00.01 .................. kwargs = {}
                    22:29:00.01 .................. arg = <function _f>
                    22:29:00.01   10 |             if arg is not None:
                    22:29:00.01   11 |                 if as_method: arg = method(arg)
                    22:29:00.01 ...... arg = <bound method int._f of 1>
                    22:29:00.01   12 |                 if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)
                    22:29:00.01 ...... arg = <bound method T._f of <fastcore.meta.T object>>
                    22:29:00.01   13 |                 setattr(self, k, arg)
                    22:29:00.01    8 |         for k in cls._methods:
                    22:29:00.01   14 |         old_init(self, *args, **kwargs)
                    22:29:00.01 <<< Return value from _funcs_kwargs.<locals>._init: None
                    22:29:00.01 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:29:00.01 .......... self = <fastcore.meta.T2 object>
                    22:29:00.01 .......... args = ()
                    22:29:00.01 .......... kwargs = {'b': <function _f>}
                    22:29:00.01 .......... len(kwargs) = 1
                    22:29:00.01 .......... as_method = True
                    22:29:00.01 .......... cls = <class 'fastcore.meta.T'>
                    22:29:00.01 .......... old_init = <slot wrapper '__init__' of 'object' objects>
                    22:29:00.01    7 |     def _init(self, *args, **kwargs):
                    22:29:00.01    8 |         for k in cls._methods:
                    22:29:00.01 .............. k = 'b'
                    22:29:00.01    9 |             arg = kwargs.pop(k,None)
                    22:29:00.01 .................. kwargs = {}
                    22:29:00.01 .................. arg = <function _f>
                    22:29:00.01   10 |             if arg is not None:
                    22:29:00.01   11 |                 if as_method: arg = method(arg)
                    22:29:00.01 ...... arg = <bound method int._f of 1>
                    22:29:00.01   12 |                 if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)
                    22:29:00.01 ...... arg = <bound method T2._f of <fastcore.meta.T2 object>>
                    22:29:00.01   13 |                 setattr(self, k, arg)
                    22:29:00.01    8 |         for k in cls._methods:
                    22:29:00.01   14 |         old_init(self, *args, **kwargs)
                    22:29:00.01 <<< Return value from _funcs_kwargs.<locals>._init: None
                
                
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                
                
                
                ```
                fdb_.debug()
                ```
                
                    _funcs_kwargs's dbsrc code: ==============
                    import snoop
                    @snoop
                    def _funcs_kwargs(cls, as_method):
                        old_init = cls.__init__
                        import snoop
                        @snoop
                        def _init(self, *args, **kwargs):
                            for k in cls._methods:
                                arg = kwargs.pop(k,None)
                                if arg is not None:
                                    if as_method: arg = method(arg)
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)
                                    setattr(self, k, arg)
                            old_init(self, *args, **kwargs)
                        functools.update_wrapper(_init, old_init)
                        cls.__init__ = use_kwargs(cls._methods)(_init)
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))
                        return cls
                    
                    
                    
                    _funcs_kwargs's example processed with dbsrc: ===============
                    
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    
                
                
                
                ```
                #| column: screen
                fdb.print()
                ```
                
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    def funcs_kwargs(as_method=False):========================================================(0)       
                        "Replace methods in `cls._methods` with those from `kwargs`"==========================(1) # [93;1mhow funcs_kwargs works[0m; [93;1mit is a wrapper around _funcs_kwargs[0m; [91;1mit offers two ways of running _funcs_kwargs[0m; [37;1mthe first, default way, is to add a func to a class without using self[0m; [91;1msecond way is to add func to class enabling self use;[0m; 
                        if callable(as_method): return _funcs_kwargs(as_method, False)========================(2) # [37;1mhow to check whether an object is callable[0m; [93;1mhow to return a result of running a func[0m; [37;1m[0m; 
                        return partial(_funcs_kwargs, as_method=as_method)====================================(3) # [92;1mhow to custom the params of `_funcs_kwargs` for a particular use with partial[0m; 
                                                                                                                                                                            (4)
                
                
                
                ```
                #| column: screen
                fdb_.print()
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m12[0m     ===============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    def _funcs_kwargs(cls, as_method):========================================================(0) # [93;1mhow does _funcs_kwargs work: _funcs_kwargs is a decorator[0m; [35;1mit helps class e.g., T to add more methods[0m; [93;1mI need to give the method a name, and put the name e.g., 'b' inside a list called _methods=['b'] inside class T[0m; [36;1mthen after writing a func e.g., _new_func, I can add it by T(b = _new_func)[0m; [36;1mif I want the func added to class to use self, I shall write @funcs_kwargs(as_method=True)[0m; 
                        old_init = cls.__init__===============================================================(1)       
                        def _init(self, *args, **kwargs):=====================================================(2) # [37;1mhow to define a method which can use self and accept any parameters[0m; 
                            for k in cls._methods:============================================================(3) # [35;1mhow to pop out the value of an item in a dict (with None as default), and if the item name is not found, pop out None instead[0m; [91;1m[0m; 
                                arg = kwargs.pop(k,None)======================================================(4)       
                                if arg is not None:===========================================================(5)       
                                    if as_method: arg = method(arg)===========================================(6) # [36;1mhow to turn a func into a method[0m; 
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)=======(7) # [93;1mhow to give a method a different instance, like self[0m; 
                                    setattr(self, k, arg)=====================================================(8) # [36;1mhow to add a method to a class as an attribute[0m; 
                            old_init(self, *args, **kwargs)===================================================(9)       
                        functools.update_wrapper(_init, old_init)=============================================(10) # [34;1mhow to wrap `_init` around `old_init`, so that `_init` can use `old_init` inside itself[0m; 
                        cls.__init__ = use_kwargs(cls._methods)(_init)========================================(11) # [34;1mhow to add a list of names with None as default value to function `_init` to repalce its kwargs param[0m; 
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__)) # [35;1mhow to make a class.`__init__` signature to be the signature of the class using `__signature__` and `_rm_self`[0m;  (12)
                        return cls============================================================================(13)      
                                                                                                                                                                            (14)
                
                
                
                ```
                
                ```
                
                
            
            
            
            [Open `0009_funcs_kwargs` in Jupyter Notebook](http://localhost:8888/tree/nbs/demos/0009_funcs_kwargs.ipynb)
            
            
            
        
        
        
        [Open `utils` in Jupyter Notebook](http://localhost:8888/tree/nbs/lib/utils.ipynb)
        
        
        
        
    
    
    
    [Open `utils` in Jupyter Notebook](http://localhost:8888/tree/nbs/lib/utils.ipynb)
    
    
    
    



[Open `utils` in Jupyter Notebook locally](http://localhost:8888/tree/nbs/lib/utils.ipynb)



###  <mark style="background-color: #ffff00">snoop:</mark>   <mark style="background-color: #ffff00">from</mark>   <mark style="background-color: #ffff00">_ <mark style="background-color: #FFFF00">funcs_kwargs</mark> </mark>   <mark style="background-color: #ffff00">to</mark>   <mark style="background-color: #FFFF00">funcs_kwargs</mark> 



    
    
    
        
        
        
            
            
            
                
                how to snoop on two functions one wrap around another: `funcs_kwargs` is a wrapper around `_funcs_kwargs`, so I can first snoop on `_funcs_kwargs` and assign its snoop dbsrc to \
                `fm._funcs_kwargs` so that when I snoop on `funcs_kwargs`, it can use the snoop dbsrc of `_funcs_kwargs` and no example codes need to change.
                
                
                ```
                from fastcore.meta import _funcs_kwargs
                ```
                
                
                ```
                fdb_ = Fastdb(_funcs_kwargs)
                fdb_.eg = """
                @funcs_kwargs
                class T:
                    _methods=['b'] # allows you to add method b upon instantiation
                    def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                    def a(self): return 1
                    def b(self): return 2
                    
                t = T()
                test_eq(t.a(), 1)
                test_eq(t.b(), 2)
                
                test_sig(T, '(f=1, *, b=None)')
                inspect.signature(T)
                
                def _new_func(): return 5
                
                t = T(b = _new_func)
                test_eq(t.b(), 5)
                
                t = T(a = lambda:3)
                test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                """
                ```
                
                
                ```
                #| column: screen
                # no snoop result, it is expected, because the example is not calling _funcs_kwargs, but funcs_kwargs
                fdb_.snoop(deco=True) # how to snoop decorator: _funcs_kwargs is a decorator, so set deco=True to see running codes in inner f
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    [0m     
                    
                
                
                
                ```
                import fastcore.meta as fm
                ```
                
                
                ```
                fm._funcs_kwargs = fdb_.dbsrc # how to snoop on two functions one wrap around another
                ```
                
                
                ```
                fdb = Fastdb(funcs_kwargs)
                fdb.eg = """
                @funcs_kwargs
                class T:
                    _methods=['b'] # allows you to add method b upon instantiation
                    def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                    def a(self): return 1
                    def b(self): return 2
                    
                t = T()
                test_eq(t.a(), 1)
                test_eq(t.b(), 2)
                
                test_sig(T, '(f=1, *, b=None)')
                inspect.signature(T)
                
                def _new_func(): return 5
                
                t = T(b = _new_func)
                test_eq(t.b(), 5)
                
                t = T(a = lambda:3)
                test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                
                def _f(self,a=1): return self.num + a # access the num attribute from the instance
                
                @funcs_kwargs(as_method=True)
                class T: 
                    _methods=['b']
                    num = 5
                    
                t = T(b = _f) # adds method b
                test_eq(t.b(5), 10) # self.num + 5 = 10
                
                def _f(self,a=1): return self.num * a #multiply instead of add 
                
                class T2(T):
                    def __init__(self,num):
                        super().__init__(b = _f) # add method b from the super class
                        self.num=num
                        
                t = T2(num=3)
                test_eq(t.b(a=5), 15) # 3 * 5 = 15
                test_sig(T2, '(num)')
                """
                ```
                
                
                ```
                #| column: screen
                fdb.print()
                ```
                
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    def funcs_kwargs(as_method=False):========================================================(0)       
                        "Replace methods in `cls._methods` with those from `kwargs`"==========================(1)       
                        if callable(as_method): return _funcs_kwargs(as_method, False)========================(2)       
                        return partial(_funcs_kwargs, as_method=as_method)====================================(3)       
                                                                                                                                                                            (4)
                
                
                
                ```
                #| column: screen
                fdb_.print()
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    def _funcs_kwargs(cls, as_method):========================================================(0)       
                        old_init = cls.__init__===============================================================(1)       
                        def _init(self, *args, **kwargs):=====================================================(2)       
                            for k in cls._methods:============================================================(3)       
                                arg = kwargs.pop(k,None)======================================================(4)       
                                if arg is not None:===========================================================(5)       
                                    if as_method: arg = method(arg)===========================================(6)       
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)=======(7)       
                                    setattr(self, k, arg)=====================================================(8)       
                            old_init(self, *args, **kwargs)===================================================(9)       
                        functools.update_wrapper(_init, old_init)=============================================(10)      
                        cls.__init__ = use_kwargs(cls._methods)(_init)========================================(11)      
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))                                                     (12)
                        return cls============================================================================(13)      
                                                                                                                                                                            (14)
                
                
                
                ```
                #| column: screen
                fdb.docsrc(1, "how funcs_kwargs works; it is a wrapper around _funcs_kwargs; it offers two ways of running _funcs_kwargs; \
                the first, default way, is to add a func to a class without using self; second way is to add func to class enabling self use;")
                fdb.docsrc(2, "how to check whether an object is callable; how to return a result of running a func; ")
                fdb.docsrc(3, "how to custom the params of `_funcs_kwargs` for a particular use with partial")
                ```
                
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m1[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                    def funcs_kwargs(as_method=False):                                                                                                                      (0)
                        "Replace methods in `cls._methods` with those from `kwargs`"========================================================================================(1)
                    [91;1mhow funcs_kwargs works; it is a wrapper around _funcs_kwargs; it offers two ways of running _funcs_kwargs; the first, default way, is to add a func to a class without using self; second way is to add func to class enabling self use;[0m
                        if callable(as_method): return _funcs_kwargs(as_method, False)                                                                                      (2)
                        return partial(_funcs_kwargs, as_method=as_method)                                                                                                  (3)
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m2[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                    def funcs_kwargs(as_method=False):                                                                                                                      (0)
                        "Replace methods in `cls._methods` with those from `kwargs`"                                                                                        (1)
                        if callable(as_method): return _funcs_kwargs(as_method, False)======================================================================================(2)
                                                                                           [91;1mhow to check whether an object is callable; how to return a result of running a func; [0m
                        return partial(_funcs_kwargs, as_method=as_method)                                                                                                  (3)
                                                                                                                                                                            (4)
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m3[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                        "Replace methods in `cls._methods` with those from `kwargs`"                                                                                        (1)
                        if callable(as_method): return _funcs_kwargs(as_method, False)                                                                                      (2)
                        return partial(_funcs_kwargs, as_method=as_method)==================================================================================================(3)
                                                                                                    [91;1mhow to custom the params of `_funcs_kwargs` for a particular use with partial[0m
                                                                                                                                                                            (4)
                
                
                
                ```
                #| column: screen
                fdb_.print()
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    def _funcs_kwargs(cls, as_method):========================================================(0)       
                        old_init = cls.__init__===============================================================(1)       
                        def _init(self, *args, **kwargs):=====================================================(2)       
                            for k in cls._methods:============================================================(3)       
                                arg = kwargs.pop(k,None)======================================================(4)       
                                if arg is not None:===========================================================(5)       
                                    if as_method: arg = method(arg)===========================================(6)       
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)=======(7)       
                                    setattr(self, k, arg)=====================================================(8)       
                            old_init(self, *args, **kwargs)===================================================(9)       
                        functools.update_wrapper(_init, old_init)=============================================(10)      
                        cls.__init__ = use_kwargs(cls._methods)(_init)========================================(11)      
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))                                                     (12)
                        return cls============================================================================(13)      
                                                                                                                                                                            (14)
                
                
                
                ```
                #| column: screen
                fdb_.docsrc(0, "how does _funcs_kwargs work: _funcs_kwargs is a decorator; it helps class e.g., T to add more methods; \
                I need to give the method a name, \
                and put the name e.g., 'b' inside a list called _methods=['b'] inside class T; \
                then after writing a func e.g., _new_func, I can add it by T(b = _new_func); if I want the func added to class to use self, \
                I shall write @funcs_kwargs(as_method=True)")
                fdb_.docsrc(2, "how to define a method which can use self and accept any parameters")
                fdb_.docsrc(3, "how to pop out the value of an item in a dict (with None as default), and if the item name is not found, pop out None instead; ")
                fdb_.docsrc(6, "how to turn a func into a method")
                fdb_.docsrc(7, "how to give a method a different instance, like self")
                fdb_.docsrc(8, "how to add a method to a class as an attribute")
                fdb_.docsrc(10, "how to wrap `_init` around `old_init`, so that `_init` can use `old_init` inside itself")
                fdb_.docsrc(11, "how to add a list of names with None as default value to function `_init` to repalce its kwargs param")
                fdb_.docsrc(12, "how to make a class.`__init__` signature to be the signature of the class using `__signature__` and `_rm_self`")
                
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m0[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                    def _funcs_kwargs(cls, as_method):======================================================================================================================(0)
                    [91;1mhow does _funcs_kwargs work: _funcs_kwargs is a decorator; it helps class e.g., T to add more methods; I need to give the method a name, and put the name e.g., 'b' inside a list called _methods=['b'] inside class T; then after writing a func e.g., _new_func, I can add it by T(b = _new_func); if I want the func added to class to use self, I shall write @funcs_kwargs(as_method=True)[0m
                        old_init = cls.__init__                                                                                                                             (1)
                        def _init(self, *args, **kwargs):                                                                                                                   (2)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m2[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                    def _funcs_kwargs(cls, as_method):                                                                                                                      (0)
                        old_init = cls.__init__                                                                                                                             (1)
                        def _init(self, *args, **kwargs):===================================================================================================================(2)
                                                                                                              [91;1mhow to define a method which can use self and accept any parameters[0m
                            for k in cls._methods:                                                                                                                          (3)
                                arg = kwargs.pop(k,None)                                                                                                                    (4)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m3[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                        old_init = cls.__init__                                                                                                                             (1)
                        def _init(self, *args, **kwargs):                                                                                                                   (2)
                            for k in cls._methods:==========================================================================================================================(3)
                                                  [91;1mhow to pop out the value of an item in a dict (with None as default), and if the item name is not found, pop out None instead; [0m
                                arg = kwargs.pop(k,None)                                                                                                                    (4)
                                if arg is not None:                                                                                                                         (5)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m6[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                                arg = kwargs.pop(k,None)                                                                                                                    (4)
                                if arg is not None:                                                                                                                         (5)
                                    if as_method: arg = method(arg)=========================================================================================================(6)
                                                                                                                                                 [91;1mhow to turn a func into a method[0m
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)                                                                     (7)
                                    setattr(self, k, arg)                                                                                                                   (8)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m7[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                                if arg is not None:                                                                                                                         (5)
                                    if as_method: arg = method(arg)                                                                                                         (6)
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)=====================================================================(7)
                                                                                                                             [91;1mhow to give a method a different instance, like self[0m
                                    setattr(self, k, arg)                                                                                                                   (8)
                            old_init(self, *args, **kwargs)                                                                                                                 (9)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m8[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                                    if as_method: arg = method(arg)                                                                                                         (6)
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)                                                                     (7)
                                    setattr(self, k, arg)===================================================================================================================(8)
                                                                                                                                   [91;1mhow to add a method to a class as an attribute[0m
                            old_init(self, *args, **kwargs)                                                                                                                 (9)
                        functools.update_wrapper(_init, old_init)                                                                                                           (10)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m10[0m     ===============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                                    setattr(self, k, arg)                                                                                                                   (8)
                            old_init(self, *args, **kwargs)                                                                                                                 (9)
                        functools.update_wrapper(_init, old_init)===========================================================================================================(10)
                                                                                          [91;1mhow to wrap `_init` around `old_init`, so that `_init` can use `old_init` inside itself[0m
                        cls.__init__ = use_kwargs(cls._methods)(_init)                                                                                                      (11)
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))                                                     (12)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m11[0m     ===============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                            old_init(self, *args, **kwargs)                                                                                                                 (9)
                        functools.update_wrapper(_init, old_init)                                                                                                           (10)
                        cls.__init__ = use_kwargs(cls._methods)(_init)======================================================================================================(11)
                                                                            [91;1mhow to add a list of names with None as default value to function `_init` to repalce its kwargs param[0m
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))                                                     (12)
                        return cls                                                                                                                                          (13)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m12[0m     ===============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                        functools.update_wrapper(_init, old_init)                                                                                                           (10)
                        cls.__init__ = use_kwargs(cls._methods)(_init)                                                                                                      (11)
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))=====================================================(12)
                                                                   [91;1mhow to make a class.`__init__` signature to be the signature of the class using `__signature__` and `_rm_self`[0m
                        return cls                                                                                                                                          (13)
                                                                                                                                                                            (14)
                
                
                
                ```
                #| column: screen
                fdb.snoop() # how to snoop together with docsrc: snoop first and docsrc above it
                ```
                
                    22:28:59.99 >>> Call to funcs_kwargs in File "/tmp/funcs_kwargs.py", line 3
                    22:28:59.99 ...... as_method = <class 'fastcore.meta.T'>
                    22:28:59.99    3 | def funcs_kwargs(as_method=False):
                    22:28:59.99    5 |     if callable(as_method): return _funcs_kwargs(as_method, False)
                        22:28:59.99 >>> Call to _funcs_kwargs in File "/tmp/_funcs_kwargs.py", line 3
                        22:28:59.99 ...... cls = <class 'fastcore.meta.T'>
                        22:28:59.99 ...... as_method = False
                        22:28:59.99    3 | def _funcs_kwargs(cls, as_method):
                        22:28:59.99    4 |     old_init = cls.__init__
                        22:28:59.99 .......... old_init = <function T.__init__>
                        22:28:59.99    5 |     import snoop
                        22:28:59.99 .......... snoop = <class 'snoop.configuration.Config.__init__.<locals>.ConfiguredTracer'>
                        22:28:59.99    6 |     @snoop
                        22:28:59.99    7 |     def _init(self, *args, **kwargs):
                        22:28:59.99 .......... _init = <function _funcs_kwargs.<locals>._init>
                        22:28:59.99   15 |     functools.update_wrapper(_init, old_init)
                        22:28:59.99 .......... _init = <function T.__init__>
                        22:28:59.99   16 |     cls.__init__ = use_kwargs(cls._methods)(_init)
                        22:28:59.99   17 |     if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))
                        22:28:59.99   18 |     return cls
                        22:28:59.99 <<< Return value from _funcs_kwargs: <class 'fastcore.meta.T'>
                    22:28:59.99    5 |     if callable(as_method): return _funcs_kwargs(as_method, False)
                    22:28:59.99 <<< Return value from funcs_kwargs: <class 'fastcore.meta.T'>
                    22:28:59.99 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:28:59.99 .......... self = <fastcore.meta.T object>
                    22:28:59.99 .......... args = ()
                    22:28:59.99 .......... kwargs = {}
                    22:28:59.99 .......... as_method = False
                    22:28:59.99 .......... cls = <class 'fastcore.meta.T'>
                    22:28:59.99 .......... old_init = <function T.__init__>
                    22:28:59.99    7 |     def _init(self, *args, **kwargs):
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00 .............. k = 'b'
                    22:29:00.00    9 |             arg = kwargs.pop(k,None)
                    22:29:00.00 .................. arg = None
                    22:29:00.00   10 |             if arg is not None:
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00   14 |         old_init(self, *args, **kwargs)
                    22:29:00.00 <<< Return value from _funcs_kwargs.<locals>._init: None
                    22:29:00.00 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:29:00.00 .......... self = <fastcore.meta.T object>
                    22:29:00.00 .......... args = ()
                    22:29:00.00 .......... kwargs = {'b': <function _new_func>}
                    22:29:00.00 .......... len(kwargs) = 1
                    22:29:00.00 .......... as_method = False
                    22:29:00.00 .......... cls = <class 'fastcore.meta.T'>
                    22:29:00.00 .......... old_init = <function T.__init__>
                    22:29:00.00    7 |     def _init(self, *args, **kwargs):
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00 .............. k = 'b'
                    22:29:00.00    9 |             arg = kwargs.pop(k,None)
                    22:29:00.00 .................. kwargs = {}
                    22:29:00.00 .................. arg = <function _new_func>
                    22:29:00.00   10 |             if arg is not None:
                    22:29:00.00   11 |                 if as_method: arg = method(arg)
                    22:29:00.00   12 |                 if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)
                    22:29:00.00   13 |                 setattr(self, k, arg)
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00   14 |         old_init(self, *args, **kwargs)
                    22:29:00.00 <<< Return value from _funcs_kwargs.<locals>._init: None
                    22:29:00.00 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:29:00.00 .......... self = <fastcore.meta.T object>
                    22:29:00.00 .......... args = ()
                    22:29:00.00 .......... kwargs = {'a': <function <lambda>>}
                    22:29:00.00 .......... len(kwargs) = 1
                    22:29:00.00 .......... as_method = False
                    22:29:00.00 .......... cls = <class 'fastcore.meta.T'>
                    22:29:00.00 .......... old_init = <function T.__init__>
                    22:29:00.00    7 |     def _init(self, *args, **kwargs):
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00 .............. k = 'b'
                    22:29:00.00    9 |             arg = kwargs.pop(k,None)
                    22:29:00.00 .................. arg = None
                    22:29:00.00   10 |             if arg is not None:
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00   14 |         old_init(self, *args, **kwargs)
                    22:29:00.00 <<< Return value from _funcs_kwargs.<locals>._init: None
                    22:29:00.00 >>> Call to funcs_kwargs in File "/tmp/funcs_kwargs.py", line 3
                    22:29:00.00 ...... as_method = True
                    22:29:00.00    3 | def funcs_kwargs(as_method=False):
                    22:29:00.00    5 |     if callable(as_method): return _funcs_kwargs(as_method, False)
                    22:29:00.00    6 |     return partial(_funcs_kwargs, as_method=as_method)
                    22:29:00.00 <<< Return value from funcs_kwargs: functools.partial(<function _funcs_kwargs>, as_method=True)
                    22:29:00.00 >>> Call to _funcs_kwargs in File "/tmp/_funcs_kwargs.py", line 3
                    22:29:00.00 ...... cls = <class 'fastcore.meta.T'>
                    22:29:00.00 ...... as_method = True
                    22:29:00.00    3 | def _funcs_kwargs(cls, as_method):
                    22:29:00.00    4 |     old_init = cls.__init__
                    22:29:00.00 .......... old_init = <slot wrapper '__init__' of 'object' objects>
                    22:29:00.00    5 |     import snoop
                    22:29:00.00 .......... snoop = <class 'snoop.configuration.Config.__init__.<locals>.ConfiguredTracer'>
                    22:29:00.00    6 |     @snoop
                    22:29:00.00    7 |     def _init(self, *args, **kwargs):
                    22:29:00.00 .......... _init = <function _funcs_kwargs.<locals>._init>
                    22:29:00.00   15 |     functools.update_wrapper(_init, old_init)
                    22:29:00.00 .......... _init = <function object.__init__>
                    22:29:00.00   16 |     cls.__init__ = use_kwargs(cls._methods)(_init)
                    22:29:00.01   17 |     if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))
                    22:29:00.01   18 |     return cls
                    22:29:00.01 <<< Return value from _funcs_kwargs: <class 'fastcore.meta.T'>
                    22:29:00.01 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:29:00.01 .......... self = <fastcore.meta.T object>
                    22:29:00.01 .......... args = ()
                    22:29:00.01 .......... kwargs = {'b': <function _f>}
                    22:29:00.01 .......... len(kwargs) = 1
                    22:29:00.01 .......... as_method = True
                    22:29:00.01 .......... cls = <class 'fastcore.meta.T'>
                    22:29:00.01 .......... old_init = <slot wrapper '__init__' of 'object' objects>
                    22:29:00.01    7 |     def _init(self, *args, **kwargs):
                    22:29:00.01    8 |         for k in cls._methods:
                    22:29:00.01 .............. k = 'b'
                    22:29:00.01    9 |             arg = kwargs.pop(k,None)
                    22:29:00.01 .................. kwargs = {}
                    22:29:00.01 .................. arg = <function _f>
                    22:29:00.01   10 |             if arg is not None:
                    22:29:00.01   11 |                 if as_method: arg = method(arg)
                    22:29:00.01 ...... arg = <bound method int._f of 1>
                    22:29:00.01   12 |                 if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)
                    22:29:00.01 ...... arg = <bound method T._f of <fastcore.meta.T object>>
                    22:29:00.01   13 |                 setattr(self, k, arg)
                    22:29:00.01    8 |         for k in cls._methods:
                    22:29:00.01   14 |         old_init(self, *args, **kwargs)
                    22:29:00.01 <<< Return value from _funcs_kwargs.<locals>._init: None
                    22:29:00.01 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:29:00.01 .......... self = <fastcore.meta.T2 object>
                    22:29:00.01 .......... args = ()
                    22:29:00.01 .......... kwargs = {'b': <function _f>}
                    22:29:00.01 .......... len(kwargs) = 1
                    22:29:00.01 .......... as_method = True
                    22:29:00.01 .......... cls = <class 'fastcore.meta.T'>
                    22:29:00.01 .......... old_init = <slot wrapper '__init__' of 'object' objects>
                    22:29:00.01    7 |     def _init(self, *args, **kwargs):
                    22:29:00.01    8 |         for k in cls._methods:
                    22:29:00.01 .............. k = 'b'
                    22:29:00.01    9 |             arg = kwargs.pop(k,None)
                    22:29:00.01 .................. kwargs = {}
                    22:29:00.01 .................. arg = <function _f>
                    22:29:00.01   10 |             if arg is not None:
                    22:29:00.01   11 |                 if as_method: arg = method(arg)
                    22:29:00.01 ...... arg = <bound method int._f of 1>
                    22:29:00.01   12 |                 if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)
                    22:29:00.01 ...... arg = <bound method T2._f of <fastcore.meta.T2 object>>
                    22:29:00.01   13 |                 setattr(self, k, arg)
                    22:29:00.01    8 |         for k in cls._methods:
                    22:29:00.01   14 |         old_init(self, *args, **kwargs)
                    22:29:00.01 <<< Return value from _funcs_kwargs.<locals>._init: None
                
                
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                
                
                
                ```
                fdb_.debug()
                ```
                
                    _funcs_kwargs's dbsrc code: ==============
                    import snoop
                    @snoop
                    def _funcs_kwargs(cls, as_method):
                        old_init = cls.__init__
                        import snoop
                        @snoop
                        def _init(self, *args, **kwargs):
                            for k in cls._methods:
                                arg = kwargs.pop(k,None)
                                if arg is not None:
                                    if as_method: arg = method(arg)
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)
                                    setattr(self, k, arg)
                            old_init(self, *args, **kwargs)
                        functools.update_wrapper(_init, old_init)
                        cls.__init__ = use_kwargs(cls._methods)(_init)
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))
                        return cls
                    
                    
                    
                    _funcs_kwargs's example processed with dbsrc: ===============
                    
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    
                
                
                
                ```
                #| column: screen
                fdb.print()
                ```
                
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    def funcs_kwargs(as_method=False):========================================================(0)       
                        "Replace methods in `cls._methods` with those from `kwargs`"==========================(1) # [93;1mhow funcs_kwargs works[0m; [93;1mit is a wrapper around _funcs_kwargs[0m; [91;1mit offers two ways of running _funcs_kwargs[0m; [37;1mthe first, default way, is to add a func to a class without using self[0m; [91;1msecond way is to add func to class enabling self use;[0m; 
                        if callable(as_method): return _funcs_kwargs(as_method, False)========================(2) # [37;1mhow to check whether an object is callable[0m; [93;1mhow to return a result of running a func[0m; [37;1m[0m; 
                        return partial(_funcs_kwargs, as_method=as_method)====================================(3) # [92;1mhow to custom the params of `_funcs_kwargs` for a particular use with partial[0m; 
                                                                                                                                                                            (4)
                
                
                
                ```
                #| column: screen
                fdb_.print()
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m12[0m     ===============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    def _funcs_kwargs(cls, as_method):========================================================(0) # [93;1mhow does _funcs_kwargs work: _funcs_kwargs is a decorator[0m; [35;1mit helps class e.g., T to add more methods[0m; [93;1mI need to give the method a name, and put the name e.g., 'b' inside a list called _methods=['b'] inside class T[0m; [36;1mthen after writing a func e.g., _new_func, I can add it by T(b = _new_func)[0m; [36;1mif I want the func added to class to use self, I shall write @funcs_kwargs(as_method=True)[0m; 
                        old_init = cls.__init__===============================================================(1)       
                        def _init(self, *args, **kwargs):=====================================================(2) # [37;1mhow to define a method which can use self and accept any parameters[0m; 
                            for k in cls._methods:============================================================(3) # [35;1mhow to pop out the value of an item in a dict (with None as default), and if the item name is not found, pop out None instead[0m; [91;1m[0m; 
                                arg = kwargs.pop(k,None)======================================================(4)       
                                if arg is not None:===========================================================(5)       
                                    if as_method: arg = method(arg)===========================================(6) # [36;1mhow to turn a func into a method[0m; 
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)=======(7) # [93;1mhow to give a method a different instance, like self[0m; 
                                    setattr(self, k, arg)=====================================================(8) # [36;1mhow to add a method to a class as an attribute[0m; 
                            old_init(self, *args, **kwargs)===================================================(9)       
                        functools.update_wrapper(_init, old_init)=============================================(10) # [34;1mhow to wrap `_init` around `old_init`, so that `_init` can use `old_init` inside itself[0m; 
                        cls.__init__ = use_kwargs(cls._methods)(_init)========================================(11) # [34;1mhow to add a list of names with None as default value to function `_init` to repalce its kwargs param[0m; 
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__)) # [35;1mhow to make a class.`__init__` signature to be the signature of the class using `__signature__` and `_rm_self`[0m;  (12)
                        return cls============================================================================(13)      
                                                                                                                                                                            (14)
                
                
                
                ```
                
                ```
                
                
            
            
            
            [Open `0009_funcs_kwargs` in Jupyter Notebook](http://localhost:8888/tree/nbs/demos/0009_funcs_kwargs.ipynb)
            
            
            
        
        
        
        [Open `utils` in Jupyter Notebook](http://localhost:8888/tree/nbs/lib/utils.ipynb)
        
        
        
        
    
    
    
    [Open `utils` in Jupyter Notebook](http://localhost:8888/tree/nbs/lib/utils.ipynb)
    
    
    
    



[Open `utils` in Jupyter Notebook locally](http://localhost:8888/tree/nbs/lib/utils.ipynb)



###  <mark style="background-color: #ffff00">snoop:</mark>   <mark style="background-color: #ffff00">from</mark>   <mark style="background-color: #ffff00">_ <mark style="background-color: #FFFF00">funcs_kwargs</mark> </mark>   <mark style="background-color: #ffff00">to</mark>   <mark style="background-color: #FFFF00">funcs_kwargs</mark> 



    
    
    
        
        
        
            
            
            
                
                how to snoop on two functions one wrap around another: `funcs_kwargs` is a wrapper around `_funcs_kwargs`, so I can first snoop on `_funcs_kwargs` and assign its snoop dbsrc to \
                `fm._funcs_kwargs` so that when I snoop on `funcs_kwargs`, it can use the snoop dbsrc of `_funcs_kwargs` and no example codes need to change.
                
                
                ```
                from fastcore.meta import _funcs_kwargs
                ```
                
                
                ```
                fdb_ = Fastdb(_funcs_kwargs)
                fdb_.eg = """
                @funcs_kwargs
                class T:
                    _methods=['b'] # allows you to add method b upon instantiation
                    def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                    def a(self): return 1
                    def b(self): return 2
                    
                t = T()
                test_eq(t.a(), 1)
                test_eq(t.b(), 2)
                
                test_sig(T, '(f=1, *, b=None)')
                inspect.signature(T)
                
                def _new_func(): return 5
                
                t = T(b = _new_func)
                test_eq(t.b(), 5)
                
                t = T(a = lambda:3)
                test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                """
                ```
                
                
                ```
                #| column: screen
                # no snoop result, it is expected, because the example is not calling _funcs_kwargs, but funcs_kwargs
                fdb_.snoop(deco=True) # how to snoop decorator: _funcs_kwargs is a decorator, so set deco=True to see running codes in inner f
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    [0m     
                    
                
                
                
                ```
                import fastcore.meta as fm
                ```
                
                
                ```
                fm._funcs_kwargs = fdb_.dbsrc # how to snoop on two functions one wrap around another
                ```
                
                
                ```
                fdb = Fastdb(funcs_kwargs)
                fdb.eg = """
                @funcs_kwargs
                class T:
                    _methods=['b'] # allows you to add method b upon instantiation
                    def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                    def a(self): return 1
                    def b(self): return 2
                    
                t = T()
                test_eq(t.a(), 1)
                test_eq(t.b(), 2)
                
                test_sig(T, '(f=1, *, b=None)')
                inspect.signature(T)
                
                def _new_func(): return 5
                
                t = T(b = _new_func)
                test_eq(t.b(), 5)
                
                t = T(a = lambda:3)
                test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                
                def _f(self,a=1): return self.num + a # access the num attribute from the instance
                
                @funcs_kwargs(as_method=True)
                class T: 
                    _methods=['b']
                    num = 5
                    
                t = T(b = _f) # adds method b
                test_eq(t.b(5), 10) # self.num + 5 = 10
                
                def _f(self,a=1): return self.num * a #multiply instead of add 
                
                class T2(T):
                    def __init__(self,num):
                        super().__init__(b = _f) # add method b from the super class
                        self.num=num
                        
                t = T2(num=3)
                test_eq(t.b(a=5), 15) # 3 * 5 = 15
                test_sig(T2, '(num)')
                """
                ```
                
                
                ```
                #| column: screen
                fdb.print()
                ```
                
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    def funcs_kwargs(as_method=False):========================================================(0)       
                        "Replace methods in `cls._methods` with those from `kwargs`"==========================(1)       
                        if callable(as_method): return _funcs_kwargs(as_method, False)========================(2)       
                        return partial(_funcs_kwargs, as_method=as_method)====================================(3)       
                                                                                                                                                                            (4)
                
                
                
                ```
                #| column: screen
                fdb_.print()
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    def _funcs_kwargs(cls, as_method):========================================================(0)       
                        old_init = cls.__init__===============================================================(1)       
                        def _init(self, *args, **kwargs):=====================================================(2)       
                            for k in cls._methods:============================================================(3)       
                                arg = kwargs.pop(k,None)======================================================(4)       
                                if arg is not None:===========================================================(5)       
                                    if as_method: arg = method(arg)===========================================(6)       
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)=======(7)       
                                    setattr(self, k, arg)=====================================================(8)       
                            old_init(self, *args, **kwargs)===================================================(9)       
                        functools.update_wrapper(_init, old_init)=============================================(10)      
                        cls.__init__ = use_kwargs(cls._methods)(_init)========================================(11)      
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))                                                     (12)
                        return cls============================================================================(13)      
                                                                                                                                                                            (14)
                
                
                
                ```
                #| column: screen
                fdb.docsrc(1, "how funcs_kwargs works; it is a wrapper around _funcs_kwargs; it offers two ways of running _funcs_kwargs; \
                the first, default way, is to add a func to a class without using self; second way is to add func to class enabling self use;")
                fdb.docsrc(2, "how to check whether an object is callable; how to return a result of running a func; ")
                fdb.docsrc(3, "how to custom the params of `_funcs_kwargs` for a particular use with partial")
                ```
                
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m1[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                    def funcs_kwargs(as_method=False):                                                                                                                      (0)
                        "Replace methods in `cls._methods` with those from `kwargs`"========================================================================================(1)
                    [91;1mhow funcs_kwargs works; it is a wrapper around _funcs_kwargs; it offers two ways of running _funcs_kwargs; the first, default way, is to add a func to a class without using self; second way is to add func to class enabling self use;[0m
                        if callable(as_method): return _funcs_kwargs(as_method, False)                                                                                      (2)
                        return partial(_funcs_kwargs, as_method=as_method)                                                                                                  (3)
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m2[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                    def funcs_kwargs(as_method=False):                                                                                                                      (0)
                        "Replace methods in `cls._methods` with those from `kwargs`"                                                                                        (1)
                        if callable(as_method): return _funcs_kwargs(as_method, False)======================================================================================(2)
                                                                                           [91;1mhow to check whether an object is callable; how to return a result of running a func; [0m
                        return partial(_funcs_kwargs, as_method=as_method)                                                                                                  (3)
                                                                                                                                                                            (4)
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m3[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                        "Replace methods in `cls._methods` with those from `kwargs`"                                                                                        (1)
                        if callable(as_method): return _funcs_kwargs(as_method, False)                                                                                      (2)
                        return partial(_funcs_kwargs, as_method=as_method)==================================================================================================(3)
                                                                                                    [91;1mhow to custom the params of `_funcs_kwargs` for a particular use with partial[0m
                                                                                                                                                                            (4)
                
                
                
                ```
                #| column: screen
                fdb_.print()
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    def _funcs_kwargs(cls, as_method):========================================================(0)       
                        old_init = cls.__init__===============================================================(1)       
                        def _init(self, *args, **kwargs):=====================================================(2)       
                            for k in cls._methods:============================================================(3)       
                                arg = kwargs.pop(k,None)======================================================(4)       
                                if arg is not None:===========================================================(5)       
                                    if as_method: arg = method(arg)===========================================(6)       
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)=======(7)       
                                    setattr(self, k, arg)=====================================================(8)       
                            old_init(self, *args, **kwargs)===================================================(9)       
                        functools.update_wrapper(_init, old_init)=============================================(10)      
                        cls.__init__ = use_kwargs(cls._methods)(_init)========================================(11)      
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))                                                     (12)
                        return cls============================================================================(13)      
                                                                                                                                                                            (14)
                
                
                
                ```
                #| column: screen
                fdb_.docsrc(0, "how does _funcs_kwargs work: _funcs_kwargs is a decorator; it helps class e.g., T to add more methods; \
                I need to give the method a name, \
                and put the name e.g., 'b' inside a list called _methods=['b'] inside class T; \
                then after writing a func e.g., _new_func, I can add it by T(b = _new_func); if I want the func added to class to use self, \
                I shall write @funcs_kwargs(as_method=True)")
                fdb_.docsrc(2, "how to define a method which can use self and accept any parameters")
                fdb_.docsrc(3, "how to pop out the value of an item in a dict (with None as default), and if the item name is not found, pop out None instead; ")
                fdb_.docsrc(6, "how to turn a func into a method")
                fdb_.docsrc(7, "how to give a method a different instance, like self")
                fdb_.docsrc(8, "how to add a method to a class as an attribute")
                fdb_.docsrc(10, "how to wrap `_init` around `old_init`, so that `_init` can use `old_init` inside itself")
                fdb_.docsrc(11, "how to add a list of names with None as default value to function `_init` to repalce its kwargs param")
                fdb_.docsrc(12, "how to make a class.`__init__` signature to be the signature of the class using `__signature__` and `_rm_self`")
                
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m0[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                    def _funcs_kwargs(cls, as_method):======================================================================================================================(0)
                    [91;1mhow does _funcs_kwargs work: _funcs_kwargs is a decorator; it helps class e.g., T to add more methods; I need to give the method a name, and put the name e.g., 'b' inside a list called _methods=['b'] inside class T; then after writing a func e.g., _new_func, I can add it by T(b = _new_func); if I want the func added to class to use self, I shall write @funcs_kwargs(as_method=True)[0m
                        old_init = cls.__init__                                                                                                                             (1)
                        def _init(self, *args, **kwargs):                                                                                                                   (2)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m2[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                    def _funcs_kwargs(cls, as_method):                                                                                                                      (0)
                        old_init = cls.__init__                                                                                                                             (1)
                        def _init(self, *args, **kwargs):===================================================================================================================(2)
                                                                                                              [91;1mhow to define a method which can use self and accept any parameters[0m
                            for k in cls._methods:                                                                                                                          (3)
                                arg = kwargs.pop(k,None)                                                                                                                    (4)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m3[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                        old_init = cls.__init__                                                                                                                             (1)
                        def _init(self, *args, **kwargs):                                                                                                                   (2)
                            for k in cls._methods:==========================================================================================================================(3)
                                                  [91;1mhow to pop out the value of an item in a dict (with None as default), and if the item name is not found, pop out None instead; [0m
                                arg = kwargs.pop(k,None)                                                                                                                    (4)
                                if arg is not None:                                                                                                                         (5)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m6[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                                arg = kwargs.pop(k,None)                                                                                                                    (4)
                                if arg is not None:                                                                                                                         (5)
                                    if as_method: arg = method(arg)=========================================================================================================(6)
                                                                                                                                                 [91;1mhow to turn a func into a method[0m
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)                                                                     (7)
                                    setattr(self, k, arg)                                                                                                                   (8)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m7[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                                if arg is not None:                                                                                                                         (5)
                                    if as_method: arg = method(arg)                                                                                                         (6)
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)=====================================================================(7)
                                                                                                                             [91;1mhow to give a method a different instance, like self[0m
                                    setattr(self, k, arg)                                                                                                                   (8)
                            old_init(self, *args, **kwargs)                                                                                                                 (9)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m8[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                                    if as_method: arg = method(arg)                                                                                                         (6)
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)                                                                     (7)
                                    setattr(self, k, arg)===================================================================================================================(8)
                                                                                                                                   [91;1mhow to add a method to a class as an attribute[0m
                            old_init(self, *args, **kwargs)                                                                                                                 (9)
                        functools.update_wrapper(_init, old_init)                                                                                                           (10)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m10[0m     ===============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                                    setattr(self, k, arg)                                                                                                                   (8)
                            old_init(self, *args, **kwargs)                                                                                                                 (9)
                        functools.update_wrapper(_init, old_init)===========================================================================================================(10)
                                                                                          [91;1mhow to wrap `_init` around `old_init`, so that `_init` can use `old_init` inside itself[0m
                        cls.__init__ = use_kwargs(cls._methods)(_init)                                                                                                      (11)
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))                                                     (12)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m11[0m     ===============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                            old_init(self, *args, **kwargs)                                                                                                                 (9)
                        functools.update_wrapper(_init, old_init)                                                                                                           (10)
                        cls.__init__ = use_kwargs(cls._methods)(_init)======================================================================================================(11)
                                                                            [91;1mhow to add a list of names with None as default value to function `_init` to repalce its kwargs param[0m
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))                                                     (12)
                        return cls                                                                                                                                          (13)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m12[0m     ===============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                        functools.update_wrapper(_init, old_init)                                                                                                           (10)
                        cls.__init__ = use_kwargs(cls._methods)(_init)                                                                                                      (11)
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))=====================================================(12)
                                                                   [91;1mhow to make a class.`__init__` signature to be the signature of the class using `__signature__` and `_rm_self`[0m
                        return cls                                                                                                                                          (13)
                                                                                                                                                                            (14)
                
                
                
                ```
                #| column: screen
                fdb.snoop() # how to snoop together with docsrc: snoop first and docsrc above it
                ```
                
                    22:28:59.99 >>> Call to funcs_kwargs in File "/tmp/funcs_kwargs.py", line 3
                    22:28:59.99 ...... as_method = <class 'fastcore.meta.T'>
                    22:28:59.99    3 | def funcs_kwargs(as_method=False):
                    22:28:59.99    5 |     if callable(as_method): return _funcs_kwargs(as_method, False)
                        22:28:59.99 >>> Call to _funcs_kwargs in File "/tmp/_funcs_kwargs.py", line 3
                        22:28:59.99 ...... cls = <class 'fastcore.meta.T'>
                        22:28:59.99 ...... as_method = False
                        22:28:59.99    3 | def _funcs_kwargs(cls, as_method):
                        22:28:59.99    4 |     old_init = cls.__init__
                        22:28:59.99 .......... old_init = <function T.__init__>
                        22:28:59.99    5 |     import snoop
                        22:28:59.99 .......... snoop = <class 'snoop.configuration.Config.__init__.<locals>.ConfiguredTracer'>
                        22:28:59.99    6 |     @snoop
                        22:28:59.99    7 |     def _init(self, *args, **kwargs):
                        22:28:59.99 .......... _init = <function _funcs_kwargs.<locals>._init>
                        22:28:59.99   15 |     functools.update_wrapper(_init, old_init)
                        22:28:59.99 .......... _init = <function T.__init__>
                        22:28:59.99   16 |     cls.__init__ = use_kwargs(cls._methods)(_init)
                        22:28:59.99   17 |     if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))
                        22:28:59.99   18 |     return cls
                        22:28:59.99 <<< Return value from _funcs_kwargs: <class 'fastcore.meta.T'>
                    22:28:59.99    5 |     if callable(as_method): return _funcs_kwargs(as_method, False)
                    22:28:59.99 <<< Return value from funcs_kwargs: <class 'fastcore.meta.T'>
                    22:28:59.99 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:28:59.99 .......... self = <fastcore.meta.T object>
                    22:28:59.99 .......... args = ()
                    22:28:59.99 .......... kwargs = {}
                    22:28:59.99 .......... as_method = False
                    22:28:59.99 .......... cls = <class 'fastcore.meta.T'>
                    22:28:59.99 .......... old_init = <function T.__init__>
                    22:28:59.99    7 |     def _init(self, *args, **kwargs):
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00 .............. k = 'b'
                    22:29:00.00    9 |             arg = kwargs.pop(k,None)
                    22:29:00.00 .................. arg = None
                    22:29:00.00   10 |             if arg is not None:
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00   14 |         old_init(self, *args, **kwargs)
                    22:29:00.00 <<< Return value from _funcs_kwargs.<locals>._init: None
                    22:29:00.00 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:29:00.00 .......... self = <fastcore.meta.T object>
                    22:29:00.00 .......... args = ()
                    22:29:00.00 .......... kwargs = {'b': <function _new_func>}
                    22:29:00.00 .......... len(kwargs) = 1
                    22:29:00.00 .......... as_method = False
                    22:29:00.00 .......... cls = <class 'fastcore.meta.T'>
                    22:29:00.00 .......... old_init = <function T.__init__>
                    22:29:00.00    7 |     def _init(self, *args, **kwargs):
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00 .............. k = 'b'
                    22:29:00.00    9 |             arg = kwargs.pop(k,None)
                    22:29:00.00 .................. kwargs = {}
                    22:29:00.00 .................. arg = <function _new_func>
                    22:29:00.00   10 |             if arg is not None:
                    22:29:00.00   11 |                 if as_method: arg = method(arg)
                    22:29:00.00   12 |                 if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)
                    22:29:00.00   13 |                 setattr(self, k, arg)
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00   14 |         old_init(self, *args, **kwargs)
                    22:29:00.00 <<< Return value from _funcs_kwargs.<locals>._init: None
                    22:29:00.00 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:29:00.00 .......... self = <fastcore.meta.T object>
                    22:29:00.00 .......... args = ()
                    22:29:00.00 .......... kwargs = {'a': <function <lambda>>}
                    22:29:00.00 .......... len(kwargs) = 1
                    22:29:00.00 .......... as_method = False
                    22:29:00.00 .......... cls = <class 'fastcore.meta.T'>
                    22:29:00.00 .......... old_init = <function T.__init__>
                    22:29:00.00    7 |     def _init(self, *args, **kwargs):
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00 .............. k = 'b'
                    22:29:00.00    9 |             arg = kwargs.pop(k,None)
                    22:29:00.00 .................. arg = None
                    22:29:00.00   10 |             if arg is not None:
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00   14 |         old_init(self, *args, **kwargs)
                    22:29:00.00 <<< Return value from _funcs_kwargs.<locals>._init: None
                    22:29:00.00 >>> Call to funcs_kwargs in File "/tmp/funcs_kwargs.py", line 3
                    22:29:00.00 ...... as_method = True
                    22:29:00.00    3 | def funcs_kwargs(as_method=False):
                    22:29:00.00    5 |     if callable(as_method): return _funcs_kwargs(as_method, False)
                    22:29:00.00    6 |     return partial(_funcs_kwargs, as_method=as_method)
                    22:29:00.00 <<< Return value from funcs_kwargs: functools.partial(<function _funcs_kwargs>, as_method=True)
                    22:29:00.00 >>> Call to _funcs_kwargs in File "/tmp/_funcs_kwargs.py", line 3
                    22:29:00.00 ...... cls = <class 'fastcore.meta.T'>
                    22:29:00.00 ...... as_method = True
                    22:29:00.00    3 | def _funcs_kwargs(cls, as_method):
                    22:29:00.00    4 |     old_init = cls.__init__
                    22:29:00.00 .......... old_init = <slot wrapper '__init__' of 'object' objects>
                    22:29:00.00    5 |     import snoop
                    22:29:00.00 .......... snoop = <class 'snoop.configuration.Config.__init__.<locals>.ConfiguredTracer'>
                    22:29:00.00    6 |     @snoop
                    22:29:00.00    7 |     def _init(self, *args, **kwargs):
                    22:29:00.00 .......... _init = <function _funcs_kwargs.<locals>._init>
                    22:29:00.00   15 |     functools.update_wrapper(_init, old_init)
                    22:29:00.00 .......... _init = <function object.__init__>
                    22:29:00.00   16 |     cls.__init__ = use_kwargs(cls._methods)(_init)
                    22:29:00.01   17 |     if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))
                    22:29:00.01   18 |     return cls
                    22:29:00.01 <<< Return value from _funcs_kwargs: <class 'fastcore.meta.T'>
                    22:29:00.01 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:29:00.01 .......... self = <fastcore.meta.T object>
                    22:29:00.01 .......... args = ()
                    22:29:00.01 .......... kwargs = {'b': <function _f>}
                    22:29:00.01 .......... len(kwargs) = 1
                    22:29:00.01 .......... as_method = True
                    22:29:00.01 .......... cls = <class 'fastcore.meta.T'>
                    22:29:00.01 .......... old_init = <slot wrapper '__init__' of 'object' objects>
                    22:29:00.01    7 |     def _init(self, *args, **kwargs):
                    22:29:00.01    8 |         for k in cls._methods:
                    22:29:00.01 .............. k = 'b'
                    22:29:00.01    9 |             arg = kwargs.pop(k,None)
                    22:29:00.01 .................. kwargs = {}
                    22:29:00.01 .................. arg = <function _f>
                    22:29:00.01   10 |             if arg is not None:
                    22:29:00.01   11 |                 if as_method: arg = method(arg)
                    22:29:00.01 ...... arg = <bound method int._f of 1>
                    22:29:00.01   12 |                 if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)
                    22:29:00.01 ...... arg = <bound method T._f of <fastcore.meta.T object>>
                    22:29:00.01   13 |                 setattr(self, k, arg)
                    22:29:00.01    8 |         for k in cls._methods:
                    22:29:00.01   14 |         old_init(self, *args, **kwargs)
                    22:29:00.01 <<< Return value from _funcs_kwargs.<locals>._init: None
                    22:29:00.01 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:29:00.01 .......... self = <fastcore.meta.T2 object>
                    22:29:00.01 .......... args = ()
                    22:29:00.01 .......... kwargs = {'b': <function _f>}
                    22:29:00.01 .......... len(kwargs) = 1
                    22:29:00.01 .......... as_method = True
                    22:29:00.01 .......... cls = <class 'fastcore.meta.T'>
                    22:29:00.01 .......... old_init = <slot wrapper '__init__' of 'object' objects>
                    22:29:00.01    7 |     def _init(self, *args, **kwargs):
                    22:29:00.01    8 |         for k in cls._methods:
                    22:29:00.01 .............. k = 'b'
                    22:29:00.01    9 |             arg = kwargs.pop(k,None)
                    22:29:00.01 .................. kwargs = {}
                    22:29:00.01 .................. arg = <function _f>
                    22:29:00.01   10 |             if arg is not None:
                    22:29:00.01   11 |                 if as_method: arg = method(arg)
                    22:29:00.01 ...... arg = <bound method int._f of 1>
                    22:29:00.01   12 |                 if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)
                    22:29:00.01 ...... arg = <bound method T2._f of <fastcore.meta.T2 object>>
                    22:29:00.01   13 |                 setattr(self, k, arg)
                    22:29:00.01    8 |         for k in cls._methods:
                    22:29:00.01   14 |         old_init(self, *args, **kwargs)
                    22:29:00.01 <<< Return value from _funcs_kwargs.<locals>._init: None
                
                
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                
                
                
                ```
                fdb_.debug()
                ```
                
                    _funcs_kwargs's dbsrc code: ==============
                    import snoop
                    @snoop
                    def _funcs_kwargs(cls, as_method):
                        old_init = cls.__init__
                        import snoop
                        @snoop
                        def _init(self, *args, **kwargs):
                            for k in cls._methods:
                                arg = kwargs.pop(k,None)
                                if arg is not None:
                                    if as_method: arg = method(arg)
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)
                                    setattr(self, k, arg)
                            old_init(self, *args, **kwargs)
                        functools.update_wrapper(_init, old_init)
                        cls.__init__ = use_kwargs(cls._methods)(_init)
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))
                        return cls
                    
                    
                    
                    _funcs_kwargs's example processed with dbsrc: ===============
                    
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    
                
                
                
                ```
                #| column: screen
                fdb.print()
                ```
                
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    def funcs_kwargs(as_method=False):========================================================(0)       
                        "Replace methods in `cls._methods` with those from `kwargs`"==========================(1) # [93;1mhow funcs_kwargs works[0m; [93;1mit is a wrapper around _funcs_kwargs[0m; [91;1mit offers two ways of running _funcs_kwargs[0m; [37;1mthe first, default way, is to add a func to a class without using self[0m; [91;1msecond way is to add func to class enabling self use;[0m; 
                        if callable(as_method): return _funcs_kwargs(as_method, False)========================(2) # [37;1mhow to check whether an object is callable[0m; [93;1mhow to return a result of running a func[0m; [37;1m[0m; 
                        return partial(_funcs_kwargs, as_method=as_method)====================================(3) # [92;1mhow to custom the params of `_funcs_kwargs` for a particular use with partial[0m; 
                                                                                                                                                                            (4)
                
                
                
                ```
                #| column: screen
                fdb_.print()
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m12[0m     ===============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    def _funcs_kwargs(cls, as_method):========================================================(0) # [93;1mhow does _funcs_kwargs work: _funcs_kwargs is a decorator[0m; [35;1mit helps class e.g., T to add more methods[0m; [93;1mI need to give the method a name, and put the name e.g., 'b' inside a list called _methods=['b'] inside class T[0m; [36;1mthen after writing a func e.g., _new_func, I can add it by T(b = _new_func)[0m; [36;1mif I want the func added to class to use self, I shall write @funcs_kwargs(as_method=True)[0m; 
                        old_init = cls.__init__===============================================================(1)       
                        def _init(self, *args, **kwargs):=====================================================(2) # [37;1mhow to define a method which can use self and accept any parameters[0m; 
                            for k in cls._methods:============================================================(3) # [35;1mhow to pop out the value of an item in a dict (with None as default), and if the item name is not found, pop out None instead[0m; [91;1m[0m; 
                                arg = kwargs.pop(k,None)======================================================(4)       
                                if arg is not None:===========================================================(5)       
                                    if as_method: arg = method(arg)===========================================(6) # [36;1mhow to turn a func into a method[0m; 
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)=======(7) # [93;1mhow to give a method a different instance, like self[0m; 
                                    setattr(self, k, arg)=====================================================(8) # [36;1mhow to add a method to a class as an attribute[0m; 
                            old_init(self, *args, **kwargs)===================================================(9)       
                        functools.update_wrapper(_init, old_init)=============================================(10) # [34;1mhow to wrap `_init` around `old_init`, so that `_init` can use `old_init` inside itself[0m; 
                        cls.__init__ = use_kwargs(cls._methods)(_init)========================================(11) # [34;1mhow to add a list of names with None as default value to function `_init` to repalce its kwargs param[0m; 
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__)) # [35;1mhow to make a class.`__init__` signature to be the signature of the class using `__signature__` and `_rm_self`[0m;  (12)
                        return cls============================================================================(13)      
                                                                                                                                                                            (14)
                
                
                
                ```
                
                ```
                
                
            
            
            
            [Open `0009_funcs_kwargs` in Jupyter Notebook](http://localhost:8888/tree/nbs/demos/0009_funcs_kwargs.ipynb)
            
            
            
        
        
        
        [Open `utils` in Jupyter Notebook](http://localhost:8888/tree/nbs/lib/utils.ipynb)
        
        
        
        
    
    
    
    [Open `utils` in Jupyter Notebook](http://localhost:8888/tree/nbs/lib/utils.ipynb)
    
    
    
    



[Open `utils` in Jupyter Notebook locally](http://localhost:8888/tree/nbs/lib/utils.ipynb)



###  <mark style="background-color: #ffff00">snoop:</mark>   <mark style="background-color: #ffff00">from</mark>   <mark style="background-color: #ffff00">_ <mark style="background-color: #FFFF00">funcs_kwargs</mark> </mark>   <mark style="background-color: #ffff00">to</mark>   <mark style="background-color: #FFFF00">funcs_kwargs</mark> 



    
    
    
        
        
        
            
            
            
                
                how to snoop on two functions one wrap around another: `funcs_kwargs` is a wrapper around `_funcs_kwargs`, so I can first snoop on `_funcs_kwargs` and assign its snoop dbsrc to \
                `fm._funcs_kwargs` so that when I snoop on `funcs_kwargs`, it can use the snoop dbsrc of `_funcs_kwargs` and no example codes need to change.
                
                
                ```
                from fastcore.meta import _funcs_kwargs
                ```
                
                
                ```
                fdb_ = Fastdb(_funcs_kwargs)
                fdb_.eg = """
                @funcs_kwargs
                class T:
                    _methods=['b'] # allows you to add method b upon instantiation
                    def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                    def a(self): return 1
                    def b(self): return 2
                    
                t = T()
                test_eq(t.a(), 1)
                test_eq(t.b(), 2)
                
                test_sig(T, '(f=1, *, b=None)')
                inspect.signature(T)
                
                def _new_func(): return 5
                
                t = T(b = _new_func)
                test_eq(t.b(), 5)
                
                t = T(a = lambda:3)
                test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                """
                ```
                
                
                ```
                #| column: screen
                # no snoop result, it is expected, because the example is not calling _funcs_kwargs, but funcs_kwargs
                fdb_.snoop(deco=True) # how to snoop decorator: _funcs_kwargs is a decorator, so set deco=True to see running codes in inner f
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    [0m     
                    
                
                
                
                ```
                import fastcore.meta as fm
                ```
                
                
                ```
                fm._funcs_kwargs = fdb_.dbsrc # how to snoop on two functions one wrap around another
                ```
                
                
                ```
                fdb = Fastdb(funcs_kwargs)
                fdb.eg = """
                @funcs_kwargs
                class T:
                    _methods=['b'] # allows you to add method b upon instantiation
                    def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                    def a(self): return 1
                    def b(self): return 2
                    
                t = T()
                test_eq(t.a(), 1)
                test_eq(t.b(), 2)
                
                test_sig(T, '(f=1, *, b=None)')
                inspect.signature(T)
                
                def _new_func(): return 5
                
                t = T(b = _new_func)
                test_eq(t.b(), 5)
                
                t = T(a = lambda:3)
                test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                
                def _f(self,a=1): return self.num + a # access the num attribute from the instance
                
                @funcs_kwargs(as_method=True)
                class T: 
                    _methods=['b']
                    num = 5
                    
                t = T(b = _f) # adds method b
                test_eq(t.b(5), 10) # self.num + 5 = 10
                
                def _f(self,a=1): return self.num * a #multiply instead of add 
                
                class T2(T):
                    def __init__(self,num):
                        super().__init__(b = _f) # add method b from the super class
                        self.num=num
                        
                t = T2(num=3)
                test_eq(t.b(a=5), 15) # 3 * 5 = 15
                test_sig(T2, '(num)')
                """
                ```
                
                
                ```
                #| column: screen
                fdb.print()
                ```
                
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    def funcs_kwargs(as_method=False):========================================================(0)       
                        "Replace methods in `cls._methods` with those from `kwargs`"==========================(1)       
                        if callable(as_method): return _funcs_kwargs(as_method, False)========================(2)       
                        return partial(_funcs_kwargs, as_method=as_method)====================================(3)       
                                                                                                                                                                            (4)
                
                
                
                ```
                #| column: screen
                fdb_.print()
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    def _funcs_kwargs(cls, as_method):========================================================(0)       
                        old_init = cls.__init__===============================================================(1)       
                        def _init(self, *args, **kwargs):=====================================================(2)       
                            for k in cls._methods:============================================================(3)       
                                arg = kwargs.pop(k,None)======================================================(4)       
                                if arg is not None:===========================================================(5)       
                                    if as_method: arg = method(arg)===========================================(6)       
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)=======(7)       
                                    setattr(self, k, arg)=====================================================(8)       
                            old_init(self, *args, **kwargs)===================================================(9)       
                        functools.update_wrapper(_init, old_init)=============================================(10)      
                        cls.__init__ = use_kwargs(cls._methods)(_init)========================================(11)      
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))                                                     (12)
                        return cls============================================================================(13)      
                                                                                                                                                                            (14)
                
                
                
                ```
                #| column: screen
                fdb.docsrc(1, "how funcs_kwargs works; it is a wrapper around _funcs_kwargs; it offers two ways of running _funcs_kwargs; \
                the first, default way, is to add a func to a class without using self; second way is to add func to class enabling self use;")
                fdb.docsrc(2, "how to check whether an object is callable; how to return a result of running a func; ")
                fdb.docsrc(3, "how to custom the params of `_funcs_kwargs` for a particular use with partial")
                ```
                
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m1[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                    def funcs_kwargs(as_method=False):                                                                                                                      (0)
                        "Replace methods in `cls._methods` with those from `kwargs`"========================================================================================(1)
                    [91;1mhow funcs_kwargs works; it is a wrapper around _funcs_kwargs; it offers two ways of running _funcs_kwargs; the first, default way, is to add a func to a class without using self; second way is to add func to class enabling self use;[0m
                        if callable(as_method): return _funcs_kwargs(as_method, False)                                                                                      (2)
                        return partial(_funcs_kwargs, as_method=as_method)                                                                                                  (3)
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m2[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                    def funcs_kwargs(as_method=False):                                                                                                                      (0)
                        "Replace methods in `cls._methods` with those from `kwargs`"                                                                                        (1)
                        if callable(as_method): return _funcs_kwargs(as_method, False)======================================================================================(2)
                                                                                           [91;1mhow to check whether an object is callable; how to return a result of running a func; [0m
                        return partial(_funcs_kwargs, as_method=as_method)                                                                                                  (3)
                                                                                                                                                                            (4)
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m3[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                        "Replace methods in `cls._methods` with those from `kwargs`"                                                                                        (1)
                        if callable(as_method): return _funcs_kwargs(as_method, False)                                                                                      (2)
                        return partial(_funcs_kwargs, as_method=as_method)==================================================================================================(3)
                                                                                                    [91;1mhow to custom the params of `_funcs_kwargs` for a particular use with partial[0m
                                                                                                                                                                            (4)
                
                
                
                ```
                #| column: screen
                fdb_.print()
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    def _funcs_kwargs(cls, as_method):========================================================(0)       
                        old_init = cls.__init__===============================================================(1)       
                        def _init(self, *args, **kwargs):=====================================================(2)       
                            for k in cls._methods:============================================================(3)       
                                arg = kwargs.pop(k,None)======================================================(4)       
                                if arg is not None:===========================================================(5)       
                                    if as_method: arg = method(arg)===========================================(6)       
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)=======(7)       
                                    setattr(self, k, arg)=====================================================(8)       
                            old_init(self, *args, **kwargs)===================================================(9)       
                        functools.update_wrapper(_init, old_init)=============================================(10)      
                        cls.__init__ = use_kwargs(cls._methods)(_init)========================================(11)      
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))                                                     (12)
                        return cls============================================================================(13)      
                                                                                                                                                                            (14)
                
                
                
                ```
                #| column: screen
                fdb_.docsrc(0, "how does _funcs_kwargs work: _funcs_kwargs is a decorator; it helps class e.g., T to add more methods; \
                I need to give the method a name, \
                and put the name e.g., 'b' inside a list called _methods=['b'] inside class T; \
                then after writing a func e.g., _new_func, I can add it by T(b = _new_func); if I want the func added to class to use self, \
                I shall write @funcs_kwargs(as_method=True)")
                fdb_.docsrc(2, "how to define a method which can use self and accept any parameters")
                fdb_.docsrc(3, "how to pop out the value of an item in a dict (with None as default), and if the item name is not found, pop out None instead; ")
                fdb_.docsrc(6, "how to turn a func into a method")
                fdb_.docsrc(7, "how to give a method a different instance, like self")
                fdb_.docsrc(8, "how to add a method to a class as an attribute")
                fdb_.docsrc(10, "how to wrap `_init` around `old_init`, so that `_init` can use `old_init` inside itself")
                fdb_.docsrc(11, "how to add a list of names with None as default value to function `_init` to repalce its kwargs param")
                fdb_.docsrc(12, "how to make a class.`__init__` signature to be the signature of the class using `__signature__` and `_rm_self`")
                
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m0[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                    def _funcs_kwargs(cls, as_method):======================================================================================================================(0)
                    [91;1mhow does _funcs_kwargs work: _funcs_kwargs is a decorator; it helps class e.g., T to add more methods; I need to give the method a name, and put the name e.g., 'b' inside a list called _methods=['b'] inside class T; then after writing a func e.g., _new_func, I can add it by T(b = _new_func); if I want the func added to class to use self, I shall write @funcs_kwargs(as_method=True)[0m
                        old_init = cls.__init__                                                                                                                             (1)
                        def _init(self, *args, **kwargs):                                                                                                                   (2)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m2[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                    def _funcs_kwargs(cls, as_method):                                                                                                                      (0)
                        old_init = cls.__init__                                                                                                                             (1)
                        def _init(self, *args, **kwargs):===================================================================================================================(2)
                                                                                                              [91;1mhow to define a method which can use self and accept any parameters[0m
                            for k in cls._methods:                                                                                                                          (3)
                                arg = kwargs.pop(k,None)                                                                                                                    (4)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m3[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                        old_init = cls.__init__                                                                                                                             (1)
                        def _init(self, *args, **kwargs):                                                                                                                   (2)
                            for k in cls._methods:==========================================================================================================================(3)
                                                  [91;1mhow to pop out the value of an item in a dict (with None as default), and if the item name is not found, pop out None instead; [0m
                                arg = kwargs.pop(k,None)                                                                                                                    (4)
                                if arg is not None:                                                                                                                         (5)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m6[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                                arg = kwargs.pop(k,None)                                                                                                                    (4)
                                if arg is not None:                                                                                                                         (5)
                                    if as_method: arg = method(arg)=========================================================================================================(6)
                                                                                                                                                 [91;1mhow to turn a func into a method[0m
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)                                                                     (7)
                                    setattr(self, k, arg)                                                                                                                   (8)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m7[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                                if arg is not None:                                                                                                                         (5)
                                    if as_method: arg = method(arg)                                                                                                         (6)
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)=====================================================================(7)
                                                                                                                             [91;1mhow to give a method a different instance, like self[0m
                                    setattr(self, k, arg)                                                                                                                   (8)
                            old_init(self, *args, **kwargs)                                                                                                                 (9)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m8[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                                    if as_method: arg = method(arg)                                                                                                         (6)
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)                                                                     (7)
                                    setattr(self, k, arg)===================================================================================================================(8)
                                                                                                                                   [91;1mhow to add a method to a class as an attribute[0m
                            old_init(self, *args, **kwargs)                                                                                                                 (9)
                        functools.update_wrapper(_init, old_init)                                                                                                           (10)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m10[0m     ===============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                                    setattr(self, k, arg)                                                                                                                   (8)
                            old_init(self, *args, **kwargs)                                                                                                                 (9)
                        functools.update_wrapper(_init, old_init)===========================================================================================================(10)
                                                                                          [91;1mhow to wrap `_init` around `old_init`, so that `_init` can use `old_init` inside itself[0m
                        cls.__init__ = use_kwargs(cls._methods)(_init)                                                                                                      (11)
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))                                                     (12)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m11[0m     ===============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                            old_init(self, *args, **kwargs)                                                                                                                 (9)
                        functools.update_wrapper(_init, old_init)                                                                                                           (10)
                        cls.__init__ = use_kwargs(cls._methods)(_init)======================================================================================================(11)
                                                                            [91;1mhow to add a list of names with None as default value to function `_init` to repalce its kwargs param[0m
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))                                                     (12)
                        return cls                                                                                                                                          (13)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m12[0m     ===============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                        functools.update_wrapper(_init, old_init)                                                                                                           (10)
                        cls.__init__ = use_kwargs(cls._methods)(_init)                                                                                                      (11)
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))=====================================================(12)
                                                                   [91;1mhow to make a class.`__init__` signature to be the signature of the class using `__signature__` and `_rm_self`[0m
                        return cls                                                                                                                                          (13)
                                                                                                                                                                            (14)
                
                
                
                ```
                #| column: screen
                fdb.snoop() # how to snoop together with docsrc: snoop first and docsrc above it
                ```
                
                    22:28:59.99 >>> Call to funcs_kwargs in File "/tmp/funcs_kwargs.py", line 3
                    22:28:59.99 ...... as_method = <class 'fastcore.meta.T'>
                    22:28:59.99    3 | def funcs_kwargs(as_method=False):
                    22:28:59.99    5 |     if callable(as_method): return _funcs_kwargs(as_method, False)
                        22:28:59.99 >>> Call to _funcs_kwargs in File "/tmp/_funcs_kwargs.py", line 3
                        22:28:59.99 ...... cls = <class 'fastcore.meta.T'>
                        22:28:59.99 ...... as_method = False
                        22:28:59.99    3 | def _funcs_kwargs(cls, as_method):
                        22:28:59.99    4 |     old_init = cls.__init__
                        22:28:59.99 .......... old_init = <function T.__init__>
                        22:28:59.99    5 |     import snoop
                        22:28:59.99 .......... snoop = <class 'snoop.configuration.Config.__init__.<locals>.ConfiguredTracer'>
                        22:28:59.99    6 |     @snoop
                        22:28:59.99    7 |     def _init(self, *args, **kwargs):
                        22:28:59.99 .......... _init = <function _funcs_kwargs.<locals>._init>
                        22:28:59.99   15 |     functools.update_wrapper(_init, old_init)
                        22:28:59.99 .......... _init = <function T.__init__>
                        22:28:59.99   16 |     cls.__init__ = use_kwargs(cls._methods)(_init)
                        22:28:59.99   17 |     if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))
                        22:28:59.99   18 |     return cls
                        22:28:59.99 <<< Return value from _funcs_kwargs: <class 'fastcore.meta.T'>
                    22:28:59.99    5 |     if callable(as_method): return _funcs_kwargs(as_method, False)
                    22:28:59.99 <<< Return value from funcs_kwargs: <class 'fastcore.meta.T'>
                    22:28:59.99 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:28:59.99 .......... self = <fastcore.meta.T object>
                    22:28:59.99 .......... args = ()
                    22:28:59.99 .......... kwargs = {}
                    22:28:59.99 .......... as_method = False
                    22:28:59.99 .......... cls = <class 'fastcore.meta.T'>
                    22:28:59.99 .......... old_init = <function T.__init__>
                    22:28:59.99    7 |     def _init(self, *args, **kwargs):
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00 .............. k = 'b'
                    22:29:00.00    9 |             arg = kwargs.pop(k,None)
                    22:29:00.00 .................. arg = None
                    22:29:00.00   10 |             if arg is not None:
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00   14 |         old_init(self, *args, **kwargs)
                    22:29:00.00 <<< Return value from _funcs_kwargs.<locals>._init: None
                    22:29:00.00 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:29:00.00 .......... self = <fastcore.meta.T object>
                    22:29:00.00 .......... args = ()
                    22:29:00.00 .......... kwargs = {'b': <function _new_func>}
                    22:29:00.00 .......... len(kwargs) = 1
                    22:29:00.00 .......... as_method = False
                    22:29:00.00 .......... cls = <class 'fastcore.meta.T'>
                    22:29:00.00 .......... old_init = <function T.__init__>
                    22:29:00.00    7 |     def _init(self, *args, **kwargs):
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00 .............. k = 'b'
                    22:29:00.00    9 |             arg = kwargs.pop(k,None)
                    22:29:00.00 .................. kwargs = {}
                    22:29:00.00 .................. arg = <function _new_func>
                    22:29:00.00   10 |             if arg is not None:
                    22:29:00.00   11 |                 if as_method: arg = method(arg)
                    22:29:00.00   12 |                 if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)
                    22:29:00.00   13 |                 setattr(self, k, arg)
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00   14 |         old_init(self, *args, **kwargs)
                    22:29:00.00 <<< Return value from _funcs_kwargs.<locals>._init: None
                    22:29:00.00 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:29:00.00 .......... self = <fastcore.meta.T object>
                    22:29:00.00 .......... args = ()
                    22:29:00.00 .......... kwargs = {'a': <function <lambda>>}
                    22:29:00.00 .......... len(kwargs) = 1
                    22:29:00.00 .......... as_method = False
                    22:29:00.00 .......... cls = <class 'fastcore.meta.T'>
                    22:29:00.00 .......... old_init = <function T.__init__>
                    22:29:00.00    7 |     def _init(self, *args, **kwargs):
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00 .............. k = 'b'
                    22:29:00.00    9 |             arg = kwargs.pop(k,None)
                    22:29:00.00 .................. arg = None
                    22:29:00.00   10 |             if arg is not None:
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00   14 |         old_init(self, *args, **kwargs)
                    22:29:00.00 <<< Return value from _funcs_kwargs.<locals>._init: None
                    22:29:00.00 >>> Call to funcs_kwargs in File "/tmp/funcs_kwargs.py", line 3
                    22:29:00.00 ...... as_method = True
                    22:29:00.00    3 | def funcs_kwargs(as_method=False):
                    22:29:00.00    5 |     if callable(as_method): return _funcs_kwargs(as_method, False)
                    22:29:00.00    6 |     return partial(_funcs_kwargs, as_method=as_method)
                    22:29:00.00 <<< Return value from funcs_kwargs: functools.partial(<function _funcs_kwargs>, as_method=True)
                    22:29:00.00 >>> Call to _funcs_kwargs in File "/tmp/_funcs_kwargs.py", line 3
                    22:29:00.00 ...... cls = <class 'fastcore.meta.T'>
                    22:29:00.00 ...... as_method = True
                    22:29:00.00    3 | def _funcs_kwargs(cls, as_method):
                    22:29:00.00    4 |     old_init = cls.__init__
                    22:29:00.00 .......... old_init = <slot wrapper '__init__' of 'object' objects>
                    22:29:00.00    5 |     import snoop
                    22:29:00.00 .......... snoop = <class 'snoop.configuration.Config.__init__.<locals>.ConfiguredTracer'>
                    22:29:00.00    6 |     @snoop
                    22:29:00.00    7 |     def _init(self, *args, **kwargs):
                    22:29:00.00 .......... _init = <function _funcs_kwargs.<locals>._init>
                    22:29:00.00   15 |     functools.update_wrapper(_init, old_init)
                    22:29:00.00 .......... _init = <function object.__init__>
                    22:29:00.00   16 |     cls.__init__ = use_kwargs(cls._methods)(_init)
                    22:29:00.01   17 |     if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))
                    22:29:00.01   18 |     return cls
                    22:29:00.01 <<< Return value from _funcs_kwargs: <class 'fastcore.meta.T'>
                    22:29:00.01 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:29:00.01 .......... self = <fastcore.meta.T object>
                    22:29:00.01 .......... args = ()
                    22:29:00.01 .......... kwargs = {'b': <function _f>}
                    22:29:00.01 .......... len(kwargs) = 1
                    22:29:00.01 .......... as_method = True
                    22:29:00.01 .......... cls = <class 'fastcore.meta.T'>
                    22:29:00.01 .......... old_init = <slot wrapper '__init__' of 'object' objects>
                    22:29:00.01    7 |     def _init(self, *args, **kwargs):
                    22:29:00.01    8 |         for k in cls._methods:
                    22:29:00.01 .............. k = 'b'
                    22:29:00.01    9 |             arg = kwargs.pop(k,None)
                    22:29:00.01 .................. kwargs = {}
                    22:29:00.01 .................. arg = <function _f>
                    22:29:00.01   10 |             if arg is not None:
                    22:29:00.01   11 |                 if as_method: arg = method(arg)
                    22:29:00.01 ...... arg = <bound method int._f of 1>
                    22:29:00.01   12 |                 if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)
                    22:29:00.01 ...... arg = <bound method T._f of <fastcore.meta.T object>>
                    22:29:00.01   13 |                 setattr(self, k, arg)
                    22:29:00.01    8 |         for k in cls._methods:
                    22:29:00.01   14 |         old_init(self, *args, **kwargs)
                    22:29:00.01 <<< Return value from _funcs_kwargs.<locals>._init: None
                    22:29:00.01 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:29:00.01 .......... self = <fastcore.meta.T2 object>
                    22:29:00.01 .......... args = ()
                    22:29:00.01 .......... kwargs = {'b': <function _f>}
                    22:29:00.01 .......... len(kwargs) = 1
                    22:29:00.01 .......... as_method = True
                    22:29:00.01 .......... cls = <class 'fastcore.meta.T'>
                    22:29:00.01 .......... old_init = <slot wrapper '__init__' of 'object' objects>
                    22:29:00.01    7 |     def _init(self, *args, **kwargs):
                    22:29:00.01    8 |         for k in cls._methods:
                    22:29:00.01 .............. k = 'b'
                    22:29:00.01    9 |             arg = kwargs.pop(k,None)
                    22:29:00.01 .................. kwargs = {}
                    22:29:00.01 .................. arg = <function _f>
                    22:29:00.01   10 |             if arg is not None:
                    22:29:00.01   11 |                 if as_method: arg = method(arg)
                    22:29:00.01 ...... arg = <bound method int._f of 1>
                    22:29:00.01   12 |                 if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)
                    22:29:00.01 ...... arg = <bound method T2._f of <fastcore.meta.T2 object>>
                    22:29:00.01   13 |                 setattr(self, k, arg)
                    22:29:00.01    8 |         for k in cls._methods:
                    22:29:00.01   14 |         old_init(self, *args, **kwargs)
                    22:29:00.01 <<< Return value from _funcs_kwargs.<locals>._init: None
                
                
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                
                
                
                ```
                fdb_.debug()
                ```
                
                    _funcs_kwargs's dbsrc code: ==============
                    import snoop
                    @snoop
                    def _funcs_kwargs(cls, as_method):
                        old_init = cls.__init__
                        import snoop
                        @snoop
                        def _init(self, *args, **kwargs):
                            for k in cls._methods:
                                arg = kwargs.pop(k,None)
                                if arg is not None:
                                    if as_method: arg = method(arg)
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)
                                    setattr(self, k, arg)
                            old_init(self, *args, **kwargs)
                        functools.update_wrapper(_init, old_init)
                        cls.__init__ = use_kwargs(cls._methods)(_init)
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))
                        return cls
                    
                    
                    
                    _funcs_kwargs's example processed with dbsrc: ===============
                    
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    
                
                
                
                ```
                #| column: screen
                fdb.print()
                ```
                
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    def funcs_kwargs(as_method=False):========================================================(0)       
                        "Replace methods in `cls._methods` with those from `kwargs`"==========================(1) # [93;1mhow funcs_kwargs works[0m; [93;1mit is a wrapper around _funcs_kwargs[0m; [91;1mit offers two ways of running _funcs_kwargs[0m; [37;1mthe first, default way, is to add a func to a class without using self[0m; [91;1msecond way is to add func to class enabling self use;[0m; 
                        if callable(as_method): return _funcs_kwargs(as_method, False)========================(2) # [37;1mhow to check whether an object is callable[0m; [93;1mhow to return a result of running a func[0m; [37;1m[0m; 
                        return partial(_funcs_kwargs, as_method=as_method)====================================(3) # [92;1mhow to custom the params of `_funcs_kwargs` for a particular use with partial[0m; 
                                                                                                                                                                            (4)
                
                
                
                ```
                #| column: screen
                fdb_.print()
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m12[0m     ===============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    def _funcs_kwargs(cls, as_method):========================================================(0) # [93;1mhow does _funcs_kwargs work: _funcs_kwargs is a decorator[0m; [35;1mit helps class e.g., T to add more methods[0m; [93;1mI need to give the method a name, and put the name e.g., 'b' inside a list called _methods=['b'] inside class T[0m; [36;1mthen after writing a func e.g., _new_func, I can add it by T(b = _new_func)[0m; [36;1mif I want the func added to class to use self, I shall write @funcs_kwargs(as_method=True)[0m; 
                        old_init = cls.__init__===============================================================(1)       
                        def _init(self, *args, **kwargs):=====================================================(2) # [37;1mhow to define a method which can use self and accept any parameters[0m; 
                            for k in cls._methods:============================================================(3) # [35;1mhow to pop out the value of an item in a dict (with None as default), and if the item name is not found, pop out None instead[0m; [91;1m[0m; 
                                arg = kwargs.pop(k,None)======================================================(4)       
                                if arg is not None:===========================================================(5)       
                                    if as_method: arg = method(arg)===========================================(6) # [36;1mhow to turn a func into a method[0m; 
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)=======(7) # [93;1mhow to give a method a different instance, like self[0m; 
                                    setattr(self, k, arg)=====================================================(8) # [36;1mhow to add a method to a class as an attribute[0m; 
                            old_init(self, *args, **kwargs)===================================================(9)       
                        functools.update_wrapper(_init, old_init)=============================================(10) # [34;1mhow to wrap `_init` around `old_init`, so that `_init` can use `old_init` inside itself[0m; 
                        cls.__init__ = use_kwargs(cls._methods)(_init)========================================(11) # [34;1mhow to add a list of names with None as default value to function `_init` to repalce its kwargs param[0m; 
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__)) # [35;1mhow to make a class.`__init__` signature to be the signature of the class using `__signature__` and `_rm_self`[0m;  (12)
                        return cls============================================================================(13)      
                                                                                                                                                                            (14)
                
                
                
                ```
                
                ```
                
                
            
            
            
            [Open `0009_funcs_kwargs` in Jupyter Notebook](http://localhost:8888/tree/nbs/demos/0009_funcs_kwargs.ipynb)
            
            
            
        
        
        
        [Open `utils` in Jupyter Notebook](http://localhost:8888/tree/nbs/lib/utils.ipynb)
        
        
        
        
    
    
    
    [Open `utils` in Jupyter Notebook](http://localhost:8888/tree/nbs/lib/utils.ipynb)
    
    
    
    



[Open `utils` in Jupyter Notebook locally](http://localhost:8888/tree/nbs/lib/utils.ipynb)



###  <mark style="background-color: #ffff00">snoop:</mark>   <mark style="background-color: #ffff00">from</mark>   <mark style="background-color: #ffff00">_ <mark style="background-color: #FFFF00">funcs_kwargs</mark> </mark>   <mark style="background-color: #ffff00">to</mark>   <mark style="background-color: #FFFF00">funcs_kwargs</mark> 



    
    
    
        
        
        
            
            
            
                
                how to snoop on two functions one wrap around another: `funcs_kwargs` is a wrapper around `_funcs_kwargs`, so I can first snoop on `_funcs_kwargs` and assign its snoop dbsrc to \
                `fm._funcs_kwargs` so that when I snoop on `funcs_kwargs`, it can use the snoop dbsrc of `_funcs_kwargs` and no example codes need to change.
                
                
                ```
                from fastcore.meta import _funcs_kwargs
                ```
                
                
                ```
                fdb_ = Fastdb(_funcs_kwargs)
                fdb_.eg = """
                @funcs_kwargs
                class T:
                    _methods=['b'] # allows you to add method b upon instantiation
                    def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                    def a(self): return 1
                    def b(self): return 2
                    
                t = T()
                test_eq(t.a(), 1)
                test_eq(t.b(), 2)
                
                test_sig(T, '(f=1, *, b=None)')
                inspect.signature(T)
                
                def _new_func(): return 5
                
                t = T(b = _new_func)
                test_eq(t.b(), 5)
                
                t = T(a = lambda:3)
                test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                """
                ```
                
                
                ```
                #| column: screen
                # no snoop result, it is expected, because the example is not calling _funcs_kwargs, but funcs_kwargs
                fdb_.snoop(deco=True) # how to snoop decorator: _funcs_kwargs is a decorator, so set deco=True to see running codes in inner f
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    [0m     
                    
                
                
                
                ```
                import fastcore.meta as fm
                ```
                
                
                ```
                fm._funcs_kwargs = fdb_.dbsrc # how to snoop on two functions one wrap around another
                ```
                
                
                ```
                fdb = Fastdb(funcs_kwargs)
                fdb.eg = """
                @funcs_kwargs
                class T:
                    _methods=['b'] # allows you to add method b upon instantiation
                    def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                    def a(self): return 1
                    def b(self): return 2
                    
                t = T()
                test_eq(t.a(), 1)
                test_eq(t.b(), 2)
                
                test_sig(T, '(f=1, *, b=None)')
                inspect.signature(T)
                
                def _new_func(): return 5
                
                t = T(b = _new_func)
                test_eq(t.b(), 5)
                
                t = T(a = lambda:3)
                test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                
                def _f(self,a=1): return self.num + a # access the num attribute from the instance
                
                @funcs_kwargs(as_method=True)
                class T: 
                    _methods=['b']
                    num = 5
                    
                t = T(b = _f) # adds method b
                test_eq(t.b(5), 10) # self.num + 5 = 10
                
                def _f(self,a=1): return self.num * a #multiply instead of add 
                
                class T2(T):
                    def __init__(self,num):
                        super().__init__(b = _f) # add method b from the super class
                        self.num=num
                        
                t = T2(num=3)
                test_eq(t.b(a=5), 15) # 3 * 5 = 15
                test_sig(T2, '(num)')
                """
                ```
                
                
                ```
                #| column: screen
                fdb.print()
                ```
                
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    def funcs_kwargs(as_method=False):========================================================(0)       
                        "Replace methods in `cls._methods` with those from `kwargs`"==========================(1)       
                        if callable(as_method): return _funcs_kwargs(as_method, False)========================(2)       
                        return partial(_funcs_kwargs, as_method=as_method)====================================(3)       
                                                                                                                                                                            (4)
                
                
                
                ```
                #| column: screen
                fdb_.print()
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    def _funcs_kwargs(cls, as_method):========================================================(0)       
                        old_init = cls.__init__===============================================================(1)       
                        def _init(self, *args, **kwargs):=====================================================(2)       
                            for k in cls._methods:============================================================(3)       
                                arg = kwargs.pop(k,None)======================================================(4)       
                                if arg is not None:===========================================================(5)       
                                    if as_method: arg = method(arg)===========================================(6)       
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)=======(7)       
                                    setattr(self, k, arg)=====================================================(8)       
                            old_init(self, *args, **kwargs)===================================================(9)       
                        functools.update_wrapper(_init, old_init)=============================================(10)      
                        cls.__init__ = use_kwargs(cls._methods)(_init)========================================(11)      
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))                                                     (12)
                        return cls============================================================================(13)      
                                                                                                                                                                            (14)
                
                
                
                ```
                #| column: screen
                fdb.docsrc(1, "how funcs_kwargs works; it is a wrapper around _funcs_kwargs; it offers two ways of running _funcs_kwargs; \
                the first, default way, is to add a func to a class without using self; second way is to add func to class enabling self use;")
                fdb.docsrc(2, "how to check whether an object is callable; how to return a result of running a func; ")
                fdb.docsrc(3, "how to custom the params of `_funcs_kwargs` for a particular use with partial")
                ```
                
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m1[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                    def funcs_kwargs(as_method=False):                                                                                                                      (0)
                        "Replace methods in `cls._methods` with those from `kwargs`"========================================================================================(1)
                    [91;1mhow funcs_kwargs works; it is a wrapper around _funcs_kwargs; it offers two ways of running _funcs_kwargs; the first, default way, is to add a func to a class without using self; second way is to add func to class enabling self use;[0m
                        if callable(as_method): return _funcs_kwargs(as_method, False)                                                                                      (2)
                        return partial(_funcs_kwargs, as_method=as_method)                                                                                                  (3)
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m2[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                    def funcs_kwargs(as_method=False):                                                                                                                      (0)
                        "Replace methods in `cls._methods` with those from `kwargs`"                                                                                        (1)
                        if callable(as_method): return _funcs_kwargs(as_method, False)======================================================================================(2)
                                                                                           [91;1mhow to check whether an object is callable; how to return a result of running a func; [0m
                        return partial(_funcs_kwargs, as_method=as_method)                                                                                                  (3)
                                                                                                                                                                            (4)
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m3[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                        "Replace methods in `cls._methods` with those from `kwargs`"                                                                                        (1)
                        if callable(as_method): return _funcs_kwargs(as_method, False)                                                                                      (2)
                        return partial(_funcs_kwargs, as_method=as_method)==================================================================================================(3)
                                                                                                    [91;1mhow to custom the params of `_funcs_kwargs` for a particular use with partial[0m
                                                                                                                                                                            (4)
                
                
                
                ```
                #| column: screen
                fdb_.print()
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    def _funcs_kwargs(cls, as_method):========================================================(0)       
                        old_init = cls.__init__===============================================================(1)       
                        def _init(self, *args, **kwargs):=====================================================(2)       
                            for k in cls._methods:============================================================(3)       
                                arg = kwargs.pop(k,None)======================================================(4)       
                                if arg is not None:===========================================================(5)       
                                    if as_method: arg = method(arg)===========================================(6)       
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)=======(7)       
                                    setattr(self, k, arg)=====================================================(8)       
                            old_init(self, *args, **kwargs)===================================================(9)       
                        functools.update_wrapper(_init, old_init)=============================================(10)      
                        cls.__init__ = use_kwargs(cls._methods)(_init)========================================(11)      
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))                                                     (12)
                        return cls============================================================================(13)      
                                                                                                                                                                            (14)
                
                
                
                ```
                #| column: screen
                fdb_.docsrc(0, "how does _funcs_kwargs work: _funcs_kwargs is a decorator; it helps class e.g., T to add more methods; \
                I need to give the method a name, \
                and put the name e.g., 'b' inside a list called _methods=['b'] inside class T; \
                then after writing a func e.g., _new_func, I can add it by T(b = _new_func); if I want the func added to class to use self, \
                I shall write @funcs_kwargs(as_method=True)")
                fdb_.docsrc(2, "how to define a method which can use self and accept any parameters")
                fdb_.docsrc(3, "how to pop out the value of an item in a dict (with None as default), and if the item name is not found, pop out None instead; ")
                fdb_.docsrc(6, "how to turn a func into a method")
                fdb_.docsrc(7, "how to give a method a different instance, like self")
                fdb_.docsrc(8, "how to add a method to a class as an attribute")
                fdb_.docsrc(10, "how to wrap `_init` around `old_init`, so that `_init` can use `old_init` inside itself")
                fdb_.docsrc(11, "how to add a list of names with None as default value to function `_init` to repalce its kwargs param")
                fdb_.docsrc(12, "how to make a class.`__init__` signature to be the signature of the class using `__signature__` and `_rm_self`")
                
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m0[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                    def _funcs_kwargs(cls, as_method):======================================================================================================================(0)
                    [91;1mhow does _funcs_kwargs work: _funcs_kwargs is a decorator; it helps class e.g., T to add more methods; I need to give the method a name, and put the name e.g., 'b' inside a list called _methods=['b'] inside class T; then after writing a func e.g., _new_func, I can add it by T(b = _new_func); if I want the func added to class to use self, I shall write @funcs_kwargs(as_method=True)[0m
                        old_init = cls.__init__                                                                                                                             (1)
                        def _init(self, *args, **kwargs):                                                                                                                   (2)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m2[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                    def _funcs_kwargs(cls, as_method):                                                                                                                      (0)
                        old_init = cls.__init__                                                                                                                             (1)
                        def _init(self, *args, **kwargs):===================================================================================================================(2)
                                                                                                              [91;1mhow to define a method which can use self and accept any parameters[0m
                            for k in cls._methods:                                                                                                                          (3)
                                arg = kwargs.pop(k,None)                                                                                                                    (4)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m3[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                        old_init = cls.__init__                                                                                                                             (1)
                        def _init(self, *args, **kwargs):                                                                                                                   (2)
                            for k in cls._methods:==========================================================================================================================(3)
                                                  [91;1mhow to pop out the value of an item in a dict (with None as default), and if the item name is not found, pop out None instead; [0m
                                arg = kwargs.pop(k,None)                                                                                                                    (4)
                                if arg is not None:                                                                                                                         (5)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m6[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                                arg = kwargs.pop(k,None)                                                                                                                    (4)
                                if arg is not None:                                                                                                                         (5)
                                    if as_method: arg = method(arg)=========================================================================================================(6)
                                                                                                                                                 [91;1mhow to turn a func into a method[0m
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)                                                                     (7)
                                    setattr(self, k, arg)                                                                                                                   (8)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m7[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                                if arg is not None:                                                                                                                         (5)
                                    if as_method: arg = method(arg)                                                                                                         (6)
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)=====================================================================(7)
                                                                                                                             [91;1mhow to give a method a different instance, like self[0m
                                    setattr(self, k, arg)                                                                                                                   (8)
                            old_init(self, *args, **kwargs)                                                                                                                 (9)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m8[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                                    if as_method: arg = method(arg)                                                                                                         (6)
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)                                                                     (7)
                                    setattr(self, k, arg)===================================================================================================================(8)
                                                                                                                                   [91;1mhow to add a method to a class as an attribute[0m
                            old_init(self, *args, **kwargs)                                                                                                                 (9)
                        functools.update_wrapper(_init, old_init)                                                                                                           (10)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m10[0m     ===============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                                    setattr(self, k, arg)                                                                                                                   (8)
                            old_init(self, *args, **kwargs)                                                                                                                 (9)
                        functools.update_wrapper(_init, old_init)===========================================================================================================(10)
                                                                                          [91;1mhow to wrap `_init` around `old_init`, so that `_init` can use `old_init` inside itself[0m
                        cls.__init__ = use_kwargs(cls._methods)(_init)                                                                                                      (11)
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))                                                     (12)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m11[0m     ===============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                            old_init(self, *args, **kwargs)                                                                                                                 (9)
                        functools.update_wrapper(_init, old_init)                                                                                                           (10)
                        cls.__init__ = use_kwargs(cls._methods)(_init)======================================================================================================(11)
                                                                            [91;1mhow to add a list of names with None as default value to function `_init` to repalce its kwargs param[0m
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))                                                     (12)
                        return cls                                                                                                                                          (13)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m12[0m     ===============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                        functools.update_wrapper(_init, old_init)                                                                                                           (10)
                        cls.__init__ = use_kwargs(cls._methods)(_init)                                                                                                      (11)
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))=====================================================(12)
                                                                   [91;1mhow to make a class.`__init__` signature to be the signature of the class using `__signature__` and `_rm_self`[0m
                        return cls                                                                                                                                          (13)
                                                                                                                                                                            (14)
                
                
                
                ```
                #| column: screen
                fdb.snoop() # how to snoop together with docsrc: snoop first and docsrc above it
                ```
                
                    22:28:59.99 >>> Call to funcs_kwargs in File "/tmp/funcs_kwargs.py", line 3
                    22:28:59.99 ...... as_method = <class 'fastcore.meta.T'>
                    22:28:59.99    3 | def funcs_kwargs(as_method=False):
                    22:28:59.99    5 |     if callable(as_method): return _funcs_kwargs(as_method, False)
                        22:28:59.99 >>> Call to _funcs_kwargs in File "/tmp/_funcs_kwargs.py", line 3
                        22:28:59.99 ...... cls = <class 'fastcore.meta.T'>
                        22:28:59.99 ...... as_method = False
                        22:28:59.99    3 | def _funcs_kwargs(cls, as_method):
                        22:28:59.99    4 |     old_init = cls.__init__
                        22:28:59.99 .......... old_init = <function T.__init__>
                        22:28:59.99    5 |     import snoop
                        22:28:59.99 .......... snoop = <class 'snoop.configuration.Config.__init__.<locals>.ConfiguredTracer'>
                        22:28:59.99    6 |     @snoop
                        22:28:59.99    7 |     def _init(self, *args, **kwargs):
                        22:28:59.99 .......... _init = <function _funcs_kwargs.<locals>._init>
                        22:28:59.99   15 |     functools.update_wrapper(_init, old_init)
                        22:28:59.99 .......... _init = <function T.__init__>
                        22:28:59.99   16 |     cls.__init__ = use_kwargs(cls._methods)(_init)
                        22:28:59.99   17 |     if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))
                        22:28:59.99   18 |     return cls
                        22:28:59.99 <<< Return value from _funcs_kwargs: <class 'fastcore.meta.T'>
                    22:28:59.99    5 |     if callable(as_method): return _funcs_kwargs(as_method, False)
                    22:28:59.99 <<< Return value from funcs_kwargs: <class 'fastcore.meta.T'>
                    22:28:59.99 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:28:59.99 .......... self = <fastcore.meta.T object>
                    22:28:59.99 .......... args = ()
                    22:28:59.99 .......... kwargs = {}
                    22:28:59.99 .......... as_method = False
                    22:28:59.99 .......... cls = <class 'fastcore.meta.T'>
                    22:28:59.99 .......... old_init = <function T.__init__>
                    22:28:59.99    7 |     def _init(self, *args, **kwargs):
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00 .............. k = 'b'
                    22:29:00.00    9 |             arg = kwargs.pop(k,None)
                    22:29:00.00 .................. arg = None
                    22:29:00.00   10 |             if arg is not None:
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00   14 |         old_init(self, *args, **kwargs)
                    22:29:00.00 <<< Return value from _funcs_kwargs.<locals>._init: None
                    22:29:00.00 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:29:00.00 .......... self = <fastcore.meta.T object>
                    22:29:00.00 .......... args = ()
                    22:29:00.00 .......... kwargs = {'b': <function _new_func>}
                    22:29:00.00 .......... len(kwargs) = 1
                    22:29:00.00 .......... as_method = False
                    22:29:00.00 .......... cls = <class 'fastcore.meta.T'>
                    22:29:00.00 .......... old_init = <function T.__init__>
                    22:29:00.00    7 |     def _init(self, *args, **kwargs):
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00 .............. k = 'b'
                    22:29:00.00    9 |             arg = kwargs.pop(k,None)
                    22:29:00.00 .................. kwargs = {}
                    22:29:00.00 .................. arg = <function _new_func>
                    22:29:00.00   10 |             if arg is not None:
                    22:29:00.00   11 |                 if as_method: arg = method(arg)
                    22:29:00.00   12 |                 if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)
                    22:29:00.00   13 |                 setattr(self, k, arg)
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00   14 |         old_init(self, *args, **kwargs)
                    22:29:00.00 <<< Return value from _funcs_kwargs.<locals>._init: None
                    22:29:00.00 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:29:00.00 .......... self = <fastcore.meta.T object>
                    22:29:00.00 .......... args = ()
                    22:29:00.00 .......... kwargs = {'a': <function <lambda>>}
                    22:29:00.00 .......... len(kwargs) = 1
                    22:29:00.00 .......... as_method = False
                    22:29:00.00 .......... cls = <class 'fastcore.meta.T'>
                    22:29:00.00 .......... old_init = <function T.__init__>
                    22:29:00.00    7 |     def _init(self, *args, **kwargs):
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00 .............. k = 'b'
                    22:29:00.00    9 |             arg = kwargs.pop(k,None)
                    22:29:00.00 .................. arg = None
                    22:29:00.00   10 |             if arg is not None:
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00   14 |         old_init(self, *args, **kwargs)
                    22:29:00.00 <<< Return value from _funcs_kwargs.<locals>._init: None
                    22:29:00.00 >>> Call to funcs_kwargs in File "/tmp/funcs_kwargs.py", line 3
                    22:29:00.00 ...... as_method = True
                    22:29:00.00    3 | def funcs_kwargs(as_method=False):
                    22:29:00.00    5 |     if callable(as_method): return _funcs_kwargs(as_method, False)
                    22:29:00.00    6 |     return partial(_funcs_kwargs, as_method=as_method)
                    22:29:00.00 <<< Return value from funcs_kwargs: functools.partial(<function _funcs_kwargs>, as_method=True)
                    22:29:00.00 >>> Call to _funcs_kwargs in File "/tmp/_funcs_kwargs.py", line 3
                    22:29:00.00 ...... cls = <class 'fastcore.meta.T'>
                    22:29:00.00 ...... as_method = True
                    22:29:00.00    3 | def _funcs_kwargs(cls, as_method):
                    22:29:00.00    4 |     old_init = cls.__init__
                    22:29:00.00 .......... old_init = <slot wrapper '__init__' of 'object' objects>
                    22:29:00.00    5 |     import snoop
                    22:29:00.00 .......... snoop = <class 'snoop.configuration.Config.__init__.<locals>.ConfiguredTracer'>
                    22:29:00.00    6 |     @snoop
                    22:29:00.00    7 |     def _init(self, *args, **kwargs):
                    22:29:00.00 .......... _init = <function _funcs_kwargs.<locals>._init>
                    22:29:00.00   15 |     functools.update_wrapper(_init, old_init)
                    22:29:00.00 .......... _init = <function object.__init__>
                    22:29:00.00   16 |     cls.__init__ = use_kwargs(cls._methods)(_init)
                    22:29:00.01   17 |     if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))
                    22:29:00.01   18 |     return cls
                    22:29:00.01 <<< Return value from _funcs_kwargs: <class 'fastcore.meta.T'>
                    22:29:00.01 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:29:00.01 .......... self = <fastcore.meta.T object>
                    22:29:00.01 .......... args = ()
                    22:29:00.01 .......... kwargs = {'b': <function _f>}
                    22:29:00.01 .......... len(kwargs) = 1
                    22:29:00.01 .......... as_method = True
                    22:29:00.01 .......... cls = <class 'fastcore.meta.T'>
                    22:29:00.01 .......... old_init = <slot wrapper '__init__' of 'object' objects>
                    22:29:00.01    7 |     def _init(self, *args, **kwargs):
                    22:29:00.01    8 |         for k in cls._methods:
                    22:29:00.01 .............. k = 'b'
                    22:29:00.01    9 |             arg = kwargs.pop(k,None)
                    22:29:00.01 .................. kwargs = {}
                    22:29:00.01 .................. arg = <function _f>
                    22:29:00.01   10 |             if arg is not None:
                    22:29:00.01   11 |                 if as_method: arg = method(arg)
                    22:29:00.01 ...... arg = <bound method int._f of 1>
                    22:29:00.01   12 |                 if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)
                    22:29:00.01 ...... arg = <bound method T._f of <fastcore.meta.T object>>
                    22:29:00.01   13 |                 setattr(self, k, arg)
                    22:29:00.01    8 |         for k in cls._methods:
                    22:29:00.01   14 |         old_init(self, *args, **kwargs)
                    22:29:00.01 <<< Return value from _funcs_kwargs.<locals>._init: None
                    22:29:00.01 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:29:00.01 .......... self = <fastcore.meta.T2 object>
                    22:29:00.01 .......... args = ()
                    22:29:00.01 .......... kwargs = {'b': <function _f>}
                    22:29:00.01 .......... len(kwargs) = 1
                    22:29:00.01 .......... as_method = True
                    22:29:00.01 .......... cls = <class 'fastcore.meta.T'>
                    22:29:00.01 .......... old_init = <slot wrapper '__init__' of 'object' objects>
                    22:29:00.01    7 |     def _init(self, *args, **kwargs):
                    22:29:00.01    8 |         for k in cls._methods:
                    22:29:00.01 .............. k = 'b'
                    22:29:00.01    9 |             arg = kwargs.pop(k,None)
                    22:29:00.01 .................. kwargs = {}
                    22:29:00.01 .................. arg = <function _f>
                    22:29:00.01   10 |             if arg is not None:
                    22:29:00.01   11 |                 if as_method: arg = method(arg)
                    22:29:00.01 ...... arg = <bound method int._f of 1>
                    22:29:00.01   12 |                 if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)
                    22:29:00.01 ...... arg = <bound method T2._f of <fastcore.meta.T2 object>>
                    22:29:00.01   13 |                 setattr(self, k, arg)
                    22:29:00.01    8 |         for k in cls._methods:
                    22:29:00.01   14 |         old_init(self, *args, **kwargs)
                    22:29:00.01 <<< Return value from _funcs_kwargs.<locals>._init: None
                
                
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                
                
                
                ```
                fdb_.debug()
                ```
                
                    _funcs_kwargs's dbsrc code: ==============
                    import snoop
                    @snoop
                    def _funcs_kwargs(cls, as_method):
                        old_init = cls.__init__
                        import snoop
                        @snoop
                        def _init(self, *args, **kwargs):
                            for k in cls._methods:
                                arg = kwargs.pop(k,None)
                                if arg is not None:
                                    if as_method: arg = method(arg)
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)
                                    setattr(self, k, arg)
                            old_init(self, *args, **kwargs)
                        functools.update_wrapper(_init, old_init)
                        cls.__init__ = use_kwargs(cls._methods)(_init)
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))
                        return cls
                    
                    
                    
                    _funcs_kwargs's example processed with dbsrc: ===============
                    
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    
                
                
                
                ```
                #| column: screen
                fdb.print()
                ```
                
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    def funcs_kwargs(as_method=False):========================================================(0)       
                        "Replace methods in `cls._methods` with those from `kwargs`"==========================(1) # [93;1mhow funcs_kwargs works[0m; [93;1mit is a wrapper around _funcs_kwargs[0m; [91;1mit offers two ways of running _funcs_kwargs[0m; [37;1mthe first, default way, is to add a func to a class without using self[0m; [91;1msecond way is to add func to class enabling self use;[0m; 
                        if callable(as_method): return _funcs_kwargs(as_method, False)========================(2) # [37;1mhow to check whether an object is callable[0m; [93;1mhow to return a result of running a func[0m; [37;1m[0m; 
                        return partial(_funcs_kwargs, as_method=as_method)====================================(3) # [92;1mhow to custom the params of `_funcs_kwargs` for a particular use with partial[0m; 
                                                                                                                                                                            (4)
                
                
                
                ```
                #| column: screen
                fdb_.print()
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m12[0m     ===============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    def _funcs_kwargs(cls, as_method):========================================================(0) # [93;1mhow does _funcs_kwargs work: _funcs_kwargs is a decorator[0m; [35;1mit helps class e.g., T to add more methods[0m; [93;1mI need to give the method a name, and put the name e.g., 'b' inside a list called _methods=['b'] inside class T[0m; [36;1mthen after writing a func e.g., _new_func, I can add it by T(b = _new_func)[0m; [36;1mif I want the func added to class to use self, I shall write @funcs_kwargs(as_method=True)[0m; 
                        old_init = cls.__init__===============================================================(1)       
                        def _init(self, *args, **kwargs):=====================================================(2) # [37;1mhow to define a method which can use self and accept any parameters[0m; 
                            for k in cls._methods:============================================================(3) # [35;1mhow to pop out the value of an item in a dict (with None as default), and if the item name is not found, pop out None instead[0m; [91;1m[0m; 
                                arg = kwargs.pop(k,None)======================================================(4)       
                                if arg is not None:===========================================================(5)       
                                    if as_method: arg = method(arg)===========================================(6) # [36;1mhow to turn a func into a method[0m; 
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)=======(7) # [93;1mhow to give a method a different instance, like self[0m; 
                                    setattr(self, k, arg)=====================================================(8) # [36;1mhow to add a method to a class as an attribute[0m; 
                            old_init(self, *args, **kwargs)===================================================(9)       
                        functools.update_wrapper(_init, old_init)=============================================(10) # [34;1mhow to wrap `_init` around `old_init`, so that `_init` can use `old_init` inside itself[0m; 
                        cls.__init__ = use_kwargs(cls._methods)(_init)========================================(11) # [34;1mhow to add a list of names with None as default value to function `_init` to repalce its kwargs param[0m; 
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__)) # [35;1mhow to make a class.`__init__` signature to be the signature of the class using `__signature__` and `_rm_self`[0m;  (12)
                        return cls============================================================================(13)      
                                                                                                                                                                            (14)
                
                
                
                ```
                
                ```
                
                
            
            
            
            [Open `0009_funcs_kwargs` in Jupyter Notebook](http://localhost:8888/tree/nbs/demos/0009_funcs_kwargs.ipynb)
            
            
            
        
        
        
        [Open `utils` in Jupyter Notebook](http://localhost:8888/tree/nbs/lib/utils.ipynb)
        
        
        
        
    
    
    
    [Open `utils` in Jupyter Notebook](http://localhost:8888/tree/nbs/lib/utils.ipynb)
    
    
    
    



[Open `utils` in Jupyter Notebook locally](http://localhost:8888/tree/nbs/lib/utils.ipynb)



###  <mark style="background-color: #ffff00">snoop:</mark>   <mark style="background-color: #ffff00">from</mark>   <mark style="background-color: #ffff00">_ <mark style="background-color: #FFFF00">funcs_kwargs</mark> </mark>   <mark style="background-color: #ffff00">to</mark>   <mark style="background-color: #FFFF00">funcs_kwargs</mark> 



    
    
    
        
        
        
            
            
            
                
                how to snoop on two functions one wrap around another: `funcs_kwargs` is a wrapper around `_funcs_kwargs`, so I can first snoop on `_funcs_kwargs` and assign its snoop dbsrc to \
                `fm._funcs_kwargs` so that when I snoop on `funcs_kwargs`, it can use the snoop dbsrc of `_funcs_kwargs` and no example codes need to change.
                
                
                ```
                from fastcore.meta import _funcs_kwargs
                ```
                
                
                ```
                fdb_ = Fastdb(_funcs_kwargs)
                fdb_.eg = """
                @funcs_kwargs
                class T:
                    _methods=['b'] # allows you to add method b upon instantiation
                    def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                    def a(self): return 1
                    def b(self): return 2
                    
                t = T()
                test_eq(t.a(), 1)
                test_eq(t.b(), 2)
                
                test_sig(T, '(f=1, *, b=None)')
                inspect.signature(T)
                
                def _new_func(): return 5
                
                t = T(b = _new_func)
                test_eq(t.b(), 5)
                
                t = T(a = lambda:3)
                test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                """
                ```
                
                
                ```
                #| column: screen
                # no snoop result, it is expected, because the example is not calling _funcs_kwargs, but funcs_kwargs
                fdb_.snoop(deco=True) # how to snoop decorator: _funcs_kwargs is a decorator, so set deco=True to see running codes in inner f
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    [0m     
                    
                
                
                
                ```
                import fastcore.meta as fm
                ```
                
                
                ```
                fm._funcs_kwargs = fdb_.dbsrc # how to snoop on two functions one wrap around another
                ```
                
                
                ```
                fdb = Fastdb(funcs_kwargs)
                fdb.eg = """
                @funcs_kwargs
                class T:
                    _methods=['b'] # allows you to add method b upon instantiation
                    def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                    def a(self): return 1
                    def b(self): return 2
                    
                t = T()
                test_eq(t.a(), 1)
                test_eq(t.b(), 2)
                
                test_sig(T, '(f=1, *, b=None)')
                inspect.signature(T)
                
                def _new_func(): return 5
                
                t = T(b = _new_func)
                test_eq(t.b(), 5)
                
                t = T(a = lambda:3)
                test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                
                def _f(self,a=1): return self.num + a # access the num attribute from the instance
                
                @funcs_kwargs(as_method=True)
                class T: 
                    _methods=['b']
                    num = 5
                    
                t = T(b = _f) # adds method b
                test_eq(t.b(5), 10) # self.num + 5 = 10
                
                def _f(self,a=1): return self.num * a #multiply instead of add 
                
                class T2(T):
                    def __init__(self,num):
                        super().__init__(b = _f) # add method b from the super class
                        self.num=num
                        
                t = T2(num=3)
                test_eq(t.b(a=5), 15) # 3 * 5 = 15
                test_sig(T2, '(num)')
                """
                ```
                
                
                ```
                #| column: screen
                fdb.print()
                ```
                
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    def funcs_kwargs(as_method=False):========================================================(0)       
                        "Replace methods in `cls._methods` with those from `kwargs`"==========================(1)       
                        if callable(as_method): return _funcs_kwargs(as_method, False)========================(2)       
                        return partial(_funcs_kwargs, as_method=as_method)====================================(3)       
                                                                                                                                                                            (4)
                
                
                
                ```
                #| column: screen
                fdb_.print()
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    def _funcs_kwargs(cls, as_method):========================================================(0)       
                        old_init = cls.__init__===============================================================(1)       
                        def _init(self, *args, **kwargs):=====================================================(2)       
                            for k in cls._methods:============================================================(3)       
                                arg = kwargs.pop(k,None)======================================================(4)       
                                if arg is not None:===========================================================(5)       
                                    if as_method: arg = method(arg)===========================================(6)       
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)=======(7)       
                                    setattr(self, k, arg)=====================================================(8)       
                            old_init(self, *args, **kwargs)===================================================(9)       
                        functools.update_wrapper(_init, old_init)=============================================(10)      
                        cls.__init__ = use_kwargs(cls._methods)(_init)========================================(11)      
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))                                                     (12)
                        return cls============================================================================(13)      
                                                                                                                                                                            (14)
                
                
                
                ```
                #| column: screen
                fdb.docsrc(1, "how funcs_kwargs works; it is a wrapper around _funcs_kwargs; it offers two ways of running _funcs_kwargs; \
                the first, default way, is to add a func to a class without using self; second way is to add func to class enabling self use;")
                fdb.docsrc(2, "how to check whether an object is callable; how to return a result of running a func; ")
                fdb.docsrc(3, "how to custom the params of `_funcs_kwargs` for a particular use with partial")
                ```
                
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m1[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                    def funcs_kwargs(as_method=False):                                                                                                                      (0)
                        "Replace methods in `cls._methods` with those from `kwargs`"========================================================================================(1)
                    [91;1mhow funcs_kwargs works; it is a wrapper around _funcs_kwargs; it offers two ways of running _funcs_kwargs; the first, default way, is to add a func to a class without using self; second way is to add func to class enabling self use;[0m
                        if callable(as_method): return _funcs_kwargs(as_method, False)                                                                                      (2)
                        return partial(_funcs_kwargs, as_method=as_method)                                                                                                  (3)
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m2[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                    def funcs_kwargs(as_method=False):                                                                                                                      (0)
                        "Replace methods in `cls._methods` with those from `kwargs`"                                                                                        (1)
                        if callable(as_method): return _funcs_kwargs(as_method, False)======================================================================================(2)
                                                                                           [91;1mhow to check whether an object is callable; how to return a result of running a func; [0m
                        return partial(_funcs_kwargs, as_method=as_method)                                                                                                  (3)
                                                                                                                                                                            (4)
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m3[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                        "Replace methods in `cls._methods` with those from `kwargs`"                                                                                        (1)
                        if callable(as_method): return _funcs_kwargs(as_method, False)                                                                                      (2)
                        return partial(_funcs_kwargs, as_method=as_method)==================================================================================================(3)
                                                                                                    [91;1mhow to custom the params of `_funcs_kwargs` for a particular use with partial[0m
                                                                                                                                                                            (4)
                
                
                
                ```
                #| column: screen
                fdb_.print()
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    def _funcs_kwargs(cls, as_method):========================================================(0)       
                        old_init = cls.__init__===============================================================(1)       
                        def _init(self, *args, **kwargs):=====================================================(2)       
                            for k in cls._methods:============================================================(3)       
                                arg = kwargs.pop(k,None)======================================================(4)       
                                if arg is not None:===========================================================(5)       
                                    if as_method: arg = method(arg)===========================================(6)       
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)=======(7)       
                                    setattr(self, k, arg)=====================================================(8)       
                            old_init(self, *args, **kwargs)===================================================(9)       
                        functools.update_wrapper(_init, old_init)=============================================(10)      
                        cls.__init__ = use_kwargs(cls._methods)(_init)========================================(11)      
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))                                                     (12)
                        return cls============================================================================(13)      
                                                                                                                                                                            (14)
                
                
                
                ```
                #| column: screen
                fdb_.docsrc(0, "how does _funcs_kwargs work: _funcs_kwargs is a decorator; it helps class e.g., T to add more methods; \
                I need to give the method a name, \
                and put the name e.g., 'b' inside a list called _methods=['b'] inside class T; \
                then after writing a func e.g., _new_func, I can add it by T(b = _new_func); if I want the func added to class to use self, \
                I shall write @funcs_kwargs(as_method=True)")
                fdb_.docsrc(2, "how to define a method which can use self and accept any parameters")
                fdb_.docsrc(3, "how to pop out the value of an item in a dict (with None as default), and if the item name is not found, pop out None instead; ")
                fdb_.docsrc(6, "how to turn a func into a method")
                fdb_.docsrc(7, "how to give a method a different instance, like self")
                fdb_.docsrc(8, "how to add a method to a class as an attribute")
                fdb_.docsrc(10, "how to wrap `_init` around `old_init`, so that `_init` can use `old_init` inside itself")
                fdb_.docsrc(11, "how to add a list of names with None as default value to function `_init` to repalce its kwargs param")
                fdb_.docsrc(12, "how to make a class.`__init__` signature to be the signature of the class using `__signature__` and `_rm_self`")
                
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m0[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                    def _funcs_kwargs(cls, as_method):======================================================================================================================(0)
                    [91;1mhow does _funcs_kwargs work: _funcs_kwargs is a decorator; it helps class e.g., T to add more methods; I need to give the method a name, and put the name e.g., 'b' inside a list called _methods=['b'] inside class T; then after writing a func e.g., _new_func, I can add it by T(b = _new_func); if I want the func added to class to use self, I shall write @funcs_kwargs(as_method=True)[0m
                        old_init = cls.__init__                                                                                                                             (1)
                        def _init(self, *args, **kwargs):                                                                                                                   (2)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m2[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                    def _funcs_kwargs(cls, as_method):                                                                                                                      (0)
                        old_init = cls.__init__                                                                                                                             (1)
                        def _init(self, *args, **kwargs):===================================================================================================================(2)
                                                                                                              [91;1mhow to define a method which can use self and accept any parameters[0m
                            for k in cls._methods:                                                                                                                          (3)
                                arg = kwargs.pop(k,None)                                                                                                                    (4)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m3[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                        old_init = cls.__init__                                                                                                                             (1)
                        def _init(self, *args, **kwargs):                                                                                                                   (2)
                            for k in cls._methods:==========================================================================================================================(3)
                                                  [91;1mhow to pop out the value of an item in a dict (with None as default), and if the item name is not found, pop out None instead; [0m
                                arg = kwargs.pop(k,None)                                                                                                                    (4)
                                if arg is not None:                                                                                                                         (5)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m6[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                                arg = kwargs.pop(k,None)                                                                                                                    (4)
                                if arg is not None:                                                                                                                         (5)
                                    if as_method: arg = method(arg)=========================================================================================================(6)
                                                                                                                                                 [91;1mhow to turn a func into a method[0m
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)                                                                     (7)
                                    setattr(self, k, arg)                                                                                                                   (8)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m7[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                                if arg is not None:                                                                                                                         (5)
                                    if as_method: arg = method(arg)                                                                                                         (6)
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)=====================================================================(7)
                                                                                                                             [91;1mhow to give a method a different instance, like self[0m
                                    setattr(self, k, arg)                                                                                                                   (8)
                            old_init(self, *args, **kwargs)                                                                                                                 (9)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m8[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                                    if as_method: arg = method(arg)                                                                                                         (6)
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)                                                                     (7)
                                    setattr(self, k, arg)===================================================================================================================(8)
                                                                                                                                   [91;1mhow to add a method to a class as an attribute[0m
                            old_init(self, *args, **kwargs)                                                                                                                 (9)
                        functools.update_wrapper(_init, old_init)                                                                                                           (10)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m10[0m     ===============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                                    setattr(self, k, arg)                                                                                                                   (8)
                            old_init(self, *args, **kwargs)                                                                                                                 (9)
                        functools.update_wrapper(_init, old_init)===========================================================================================================(10)
                                                                                          [91;1mhow to wrap `_init` around `old_init`, so that `_init` can use `old_init` inside itself[0m
                        cls.__init__ = use_kwargs(cls._methods)(_init)                                                                                                      (11)
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))                                                     (12)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m11[0m     ===============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                            old_init(self, *args, **kwargs)                                                                                                                 (9)
                        functools.update_wrapper(_init, old_init)                                                                                                           (10)
                        cls.__init__ = use_kwargs(cls._methods)(_init)======================================================================================================(11)
                                                                            [91;1mhow to add a list of names with None as default value to function `_init` to repalce its kwargs param[0m
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))                                                     (12)
                        return cls                                                                                                                                          (13)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m12[0m     ===============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                        functools.update_wrapper(_init, old_init)                                                                                                           (10)
                        cls.__init__ = use_kwargs(cls._methods)(_init)                                                                                                      (11)
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))=====================================================(12)
                                                                   [91;1mhow to make a class.`__init__` signature to be the signature of the class using `__signature__` and `_rm_self`[0m
                        return cls                                                                                                                                          (13)
                                                                                                                                                                            (14)
                
                
                
                ```
                #| column: screen
                fdb.snoop() # how to snoop together with docsrc: snoop first and docsrc above it
                ```
                
                    22:28:59.99 >>> Call to funcs_kwargs in File "/tmp/funcs_kwargs.py", line 3
                    22:28:59.99 ...... as_method = <class 'fastcore.meta.T'>
                    22:28:59.99    3 | def funcs_kwargs(as_method=False):
                    22:28:59.99    5 |     if callable(as_method): return _funcs_kwargs(as_method, False)
                        22:28:59.99 >>> Call to _funcs_kwargs in File "/tmp/_funcs_kwargs.py", line 3
                        22:28:59.99 ...... cls = <class 'fastcore.meta.T'>
                        22:28:59.99 ...... as_method = False
                        22:28:59.99    3 | def _funcs_kwargs(cls, as_method):
                        22:28:59.99    4 |     old_init = cls.__init__
                        22:28:59.99 .......... old_init = <function T.__init__>
                        22:28:59.99    5 |     import snoop
                        22:28:59.99 .......... snoop = <class 'snoop.configuration.Config.__init__.<locals>.ConfiguredTracer'>
                        22:28:59.99    6 |     @snoop
                        22:28:59.99    7 |     def _init(self, *args, **kwargs):
                        22:28:59.99 .......... _init = <function _funcs_kwargs.<locals>._init>
                        22:28:59.99   15 |     functools.update_wrapper(_init, old_init)
                        22:28:59.99 .......... _init = <function T.__init__>
                        22:28:59.99   16 |     cls.__init__ = use_kwargs(cls._methods)(_init)
                        22:28:59.99   17 |     if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))
                        22:28:59.99   18 |     return cls
                        22:28:59.99 <<< Return value from _funcs_kwargs: <class 'fastcore.meta.T'>
                    22:28:59.99    5 |     if callable(as_method): return _funcs_kwargs(as_method, False)
                    22:28:59.99 <<< Return value from funcs_kwargs: <class 'fastcore.meta.T'>
                    22:28:59.99 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:28:59.99 .......... self = <fastcore.meta.T object>
                    22:28:59.99 .......... args = ()
                    22:28:59.99 .......... kwargs = {}
                    22:28:59.99 .......... as_method = False
                    22:28:59.99 .......... cls = <class 'fastcore.meta.T'>
                    22:28:59.99 .......... old_init = <function T.__init__>
                    22:28:59.99    7 |     def _init(self, *args, **kwargs):
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00 .............. k = 'b'
                    22:29:00.00    9 |             arg = kwargs.pop(k,None)
                    22:29:00.00 .................. arg = None
                    22:29:00.00   10 |             if arg is not None:
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00   14 |         old_init(self, *args, **kwargs)
                    22:29:00.00 <<< Return value from _funcs_kwargs.<locals>._init: None
                    22:29:00.00 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:29:00.00 .......... self = <fastcore.meta.T object>
                    22:29:00.00 .......... args = ()
                    22:29:00.00 .......... kwargs = {'b': <function _new_func>}
                    22:29:00.00 .......... len(kwargs) = 1
                    22:29:00.00 .......... as_method = False
                    22:29:00.00 .......... cls = <class 'fastcore.meta.T'>
                    22:29:00.00 .......... old_init = <function T.__init__>
                    22:29:00.00    7 |     def _init(self, *args, **kwargs):
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00 .............. k = 'b'
                    22:29:00.00    9 |             arg = kwargs.pop(k,None)
                    22:29:00.00 .................. kwargs = {}
                    22:29:00.00 .................. arg = <function _new_func>
                    22:29:00.00   10 |             if arg is not None:
                    22:29:00.00   11 |                 if as_method: arg = method(arg)
                    22:29:00.00   12 |                 if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)
                    22:29:00.00   13 |                 setattr(self, k, arg)
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00   14 |         old_init(self, *args, **kwargs)
                    22:29:00.00 <<< Return value from _funcs_kwargs.<locals>._init: None
                    22:29:00.00 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:29:00.00 .......... self = <fastcore.meta.T object>
                    22:29:00.00 .......... args = ()
                    22:29:00.00 .......... kwargs = {'a': <function <lambda>>}
                    22:29:00.00 .......... len(kwargs) = 1
                    22:29:00.00 .......... as_method = False
                    22:29:00.00 .......... cls = <class 'fastcore.meta.T'>
                    22:29:00.00 .......... old_init = <function T.__init__>
                    22:29:00.00    7 |     def _init(self, *args, **kwargs):
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00 .............. k = 'b'
                    22:29:00.00    9 |             arg = kwargs.pop(k,None)
                    22:29:00.00 .................. arg = None
                    22:29:00.00   10 |             if arg is not None:
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00   14 |         old_init(self, *args, **kwargs)
                    22:29:00.00 <<< Return value from _funcs_kwargs.<locals>._init: None
                    22:29:00.00 >>> Call to funcs_kwargs in File "/tmp/funcs_kwargs.py", line 3
                    22:29:00.00 ...... as_method = True
                    22:29:00.00    3 | def funcs_kwargs(as_method=False):
                    22:29:00.00    5 |     if callable(as_method): return _funcs_kwargs(as_method, False)
                    22:29:00.00    6 |     return partial(_funcs_kwargs, as_method=as_method)
                    22:29:00.00 <<< Return value from funcs_kwargs: functools.partial(<function _funcs_kwargs>, as_method=True)
                    22:29:00.00 >>> Call to _funcs_kwargs in File "/tmp/_funcs_kwargs.py", line 3
                    22:29:00.00 ...... cls = <class 'fastcore.meta.T'>
                    22:29:00.00 ...... as_method = True
                    22:29:00.00    3 | def _funcs_kwargs(cls, as_method):
                    22:29:00.00    4 |     old_init = cls.__init__
                    22:29:00.00 .......... old_init = <slot wrapper '__init__' of 'object' objects>
                    22:29:00.00    5 |     import snoop
                    22:29:00.00 .......... snoop = <class 'snoop.configuration.Config.__init__.<locals>.ConfiguredTracer'>
                    22:29:00.00    6 |     @snoop
                    22:29:00.00    7 |     def _init(self, *args, **kwargs):
                    22:29:00.00 .......... _init = <function _funcs_kwargs.<locals>._init>
                    22:29:00.00   15 |     functools.update_wrapper(_init, old_init)
                    22:29:00.00 .......... _init = <function object.__init__>
                    22:29:00.00   16 |     cls.__init__ = use_kwargs(cls._methods)(_init)
                    22:29:00.01   17 |     if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))
                    22:29:00.01   18 |     return cls
                    22:29:00.01 <<< Return value from _funcs_kwargs: <class 'fastcore.meta.T'>
                    22:29:00.01 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:29:00.01 .......... self = <fastcore.meta.T object>
                    22:29:00.01 .......... args = ()
                    22:29:00.01 .......... kwargs = {'b': <function _f>}
                    22:29:00.01 .......... len(kwargs) = 1
                    22:29:00.01 .......... as_method = True
                    22:29:00.01 .......... cls = <class 'fastcore.meta.T'>
                    22:29:00.01 .......... old_init = <slot wrapper '__init__' of 'object' objects>
                    22:29:00.01    7 |     def _init(self, *args, **kwargs):
                    22:29:00.01    8 |         for k in cls._methods:
                    22:29:00.01 .............. k = 'b'
                    22:29:00.01    9 |             arg = kwargs.pop(k,None)
                    22:29:00.01 .................. kwargs = {}
                    22:29:00.01 .................. arg = <function _f>
                    22:29:00.01   10 |             if arg is not None:
                    22:29:00.01   11 |                 if as_method: arg = method(arg)
                    22:29:00.01 ...... arg = <bound method int._f of 1>
                    22:29:00.01   12 |                 if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)
                    22:29:00.01 ...... arg = <bound method T._f of <fastcore.meta.T object>>
                    22:29:00.01   13 |                 setattr(self, k, arg)
                    22:29:00.01    8 |         for k in cls._methods:
                    22:29:00.01   14 |         old_init(self, *args, **kwargs)
                    22:29:00.01 <<< Return value from _funcs_kwargs.<locals>._init: None
                    22:29:00.01 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:29:00.01 .......... self = <fastcore.meta.T2 object>
                    22:29:00.01 .......... args = ()
                    22:29:00.01 .......... kwargs = {'b': <function _f>}
                    22:29:00.01 .......... len(kwargs) = 1
                    22:29:00.01 .......... as_method = True
                    22:29:00.01 .......... cls = <class 'fastcore.meta.T'>
                    22:29:00.01 .......... old_init = <slot wrapper '__init__' of 'object' objects>
                    22:29:00.01    7 |     def _init(self, *args, **kwargs):
                    22:29:00.01    8 |         for k in cls._methods:
                    22:29:00.01 .............. k = 'b'
                    22:29:00.01    9 |             arg = kwargs.pop(k,None)
                    22:29:00.01 .................. kwargs = {}
                    22:29:00.01 .................. arg = <function _f>
                    22:29:00.01   10 |             if arg is not None:
                    22:29:00.01   11 |                 if as_method: arg = method(arg)
                    22:29:00.01 ...... arg = <bound method int._f of 1>
                    22:29:00.01   12 |                 if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)
                    22:29:00.01 ...... arg = <bound method T2._f of <fastcore.meta.T2 object>>
                    22:29:00.01   13 |                 setattr(self, k, arg)
                    22:29:00.01    8 |         for k in cls._methods:
                    22:29:00.01   14 |         old_init(self, *args, **kwargs)
                    22:29:00.01 <<< Return value from _funcs_kwargs.<locals>._init: None
                
                
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                
                
                
                ```
                fdb_.debug()
                ```
                
                    _funcs_kwargs's dbsrc code: ==============
                    import snoop
                    @snoop
                    def _funcs_kwargs(cls, as_method):
                        old_init = cls.__init__
                        import snoop
                        @snoop
                        def _init(self, *args, **kwargs):
                            for k in cls._methods:
                                arg = kwargs.pop(k,None)
                                if arg is not None:
                                    if as_method: arg = method(arg)
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)
                                    setattr(self, k, arg)
                            old_init(self, *args, **kwargs)
                        functools.update_wrapper(_init, old_init)
                        cls.__init__ = use_kwargs(cls._methods)(_init)
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))
                        return cls
                    
                    
                    
                    _funcs_kwargs's example processed with dbsrc: ===============
                    
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    
                
                
                
                ```
                #| column: screen
                fdb.print()
                ```
                
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    def funcs_kwargs(as_method=False):========================================================(0)       
                        "Replace methods in `cls._methods` with those from `kwargs`"==========================(1) # [93;1mhow funcs_kwargs works[0m; [93;1mit is a wrapper around _funcs_kwargs[0m; [91;1mit offers two ways of running _funcs_kwargs[0m; [37;1mthe first, default way, is to add a func to a class without using self[0m; [91;1msecond way is to add func to class enabling self use;[0m; 
                        if callable(as_method): return _funcs_kwargs(as_method, False)========================(2) # [37;1mhow to check whether an object is callable[0m; [93;1mhow to return a result of running a func[0m; [37;1m[0m; 
                        return partial(_funcs_kwargs, as_method=as_method)====================================(3) # [92;1mhow to custom the params of `_funcs_kwargs` for a particular use with partial[0m; 
                                                                                                                                                                            (4)
                
                
                
                ```
                #| column: screen
                fdb_.print()
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m12[0m     ===============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    def _funcs_kwargs(cls, as_method):========================================================(0) # [93;1mhow does _funcs_kwargs work: _funcs_kwargs is a decorator[0m; [35;1mit helps class e.g., T to add more methods[0m; [93;1mI need to give the method a name, and put the name e.g., 'b' inside a list called _methods=['b'] inside class T[0m; [36;1mthen after writing a func e.g., _new_func, I can add it by T(b = _new_func)[0m; [36;1mif I want the func added to class to use self, I shall write @funcs_kwargs(as_method=True)[0m; 
                        old_init = cls.__init__===============================================================(1)       
                        def _init(self, *args, **kwargs):=====================================================(2) # [37;1mhow to define a method which can use self and accept any parameters[0m; 
                            for k in cls._methods:============================================================(3) # [35;1mhow to pop out the value of an item in a dict (with None as default), and if the item name is not found, pop out None instead[0m; [91;1m[0m; 
                                arg = kwargs.pop(k,None)======================================================(4)       
                                if arg is not None:===========================================================(5)       
                                    if as_method: arg = method(arg)===========================================(6) # [36;1mhow to turn a func into a method[0m; 
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)=======(7) # [93;1mhow to give a method a different instance, like self[0m; 
                                    setattr(self, k, arg)=====================================================(8) # [36;1mhow to add a method to a class as an attribute[0m; 
                            old_init(self, *args, **kwargs)===================================================(9)       
                        functools.update_wrapper(_init, old_init)=============================================(10) # [34;1mhow to wrap `_init` around `old_init`, so that `_init` can use `old_init` inside itself[0m; 
                        cls.__init__ = use_kwargs(cls._methods)(_init)========================================(11) # [34;1mhow to add a list of names with None as default value to function `_init` to repalce its kwargs param[0m; 
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__)) # [35;1mhow to make a class.`__init__` signature to be the signature of the class using `__signature__` and `_rm_self`[0m;  (12)
                        return cls============================================================================(13)      
                                                                                                                                                                            (14)
                
                
                
                ```
                
                ```
                
                
            
            
            
            [Open `0009_funcs_kwargs` in Jupyter Notebook](http://localhost:8888/tree/nbs/demos/0009_funcs_kwargs.ipynb)
            
            
            
        
        
        
        [Open `utils` in Jupyter Notebook](http://localhost:8888/tree/nbs/lib/utils.ipynb)
        
        
        
        
    
    
    
    [Open `utils` in Jupyter Notebook](http://localhost:8888/tree/nbs/lib/utils.ipynb)
    
    
    
    



[Open `utils` in Jupyter Notebook locally](http://localhost:8888/tree/nbs/lib/utils.ipynb)



###  <mark style="background-color: #ffff00">snoop:</mark>   <mark style="background-color: #ffff00">from</mark>   <mark style="background-color: #ffff00">_ <mark style="background-color: #FFFF00">funcs_kwargs</mark> </mark>   <mark style="background-color: #ffff00">to</mark>   <mark style="background-color: #FFFF00">funcs_kwargs</mark> 



    
    
    
        
        
        
            
            
            
                
                how to snoop on two functions one wrap around another: `funcs_kwargs` is a wrapper around `_funcs_kwargs`, so I can first snoop on `_funcs_kwargs` and assign its snoop dbsrc to \
                `fm._funcs_kwargs` so that when I snoop on `funcs_kwargs`, it can use the snoop dbsrc of `_funcs_kwargs` and no example codes need to change.
                
                
                ```
                from fastcore.meta import _funcs_kwargs
                ```
                
                
                ```
                fdb_ = Fastdb(_funcs_kwargs)
                fdb_.eg = """
                @funcs_kwargs
                class T:
                    _methods=['b'] # allows you to add method b upon instantiation
                    def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                    def a(self): return 1
                    def b(self): return 2
                    
                t = T()
                test_eq(t.a(), 1)
                test_eq(t.b(), 2)
                
                test_sig(T, '(f=1, *, b=None)')
                inspect.signature(T)
                
                def _new_func(): return 5
                
                t = T(b = _new_func)
                test_eq(t.b(), 5)
                
                t = T(a = lambda:3)
                test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                """
                ```
                
                
                ```
                #| column: screen
                # no snoop result, it is expected, because the example is not calling _funcs_kwargs, but funcs_kwargs
                fdb_.snoop(deco=True) # how to snoop decorator: _funcs_kwargs is a decorator, so set deco=True to see running codes in inner f
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    [0m     
                    
                
                
                
                ```
                import fastcore.meta as fm
                ```
                
                
                ```
                fm._funcs_kwargs = fdb_.dbsrc # how to snoop on two functions one wrap around another
                ```
                
                
                ```
                fdb = Fastdb(funcs_kwargs)
                fdb.eg = """
                @funcs_kwargs
                class T:
                    _methods=['b'] # allows you to add method b upon instantiation
                    def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                    def a(self): return 1
                    def b(self): return 2
                    
                t = T()
                test_eq(t.a(), 1)
                test_eq(t.b(), 2)
                
                test_sig(T, '(f=1, *, b=None)')
                inspect.signature(T)
                
                def _new_func(): return 5
                
                t = T(b = _new_func)
                test_eq(t.b(), 5)
                
                t = T(a = lambda:3)
                test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                
                def _f(self,a=1): return self.num + a # access the num attribute from the instance
                
                @funcs_kwargs(as_method=True)
                class T: 
                    _methods=['b']
                    num = 5
                    
                t = T(b = _f) # adds method b
                test_eq(t.b(5), 10) # self.num + 5 = 10
                
                def _f(self,a=1): return self.num * a #multiply instead of add 
                
                class T2(T):
                    def __init__(self,num):
                        super().__init__(b = _f) # add method b from the super class
                        self.num=num
                        
                t = T2(num=3)
                test_eq(t.b(a=5), 15) # 3 * 5 = 15
                test_sig(T2, '(num)')
                """
                ```
                
                
                ```
                #| column: screen
                fdb.print()
                ```
                
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    def funcs_kwargs(as_method=False):========================================================(0)       
                        "Replace methods in `cls._methods` with those from `kwargs`"==========================(1)       
                        if callable(as_method): return _funcs_kwargs(as_method, False)========================(2)       
                        return partial(_funcs_kwargs, as_method=as_method)====================================(3)       
                                                                                                                                                                            (4)
                
                
                
                ```
                #| column: screen
                fdb_.print()
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    def _funcs_kwargs(cls, as_method):========================================================(0)       
                        old_init = cls.__init__===============================================================(1)       
                        def _init(self, *args, **kwargs):=====================================================(2)       
                            for k in cls._methods:============================================================(3)       
                                arg = kwargs.pop(k,None)======================================================(4)       
                                if arg is not None:===========================================================(5)       
                                    if as_method: arg = method(arg)===========================================(6)       
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)=======(7)       
                                    setattr(self, k, arg)=====================================================(8)       
                            old_init(self, *args, **kwargs)===================================================(9)       
                        functools.update_wrapper(_init, old_init)=============================================(10)      
                        cls.__init__ = use_kwargs(cls._methods)(_init)========================================(11)      
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))                                                     (12)
                        return cls============================================================================(13)      
                                                                                                                                                                            (14)
                
                
                
                ```
                #| column: screen
                fdb.docsrc(1, "how funcs_kwargs works; it is a wrapper around _funcs_kwargs; it offers two ways of running _funcs_kwargs; \
                the first, default way, is to add a func to a class without using self; second way is to add func to class enabling self use;")
                fdb.docsrc(2, "how to check whether an object is callable; how to return a result of running a func; ")
                fdb.docsrc(3, "how to custom the params of `_funcs_kwargs` for a particular use with partial")
                ```
                
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m1[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                    def funcs_kwargs(as_method=False):                                                                                                                      (0)
                        "Replace methods in `cls._methods` with those from `kwargs`"========================================================================================(1)
                    [91;1mhow funcs_kwargs works; it is a wrapper around _funcs_kwargs; it offers two ways of running _funcs_kwargs; the first, default way, is to add a func to a class without using self; second way is to add func to class enabling self use;[0m
                        if callable(as_method): return _funcs_kwargs(as_method, False)                                                                                      (2)
                        return partial(_funcs_kwargs, as_method=as_method)                                                                                                  (3)
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m2[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                    def funcs_kwargs(as_method=False):                                                                                                                      (0)
                        "Replace methods in `cls._methods` with those from `kwargs`"                                                                                        (1)
                        if callable(as_method): return _funcs_kwargs(as_method, False)======================================================================================(2)
                                                                                           [91;1mhow to check whether an object is callable; how to return a result of running a func; [0m
                        return partial(_funcs_kwargs, as_method=as_method)                                                                                                  (3)
                                                                                                                                                                            (4)
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m3[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                        "Replace methods in `cls._methods` with those from `kwargs`"                                                                                        (1)
                        if callable(as_method): return _funcs_kwargs(as_method, False)                                                                                      (2)
                        return partial(_funcs_kwargs, as_method=as_method)==================================================================================================(3)
                                                                                                    [91;1mhow to custom the params of `_funcs_kwargs` for a particular use with partial[0m
                                                                                                                                                                            (4)
                
                
                
                ```
                #| column: screen
                fdb_.print()
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    def _funcs_kwargs(cls, as_method):========================================================(0)       
                        old_init = cls.__init__===============================================================(1)       
                        def _init(self, *args, **kwargs):=====================================================(2)       
                            for k in cls._methods:============================================================(3)       
                                arg = kwargs.pop(k,None)======================================================(4)       
                                if arg is not None:===========================================================(5)       
                                    if as_method: arg = method(arg)===========================================(6)       
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)=======(7)       
                                    setattr(self, k, arg)=====================================================(8)       
                            old_init(self, *args, **kwargs)===================================================(9)       
                        functools.update_wrapper(_init, old_init)=============================================(10)      
                        cls.__init__ = use_kwargs(cls._methods)(_init)========================================(11)      
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))                                                     (12)
                        return cls============================================================================(13)      
                                                                                                                                                                            (14)
                
                
                
                ```
                #| column: screen
                fdb_.docsrc(0, "how does _funcs_kwargs work: _funcs_kwargs is a decorator; it helps class e.g., T to add more methods; \
                I need to give the method a name, \
                and put the name e.g., 'b' inside a list called _methods=['b'] inside class T; \
                then after writing a func e.g., _new_func, I can add it by T(b = _new_func); if I want the func added to class to use self, \
                I shall write @funcs_kwargs(as_method=True)")
                fdb_.docsrc(2, "how to define a method which can use self and accept any parameters")
                fdb_.docsrc(3, "how to pop out the value of an item in a dict (with None as default), and if the item name is not found, pop out None instead; ")
                fdb_.docsrc(6, "how to turn a func into a method")
                fdb_.docsrc(7, "how to give a method a different instance, like self")
                fdb_.docsrc(8, "how to add a method to a class as an attribute")
                fdb_.docsrc(10, "how to wrap `_init` around `old_init`, so that `_init` can use `old_init` inside itself")
                fdb_.docsrc(11, "how to add a list of names with None as default value to function `_init` to repalce its kwargs param")
                fdb_.docsrc(12, "how to make a class.`__init__` signature to be the signature of the class using `__signature__` and `_rm_self`")
                
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m0[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                    def _funcs_kwargs(cls, as_method):======================================================================================================================(0)
                    [91;1mhow does _funcs_kwargs work: _funcs_kwargs is a decorator; it helps class e.g., T to add more methods; I need to give the method a name, and put the name e.g., 'b' inside a list called _methods=['b'] inside class T; then after writing a func e.g., _new_func, I can add it by T(b = _new_func); if I want the func added to class to use self, I shall write @funcs_kwargs(as_method=True)[0m
                        old_init = cls.__init__                                                                                                                             (1)
                        def _init(self, *args, **kwargs):                                                                                                                   (2)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m2[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                    def _funcs_kwargs(cls, as_method):                                                                                                                      (0)
                        old_init = cls.__init__                                                                                                                             (1)
                        def _init(self, *args, **kwargs):===================================================================================================================(2)
                                                                                                              [91;1mhow to define a method which can use self and accept any parameters[0m
                            for k in cls._methods:                                                                                                                          (3)
                                arg = kwargs.pop(k,None)                                                                                                                    (4)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m3[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                        old_init = cls.__init__                                                                                                                             (1)
                        def _init(self, *args, **kwargs):                                                                                                                   (2)
                            for k in cls._methods:==========================================================================================================================(3)
                                                  [91;1mhow to pop out the value of an item in a dict (with None as default), and if the item name is not found, pop out None instead; [0m
                                arg = kwargs.pop(k,None)                                                                                                                    (4)
                                if arg is not None:                                                                                                                         (5)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m6[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                                arg = kwargs.pop(k,None)                                                                                                                    (4)
                                if arg is not None:                                                                                                                         (5)
                                    if as_method: arg = method(arg)=========================================================================================================(6)
                                                                                                                                                 [91;1mhow to turn a func into a method[0m
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)                                                                     (7)
                                    setattr(self, k, arg)                                                                                                                   (8)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m7[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                                if arg is not None:                                                                                                                         (5)
                                    if as_method: arg = method(arg)                                                                                                         (6)
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)=====================================================================(7)
                                                                                                                             [91;1mhow to give a method a different instance, like self[0m
                                    setattr(self, k, arg)                                                                                                                   (8)
                            old_init(self, *args, **kwargs)                                                                                                                 (9)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m8[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                                    if as_method: arg = method(arg)                                                                                                         (6)
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)                                                                     (7)
                                    setattr(self, k, arg)===================================================================================================================(8)
                                                                                                                                   [91;1mhow to add a method to a class as an attribute[0m
                            old_init(self, *args, **kwargs)                                                                                                                 (9)
                        functools.update_wrapper(_init, old_init)                                                                                                           (10)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m10[0m     ===============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                                    setattr(self, k, arg)                                                                                                                   (8)
                            old_init(self, *args, **kwargs)                                                                                                                 (9)
                        functools.update_wrapper(_init, old_init)===========================================================================================================(10)
                                                                                          [91;1mhow to wrap `_init` around `old_init`, so that `_init` can use `old_init` inside itself[0m
                        cls.__init__ = use_kwargs(cls._methods)(_init)                                                                                                      (11)
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))                                                     (12)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m11[0m     ===============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                            old_init(self, *args, **kwargs)                                                                                                                 (9)
                        functools.update_wrapper(_init, old_init)                                                                                                           (10)
                        cls.__init__ = use_kwargs(cls._methods)(_init)======================================================================================================(11)
                                                                            [91;1mhow to add a list of names with None as default value to function `_init` to repalce its kwargs param[0m
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))                                                     (12)
                        return cls                                                                                                                                          (13)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m12[0m     ===============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                        functools.update_wrapper(_init, old_init)                                                                                                           (10)
                        cls.__init__ = use_kwargs(cls._methods)(_init)                                                                                                      (11)
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))=====================================================(12)
                                                                   [91;1mhow to make a class.`__init__` signature to be the signature of the class using `__signature__` and `_rm_self`[0m
                        return cls                                                                                                                                          (13)
                                                                                                                                                                            (14)
                
                
                
                ```
                #| column: screen
                fdb.snoop() # how to snoop together with docsrc: snoop first and docsrc above it
                ```
                
                    22:28:59.99 >>> Call to funcs_kwargs in File "/tmp/funcs_kwargs.py", line 3
                    22:28:59.99 ...... as_method = <class 'fastcore.meta.T'>
                    22:28:59.99    3 | def funcs_kwargs(as_method=False):
                    22:28:59.99    5 |     if callable(as_method): return _funcs_kwargs(as_method, False)
                        22:28:59.99 >>> Call to _funcs_kwargs in File "/tmp/_funcs_kwargs.py", line 3
                        22:28:59.99 ...... cls = <class 'fastcore.meta.T'>
                        22:28:59.99 ...... as_method = False
                        22:28:59.99    3 | def _funcs_kwargs(cls, as_method):
                        22:28:59.99    4 |     old_init = cls.__init__
                        22:28:59.99 .......... old_init = <function T.__init__>
                        22:28:59.99    5 |     import snoop
                        22:28:59.99 .......... snoop = <class 'snoop.configuration.Config.__init__.<locals>.ConfiguredTracer'>
                        22:28:59.99    6 |     @snoop
                        22:28:59.99    7 |     def _init(self, *args, **kwargs):
                        22:28:59.99 .......... _init = <function _funcs_kwargs.<locals>._init>
                        22:28:59.99   15 |     functools.update_wrapper(_init, old_init)
                        22:28:59.99 .......... _init = <function T.__init__>
                        22:28:59.99   16 |     cls.__init__ = use_kwargs(cls._methods)(_init)
                        22:28:59.99   17 |     if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))
                        22:28:59.99   18 |     return cls
                        22:28:59.99 <<< Return value from _funcs_kwargs: <class 'fastcore.meta.T'>
                    22:28:59.99    5 |     if callable(as_method): return _funcs_kwargs(as_method, False)
                    22:28:59.99 <<< Return value from funcs_kwargs: <class 'fastcore.meta.T'>
                    22:28:59.99 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:28:59.99 .......... self = <fastcore.meta.T object>
                    22:28:59.99 .......... args = ()
                    22:28:59.99 .......... kwargs = {}
                    22:28:59.99 .......... as_method = False
                    22:28:59.99 .......... cls = <class 'fastcore.meta.T'>
                    22:28:59.99 .......... old_init = <function T.__init__>
                    22:28:59.99    7 |     def _init(self, *args, **kwargs):
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00 .............. k = 'b'
                    22:29:00.00    9 |             arg = kwargs.pop(k,None)
                    22:29:00.00 .................. arg = None
                    22:29:00.00   10 |             if arg is not None:
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00   14 |         old_init(self, *args, **kwargs)
                    22:29:00.00 <<< Return value from _funcs_kwargs.<locals>._init: None
                    22:29:00.00 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:29:00.00 .......... self = <fastcore.meta.T object>
                    22:29:00.00 .......... args = ()
                    22:29:00.00 .......... kwargs = {'b': <function _new_func>}
                    22:29:00.00 .......... len(kwargs) = 1
                    22:29:00.00 .......... as_method = False
                    22:29:00.00 .......... cls = <class 'fastcore.meta.T'>
                    22:29:00.00 .......... old_init = <function T.__init__>
                    22:29:00.00    7 |     def _init(self, *args, **kwargs):
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00 .............. k = 'b'
                    22:29:00.00    9 |             arg = kwargs.pop(k,None)
                    22:29:00.00 .................. kwargs = {}
                    22:29:00.00 .................. arg = <function _new_func>
                    22:29:00.00   10 |             if arg is not None:
                    22:29:00.00   11 |                 if as_method: arg = method(arg)
                    22:29:00.00   12 |                 if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)
                    22:29:00.00   13 |                 setattr(self, k, arg)
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00   14 |         old_init(self, *args, **kwargs)
                    22:29:00.00 <<< Return value from _funcs_kwargs.<locals>._init: None
                    22:29:00.00 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:29:00.00 .......... self = <fastcore.meta.T object>
                    22:29:00.00 .......... args = ()
                    22:29:00.00 .......... kwargs = {'a': <function <lambda>>}
                    22:29:00.00 .......... len(kwargs) = 1
                    22:29:00.00 .......... as_method = False
                    22:29:00.00 .......... cls = <class 'fastcore.meta.T'>
                    22:29:00.00 .......... old_init = <function T.__init__>
                    22:29:00.00    7 |     def _init(self, *args, **kwargs):
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00 .............. k = 'b'
                    22:29:00.00    9 |             arg = kwargs.pop(k,None)
                    22:29:00.00 .................. arg = None
                    22:29:00.00   10 |             if arg is not None:
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00   14 |         old_init(self, *args, **kwargs)
                    22:29:00.00 <<< Return value from _funcs_kwargs.<locals>._init: None
                    22:29:00.00 >>> Call to funcs_kwargs in File "/tmp/funcs_kwargs.py", line 3
                    22:29:00.00 ...... as_method = True
                    22:29:00.00    3 | def funcs_kwargs(as_method=False):
                    22:29:00.00    5 |     if callable(as_method): return _funcs_kwargs(as_method, False)
                    22:29:00.00    6 |     return partial(_funcs_kwargs, as_method=as_method)
                    22:29:00.00 <<< Return value from funcs_kwargs: functools.partial(<function _funcs_kwargs>, as_method=True)
                    22:29:00.00 >>> Call to _funcs_kwargs in File "/tmp/_funcs_kwargs.py", line 3
                    22:29:00.00 ...... cls = <class 'fastcore.meta.T'>
                    22:29:00.00 ...... as_method = True
                    22:29:00.00    3 | def _funcs_kwargs(cls, as_method):
                    22:29:00.00    4 |     old_init = cls.__init__
                    22:29:00.00 .......... old_init = <slot wrapper '__init__' of 'object' objects>
                    22:29:00.00    5 |     import snoop
                    22:29:00.00 .......... snoop = <class 'snoop.configuration.Config.__init__.<locals>.ConfiguredTracer'>
                    22:29:00.00    6 |     @snoop
                    22:29:00.00    7 |     def _init(self, *args, **kwargs):
                    22:29:00.00 .......... _init = <function _funcs_kwargs.<locals>._init>
                    22:29:00.00   15 |     functools.update_wrapper(_init, old_init)
                    22:29:00.00 .......... _init = <function object.__init__>
                    22:29:00.00   16 |     cls.__init__ = use_kwargs(cls._methods)(_init)
                    22:29:00.01   17 |     if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))
                    22:29:00.01   18 |     return cls
                    22:29:00.01 <<< Return value from _funcs_kwargs: <class 'fastcore.meta.T'>
                    22:29:00.01 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:29:00.01 .......... self = <fastcore.meta.T object>
                    22:29:00.01 .......... args = ()
                    22:29:00.01 .......... kwargs = {'b': <function _f>}
                    22:29:00.01 .......... len(kwargs) = 1
                    22:29:00.01 .......... as_method = True
                    22:29:00.01 .......... cls = <class 'fastcore.meta.T'>
                    22:29:00.01 .......... old_init = <slot wrapper '__init__' of 'object' objects>
                    22:29:00.01    7 |     def _init(self, *args, **kwargs):
                    22:29:00.01    8 |         for k in cls._methods:
                    22:29:00.01 .............. k = 'b'
                    22:29:00.01    9 |             arg = kwargs.pop(k,None)
                    22:29:00.01 .................. kwargs = {}
                    22:29:00.01 .................. arg = <function _f>
                    22:29:00.01   10 |             if arg is not None:
                    22:29:00.01   11 |                 if as_method: arg = method(arg)
                    22:29:00.01 ...... arg = <bound method int._f of 1>
                    22:29:00.01   12 |                 if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)
                    22:29:00.01 ...... arg = <bound method T._f of <fastcore.meta.T object>>
                    22:29:00.01   13 |                 setattr(self, k, arg)
                    22:29:00.01    8 |         for k in cls._methods:
                    22:29:00.01   14 |         old_init(self, *args, **kwargs)
                    22:29:00.01 <<< Return value from _funcs_kwargs.<locals>._init: None
                    22:29:00.01 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:29:00.01 .......... self = <fastcore.meta.T2 object>
                    22:29:00.01 .......... args = ()
                    22:29:00.01 .......... kwargs = {'b': <function _f>}
                    22:29:00.01 .......... len(kwargs) = 1
                    22:29:00.01 .......... as_method = True
                    22:29:00.01 .......... cls = <class 'fastcore.meta.T'>
                    22:29:00.01 .......... old_init = <slot wrapper '__init__' of 'object' objects>
                    22:29:00.01    7 |     def _init(self, *args, **kwargs):
                    22:29:00.01    8 |         for k in cls._methods:
                    22:29:00.01 .............. k = 'b'
                    22:29:00.01    9 |             arg = kwargs.pop(k,None)
                    22:29:00.01 .................. kwargs = {}
                    22:29:00.01 .................. arg = <function _f>
                    22:29:00.01   10 |             if arg is not None:
                    22:29:00.01   11 |                 if as_method: arg = method(arg)
                    22:29:00.01 ...... arg = <bound method int._f of 1>
                    22:29:00.01   12 |                 if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)
                    22:29:00.01 ...... arg = <bound method T2._f of <fastcore.meta.T2 object>>
                    22:29:00.01   13 |                 setattr(self, k, arg)
                    22:29:00.01    8 |         for k in cls._methods:
                    22:29:00.01   14 |         old_init(self, *args, **kwargs)
                    22:29:00.01 <<< Return value from _funcs_kwargs.<locals>._init: None
                
                
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                
                
                
                ```
                fdb_.debug()
                ```
                
                    _funcs_kwargs's dbsrc code: ==============
                    import snoop
                    @snoop
                    def _funcs_kwargs(cls, as_method):
                        old_init = cls.__init__
                        import snoop
                        @snoop
                        def _init(self, *args, **kwargs):
                            for k in cls._methods:
                                arg = kwargs.pop(k,None)
                                if arg is not None:
                                    if as_method: arg = method(arg)
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)
                                    setattr(self, k, arg)
                            old_init(self, *args, **kwargs)
                        functools.update_wrapper(_init, old_init)
                        cls.__init__ = use_kwargs(cls._methods)(_init)
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))
                        return cls
                    
                    
                    
                    _funcs_kwargs's example processed with dbsrc: ===============
                    
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    
                
                
                
                ```
                #| column: screen
                fdb.print()
                ```
                
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    def funcs_kwargs(as_method=False):========================================================(0)       
                        "Replace methods in `cls._methods` with those from `kwargs`"==========================(1) # [93;1mhow funcs_kwargs works[0m; [93;1mit is a wrapper around _funcs_kwargs[0m; [91;1mit offers two ways of running _funcs_kwargs[0m; [37;1mthe first, default way, is to add a func to a class without using self[0m; [91;1msecond way is to add func to class enabling self use;[0m; 
                        if callable(as_method): return _funcs_kwargs(as_method, False)========================(2) # [37;1mhow to check whether an object is callable[0m; [93;1mhow to return a result of running a func[0m; [37;1m[0m; 
                        return partial(_funcs_kwargs, as_method=as_method)====================================(3) # [92;1mhow to custom the params of `_funcs_kwargs` for a particular use with partial[0m; 
                                                                                                                                                                            (4)
                
                
                
                ```
                #| column: screen
                fdb_.print()
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m12[0m     ===============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    def _funcs_kwargs(cls, as_method):========================================================(0) # [93;1mhow does _funcs_kwargs work: _funcs_kwargs is a decorator[0m; [35;1mit helps class e.g., T to add more methods[0m; [93;1mI need to give the method a name, and put the name e.g., 'b' inside a list called _methods=['b'] inside class T[0m; [36;1mthen after writing a func e.g., _new_func, I can add it by T(b = _new_func)[0m; [36;1mif I want the func added to class to use self, I shall write @funcs_kwargs(as_method=True)[0m; 
                        old_init = cls.__init__===============================================================(1)       
                        def _init(self, *args, **kwargs):=====================================================(2) # [37;1mhow to define a method which can use self and accept any parameters[0m; 
                            for k in cls._methods:============================================================(3) # [35;1mhow to pop out the value of an item in a dict (with None as default), and if the item name is not found, pop out None instead[0m; [91;1m[0m; 
                                arg = kwargs.pop(k,None)======================================================(4)       
                                if arg is not None:===========================================================(5)       
                                    if as_method: arg = method(arg)===========================================(6) # [36;1mhow to turn a func into a method[0m; 
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)=======(7) # [93;1mhow to give a method a different instance, like self[0m; 
                                    setattr(self, k, arg)=====================================================(8) # [36;1mhow to add a method to a class as an attribute[0m; 
                            old_init(self, *args, **kwargs)===================================================(9)       
                        functools.update_wrapper(_init, old_init)=============================================(10) # [34;1mhow to wrap `_init` around `old_init`, so that `_init` can use `old_init` inside itself[0m; 
                        cls.__init__ = use_kwargs(cls._methods)(_init)========================================(11) # [34;1mhow to add a list of names with None as default value to function `_init` to repalce its kwargs param[0m; 
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__)) # [35;1mhow to make a class.`__init__` signature to be the signature of the class using `__signature__` and `_rm_self`[0m;  (12)
                        return cls============================================================================(13)      
                                                                                                                                                                            (14)
                
                
                
                ```
                
                ```
                
                
            
            
            
            [Open `0009_funcs_kwargs` in Jupyter Notebook](http://localhost:8888/tree/nbs/demos/0009_funcs_kwargs.ipynb)
            
            
            
        
        
        
        [Open `utils` in Jupyter Notebook](http://localhost:8888/tree/nbs/lib/utils.ipynb)
        
        
        
        
    
    
    
    [Open `utils` in Jupyter Notebook](http://localhost:8888/tree/nbs/lib/utils.ipynb)
    
    
    
    



[Open `utils` in Jupyter Notebook locally](http://localhost:8888/tree/nbs/lib/utils.ipynb)



###  <mark style="background-color: #ffff00">snoop:</mark>   <mark style="background-color: #ffff00">from</mark>   <mark style="background-color: #ffff00">_ <mark style="background-color: #FFFF00">funcs_kwargs</mark> </mark>   <mark style="background-color: #ffff00">to</mark>   <mark style="background-color: #FFFF00">funcs_kwargs</mark> 



    
    
    
        
        
        
            
            
            
                
                how to snoop on two functions one wrap around another: `funcs_kwargs` is a wrapper around `_funcs_kwargs`, so I can first snoop on `_funcs_kwargs` and assign its snoop dbsrc to \
                `fm._funcs_kwargs` so that when I snoop on `funcs_kwargs`, it can use the snoop dbsrc of `_funcs_kwargs` and no example codes need to change.
                
                
                ```
                from fastcore.meta import _funcs_kwargs
                ```
                
                
                ```
                fdb_ = Fastdb(_funcs_kwargs)
                fdb_.eg = """
                @funcs_kwargs
                class T:
                    _methods=['b'] # allows you to add method b upon instantiation
                    def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                    def a(self): return 1
                    def b(self): return 2
                    
                t = T()
                test_eq(t.a(), 1)
                test_eq(t.b(), 2)
                
                test_sig(T, '(f=1, *, b=None)')
                inspect.signature(T)
                
                def _new_func(): return 5
                
                t = T(b = _new_func)
                test_eq(t.b(), 5)
                
                t = T(a = lambda:3)
                test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                """
                ```
                
                
                ```
                #| column: screen
                # no snoop result, it is expected, because the example is not calling _funcs_kwargs, but funcs_kwargs
                fdb_.snoop(deco=True) # how to snoop decorator: _funcs_kwargs is a decorator, so set deco=True to see running codes in inner f
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    [0m     
                    
                
                
                
                ```
                import fastcore.meta as fm
                ```
                
                
                ```
                fm._funcs_kwargs = fdb_.dbsrc # how to snoop on two functions one wrap around another
                ```
                
                
                ```
                fdb = Fastdb(funcs_kwargs)
                fdb.eg = """
                @funcs_kwargs
                class T:
                    _methods=['b'] # allows you to add method b upon instantiation
                    def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                    def a(self): return 1
                    def b(self): return 2
                    
                t = T()
                test_eq(t.a(), 1)
                test_eq(t.b(), 2)
                
                test_sig(T, '(f=1, *, b=None)')
                inspect.signature(T)
                
                def _new_func(): return 5
                
                t = T(b = _new_func)
                test_eq(t.b(), 5)
                
                t = T(a = lambda:3)
                test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                
                def _f(self,a=1): return self.num + a # access the num attribute from the instance
                
                @funcs_kwargs(as_method=True)
                class T: 
                    _methods=['b']
                    num = 5
                    
                t = T(b = _f) # adds method b
                test_eq(t.b(5), 10) # self.num + 5 = 10
                
                def _f(self,a=1): return self.num * a #multiply instead of add 
                
                class T2(T):
                    def __init__(self,num):
                        super().__init__(b = _f) # add method b from the super class
                        self.num=num
                        
                t = T2(num=3)
                test_eq(t.b(a=5), 15) # 3 * 5 = 15
                test_sig(T2, '(num)')
                """
                ```
                
                
                ```
                #| column: screen
                fdb.print()
                ```
                
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    def funcs_kwargs(as_method=False):========================================================(0)       
                        "Replace methods in `cls._methods` with those from `kwargs`"==========================(1)       
                        if callable(as_method): return _funcs_kwargs(as_method, False)========================(2)       
                        return partial(_funcs_kwargs, as_method=as_method)====================================(3)       
                                                                                                                                                                            (4)
                
                
                
                ```
                #| column: screen
                fdb_.print()
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    def _funcs_kwargs(cls, as_method):========================================================(0)       
                        old_init = cls.__init__===============================================================(1)       
                        def _init(self, *args, **kwargs):=====================================================(2)       
                            for k in cls._methods:============================================================(3)       
                                arg = kwargs.pop(k,None)======================================================(4)       
                                if arg is not None:===========================================================(5)       
                                    if as_method: arg = method(arg)===========================================(6)       
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)=======(7)       
                                    setattr(self, k, arg)=====================================================(8)       
                            old_init(self, *args, **kwargs)===================================================(9)       
                        functools.update_wrapper(_init, old_init)=============================================(10)      
                        cls.__init__ = use_kwargs(cls._methods)(_init)========================================(11)      
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))                                                     (12)
                        return cls============================================================================(13)      
                                                                                                                                                                            (14)
                
                
                
                ```
                #| column: screen
                fdb.docsrc(1, "how funcs_kwargs works; it is a wrapper around _funcs_kwargs; it offers two ways of running _funcs_kwargs; \
                the first, default way, is to add a func to a class without using self; second way is to add func to class enabling self use;")
                fdb.docsrc(2, "how to check whether an object is callable; how to return a result of running a func; ")
                fdb.docsrc(3, "how to custom the params of `_funcs_kwargs` for a particular use with partial")
                ```
                
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m1[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                    def funcs_kwargs(as_method=False):                                                                                                                      (0)
                        "Replace methods in `cls._methods` with those from `kwargs`"========================================================================================(1)
                    [91;1mhow funcs_kwargs works; it is a wrapper around _funcs_kwargs; it offers two ways of running _funcs_kwargs; the first, default way, is to add a func to a class without using self; second way is to add func to class enabling self use;[0m
                        if callable(as_method): return _funcs_kwargs(as_method, False)                                                                                      (2)
                        return partial(_funcs_kwargs, as_method=as_method)                                                                                                  (3)
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m2[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                    def funcs_kwargs(as_method=False):                                                                                                                      (0)
                        "Replace methods in `cls._methods` with those from `kwargs`"                                                                                        (1)
                        if callable(as_method): return _funcs_kwargs(as_method, False)======================================================================================(2)
                                                                                           [91;1mhow to check whether an object is callable; how to return a result of running a func; [0m
                        return partial(_funcs_kwargs, as_method=as_method)                                                                                                  (3)
                                                                                                                                                                            (4)
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m3[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                        "Replace methods in `cls._methods` with those from `kwargs`"                                                                                        (1)
                        if callable(as_method): return _funcs_kwargs(as_method, False)                                                                                      (2)
                        return partial(_funcs_kwargs, as_method=as_method)==================================================================================================(3)
                                                                                                    [91;1mhow to custom the params of `_funcs_kwargs` for a particular use with partial[0m
                                                                                                                                                                            (4)
                
                
                
                ```
                #| column: screen
                fdb_.print()
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    def _funcs_kwargs(cls, as_method):========================================================(0)       
                        old_init = cls.__init__===============================================================(1)       
                        def _init(self, *args, **kwargs):=====================================================(2)       
                            for k in cls._methods:============================================================(3)       
                                arg = kwargs.pop(k,None)======================================================(4)       
                                if arg is not None:===========================================================(5)       
                                    if as_method: arg = method(arg)===========================================(6)       
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)=======(7)       
                                    setattr(self, k, arg)=====================================================(8)       
                            old_init(self, *args, **kwargs)===================================================(9)       
                        functools.update_wrapper(_init, old_init)=============================================(10)      
                        cls.__init__ = use_kwargs(cls._methods)(_init)========================================(11)      
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))                                                     (12)
                        return cls============================================================================(13)      
                                                                                                                                                                            (14)
                
                
                
                ```
                #| column: screen
                fdb_.docsrc(0, "how does _funcs_kwargs work: _funcs_kwargs is a decorator; it helps class e.g., T to add more methods; \
                I need to give the method a name, \
                and put the name e.g., 'b' inside a list called _methods=['b'] inside class T; \
                then after writing a func e.g., _new_func, I can add it by T(b = _new_func); if I want the func added to class to use self, \
                I shall write @funcs_kwargs(as_method=True)")
                fdb_.docsrc(2, "how to define a method which can use self and accept any parameters")
                fdb_.docsrc(3, "how to pop out the value of an item in a dict (with None as default), and if the item name is not found, pop out None instead; ")
                fdb_.docsrc(6, "how to turn a func into a method")
                fdb_.docsrc(7, "how to give a method a different instance, like self")
                fdb_.docsrc(8, "how to add a method to a class as an attribute")
                fdb_.docsrc(10, "how to wrap `_init` around `old_init`, so that `_init` can use `old_init` inside itself")
                fdb_.docsrc(11, "how to add a list of names with None as default value to function `_init` to repalce its kwargs param")
                fdb_.docsrc(12, "how to make a class.`__init__` signature to be the signature of the class using `__signature__` and `_rm_self`")
                
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m0[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                    def _funcs_kwargs(cls, as_method):======================================================================================================================(0)
                    [91;1mhow does _funcs_kwargs work: _funcs_kwargs is a decorator; it helps class e.g., T to add more methods; I need to give the method a name, and put the name e.g., 'b' inside a list called _methods=['b'] inside class T; then after writing a func e.g., _new_func, I can add it by T(b = _new_func); if I want the func added to class to use self, I shall write @funcs_kwargs(as_method=True)[0m
                        old_init = cls.__init__                                                                                                                             (1)
                        def _init(self, *args, **kwargs):                                                                                                                   (2)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m2[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                    def _funcs_kwargs(cls, as_method):                                                                                                                      (0)
                        old_init = cls.__init__                                                                                                                             (1)
                        def _init(self, *args, **kwargs):===================================================================================================================(2)
                                                                                                              [91;1mhow to define a method which can use self and accept any parameters[0m
                            for k in cls._methods:                                                                                                                          (3)
                                arg = kwargs.pop(k,None)                                                                                                                    (4)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m3[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                        old_init = cls.__init__                                                                                                                             (1)
                        def _init(self, *args, **kwargs):                                                                                                                   (2)
                            for k in cls._methods:==========================================================================================================================(3)
                                                  [91;1mhow to pop out the value of an item in a dict (with None as default), and if the item name is not found, pop out None instead; [0m
                                arg = kwargs.pop(k,None)                                                                                                                    (4)
                                if arg is not None:                                                                                                                         (5)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m6[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                                arg = kwargs.pop(k,None)                                                                                                                    (4)
                                if arg is not None:                                                                                                                         (5)
                                    if as_method: arg = method(arg)=========================================================================================================(6)
                                                                                                                                                 [91;1mhow to turn a func into a method[0m
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)                                                                     (7)
                                    setattr(self, k, arg)                                                                                                                   (8)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m7[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                                if arg is not None:                                                                                                                         (5)
                                    if as_method: arg = method(arg)                                                                                                         (6)
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)=====================================================================(7)
                                                                                                                             [91;1mhow to give a method a different instance, like self[0m
                                    setattr(self, k, arg)                                                                                                                   (8)
                            old_init(self, *args, **kwargs)                                                                                                                 (9)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m8[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                                    if as_method: arg = method(arg)                                                                                                         (6)
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)                                                                     (7)
                                    setattr(self, k, arg)===================================================================================================================(8)
                                                                                                                                   [91;1mhow to add a method to a class as an attribute[0m
                            old_init(self, *args, **kwargs)                                                                                                                 (9)
                        functools.update_wrapper(_init, old_init)                                                                                                           (10)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m10[0m     ===============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                                    setattr(self, k, arg)                                                                                                                   (8)
                            old_init(self, *args, **kwargs)                                                                                                                 (9)
                        functools.update_wrapper(_init, old_init)===========================================================================================================(10)
                                                                                          [91;1mhow to wrap `_init` around `old_init`, so that `_init` can use `old_init` inside itself[0m
                        cls.__init__ = use_kwargs(cls._methods)(_init)                                                                                                      (11)
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))                                                     (12)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m11[0m     ===============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                            old_init(self, *args, **kwargs)                                                                                                                 (9)
                        functools.update_wrapper(_init, old_init)                                                                                                           (10)
                        cls.__init__ = use_kwargs(cls._methods)(_init)======================================================================================================(11)
                                                                            [91;1mhow to add a list of names with None as default value to function `_init` to repalce its kwargs param[0m
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))                                                     (12)
                        return cls                                                                                                                                          (13)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m12[0m     ===============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                        functools.update_wrapper(_init, old_init)                                                                                                           (10)
                        cls.__init__ = use_kwargs(cls._methods)(_init)                                                                                                      (11)
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))=====================================================(12)
                                                                   [91;1mhow to make a class.`__init__` signature to be the signature of the class using `__signature__` and `_rm_self`[0m
                        return cls                                                                                                                                          (13)
                                                                                                                                                                            (14)
                
                
                
                ```
                #| column: screen
                fdb.snoop() # how to snoop together with docsrc: snoop first and docsrc above it
                ```
                
                    22:28:59.99 >>> Call to funcs_kwargs in File "/tmp/funcs_kwargs.py", line 3
                    22:28:59.99 ...... as_method = <class 'fastcore.meta.T'>
                    22:28:59.99    3 | def funcs_kwargs(as_method=False):
                    22:28:59.99    5 |     if callable(as_method): return _funcs_kwargs(as_method, False)
                        22:28:59.99 >>> Call to _funcs_kwargs in File "/tmp/_funcs_kwargs.py", line 3
                        22:28:59.99 ...... cls = <class 'fastcore.meta.T'>
                        22:28:59.99 ...... as_method = False
                        22:28:59.99    3 | def _funcs_kwargs(cls, as_method):
                        22:28:59.99    4 |     old_init = cls.__init__
                        22:28:59.99 .......... old_init = <function T.__init__>
                        22:28:59.99    5 |     import snoop
                        22:28:59.99 .......... snoop = <class 'snoop.configuration.Config.__init__.<locals>.ConfiguredTracer'>
                        22:28:59.99    6 |     @snoop
                        22:28:59.99    7 |     def _init(self, *args, **kwargs):
                        22:28:59.99 .......... _init = <function _funcs_kwargs.<locals>._init>
                        22:28:59.99   15 |     functools.update_wrapper(_init, old_init)
                        22:28:59.99 .......... _init = <function T.__init__>
                        22:28:59.99   16 |     cls.__init__ = use_kwargs(cls._methods)(_init)
                        22:28:59.99   17 |     if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))
                        22:28:59.99   18 |     return cls
                        22:28:59.99 <<< Return value from _funcs_kwargs: <class 'fastcore.meta.T'>
                    22:28:59.99    5 |     if callable(as_method): return _funcs_kwargs(as_method, False)
                    22:28:59.99 <<< Return value from funcs_kwargs: <class 'fastcore.meta.T'>
                    22:28:59.99 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:28:59.99 .......... self = <fastcore.meta.T object>
                    22:28:59.99 .......... args = ()
                    22:28:59.99 .......... kwargs = {}
                    22:28:59.99 .......... as_method = False
                    22:28:59.99 .......... cls = <class 'fastcore.meta.T'>
                    22:28:59.99 .......... old_init = <function T.__init__>
                    22:28:59.99    7 |     def _init(self, *args, **kwargs):
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00 .............. k = 'b'
                    22:29:00.00    9 |             arg = kwargs.pop(k,None)
                    22:29:00.00 .................. arg = None
                    22:29:00.00   10 |             if arg is not None:
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00   14 |         old_init(self, *args, **kwargs)
                    22:29:00.00 <<< Return value from _funcs_kwargs.<locals>._init: None
                    22:29:00.00 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:29:00.00 .......... self = <fastcore.meta.T object>
                    22:29:00.00 .......... args = ()
                    22:29:00.00 .......... kwargs = {'b': <function _new_func>}
                    22:29:00.00 .......... len(kwargs) = 1
                    22:29:00.00 .......... as_method = False
                    22:29:00.00 .......... cls = <class 'fastcore.meta.T'>
                    22:29:00.00 .......... old_init = <function T.__init__>
                    22:29:00.00    7 |     def _init(self, *args, **kwargs):
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00 .............. k = 'b'
                    22:29:00.00    9 |             arg = kwargs.pop(k,None)
                    22:29:00.00 .................. kwargs = {}
                    22:29:00.00 .................. arg = <function _new_func>
                    22:29:00.00   10 |             if arg is not None:
                    22:29:00.00   11 |                 if as_method: arg = method(arg)
                    22:29:00.00   12 |                 if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)
                    22:29:00.00   13 |                 setattr(self, k, arg)
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00   14 |         old_init(self, *args, **kwargs)
                    22:29:00.00 <<< Return value from _funcs_kwargs.<locals>._init: None
                    22:29:00.00 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:29:00.00 .......... self = <fastcore.meta.T object>
                    22:29:00.00 .......... args = ()
                    22:29:00.00 .......... kwargs = {'a': <function <lambda>>}
                    22:29:00.00 .......... len(kwargs) = 1
                    22:29:00.00 .......... as_method = False
                    22:29:00.00 .......... cls = <class 'fastcore.meta.T'>
                    22:29:00.00 .......... old_init = <function T.__init__>
                    22:29:00.00    7 |     def _init(self, *args, **kwargs):
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00 .............. k = 'b'
                    22:29:00.00    9 |             arg = kwargs.pop(k,None)
                    22:29:00.00 .................. arg = None
                    22:29:00.00   10 |             if arg is not None:
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00   14 |         old_init(self, *args, **kwargs)
                    22:29:00.00 <<< Return value from _funcs_kwargs.<locals>._init: None
                    22:29:00.00 >>> Call to funcs_kwargs in File "/tmp/funcs_kwargs.py", line 3
                    22:29:00.00 ...... as_method = True
                    22:29:00.00    3 | def funcs_kwargs(as_method=False):
                    22:29:00.00    5 |     if callable(as_method): return _funcs_kwargs(as_method, False)
                    22:29:00.00    6 |     return partial(_funcs_kwargs, as_method=as_method)
                    22:29:00.00 <<< Return value from funcs_kwargs: functools.partial(<function _funcs_kwargs>, as_method=True)
                    22:29:00.00 >>> Call to _funcs_kwargs in File "/tmp/_funcs_kwargs.py", line 3
                    22:29:00.00 ...... cls = <class 'fastcore.meta.T'>
                    22:29:00.00 ...... as_method = True
                    22:29:00.00    3 | def _funcs_kwargs(cls, as_method):
                    22:29:00.00    4 |     old_init = cls.__init__
                    22:29:00.00 .......... old_init = <slot wrapper '__init__' of 'object' objects>
                    22:29:00.00    5 |     import snoop
                    22:29:00.00 .......... snoop = <class 'snoop.configuration.Config.__init__.<locals>.ConfiguredTracer'>
                    22:29:00.00    6 |     @snoop
                    22:29:00.00    7 |     def _init(self, *args, **kwargs):
                    22:29:00.00 .......... _init = <function _funcs_kwargs.<locals>._init>
                    22:29:00.00   15 |     functools.update_wrapper(_init, old_init)
                    22:29:00.00 .......... _init = <function object.__init__>
                    22:29:00.00   16 |     cls.__init__ = use_kwargs(cls._methods)(_init)
                    22:29:00.01   17 |     if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))
                    22:29:00.01   18 |     return cls
                    22:29:00.01 <<< Return value from _funcs_kwargs: <class 'fastcore.meta.T'>
                    22:29:00.01 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:29:00.01 .......... self = <fastcore.meta.T object>
                    22:29:00.01 .......... args = ()
                    22:29:00.01 .......... kwargs = {'b': <function _f>}
                    22:29:00.01 .......... len(kwargs) = 1
                    22:29:00.01 .......... as_method = True
                    22:29:00.01 .......... cls = <class 'fastcore.meta.T'>
                    22:29:00.01 .......... old_init = <slot wrapper '__init__' of 'object' objects>
                    22:29:00.01    7 |     def _init(self, *args, **kwargs):
                    22:29:00.01    8 |         for k in cls._methods:
                    22:29:00.01 .............. k = 'b'
                    22:29:00.01    9 |             arg = kwargs.pop(k,None)
                    22:29:00.01 .................. kwargs = {}
                    22:29:00.01 .................. arg = <function _f>
                    22:29:00.01   10 |             if arg is not None:
                    22:29:00.01   11 |                 if as_method: arg = method(arg)
                    22:29:00.01 ...... arg = <bound method int._f of 1>
                    22:29:00.01   12 |                 if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)
                    22:29:00.01 ...... arg = <bound method T._f of <fastcore.meta.T object>>
                    22:29:00.01   13 |                 setattr(self, k, arg)
                    22:29:00.01    8 |         for k in cls._methods:
                    22:29:00.01   14 |         old_init(self, *args, **kwargs)
                    22:29:00.01 <<< Return value from _funcs_kwargs.<locals>._init: None
                    22:29:00.01 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:29:00.01 .......... self = <fastcore.meta.T2 object>
                    22:29:00.01 .......... args = ()
                    22:29:00.01 .......... kwargs = {'b': <function _f>}
                    22:29:00.01 .......... len(kwargs) = 1
                    22:29:00.01 .......... as_method = True
                    22:29:00.01 .......... cls = <class 'fastcore.meta.T'>
                    22:29:00.01 .......... old_init = <slot wrapper '__init__' of 'object' objects>
                    22:29:00.01    7 |     def _init(self, *args, **kwargs):
                    22:29:00.01    8 |         for k in cls._methods:
                    22:29:00.01 .............. k = 'b'
                    22:29:00.01    9 |             arg = kwargs.pop(k,None)
                    22:29:00.01 .................. kwargs = {}
                    22:29:00.01 .................. arg = <function _f>
                    22:29:00.01   10 |             if arg is not None:
                    22:29:00.01   11 |                 if as_method: arg = method(arg)
                    22:29:00.01 ...... arg = <bound method int._f of 1>
                    22:29:00.01   12 |                 if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)
                    22:29:00.01 ...... arg = <bound method T2._f of <fastcore.meta.T2 object>>
                    22:29:00.01   13 |                 setattr(self, k, arg)
                    22:29:00.01    8 |         for k in cls._methods:
                    22:29:00.01   14 |         old_init(self, *args, **kwargs)
                    22:29:00.01 <<< Return value from _funcs_kwargs.<locals>._init: None
                
                
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                
                
                
                ```
                fdb_.debug()
                ```
                
                    _funcs_kwargs's dbsrc code: ==============
                    import snoop
                    @snoop
                    def _funcs_kwargs(cls, as_method):
                        old_init = cls.__init__
                        import snoop
                        @snoop
                        def _init(self, *args, **kwargs):
                            for k in cls._methods:
                                arg = kwargs.pop(k,None)
                                if arg is not None:
                                    if as_method: arg = method(arg)
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)
                                    setattr(self, k, arg)
                            old_init(self, *args, **kwargs)
                        functools.update_wrapper(_init, old_init)
                        cls.__init__ = use_kwargs(cls._methods)(_init)
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))
                        return cls
                    
                    
                    
                    _funcs_kwargs's example processed with dbsrc: ===============
                    
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    
                
                
                
                ```
                #| column: screen
                fdb.print()
                ```
                
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    def funcs_kwargs(as_method=False):========================================================(0)       
                        "Replace methods in `cls._methods` with those from `kwargs`"==========================(1) # [93;1mhow funcs_kwargs works[0m; [93;1mit is a wrapper around _funcs_kwargs[0m; [91;1mit offers two ways of running _funcs_kwargs[0m; [37;1mthe first, default way, is to add a func to a class without using self[0m; [91;1msecond way is to add func to class enabling self use;[0m; 
                        if callable(as_method): return _funcs_kwargs(as_method, False)========================(2) # [37;1mhow to check whether an object is callable[0m; [93;1mhow to return a result of running a func[0m; [37;1m[0m; 
                        return partial(_funcs_kwargs, as_method=as_method)====================================(3) # [92;1mhow to custom the params of `_funcs_kwargs` for a particular use with partial[0m; 
                                                                                                                                                                            (4)
                
                
                
                ```
                #| column: screen
                fdb_.print()
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m12[0m     ===============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    def _funcs_kwargs(cls, as_method):========================================================(0) # [93;1mhow does _funcs_kwargs work: _funcs_kwargs is a decorator[0m; [35;1mit helps class e.g., T to add more methods[0m; [93;1mI need to give the method a name, and put the name e.g., 'b' inside a list called _methods=['b'] inside class T[0m; [36;1mthen after writing a func e.g., _new_func, I can add it by T(b = _new_func)[0m; [36;1mif I want the func added to class to use self, I shall write @funcs_kwargs(as_method=True)[0m; 
                        old_init = cls.__init__===============================================================(1)       
                        def _init(self, *args, **kwargs):=====================================================(2) # [37;1mhow to define a method which can use self and accept any parameters[0m; 
                            for k in cls._methods:============================================================(3) # [35;1mhow to pop out the value of an item in a dict (with None as default), and if the item name is not found, pop out None instead[0m; [91;1m[0m; 
                                arg = kwargs.pop(k,None)======================================================(4)       
                                if arg is not None:===========================================================(5)       
                                    if as_method: arg = method(arg)===========================================(6) # [36;1mhow to turn a func into a method[0m; 
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)=======(7) # [93;1mhow to give a method a different instance, like self[0m; 
                                    setattr(self, k, arg)=====================================================(8) # [36;1mhow to add a method to a class as an attribute[0m; 
                            old_init(self, *args, **kwargs)===================================================(9)       
                        functools.update_wrapper(_init, old_init)=============================================(10) # [34;1mhow to wrap `_init` around `old_init`, so that `_init` can use `old_init` inside itself[0m; 
                        cls.__init__ = use_kwargs(cls._methods)(_init)========================================(11) # [34;1mhow to add a list of names with None as default value to function `_init` to repalce its kwargs param[0m; 
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__)) # [35;1mhow to make a class.`__init__` signature to be the signature of the class using `__signature__` and `_rm_self`[0m;  (12)
                        return cls============================================================================(13)      
                                                                                                                                                                            (14)
                
                
                
                ```
                
                ```
                
                
            
            
            
            [Open `0009_funcs_kwargs` in Jupyter Notebook](http://localhost:8888/tree/nbs/demos/0009_funcs_kwargs.ipynb)
            
            
            
        
        
        
        [Open `utils` in Jupyter Notebook](http://localhost:8888/tree/nbs/lib/utils.ipynb)
        
        
        
        
    
    
    
    [Open `utils` in Jupyter Notebook](http://localhost:8888/tree/nbs/lib/utils.ipynb)
    
    
    
    



[Open `utils` in Jupyter Notebook locally](http://localhost:8888/tree/nbs/lib/utils.ipynb)



###  <mark style="background-color: #ffff00">snoop:</mark>   <mark style="background-color: #ffff00">from</mark>   <mark style="background-color: #ffff00">_ <mark style="background-color: #FFFF00">funcs_kwargs</mark> </mark>   <mark style="background-color: #ffff00">to</mark>   <mark style="background-color: #FFFF00">funcs_kwargs</mark> 



    
    
    
        
        
        
            
            
            
                
                how to snoop on two functions one wrap around another: `funcs_kwargs` is a wrapper around `_funcs_kwargs`, so I can first snoop on `_funcs_kwargs` and assign its snoop dbsrc to \
                `fm._funcs_kwargs` so that when I snoop on `funcs_kwargs`, it can use the snoop dbsrc of `_funcs_kwargs` and no example codes need to change.
                
                
                ```
                from fastcore.meta import _funcs_kwargs
                ```
                
                
                ```
                fdb_ = Fastdb(_funcs_kwargs)
                fdb_.eg = """
                @funcs_kwargs
                class T:
                    _methods=['b'] # allows you to add method b upon instantiation
                    def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                    def a(self): return 1
                    def b(self): return 2
                    
                t = T()
                test_eq(t.a(), 1)
                test_eq(t.b(), 2)
                
                test_sig(T, '(f=1, *, b=None)')
                inspect.signature(T)
                
                def _new_func(): return 5
                
                t = T(b = _new_func)
                test_eq(t.b(), 5)
                
                t = T(a = lambda:3)
                test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                """
                ```
                
                
                ```
                #| column: screen
                # no snoop result, it is expected, because the example is not calling _funcs_kwargs, but funcs_kwargs
                fdb_.snoop(deco=True) # how to snoop decorator: _funcs_kwargs is a decorator, so set deco=True to see running codes in inner f
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    [0m     
                    
                
                
                
                ```
                import fastcore.meta as fm
                ```
                
                
                ```
                fm._funcs_kwargs = fdb_.dbsrc # how to snoop on two functions one wrap around another
                ```
                
                
                ```
                fdb = Fastdb(funcs_kwargs)
                fdb.eg = """
                @funcs_kwargs
                class T:
                    _methods=['b'] # allows you to add method b upon instantiation
                    def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                    def a(self): return 1
                    def b(self): return 2
                    
                t = T()
                test_eq(t.a(), 1)
                test_eq(t.b(), 2)
                
                test_sig(T, '(f=1, *, b=None)')
                inspect.signature(T)
                
                def _new_func(): return 5
                
                t = T(b = _new_func)
                test_eq(t.b(), 5)
                
                t = T(a = lambda:3)
                test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                
                def _f(self,a=1): return self.num + a # access the num attribute from the instance
                
                @funcs_kwargs(as_method=True)
                class T: 
                    _methods=['b']
                    num = 5
                    
                t = T(b = _f) # adds method b
                test_eq(t.b(5), 10) # self.num + 5 = 10
                
                def _f(self,a=1): return self.num * a #multiply instead of add 
                
                class T2(T):
                    def __init__(self,num):
                        super().__init__(b = _f) # add method b from the super class
                        self.num=num
                        
                t = T2(num=3)
                test_eq(t.b(a=5), 15) # 3 * 5 = 15
                test_sig(T2, '(num)')
                """
                ```
                
                
                ```
                #| column: screen
                fdb.print()
                ```
                
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    def funcs_kwargs(as_method=False):========================================================(0)       
                        "Replace methods in `cls._methods` with those from `kwargs`"==========================(1)       
                        if callable(as_method): return _funcs_kwargs(as_method, False)========================(2)       
                        return partial(_funcs_kwargs, as_method=as_method)====================================(3)       
                                                                                                                                                                            (4)
                
                
                
                ```
                #| column: screen
                fdb_.print()
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    def _funcs_kwargs(cls, as_method):========================================================(0)       
                        old_init = cls.__init__===============================================================(1)       
                        def _init(self, *args, **kwargs):=====================================================(2)       
                            for k in cls._methods:============================================================(3)       
                                arg = kwargs.pop(k,None)======================================================(4)       
                                if arg is not None:===========================================================(5)       
                                    if as_method: arg = method(arg)===========================================(6)       
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)=======(7)       
                                    setattr(self, k, arg)=====================================================(8)       
                            old_init(self, *args, **kwargs)===================================================(9)       
                        functools.update_wrapper(_init, old_init)=============================================(10)      
                        cls.__init__ = use_kwargs(cls._methods)(_init)========================================(11)      
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))                                                     (12)
                        return cls============================================================================(13)      
                                                                                                                                                                            (14)
                
                
                
                ```
                #| column: screen
                fdb.docsrc(1, "how funcs_kwargs works; it is a wrapper around _funcs_kwargs; it offers two ways of running _funcs_kwargs; \
                the first, default way, is to add a func to a class without using self; second way is to add func to class enabling self use;")
                fdb.docsrc(2, "how to check whether an object is callable; how to return a result of running a func; ")
                fdb.docsrc(3, "how to custom the params of `_funcs_kwargs` for a particular use with partial")
                ```
                
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m1[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                    def funcs_kwargs(as_method=False):                                                                                                                      (0)
                        "Replace methods in `cls._methods` with those from `kwargs`"========================================================================================(1)
                    [91;1mhow funcs_kwargs works; it is a wrapper around _funcs_kwargs; it offers two ways of running _funcs_kwargs; the first, default way, is to add a func to a class without using self; second way is to add func to class enabling self use;[0m
                        if callable(as_method): return _funcs_kwargs(as_method, False)                                                                                      (2)
                        return partial(_funcs_kwargs, as_method=as_method)                                                                                                  (3)
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m2[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                    def funcs_kwargs(as_method=False):                                                                                                                      (0)
                        "Replace methods in `cls._methods` with those from `kwargs`"                                                                                        (1)
                        if callable(as_method): return _funcs_kwargs(as_method, False)======================================================================================(2)
                                                                                           [91;1mhow to check whether an object is callable; how to return a result of running a func; [0m
                        return partial(_funcs_kwargs, as_method=as_method)                                                                                                  (3)
                                                                                                                                                                            (4)
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m3[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                        "Replace methods in `cls._methods` with those from `kwargs`"                                                                                        (1)
                        if callable(as_method): return _funcs_kwargs(as_method, False)                                                                                      (2)
                        return partial(_funcs_kwargs, as_method=as_method)==================================================================================================(3)
                                                                                                    [91;1mhow to custom the params of `_funcs_kwargs` for a particular use with partial[0m
                                                                                                                                                                            (4)
                
                
                
                ```
                #| column: screen
                fdb_.print()
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    def _funcs_kwargs(cls, as_method):========================================================(0)       
                        old_init = cls.__init__===============================================================(1)       
                        def _init(self, *args, **kwargs):=====================================================(2)       
                            for k in cls._methods:============================================================(3)       
                                arg = kwargs.pop(k,None)======================================================(4)       
                                if arg is not None:===========================================================(5)       
                                    if as_method: arg = method(arg)===========================================(6)       
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)=======(7)       
                                    setattr(self, k, arg)=====================================================(8)       
                            old_init(self, *args, **kwargs)===================================================(9)       
                        functools.update_wrapper(_init, old_init)=============================================(10)      
                        cls.__init__ = use_kwargs(cls._methods)(_init)========================================(11)      
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))                                                     (12)
                        return cls============================================================================(13)      
                                                                                                                                                                            (14)
                
                
                
                ```
                #| column: screen
                fdb_.docsrc(0, "how does _funcs_kwargs work: _funcs_kwargs is a decorator; it helps class e.g., T to add more methods; \
                I need to give the method a name, \
                and put the name e.g., 'b' inside a list called _methods=['b'] inside class T; \
                then after writing a func e.g., _new_func, I can add it by T(b = _new_func); if I want the func added to class to use self, \
                I shall write @funcs_kwargs(as_method=True)")
                fdb_.docsrc(2, "how to define a method which can use self and accept any parameters")
                fdb_.docsrc(3, "how to pop out the value of an item in a dict (with None as default), and if the item name is not found, pop out None instead; ")
                fdb_.docsrc(6, "how to turn a func into a method")
                fdb_.docsrc(7, "how to give a method a different instance, like self")
                fdb_.docsrc(8, "how to add a method to a class as an attribute")
                fdb_.docsrc(10, "how to wrap `_init` around `old_init`, so that `_init` can use `old_init` inside itself")
                fdb_.docsrc(11, "how to add a list of names with None as default value to function `_init` to repalce its kwargs param")
                fdb_.docsrc(12, "how to make a class.`__init__` signature to be the signature of the class using `__signature__` and `_rm_self`")
                
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m0[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                    def _funcs_kwargs(cls, as_method):======================================================================================================================(0)
                    [91;1mhow does _funcs_kwargs work: _funcs_kwargs is a decorator; it helps class e.g., T to add more methods; I need to give the method a name, and put the name e.g., 'b' inside a list called _methods=['b'] inside class T; then after writing a func e.g., _new_func, I can add it by T(b = _new_func); if I want the func added to class to use self, I shall write @funcs_kwargs(as_method=True)[0m
                        old_init = cls.__init__                                                                                                                             (1)
                        def _init(self, *args, **kwargs):                                                                                                                   (2)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m2[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                    def _funcs_kwargs(cls, as_method):                                                                                                                      (0)
                        old_init = cls.__init__                                                                                                                             (1)
                        def _init(self, *args, **kwargs):===================================================================================================================(2)
                                                                                                              [91;1mhow to define a method which can use self and accept any parameters[0m
                            for k in cls._methods:                                                                                                                          (3)
                                arg = kwargs.pop(k,None)                                                                                                                    (4)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m3[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                        old_init = cls.__init__                                                                                                                             (1)
                        def _init(self, *args, **kwargs):                                                                                                                   (2)
                            for k in cls._methods:==========================================================================================================================(3)
                                                  [91;1mhow to pop out the value of an item in a dict (with None as default), and if the item name is not found, pop out None instead; [0m
                                arg = kwargs.pop(k,None)                                                                                                                    (4)
                                if arg is not None:                                                                                                                         (5)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m6[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                                arg = kwargs.pop(k,None)                                                                                                                    (4)
                                if arg is not None:                                                                                                                         (5)
                                    if as_method: arg = method(arg)=========================================================================================================(6)
                                                                                                                                                 [91;1mhow to turn a func into a method[0m
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)                                                                     (7)
                                    setattr(self, k, arg)                                                                                                                   (8)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m7[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                                if arg is not None:                                                                                                                         (5)
                                    if as_method: arg = method(arg)                                                                                                         (6)
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)=====================================================================(7)
                                                                                                                             [91;1mhow to give a method a different instance, like self[0m
                                    setattr(self, k, arg)                                                                                                                   (8)
                            old_init(self, *args, **kwargs)                                                                                                                 (9)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m8[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                                    if as_method: arg = method(arg)                                                                                                         (6)
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)                                                                     (7)
                                    setattr(self, k, arg)===================================================================================================================(8)
                                                                                                                                   [91;1mhow to add a method to a class as an attribute[0m
                            old_init(self, *args, **kwargs)                                                                                                                 (9)
                        functools.update_wrapper(_init, old_init)                                                                                                           (10)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m10[0m     ===============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                                    setattr(self, k, arg)                                                                                                                   (8)
                            old_init(self, *args, **kwargs)                                                                                                                 (9)
                        functools.update_wrapper(_init, old_init)===========================================================================================================(10)
                                                                                          [91;1mhow to wrap `_init` around `old_init`, so that `_init` can use `old_init` inside itself[0m
                        cls.__init__ = use_kwargs(cls._methods)(_init)                                                                                                      (11)
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))                                                     (12)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m11[0m     ===============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                            old_init(self, *args, **kwargs)                                                                                                                 (9)
                        functools.update_wrapper(_init, old_init)                                                                                                           (10)
                        cls.__init__ = use_kwargs(cls._methods)(_init)======================================================================================================(11)
                                                                            [91;1mhow to add a list of names with None as default value to function `_init` to repalce its kwargs param[0m
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))                                                     (12)
                        return cls                                                                                                                                          (13)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m12[0m     ===============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                        functools.update_wrapper(_init, old_init)                                                                                                           (10)
                        cls.__init__ = use_kwargs(cls._methods)(_init)                                                                                                      (11)
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))=====================================================(12)
                                                                   [91;1mhow to make a class.`__init__` signature to be the signature of the class using `__signature__` and `_rm_self`[0m
                        return cls                                                                                                                                          (13)
                                                                                                                                                                            (14)
                
                
                
                ```
                #| column: screen
                fdb.snoop() # how to snoop together with docsrc: snoop first and docsrc above it
                ```
                
                    22:28:59.99 >>> Call to funcs_kwargs in File "/tmp/funcs_kwargs.py", line 3
                    22:28:59.99 ...... as_method = <class 'fastcore.meta.T'>
                    22:28:59.99    3 | def funcs_kwargs(as_method=False):
                    22:28:59.99    5 |     if callable(as_method): return _funcs_kwargs(as_method, False)
                        22:28:59.99 >>> Call to _funcs_kwargs in File "/tmp/_funcs_kwargs.py", line 3
                        22:28:59.99 ...... cls = <class 'fastcore.meta.T'>
                        22:28:59.99 ...... as_method = False
                        22:28:59.99    3 | def _funcs_kwargs(cls, as_method):
                        22:28:59.99    4 |     old_init = cls.__init__
                        22:28:59.99 .......... old_init = <function T.__init__>
                        22:28:59.99    5 |     import snoop
                        22:28:59.99 .......... snoop = <class 'snoop.configuration.Config.__init__.<locals>.ConfiguredTracer'>
                        22:28:59.99    6 |     @snoop
                        22:28:59.99    7 |     def _init(self, *args, **kwargs):
                        22:28:59.99 .......... _init = <function _funcs_kwargs.<locals>._init>
                        22:28:59.99   15 |     functools.update_wrapper(_init, old_init)
                        22:28:59.99 .......... _init = <function T.__init__>
                        22:28:59.99   16 |     cls.__init__ = use_kwargs(cls._methods)(_init)
                        22:28:59.99   17 |     if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))
                        22:28:59.99   18 |     return cls
                        22:28:59.99 <<< Return value from _funcs_kwargs: <class 'fastcore.meta.T'>
                    22:28:59.99    5 |     if callable(as_method): return _funcs_kwargs(as_method, False)
                    22:28:59.99 <<< Return value from funcs_kwargs: <class 'fastcore.meta.T'>
                    22:28:59.99 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:28:59.99 .......... self = <fastcore.meta.T object>
                    22:28:59.99 .......... args = ()
                    22:28:59.99 .......... kwargs = {}
                    22:28:59.99 .......... as_method = False
                    22:28:59.99 .......... cls = <class 'fastcore.meta.T'>
                    22:28:59.99 .......... old_init = <function T.__init__>
                    22:28:59.99    7 |     def _init(self, *args, **kwargs):
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00 .............. k = 'b'
                    22:29:00.00    9 |             arg = kwargs.pop(k,None)
                    22:29:00.00 .................. arg = None
                    22:29:00.00   10 |             if arg is not None:
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00   14 |         old_init(self, *args, **kwargs)
                    22:29:00.00 <<< Return value from _funcs_kwargs.<locals>._init: None
                    22:29:00.00 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:29:00.00 .......... self = <fastcore.meta.T object>
                    22:29:00.00 .......... args = ()
                    22:29:00.00 .......... kwargs = {'b': <function _new_func>}
                    22:29:00.00 .......... len(kwargs) = 1
                    22:29:00.00 .......... as_method = False
                    22:29:00.00 .......... cls = <class 'fastcore.meta.T'>
                    22:29:00.00 .......... old_init = <function T.__init__>
                    22:29:00.00    7 |     def _init(self, *args, **kwargs):
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00 .............. k = 'b'
                    22:29:00.00    9 |             arg = kwargs.pop(k,None)
                    22:29:00.00 .................. kwargs = {}
                    22:29:00.00 .................. arg = <function _new_func>
                    22:29:00.00   10 |             if arg is not None:
                    22:29:00.00   11 |                 if as_method: arg = method(arg)
                    22:29:00.00   12 |                 if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)
                    22:29:00.00   13 |                 setattr(self, k, arg)
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00   14 |         old_init(self, *args, **kwargs)
                    22:29:00.00 <<< Return value from _funcs_kwargs.<locals>._init: None
                    22:29:00.00 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:29:00.00 .......... self = <fastcore.meta.T object>
                    22:29:00.00 .......... args = ()
                    22:29:00.00 .......... kwargs = {'a': <function <lambda>>}
                    22:29:00.00 .......... len(kwargs) = 1
                    22:29:00.00 .......... as_method = False
                    22:29:00.00 .......... cls = <class 'fastcore.meta.T'>
                    22:29:00.00 .......... old_init = <function T.__init__>
                    22:29:00.00    7 |     def _init(self, *args, **kwargs):
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00 .............. k = 'b'
                    22:29:00.00    9 |             arg = kwargs.pop(k,None)
                    22:29:00.00 .................. arg = None
                    22:29:00.00   10 |             if arg is not None:
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00   14 |         old_init(self, *args, **kwargs)
                    22:29:00.00 <<< Return value from _funcs_kwargs.<locals>._init: None
                    22:29:00.00 >>> Call to funcs_kwargs in File "/tmp/funcs_kwargs.py", line 3
                    22:29:00.00 ...... as_method = True
                    22:29:00.00    3 | def funcs_kwargs(as_method=False):
                    22:29:00.00    5 |     if callable(as_method): return _funcs_kwargs(as_method, False)
                    22:29:00.00    6 |     return partial(_funcs_kwargs, as_method=as_method)
                    22:29:00.00 <<< Return value from funcs_kwargs: functools.partial(<function _funcs_kwargs>, as_method=True)
                    22:29:00.00 >>> Call to _funcs_kwargs in File "/tmp/_funcs_kwargs.py", line 3
                    22:29:00.00 ...... cls = <class 'fastcore.meta.T'>
                    22:29:00.00 ...... as_method = True
                    22:29:00.00    3 | def _funcs_kwargs(cls, as_method):
                    22:29:00.00    4 |     old_init = cls.__init__
                    22:29:00.00 .......... old_init = <slot wrapper '__init__' of 'object' objects>
                    22:29:00.00    5 |     import snoop
                    22:29:00.00 .......... snoop = <class 'snoop.configuration.Config.__init__.<locals>.ConfiguredTracer'>
                    22:29:00.00    6 |     @snoop
                    22:29:00.00    7 |     def _init(self, *args, **kwargs):
                    22:29:00.00 .......... _init = <function _funcs_kwargs.<locals>._init>
                    22:29:00.00   15 |     functools.update_wrapper(_init, old_init)
                    22:29:00.00 .......... _init = <function object.__init__>
                    22:29:00.00   16 |     cls.__init__ = use_kwargs(cls._methods)(_init)
                    22:29:00.01   17 |     if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))
                    22:29:00.01   18 |     return cls
                    22:29:00.01 <<< Return value from _funcs_kwargs: <class 'fastcore.meta.T'>
                    22:29:00.01 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:29:00.01 .......... self = <fastcore.meta.T object>
                    22:29:00.01 .......... args = ()
                    22:29:00.01 .......... kwargs = {'b': <function _f>}
                    22:29:00.01 .......... len(kwargs) = 1
                    22:29:00.01 .......... as_method = True
                    22:29:00.01 .......... cls = <class 'fastcore.meta.T'>
                    22:29:00.01 .......... old_init = <slot wrapper '__init__' of 'object' objects>
                    22:29:00.01    7 |     def _init(self, *args, **kwargs):
                    22:29:00.01    8 |         for k in cls._methods:
                    22:29:00.01 .............. k = 'b'
                    22:29:00.01    9 |             arg = kwargs.pop(k,None)
                    22:29:00.01 .................. kwargs = {}
                    22:29:00.01 .................. arg = <function _f>
                    22:29:00.01   10 |             if arg is not None:
                    22:29:00.01   11 |                 if as_method: arg = method(arg)
                    22:29:00.01 ...... arg = <bound method int._f of 1>
                    22:29:00.01   12 |                 if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)
                    22:29:00.01 ...... arg = <bound method T._f of <fastcore.meta.T object>>
                    22:29:00.01   13 |                 setattr(self, k, arg)
                    22:29:00.01    8 |         for k in cls._methods:
                    22:29:00.01   14 |         old_init(self, *args, **kwargs)
                    22:29:00.01 <<< Return value from _funcs_kwargs.<locals>._init: None
                    22:29:00.01 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:29:00.01 .......... self = <fastcore.meta.T2 object>
                    22:29:00.01 .......... args = ()
                    22:29:00.01 .......... kwargs = {'b': <function _f>}
                    22:29:00.01 .......... len(kwargs) = 1
                    22:29:00.01 .......... as_method = True
                    22:29:00.01 .......... cls = <class 'fastcore.meta.T'>
                    22:29:00.01 .......... old_init = <slot wrapper '__init__' of 'object' objects>
                    22:29:00.01    7 |     def _init(self, *args, **kwargs):
                    22:29:00.01    8 |         for k in cls._methods:
                    22:29:00.01 .............. k = 'b'
                    22:29:00.01    9 |             arg = kwargs.pop(k,None)
                    22:29:00.01 .................. kwargs = {}
                    22:29:00.01 .................. arg = <function _f>
                    22:29:00.01   10 |             if arg is not None:
                    22:29:00.01   11 |                 if as_method: arg = method(arg)
                    22:29:00.01 ...... arg = <bound method int._f of 1>
                    22:29:00.01   12 |                 if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)
                    22:29:00.01 ...... arg = <bound method T2._f of <fastcore.meta.T2 object>>
                    22:29:00.01   13 |                 setattr(self, k, arg)
                    22:29:00.01    8 |         for k in cls._methods:
                    22:29:00.01   14 |         old_init(self, *args, **kwargs)
                    22:29:00.01 <<< Return value from _funcs_kwargs.<locals>._init: None
                
                
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                
                
                
                ```
                fdb_.debug()
                ```
                
                    _funcs_kwargs's dbsrc code: ==============
                    import snoop
                    @snoop
                    def _funcs_kwargs(cls, as_method):
                        old_init = cls.__init__
                        import snoop
                        @snoop
                        def _init(self, *args, **kwargs):
                            for k in cls._methods:
                                arg = kwargs.pop(k,None)
                                if arg is not None:
                                    if as_method: arg = method(arg)
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)
                                    setattr(self, k, arg)
                            old_init(self, *args, **kwargs)
                        functools.update_wrapper(_init, old_init)
                        cls.__init__ = use_kwargs(cls._methods)(_init)
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))
                        return cls
                    
                    
                    
                    _funcs_kwargs's example processed with dbsrc: ===============
                    
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    
                
                
                
                ```
                #| column: screen
                fdb.print()
                ```
                
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    def funcs_kwargs(as_method=False):========================================================(0)       
                        "Replace methods in `cls._methods` with those from `kwargs`"==========================(1) # [93;1mhow funcs_kwargs works[0m; [93;1mit is a wrapper around _funcs_kwargs[0m; [91;1mit offers two ways of running _funcs_kwargs[0m; [37;1mthe first, default way, is to add a func to a class without using self[0m; [91;1msecond way is to add func to class enabling self use;[0m; 
                        if callable(as_method): return _funcs_kwargs(as_method, False)========================(2) # [37;1mhow to check whether an object is callable[0m; [93;1mhow to return a result of running a func[0m; [37;1m[0m; 
                        return partial(_funcs_kwargs, as_method=as_method)====================================(3) # [92;1mhow to custom the params of `_funcs_kwargs` for a particular use with partial[0m; 
                                                                                                                                                                            (4)
                
                
                
                ```
                #| column: screen
                fdb_.print()
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m12[0m     ===============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    def _funcs_kwargs(cls, as_method):========================================================(0) # [93;1mhow does _funcs_kwargs work: _funcs_kwargs is a decorator[0m; [35;1mit helps class e.g., T to add more methods[0m; [93;1mI need to give the method a name, and put the name e.g., 'b' inside a list called _methods=['b'] inside class T[0m; [36;1mthen after writing a func e.g., _new_func, I can add it by T(b = _new_func)[0m; [36;1mif I want the func added to class to use self, I shall write @funcs_kwargs(as_method=True)[0m; 
                        old_init = cls.__init__===============================================================(1)       
                        def _init(self, *args, **kwargs):=====================================================(2) # [37;1mhow to define a method which can use self and accept any parameters[0m; 
                            for k in cls._methods:============================================================(3) # [35;1mhow to pop out the value of an item in a dict (with None as default), and if the item name is not found, pop out None instead[0m; [91;1m[0m; 
                                arg = kwargs.pop(k,None)======================================================(4)       
                                if arg is not None:===========================================================(5)       
                                    if as_method: arg = method(arg)===========================================(6) # [36;1mhow to turn a func into a method[0m; 
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)=======(7) # [93;1mhow to give a method a different instance, like self[0m; 
                                    setattr(self, k, arg)=====================================================(8) # [36;1mhow to add a method to a class as an attribute[0m; 
                            old_init(self, *args, **kwargs)===================================================(9)       
                        functools.update_wrapper(_init, old_init)=============================================(10) # [34;1mhow to wrap `_init` around `old_init`, so that `_init` can use `old_init` inside itself[0m; 
                        cls.__init__ = use_kwargs(cls._methods)(_init)========================================(11) # [34;1mhow to add a list of names with None as default value to function `_init` to repalce its kwargs param[0m; 
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__)) # [35;1mhow to make a class.`__init__` signature to be the signature of the class using `__signature__` and `_rm_self`[0m;  (12)
                        return cls============================================================================(13)      
                                                                                                                                                                            (14)
                
                
                
                ```
                
                ```
                
                
            
            
            
            [Open `0009_funcs_kwargs` in Jupyter Notebook](http://localhost:8888/tree/nbs/demos/0009_funcs_kwargs.ipynb)
            
            
            
        
        
        
        [Open `utils` in Jupyter Notebook](http://localhost:8888/tree/nbs/lib/utils.ipynb)
        
        
        
        
    
    
    
    [Open `utils` in Jupyter Notebook](http://localhost:8888/tree/nbs/lib/utils.ipynb)
    
    
    
    



[Open `utils` in Jupyter Notebook locally](http://localhost:8888/tree/nbs/lib/utils.ipynb)



###  <mark style="background-color: #ffff00">snoop:</mark>   <mark style="background-color: #ffff00">from</mark>   <mark style="background-color: #ffff00">_ <mark style="background-color: #FFFF00">funcs_kwargs</mark> </mark>   <mark style="background-color: #ffff00">to</mark>   <mark style="background-color: #FFFF00">funcs_kwargs</mark> 



    
    
    
        
        
        
            
            
            
                
                how to snoop on two functions one wrap around another: `funcs_kwargs` is a wrapper around `_funcs_kwargs`, so I can first snoop on `_funcs_kwargs` and assign its snoop dbsrc to \
                `fm._funcs_kwargs` so that when I snoop on `funcs_kwargs`, it can use the snoop dbsrc of `_funcs_kwargs` and no example codes need to change.
                
                
                ```
                from fastcore.meta import _funcs_kwargs
                ```
                
                
                ```
                fdb_ = Fastdb(_funcs_kwargs)
                fdb_.eg = """
                @funcs_kwargs
                class T:
                    _methods=['b'] # allows you to add method b upon instantiation
                    def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                    def a(self): return 1
                    def b(self): return 2
                    
                t = T()
                test_eq(t.a(), 1)
                test_eq(t.b(), 2)
                
                test_sig(T, '(f=1, *, b=None)')
                inspect.signature(T)
                
                def _new_func(): return 5
                
                t = T(b = _new_func)
                test_eq(t.b(), 5)
                
                t = T(a = lambda:3)
                test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                """
                ```
                
                
                ```
                #| column: screen
                # no snoop result, it is expected, because the example is not calling _funcs_kwargs, but funcs_kwargs
                fdb_.snoop(deco=True) # how to snoop decorator: _funcs_kwargs is a decorator, so set deco=True to see running codes in inner f
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    [0m     
                    
                
                
                
                ```
                import fastcore.meta as fm
                ```
                
                
                ```
                fm._funcs_kwargs = fdb_.dbsrc # how to snoop on two functions one wrap around another
                ```
                
                
                ```
                fdb = Fastdb(funcs_kwargs)
                fdb.eg = """
                @funcs_kwargs
                class T:
                    _methods=['b'] # allows you to add method b upon instantiation
                    def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                    def a(self): return 1
                    def b(self): return 2
                    
                t = T()
                test_eq(t.a(), 1)
                test_eq(t.b(), 2)
                
                test_sig(T, '(f=1, *, b=None)')
                inspect.signature(T)
                
                def _new_func(): return 5
                
                t = T(b = _new_func)
                test_eq(t.b(), 5)
                
                t = T(a = lambda:3)
                test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                
                def _f(self,a=1): return self.num + a # access the num attribute from the instance
                
                @funcs_kwargs(as_method=True)
                class T: 
                    _methods=['b']
                    num = 5
                    
                t = T(b = _f) # adds method b
                test_eq(t.b(5), 10) # self.num + 5 = 10
                
                def _f(self,a=1): return self.num * a #multiply instead of add 
                
                class T2(T):
                    def __init__(self,num):
                        super().__init__(b = _f) # add method b from the super class
                        self.num=num
                        
                t = T2(num=3)
                test_eq(t.b(a=5), 15) # 3 * 5 = 15
                test_sig(T2, '(num)')
                """
                ```
                
                
                ```
                #| column: screen
                fdb.print()
                ```
                
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    def funcs_kwargs(as_method=False):========================================================(0)       
                        "Replace methods in `cls._methods` with those from `kwargs`"==========================(1)       
                        if callable(as_method): return _funcs_kwargs(as_method, False)========================(2)       
                        return partial(_funcs_kwargs, as_method=as_method)====================================(3)       
                                                                                                                                                                            (4)
                
                
                
                ```
                #| column: screen
                fdb_.print()
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    def _funcs_kwargs(cls, as_method):========================================================(0)       
                        old_init = cls.__init__===============================================================(1)       
                        def _init(self, *args, **kwargs):=====================================================(2)       
                            for k in cls._methods:============================================================(3)       
                                arg = kwargs.pop(k,None)======================================================(4)       
                                if arg is not None:===========================================================(5)       
                                    if as_method: arg = method(arg)===========================================(6)       
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)=======(7)       
                                    setattr(self, k, arg)=====================================================(8)       
                            old_init(self, *args, **kwargs)===================================================(9)       
                        functools.update_wrapper(_init, old_init)=============================================(10)      
                        cls.__init__ = use_kwargs(cls._methods)(_init)========================================(11)      
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))                                                     (12)
                        return cls============================================================================(13)      
                                                                                                                                                                            (14)
                
                
                
                ```
                #| column: screen
                fdb.docsrc(1, "how funcs_kwargs works; it is a wrapper around _funcs_kwargs; it offers two ways of running _funcs_kwargs; \
                the first, default way, is to add a func to a class without using self; second way is to add func to class enabling self use;")
                fdb.docsrc(2, "how to check whether an object is callable; how to return a result of running a func; ")
                fdb.docsrc(3, "how to custom the params of `_funcs_kwargs` for a particular use with partial")
                ```
                
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m1[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                    def funcs_kwargs(as_method=False):                                                                                                                      (0)
                        "Replace methods in `cls._methods` with those from `kwargs`"========================================================================================(1)
                    [91;1mhow funcs_kwargs works; it is a wrapper around _funcs_kwargs; it offers two ways of running _funcs_kwargs; the first, default way, is to add a func to a class without using self; second way is to add func to class enabling self use;[0m
                        if callable(as_method): return _funcs_kwargs(as_method, False)                                                                                      (2)
                        return partial(_funcs_kwargs, as_method=as_method)                                                                                                  (3)
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m2[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                    def funcs_kwargs(as_method=False):                                                                                                                      (0)
                        "Replace methods in `cls._methods` with those from `kwargs`"                                                                                        (1)
                        if callable(as_method): return _funcs_kwargs(as_method, False)======================================================================================(2)
                                                                                           [91;1mhow to check whether an object is callable; how to return a result of running a func; [0m
                        return partial(_funcs_kwargs, as_method=as_method)                                                                                                  (3)
                                                                                                                                                                            (4)
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m3[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                        "Replace methods in `cls._methods` with those from `kwargs`"                                                                                        (1)
                        if callable(as_method): return _funcs_kwargs(as_method, False)                                                                                      (2)
                        return partial(_funcs_kwargs, as_method=as_method)==================================================================================================(3)
                                                                                                    [91;1mhow to custom the params of `_funcs_kwargs` for a particular use with partial[0m
                                                                                                                                                                            (4)
                
                
                
                ```
                #| column: screen
                fdb_.print()
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    def _funcs_kwargs(cls, as_method):========================================================(0)       
                        old_init = cls.__init__===============================================================(1)       
                        def _init(self, *args, **kwargs):=====================================================(2)       
                            for k in cls._methods:============================================================(3)       
                                arg = kwargs.pop(k,None)======================================================(4)       
                                if arg is not None:===========================================================(5)       
                                    if as_method: arg = method(arg)===========================================(6)       
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)=======(7)       
                                    setattr(self, k, arg)=====================================================(8)       
                            old_init(self, *args, **kwargs)===================================================(9)       
                        functools.update_wrapper(_init, old_init)=============================================(10)      
                        cls.__init__ = use_kwargs(cls._methods)(_init)========================================(11)      
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))                                                     (12)
                        return cls============================================================================(13)      
                                                                                                                                                                            (14)
                
                
                
                ```
                #| column: screen
                fdb_.docsrc(0, "how does _funcs_kwargs work: _funcs_kwargs is a decorator; it helps class e.g., T to add more methods; \
                I need to give the method a name, \
                and put the name e.g., 'b' inside a list called _methods=['b'] inside class T; \
                then after writing a func e.g., _new_func, I can add it by T(b = _new_func); if I want the func added to class to use self, \
                I shall write @funcs_kwargs(as_method=True)")
                fdb_.docsrc(2, "how to define a method which can use self and accept any parameters")
                fdb_.docsrc(3, "how to pop out the value of an item in a dict (with None as default), and if the item name is not found, pop out None instead; ")
                fdb_.docsrc(6, "how to turn a func into a method")
                fdb_.docsrc(7, "how to give a method a different instance, like self")
                fdb_.docsrc(8, "how to add a method to a class as an attribute")
                fdb_.docsrc(10, "how to wrap `_init` around `old_init`, so that `_init` can use `old_init` inside itself")
                fdb_.docsrc(11, "how to add a list of names with None as default value to function `_init` to repalce its kwargs param")
                fdb_.docsrc(12, "how to make a class.`__init__` signature to be the signature of the class using `__signature__` and `_rm_self`")
                
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m0[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                    def _funcs_kwargs(cls, as_method):======================================================================================================================(0)
                    [91;1mhow does _funcs_kwargs work: _funcs_kwargs is a decorator; it helps class e.g., T to add more methods; I need to give the method a name, and put the name e.g., 'b' inside a list called _methods=['b'] inside class T; then after writing a func e.g., _new_func, I can add it by T(b = _new_func); if I want the func added to class to use self, I shall write @funcs_kwargs(as_method=True)[0m
                        old_init = cls.__init__                                                                                                                             (1)
                        def _init(self, *args, **kwargs):                                                                                                                   (2)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m2[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                    def _funcs_kwargs(cls, as_method):                                                                                                                      (0)
                        old_init = cls.__init__                                                                                                                             (1)
                        def _init(self, *args, **kwargs):===================================================================================================================(2)
                                                                                                              [91;1mhow to define a method which can use self and accept any parameters[0m
                            for k in cls._methods:                                                                                                                          (3)
                                arg = kwargs.pop(k,None)                                                                                                                    (4)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m3[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                        old_init = cls.__init__                                                                                                                             (1)
                        def _init(self, *args, **kwargs):                                                                                                                   (2)
                            for k in cls._methods:==========================================================================================================================(3)
                                                  [91;1mhow to pop out the value of an item in a dict (with None as default), and if the item name is not found, pop out None instead; [0m
                                arg = kwargs.pop(k,None)                                                                                                                    (4)
                                if arg is not None:                                                                                                                         (5)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m6[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                                arg = kwargs.pop(k,None)                                                                                                                    (4)
                                if arg is not None:                                                                                                                         (5)
                                    if as_method: arg = method(arg)=========================================================================================================(6)
                                                                                                                                                 [91;1mhow to turn a func into a method[0m
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)                                                                     (7)
                                    setattr(self, k, arg)                                                                                                                   (8)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m7[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                                if arg is not None:                                                                                                                         (5)
                                    if as_method: arg = method(arg)                                                                                                         (6)
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)=====================================================================(7)
                                                                                                                             [91;1mhow to give a method a different instance, like self[0m
                                    setattr(self, k, arg)                                                                                                                   (8)
                            old_init(self, *args, **kwargs)                                                                                                                 (9)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m8[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                                    if as_method: arg = method(arg)                                                                                                         (6)
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)                                                                     (7)
                                    setattr(self, k, arg)===================================================================================================================(8)
                                                                                                                                   [91;1mhow to add a method to a class as an attribute[0m
                            old_init(self, *args, **kwargs)                                                                                                                 (9)
                        functools.update_wrapper(_init, old_init)                                                                                                           (10)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m10[0m     ===============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                                    setattr(self, k, arg)                                                                                                                   (8)
                            old_init(self, *args, **kwargs)                                                                                                                 (9)
                        functools.update_wrapper(_init, old_init)===========================================================================================================(10)
                                                                                          [91;1mhow to wrap `_init` around `old_init`, so that `_init` can use `old_init` inside itself[0m
                        cls.__init__ = use_kwargs(cls._methods)(_init)                                                                                                      (11)
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))                                                     (12)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m11[0m     ===============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                            old_init(self, *args, **kwargs)                                                                                                                 (9)
                        functools.update_wrapper(_init, old_init)                                                                                                           (10)
                        cls.__init__ = use_kwargs(cls._methods)(_init)======================================================================================================(11)
                                                                            [91;1mhow to add a list of names with None as default value to function `_init` to repalce its kwargs param[0m
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))                                                     (12)
                        return cls                                                                                                                                          (13)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m12[0m     ===============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                        functools.update_wrapper(_init, old_init)                                                                                                           (10)
                        cls.__init__ = use_kwargs(cls._methods)(_init)                                                                                                      (11)
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))=====================================================(12)
                                                                   [91;1mhow to make a class.`__init__` signature to be the signature of the class using `__signature__` and `_rm_self`[0m
                        return cls                                                                                                                                          (13)
                                                                                                                                                                            (14)
                
                
                
                ```
                #| column: screen
                fdb.snoop() # how to snoop together with docsrc: snoop first and docsrc above it
                ```
                
                    22:28:59.99 >>> Call to funcs_kwargs in File "/tmp/funcs_kwargs.py", line 3
                    22:28:59.99 ...... as_method = <class 'fastcore.meta.T'>
                    22:28:59.99    3 | def funcs_kwargs(as_method=False):
                    22:28:59.99    5 |     if callable(as_method): return _funcs_kwargs(as_method, False)
                        22:28:59.99 >>> Call to _funcs_kwargs in File "/tmp/_funcs_kwargs.py", line 3
                        22:28:59.99 ...... cls = <class 'fastcore.meta.T'>
                        22:28:59.99 ...... as_method = False
                        22:28:59.99    3 | def _funcs_kwargs(cls, as_method):
                        22:28:59.99    4 |     old_init = cls.__init__
                        22:28:59.99 .......... old_init = <function T.__init__>
                        22:28:59.99    5 |     import snoop
                        22:28:59.99 .......... snoop = <class 'snoop.configuration.Config.__init__.<locals>.ConfiguredTracer'>
                        22:28:59.99    6 |     @snoop
                        22:28:59.99    7 |     def _init(self, *args, **kwargs):
                        22:28:59.99 .......... _init = <function _funcs_kwargs.<locals>._init>
                        22:28:59.99   15 |     functools.update_wrapper(_init, old_init)
                        22:28:59.99 .......... _init = <function T.__init__>
                        22:28:59.99   16 |     cls.__init__ = use_kwargs(cls._methods)(_init)
                        22:28:59.99   17 |     if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))
                        22:28:59.99   18 |     return cls
                        22:28:59.99 <<< Return value from _funcs_kwargs: <class 'fastcore.meta.T'>
                    22:28:59.99    5 |     if callable(as_method): return _funcs_kwargs(as_method, False)
                    22:28:59.99 <<< Return value from funcs_kwargs: <class 'fastcore.meta.T'>
                    22:28:59.99 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:28:59.99 .......... self = <fastcore.meta.T object>
                    22:28:59.99 .......... args = ()
                    22:28:59.99 .......... kwargs = {}
                    22:28:59.99 .......... as_method = False
                    22:28:59.99 .......... cls = <class 'fastcore.meta.T'>
                    22:28:59.99 .......... old_init = <function T.__init__>
                    22:28:59.99    7 |     def _init(self, *args, **kwargs):
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00 .............. k = 'b'
                    22:29:00.00    9 |             arg = kwargs.pop(k,None)
                    22:29:00.00 .................. arg = None
                    22:29:00.00   10 |             if arg is not None:
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00   14 |         old_init(self, *args, **kwargs)
                    22:29:00.00 <<< Return value from _funcs_kwargs.<locals>._init: None
                    22:29:00.00 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:29:00.00 .......... self = <fastcore.meta.T object>
                    22:29:00.00 .......... args = ()
                    22:29:00.00 .......... kwargs = {'b': <function _new_func>}
                    22:29:00.00 .......... len(kwargs) = 1
                    22:29:00.00 .......... as_method = False
                    22:29:00.00 .......... cls = <class 'fastcore.meta.T'>
                    22:29:00.00 .......... old_init = <function T.__init__>
                    22:29:00.00    7 |     def _init(self, *args, **kwargs):
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00 .............. k = 'b'
                    22:29:00.00    9 |             arg = kwargs.pop(k,None)
                    22:29:00.00 .................. kwargs = {}
                    22:29:00.00 .................. arg = <function _new_func>
                    22:29:00.00   10 |             if arg is not None:
                    22:29:00.00   11 |                 if as_method: arg = method(arg)
                    22:29:00.00   12 |                 if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)
                    22:29:00.00   13 |                 setattr(self, k, arg)
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00   14 |         old_init(self, *args, **kwargs)
                    22:29:00.00 <<< Return value from _funcs_kwargs.<locals>._init: None
                    22:29:00.00 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:29:00.00 .......... self = <fastcore.meta.T object>
                    22:29:00.00 .......... args = ()
                    22:29:00.00 .......... kwargs = {'a': <function <lambda>>}
                    22:29:00.00 .......... len(kwargs) = 1
                    22:29:00.00 .......... as_method = False
                    22:29:00.00 .......... cls = <class 'fastcore.meta.T'>
                    22:29:00.00 .......... old_init = <function T.__init__>
                    22:29:00.00    7 |     def _init(self, *args, **kwargs):
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00 .............. k = 'b'
                    22:29:00.00    9 |             arg = kwargs.pop(k,None)
                    22:29:00.00 .................. arg = None
                    22:29:00.00   10 |             if arg is not None:
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00   14 |         old_init(self, *args, **kwargs)
                    22:29:00.00 <<< Return value from _funcs_kwargs.<locals>._init: None
                    22:29:00.00 >>> Call to funcs_kwargs in File "/tmp/funcs_kwargs.py", line 3
                    22:29:00.00 ...... as_method = True
                    22:29:00.00    3 | def funcs_kwargs(as_method=False):
                    22:29:00.00    5 |     if callable(as_method): return _funcs_kwargs(as_method, False)
                    22:29:00.00    6 |     return partial(_funcs_kwargs, as_method=as_method)
                    22:29:00.00 <<< Return value from funcs_kwargs: functools.partial(<function _funcs_kwargs>, as_method=True)
                    22:29:00.00 >>> Call to _funcs_kwargs in File "/tmp/_funcs_kwargs.py", line 3
                    22:29:00.00 ...... cls = <class 'fastcore.meta.T'>
                    22:29:00.00 ...... as_method = True
                    22:29:00.00    3 | def _funcs_kwargs(cls, as_method):
                    22:29:00.00    4 |     old_init = cls.__init__
                    22:29:00.00 .......... old_init = <slot wrapper '__init__' of 'object' objects>
                    22:29:00.00    5 |     import snoop
                    22:29:00.00 .......... snoop = <class 'snoop.configuration.Config.__init__.<locals>.ConfiguredTracer'>
                    22:29:00.00    6 |     @snoop
                    22:29:00.00    7 |     def _init(self, *args, **kwargs):
                    22:29:00.00 .......... _init = <function _funcs_kwargs.<locals>._init>
                    22:29:00.00   15 |     functools.update_wrapper(_init, old_init)
                    22:29:00.00 .......... _init = <function object.__init__>
                    22:29:00.00   16 |     cls.__init__ = use_kwargs(cls._methods)(_init)
                    22:29:00.01   17 |     if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))
                    22:29:00.01   18 |     return cls
                    22:29:00.01 <<< Return value from _funcs_kwargs: <class 'fastcore.meta.T'>
                    22:29:00.01 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:29:00.01 .......... self = <fastcore.meta.T object>
                    22:29:00.01 .......... args = ()
                    22:29:00.01 .......... kwargs = {'b': <function _f>}
                    22:29:00.01 .......... len(kwargs) = 1
                    22:29:00.01 .......... as_method = True
                    22:29:00.01 .......... cls = <class 'fastcore.meta.T'>
                    22:29:00.01 .......... old_init = <slot wrapper '__init__' of 'object' objects>
                    22:29:00.01    7 |     def _init(self, *args, **kwargs):
                    22:29:00.01    8 |         for k in cls._methods:
                    22:29:00.01 .............. k = 'b'
                    22:29:00.01    9 |             arg = kwargs.pop(k,None)
                    22:29:00.01 .................. kwargs = {}
                    22:29:00.01 .................. arg = <function _f>
                    22:29:00.01   10 |             if arg is not None:
                    22:29:00.01   11 |                 if as_method: arg = method(arg)
                    22:29:00.01 ...... arg = <bound method int._f of 1>
                    22:29:00.01   12 |                 if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)
                    22:29:00.01 ...... arg = <bound method T._f of <fastcore.meta.T object>>
                    22:29:00.01   13 |                 setattr(self, k, arg)
                    22:29:00.01    8 |         for k in cls._methods:
                    22:29:00.01   14 |         old_init(self, *args, **kwargs)
                    22:29:00.01 <<< Return value from _funcs_kwargs.<locals>._init: None
                    22:29:00.01 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:29:00.01 .......... self = <fastcore.meta.T2 object>
                    22:29:00.01 .......... args = ()
                    22:29:00.01 .......... kwargs = {'b': <function _f>}
                    22:29:00.01 .......... len(kwargs) = 1
                    22:29:00.01 .......... as_method = True
                    22:29:00.01 .......... cls = <class 'fastcore.meta.T'>
                    22:29:00.01 .......... old_init = <slot wrapper '__init__' of 'object' objects>
                    22:29:00.01    7 |     def _init(self, *args, **kwargs):
                    22:29:00.01    8 |         for k in cls._methods:
                    22:29:00.01 .............. k = 'b'
                    22:29:00.01    9 |             arg = kwargs.pop(k,None)
                    22:29:00.01 .................. kwargs = {}
                    22:29:00.01 .................. arg = <function _f>
                    22:29:00.01   10 |             if arg is not None:
                    22:29:00.01   11 |                 if as_method: arg = method(arg)
                    22:29:00.01 ...... arg = <bound method int._f of 1>
                    22:29:00.01   12 |                 if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)
                    22:29:00.01 ...... arg = <bound method T2._f of <fastcore.meta.T2 object>>
                    22:29:00.01   13 |                 setattr(self, k, arg)
                    22:29:00.01    8 |         for k in cls._methods:
                    22:29:00.01   14 |         old_init(self, *args, **kwargs)
                    22:29:00.01 <<< Return value from _funcs_kwargs.<locals>._init: None
                
                
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                
                
                
                ```
                fdb_.debug()
                ```
                
                    _funcs_kwargs's dbsrc code: ==============
                    import snoop
                    @snoop
                    def _funcs_kwargs(cls, as_method):
                        old_init = cls.__init__
                        import snoop
                        @snoop
                        def _init(self, *args, **kwargs):
                            for k in cls._methods:
                                arg = kwargs.pop(k,None)
                                if arg is not None:
                                    if as_method: arg = method(arg)
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)
                                    setattr(self, k, arg)
                            old_init(self, *args, **kwargs)
                        functools.update_wrapper(_init, old_init)
                        cls.__init__ = use_kwargs(cls._methods)(_init)
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))
                        return cls
                    
                    
                    
                    _funcs_kwargs's example processed with dbsrc: ===============
                    
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    
                
                
                
                ```
                #| column: screen
                fdb.print()
                ```
                
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    def funcs_kwargs(as_method=False):========================================================(0)       
                        "Replace methods in `cls._methods` with those from `kwargs`"==========================(1) # [93;1mhow funcs_kwargs works[0m; [93;1mit is a wrapper around _funcs_kwargs[0m; [91;1mit offers two ways of running _funcs_kwargs[0m; [37;1mthe first, default way, is to add a func to a class without using self[0m; [91;1msecond way is to add func to class enabling self use;[0m; 
                        if callable(as_method): return _funcs_kwargs(as_method, False)========================(2) # [37;1mhow to check whether an object is callable[0m; [93;1mhow to return a result of running a func[0m; [37;1m[0m; 
                        return partial(_funcs_kwargs, as_method=as_method)====================================(3) # [92;1mhow to custom the params of `_funcs_kwargs` for a particular use with partial[0m; 
                                                                                                                                                                            (4)
                
                
                
                ```
                #| column: screen
                fdb_.print()
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m12[0m     ===============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    def _funcs_kwargs(cls, as_method):========================================================(0) # [93;1mhow does _funcs_kwargs work: _funcs_kwargs is a decorator[0m; [35;1mit helps class e.g., T to add more methods[0m; [93;1mI need to give the method a name, and put the name e.g., 'b' inside a list called _methods=['b'] inside class T[0m; [36;1mthen after writing a func e.g., _new_func, I can add it by T(b = _new_func)[0m; [36;1mif I want the func added to class to use self, I shall write @funcs_kwargs(as_method=True)[0m; 
                        old_init = cls.__init__===============================================================(1)       
                        def _init(self, *args, **kwargs):=====================================================(2) # [37;1mhow to define a method which can use self and accept any parameters[0m; 
                            for k in cls._methods:============================================================(3) # [35;1mhow to pop out the value of an item in a dict (with None as default), and if the item name is not found, pop out None instead[0m; [91;1m[0m; 
                                arg = kwargs.pop(k,None)======================================================(4)       
                                if arg is not None:===========================================================(5)       
                                    if as_method: arg = method(arg)===========================================(6) # [36;1mhow to turn a func into a method[0m; 
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)=======(7) # [93;1mhow to give a method a different instance, like self[0m; 
                                    setattr(self, k, arg)=====================================================(8) # [36;1mhow to add a method to a class as an attribute[0m; 
                            old_init(self, *args, **kwargs)===================================================(9)       
                        functools.update_wrapper(_init, old_init)=============================================(10) # [34;1mhow to wrap `_init` around `old_init`, so that `_init` can use `old_init` inside itself[0m; 
                        cls.__init__ = use_kwargs(cls._methods)(_init)========================================(11) # [34;1mhow to add a list of names with None as default value to function `_init` to repalce its kwargs param[0m; 
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__)) # [35;1mhow to make a class.`__init__` signature to be the signature of the class using `__signature__` and `_rm_self`[0m;  (12)
                        return cls============================================================================(13)      
                                                                                                                                                                            (14)
                
                
                
                ```
                
                ```
                
                
            
            
            
            [Open `0009_funcs_kwargs` in Jupyter Notebook](http://localhost:8888/tree/nbs/demos/0009_funcs_kwargs.ipynb)
            
            
            
        
        
        
        [Open `utils` in Jupyter Notebook](http://localhost:8888/tree/nbs/lib/utils.ipynb)
        
        
        
        
    
    
    
    [Open `utils` in Jupyter Notebook](http://localhost:8888/tree/nbs/lib/utils.ipynb)
    
    
    
    



[Open `utils` in Jupyter Notebook locally](http://localhost:8888/tree/nbs/lib/utils.ipynb)



###  <mark style="background-color: #ffff00">snoop:</mark>   <mark style="background-color: #ffff00">from</mark>   <mark style="background-color: #ffff00">_ <mark style="background-color: #FFFF00">funcs_kwargs</mark> </mark>   <mark style="background-color: #ffff00">to</mark>   <mark style="background-color: #FFFF00">funcs_kwargs</mark> 



    
    
    
        
        
        
            
            
            
                
                how to snoop on two functions one wrap around another: `funcs_kwargs` is a wrapper around `_funcs_kwargs`, so I can first snoop on `_funcs_kwargs` and assign its snoop dbsrc to \
                `fm._funcs_kwargs` so that when I snoop on `funcs_kwargs`, it can use the snoop dbsrc of `_funcs_kwargs` and no example codes need to change.
                
                
                ```
                from fastcore.meta import _funcs_kwargs
                ```
                
                
                ```
                fdb_ = Fastdb(_funcs_kwargs)
                fdb_.eg = """
                @funcs_kwargs
                class T:
                    _methods=['b'] # allows you to add method b upon instantiation
                    def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                    def a(self): return 1
                    def b(self): return 2
                    
                t = T()
                test_eq(t.a(), 1)
                test_eq(t.b(), 2)
                
                test_sig(T, '(f=1, *, b=None)')
                inspect.signature(T)
                
                def _new_func(): return 5
                
                t = T(b = _new_func)
                test_eq(t.b(), 5)
                
                t = T(a = lambda:3)
                test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                """
                ```
                
                
                ```
                #| column: screen
                # no snoop result, it is expected, because the example is not calling _funcs_kwargs, but funcs_kwargs
                fdb_.snoop(deco=True) # how to snoop decorator: _funcs_kwargs is a decorator, so set deco=True to see running codes in inner f
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    [0m     
                    
                
                
                
                ```
                import fastcore.meta as fm
                ```
                
                
                ```
                fm._funcs_kwargs = fdb_.dbsrc # how to snoop on two functions one wrap around another
                ```
                
                
                ```
                fdb = Fastdb(funcs_kwargs)
                fdb.eg = """
                @funcs_kwargs
                class T:
                    _methods=['b'] # allows you to add method b upon instantiation
                    def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                    def a(self): return 1
                    def b(self): return 2
                    
                t = T()
                test_eq(t.a(), 1)
                test_eq(t.b(), 2)
                
                test_sig(T, '(f=1, *, b=None)')
                inspect.signature(T)
                
                def _new_func(): return 5
                
                t = T(b = _new_func)
                test_eq(t.b(), 5)
                
                t = T(a = lambda:3)
                test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                
                def _f(self,a=1): return self.num + a # access the num attribute from the instance
                
                @funcs_kwargs(as_method=True)
                class T: 
                    _methods=['b']
                    num = 5
                    
                t = T(b = _f) # adds method b
                test_eq(t.b(5), 10) # self.num + 5 = 10
                
                def _f(self,a=1): return self.num * a #multiply instead of add 
                
                class T2(T):
                    def __init__(self,num):
                        super().__init__(b = _f) # add method b from the super class
                        self.num=num
                        
                t = T2(num=3)
                test_eq(t.b(a=5), 15) # 3 * 5 = 15
                test_sig(T2, '(num)')
                """
                ```
                
                
                ```
                #| column: screen
                fdb.print()
                ```
                
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    def funcs_kwargs(as_method=False):========================================================(0)       
                        "Replace methods in `cls._methods` with those from `kwargs`"==========================(1)       
                        if callable(as_method): return _funcs_kwargs(as_method, False)========================(2)       
                        return partial(_funcs_kwargs, as_method=as_method)====================================(3)       
                                                                                                                                                                            (4)
                
                
                
                ```
                #| column: screen
                fdb_.print()
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    def _funcs_kwargs(cls, as_method):========================================================(0)       
                        old_init = cls.__init__===============================================================(1)       
                        def _init(self, *args, **kwargs):=====================================================(2)       
                            for k in cls._methods:============================================================(3)       
                                arg = kwargs.pop(k,None)======================================================(4)       
                                if arg is not None:===========================================================(5)       
                                    if as_method: arg = method(arg)===========================================(6)       
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)=======(7)       
                                    setattr(self, k, arg)=====================================================(8)       
                            old_init(self, *args, **kwargs)===================================================(9)       
                        functools.update_wrapper(_init, old_init)=============================================(10)      
                        cls.__init__ = use_kwargs(cls._methods)(_init)========================================(11)      
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))                                                     (12)
                        return cls============================================================================(13)      
                                                                                                                                                                            (14)
                
                
                
                ```
                #| column: screen
                fdb.docsrc(1, "how funcs_kwargs works; it is a wrapper around _funcs_kwargs; it offers two ways of running _funcs_kwargs; \
                the first, default way, is to add a func to a class without using self; second way is to add func to class enabling self use;")
                fdb.docsrc(2, "how to check whether an object is callable; how to return a result of running a func; ")
                fdb.docsrc(3, "how to custom the params of `_funcs_kwargs` for a particular use with partial")
                ```
                
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m1[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                    def funcs_kwargs(as_method=False):                                                                                                                      (0)
                        "Replace methods in `cls._methods` with those from `kwargs`"========================================================================================(1)
                    [91;1mhow funcs_kwargs works; it is a wrapper around _funcs_kwargs; it offers two ways of running _funcs_kwargs; the first, default way, is to add a func to a class without using self; second way is to add func to class enabling self use;[0m
                        if callable(as_method): return _funcs_kwargs(as_method, False)                                                                                      (2)
                        return partial(_funcs_kwargs, as_method=as_method)                                                                                                  (3)
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m2[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                    def funcs_kwargs(as_method=False):                                                                                                                      (0)
                        "Replace methods in `cls._methods` with those from `kwargs`"                                                                                        (1)
                        if callable(as_method): return _funcs_kwargs(as_method, False)======================================================================================(2)
                                                                                           [91;1mhow to check whether an object is callable; how to return a result of running a func; [0m
                        return partial(_funcs_kwargs, as_method=as_method)                                                                                                  (3)
                                                                                                                                                                            (4)
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m3[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                        "Replace methods in `cls._methods` with those from `kwargs`"                                                                                        (1)
                        if callable(as_method): return _funcs_kwargs(as_method, False)                                                                                      (2)
                        return partial(_funcs_kwargs, as_method=as_method)==================================================================================================(3)
                                                                                                    [91;1mhow to custom the params of `_funcs_kwargs` for a particular use with partial[0m
                                                                                                                                                                            (4)
                
                
                
                ```
                #| column: screen
                fdb_.print()
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    def _funcs_kwargs(cls, as_method):========================================================(0)       
                        old_init = cls.__init__===============================================================(1)       
                        def _init(self, *args, **kwargs):=====================================================(2)       
                            for k in cls._methods:============================================================(3)       
                                arg = kwargs.pop(k,None)======================================================(4)       
                                if arg is not None:===========================================================(5)       
                                    if as_method: arg = method(arg)===========================================(6)       
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)=======(7)       
                                    setattr(self, k, arg)=====================================================(8)       
                            old_init(self, *args, **kwargs)===================================================(9)       
                        functools.update_wrapper(_init, old_init)=============================================(10)      
                        cls.__init__ = use_kwargs(cls._methods)(_init)========================================(11)      
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))                                                     (12)
                        return cls============================================================================(13)      
                                                                                                                                                                            (14)
                
                
                
                ```
                #| column: screen
                fdb_.docsrc(0, "how does _funcs_kwargs work: _funcs_kwargs is a decorator; it helps class e.g., T to add more methods; \
                I need to give the method a name, \
                and put the name e.g., 'b' inside a list called _methods=['b'] inside class T; \
                then after writing a func e.g., _new_func, I can add it by T(b = _new_func); if I want the func added to class to use self, \
                I shall write @funcs_kwargs(as_method=True)")
                fdb_.docsrc(2, "how to define a method which can use self and accept any parameters")
                fdb_.docsrc(3, "how to pop out the value of an item in a dict (with None as default), and if the item name is not found, pop out None instead; ")
                fdb_.docsrc(6, "how to turn a func into a method")
                fdb_.docsrc(7, "how to give a method a different instance, like self")
                fdb_.docsrc(8, "how to add a method to a class as an attribute")
                fdb_.docsrc(10, "how to wrap `_init` around `old_init`, so that `_init` can use `old_init` inside itself")
                fdb_.docsrc(11, "how to add a list of names with None as default value to function `_init` to repalce its kwargs param")
                fdb_.docsrc(12, "how to make a class.`__init__` signature to be the signature of the class using `__signature__` and `_rm_self`")
                
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m0[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                    def _funcs_kwargs(cls, as_method):======================================================================================================================(0)
                    [91;1mhow does _funcs_kwargs work: _funcs_kwargs is a decorator; it helps class e.g., T to add more methods; I need to give the method a name, and put the name e.g., 'b' inside a list called _methods=['b'] inside class T; then after writing a func e.g., _new_func, I can add it by T(b = _new_func); if I want the func added to class to use self, I shall write @funcs_kwargs(as_method=True)[0m
                        old_init = cls.__init__                                                                                                                             (1)
                        def _init(self, *args, **kwargs):                                                                                                                   (2)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m2[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                    def _funcs_kwargs(cls, as_method):                                                                                                                      (0)
                        old_init = cls.__init__                                                                                                                             (1)
                        def _init(self, *args, **kwargs):===================================================================================================================(2)
                                                                                                              [91;1mhow to define a method which can use self and accept any parameters[0m
                            for k in cls._methods:                                                                                                                          (3)
                                arg = kwargs.pop(k,None)                                                                                                                    (4)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m3[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                        old_init = cls.__init__                                                                                                                             (1)
                        def _init(self, *args, **kwargs):                                                                                                                   (2)
                            for k in cls._methods:==========================================================================================================================(3)
                                                  [91;1mhow to pop out the value of an item in a dict (with None as default), and if the item name is not found, pop out None instead; [0m
                                arg = kwargs.pop(k,None)                                                                                                                    (4)
                                if arg is not None:                                                                                                                         (5)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m6[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                                arg = kwargs.pop(k,None)                                                                                                                    (4)
                                if arg is not None:                                                                                                                         (5)
                                    if as_method: arg = method(arg)=========================================================================================================(6)
                                                                                                                                                 [91;1mhow to turn a func into a method[0m
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)                                                                     (7)
                                    setattr(self, k, arg)                                                                                                                   (8)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m7[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                                if arg is not None:                                                                                                                         (5)
                                    if as_method: arg = method(arg)                                                                                                         (6)
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)=====================================================================(7)
                                                                                                                             [91;1mhow to give a method a different instance, like self[0m
                                    setattr(self, k, arg)                                                                                                                   (8)
                            old_init(self, *args, **kwargs)                                                                                                                 (9)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m8[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                                    if as_method: arg = method(arg)                                                                                                         (6)
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)                                                                     (7)
                                    setattr(self, k, arg)===================================================================================================================(8)
                                                                                                                                   [91;1mhow to add a method to a class as an attribute[0m
                            old_init(self, *args, **kwargs)                                                                                                                 (9)
                        functools.update_wrapper(_init, old_init)                                                                                                           (10)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m10[0m     ===============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                                    setattr(self, k, arg)                                                                                                                   (8)
                            old_init(self, *args, **kwargs)                                                                                                                 (9)
                        functools.update_wrapper(_init, old_init)===========================================================================================================(10)
                                                                                          [91;1mhow to wrap `_init` around `old_init`, so that `_init` can use `old_init` inside itself[0m
                        cls.__init__ = use_kwargs(cls._methods)(_init)                                                                                                      (11)
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))                                                     (12)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m11[0m     ===============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                            old_init(self, *args, **kwargs)                                                                                                                 (9)
                        functools.update_wrapper(_init, old_init)                                                                                                           (10)
                        cls.__init__ = use_kwargs(cls._methods)(_init)======================================================================================================(11)
                                                                            [91;1mhow to add a list of names with None as default value to function `_init` to repalce its kwargs param[0m
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))                                                     (12)
                        return cls                                                                                                                                          (13)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m12[0m     ===============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                        functools.update_wrapper(_init, old_init)                                                                                                           (10)
                        cls.__init__ = use_kwargs(cls._methods)(_init)                                                                                                      (11)
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))=====================================================(12)
                                                                   [91;1mhow to make a class.`__init__` signature to be the signature of the class using `__signature__` and `_rm_self`[0m
                        return cls                                                                                                                                          (13)
                                                                                                                                                                            (14)
                
                
                
                ```
                #| column: screen
                fdb.snoop() # how to snoop together with docsrc: snoop first and docsrc above it
                ```
                
                    22:28:59.99 >>> Call to funcs_kwargs in File "/tmp/funcs_kwargs.py", line 3
                    22:28:59.99 ...... as_method = <class 'fastcore.meta.T'>
                    22:28:59.99    3 | def funcs_kwargs(as_method=False):
                    22:28:59.99    5 |     if callable(as_method): return _funcs_kwargs(as_method, False)
                        22:28:59.99 >>> Call to _funcs_kwargs in File "/tmp/_funcs_kwargs.py", line 3
                        22:28:59.99 ...... cls = <class 'fastcore.meta.T'>
                        22:28:59.99 ...... as_method = False
                        22:28:59.99    3 | def _funcs_kwargs(cls, as_method):
                        22:28:59.99    4 |     old_init = cls.__init__
                        22:28:59.99 .......... old_init = <function T.__init__>
                        22:28:59.99    5 |     import snoop
                        22:28:59.99 .......... snoop = <class 'snoop.configuration.Config.__init__.<locals>.ConfiguredTracer'>
                        22:28:59.99    6 |     @snoop
                        22:28:59.99    7 |     def _init(self, *args, **kwargs):
                        22:28:59.99 .......... _init = <function _funcs_kwargs.<locals>._init>
                        22:28:59.99   15 |     functools.update_wrapper(_init, old_init)
                        22:28:59.99 .......... _init = <function T.__init__>
                        22:28:59.99   16 |     cls.__init__ = use_kwargs(cls._methods)(_init)
                        22:28:59.99   17 |     if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))
                        22:28:59.99   18 |     return cls
                        22:28:59.99 <<< Return value from _funcs_kwargs: <class 'fastcore.meta.T'>
                    22:28:59.99    5 |     if callable(as_method): return _funcs_kwargs(as_method, False)
                    22:28:59.99 <<< Return value from funcs_kwargs: <class 'fastcore.meta.T'>
                    22:28:59.99 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:28:59.99 .......... self = <fastcore.meta.T object>
                    22:28:59.99 .......... args = ()
                    22:28:59.99 .......... kwargs = {}
                    22:28:59.99 .......... as_method = False
                    22:28:59.99 .......... cls = <class 'fastcore.meta.T'>
                    22:28:59.99 .......... old_init = <function T.__init__>
                    22:28:59.99    7 |     def _init(self, *args, **kwargs):
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00 .............. k = 'b'
                    22:29:00.00    9 |             arg = kwargs.pop(k,None)
                    22:29:00.00 .................. arg = None
                    22:29:00.00   10 |             if arg is not None:
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00   14 |         old_init(self, *args, **kwargs)
                    22:29:00.00 <<< Return value from _funcs_kwargs.<locals>._init: None
                    22:29:00.00 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:29:00.00 .......... self = <fastcore.meta.T object>
                    22:29:00.00 .......... args = ()
                    22:29:00.00 .......... kwargs = {'b': <function _new_func>}
                    22:29:00.00 .......... len(kwargs) = 1
                    22:29:00.00 .......... as_method = False
                    22:29:00.00 .......... cls = <class 'fastcore.meta.T'>
                    22:29:00.00 .......... old_init = <function T.__init__>
                    22:29:00.00    7 |     def _init(self, *args, **kwargs):
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00 .............. k = 'b'
                    22:29:00.00    9 |             arg = kwargs.pop(k,None)
                    22:29:00.00 .................. kwargs = {}
                    22:29:00.00 .................. arg = <function _new_func>
                    22:29:00.00   10 |             if arg is not None:
                    22:29:00.00   11 |                 if as_method: arg = method(arg)
                    22:29:00.00   12 |                 if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)
                    22:29:00.00   13 |                 setattr(self, k, arg)
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00   14 |         old_init(self, *args, **kwargs)
                    22:29:00.00 <<< Return value from _funcs_kwargs.<locals>._init: None
                    22:29:00.00 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:29:00.00 .......... self = <fastcore.meta.T object>
                    22:29:00.00 .......... args = ()
                    22:29:00.00 .......... kwargs = {'a': <function <lambda>>}
                    22:29:00.00 .......... len(kwargs) = 1
                    22:29:00.00 .......... as_method = False
                    22:29:00.00 .......... cls = <class 'fastcore.meta.T'>
                    22:29:00.00 .......... old_init = <function T.__init__>
                    22:29:00.00    7 |     def _init(self, *args, **kwargs):
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00 .............. k = 'b'
                    22:29:00.00    9 |             arg = kwargs.pop(k,None)
                    22:29:00.00 .................. arg = None
                    22:29:00.00   10 |             if arg is not None:
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00   14 |         old_init(self, *args, **kwargs)
                    22:29:00.00 <<< Return value from _funcs_kwargs.<locals>._init: None
                    22:29:00.00 >>> Call to funcs_kwargs in File "/tmp/funcs_kwargs.py", line 3
                    22:29:00.00 ...... as_method = True
                    22:29:00.00    3 | def funcs_kwargs(as_method=False):
                    22:29:00.00    5 |     if callable(as_method): return _funcs_kwargs(as_method, False)
                    22:29:00.00    6 |     return partial(_funcs_kwargs, as_method=as_method)
                    22:29:00.00 <<< Return value from funcs_kwargs: functools.partial(<function _funcs_kwargs>, as_method=True)
                    22:29:00.00 >>> Call to _funcs_kwargs in File "/tmp/_funcs_kwargs.py", line 3
                    22:29:00.00 ...... cls = <class 'fastcore.meta.T'>
                    22:29:00.00 ...... as_method = True
                    22:29:00.00    3 | def _funcs_kwargs(cls, as_method):
                    22:29:00.00    4 |     old_init = cls.__init__
                    22:29:00.00 .......... old_init = <slot wrapper '__init__' of 'object' objects>
                    22:29:00.00    5 |     import snoop
                    22:29:00.00 .......... snoop = <class 'snoop.configuration.Config.__init__.<locals>.ConfiguredTracer'>
                    22:29:00.00    6 |     @snoop
                    22:29:00.00    7 |     def _init(self, *args, **kwargs):
                    22:29:00.00 .......... _init = <function _funcs_kwargs.<locals>._init>
                    22:29:00.00   15 |     functools.update_wrapper(_init, old_init)
                    22:29:00.00 .......... _init = <function object.__init__>
                    22:29:00.00   16 |     cls.__init__ = use_kwargs(cls._methods)(_init)
                    22:29:00.01   17 |     if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))
                    22:29:00.01   18 |     return cls
                    22:29:00.01 <<< Return value from _funcs_kwargs: <class 'fastcore.meta.T'>
                    22:29:00.01 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:29:00.01 .......... self = <fastcore.meta.T object>
                    22:29:00.01 .......... args = ()
                    22:29:00.01 .......... kwargs = {'b': <function _f>}
                    22:29:00.01 .......... len(kwargs) = 1
                    22:29:00.01 .......... as_method = True
                    22:29:00.01 .......... cls = <class 'fastcore.meta.T'>
                    22:29:00.01 .......... old_init = <slot wrapper '__init__' of 'object' objects>
                    22:29:00.01    7 |     def _init(self, *args, **kwargs):
                    22:29:00.01    8 |         for k in cls._methods:
                    22:29:00.01 .............. k = 'b'
                    22:29:00.01    9 |             arg = kwargs.pop(k,None)
                    22:29:00.01 .................. kwargs = {}
                    22:29:00.01 .................. arg = <function _f>
                    22:29:00.01   10 |             if arg is not None:
                    22:29:00.01   11 |                 if as_method: arg = method(arg)
                    22:29:00.01 ...... arg = <bound method int._f of 1>
                    22:29:00.01   12 |                 if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)
                    22:29:00.01 ...... arg = <bound method T._f of <fastcore.meta.T object>>
                    22:29:00.01   13 |                 setattr(self, k, arg)
                    22:29:00.01    8 |         for k in cls._methods:
                    22:29:00.01   14 |         old_init(self, *args, **kwargs)
                    22:29:00.01 <<< Return value from _funcs_kwargs.<locals>._init: None
                    22:29:00.01 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:29:00.01 .......... self = <fastcore.meta.T2 object>
                    22:29:00.01 .......... args = ()
                    22:29:00.01 .......... kwargs = {'b': <function _f>}
                    22:29:00.01 .......... len(kwargs) = 1
                    22:29:00.01 .......... as_method = True
                    22:29:00.01 .......... cls = <class 'fastcore.meta.T'>
                    22:29:00.01 .......... old_init = <slot wrapper '__init__' of 'object' objects>
                    22:29:00.01    7 |     def _init(self, *args, **kwargs):
                    22:29:00.01    8 |         for k in cls._methods:
                    22:29:00.01 .............. k = 'b'
                    22:29:00.01    9 |             arg = kwargs.pop(k,None)
                    22:29:00.01 .................. kwargs = {}
                    22:29:00.01 .................. arg = <function _f>
                    22:29:00.01   10 |             if arg is not None:
                    22:29:00.01   11 |                 if as_method: arg = method(arg)
                    22:29:00.01 ...... arg = <bound method int._f of 1>
                    22:29:00.01   12 |                 if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)
                    22:29:00.01 ...... arg = <bound method T2._f of <fastcore.meta.T2 object>>
                    22:29:00.01   13 |                 setattr(self, k, arg)
                    22:29:00.01    8 |         for k in cls._methods:
                    22:29:00.01   14 |         old_init(self, *args, **kwargs)
                    22:29:00.01 <<< Return value from _funcs_kwargs.<locals>._init: None
                
                
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                
                
                
                ```
                fdb_.debug()
                ```
                
                    _funcs_kwargs's dbsrc code: ==============
                    import snoop
                    @snoop
                    def _funcs_kwargs(cls, as_method):
                        old_init = cls.__init__
                        import snoop
                        @snoop
                        def _init(self, *args, **kwargs):
                            for k in cls._methods:
                                arg = kwargs.pop(k,None)
                                if arg is not None:
                                    if as_method: arg = method(arg)
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)
                                    setattr(self, k, arg)
                            old_init(self, *args, **kwargs)
                        functools.update_wrapper(_init, old_init)
                        cls.__init__ = use_kwargs(cls._methods)(_init)
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))
                        return cls
                    
                    
                    
                    _funcs_kwargs's example processed with dbsrc: ===============
                    
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    
                
                
                
                ```
                #| column: screen
                fdb.print()
                ```
                
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    def funcs_kwargs(as_method=False):========================================================(0)       
                        "Replace methods in `cls._methods` with those from `kwargs`"==========================(1) # [93;1mhow funcs_kwargs works[0m; [93;1mit is a wrapper around _funcs_kwargs[0m; [91;1mit offers two ways of running _funcs_kwargs[0m; [37;1mthe first, default way, is to add a func to a class without using self[0m; [91;1msecond way is to add func to class enabling self use;[0m; 
                        if callable(as_method): return _funcs_kwargs(as_method, False)========================(2) # [37;1mhow to check whether an object is callable[0m; [93;1mhow to return a result of running a func[0m; [37;1m[0m; 
                        return partial(_funcs_kwargs, as_method=as_method)====================================(3) # [92;1mhow to custom the params of `_funcs_kwargs` for a particular use with partial[0m; 
                                                                                                                                                                            (4)
                
                
                
                ```
                #| column: screen
                fdb_.print()
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m12[0m     ===============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    def _funcs_kwargs(cls, as_method):========================================================(0) # [93;1mhow does _funcs_kwargs work: _funcs_kwargs is a decorator[0m; [35;1mit helps class e.g., T to add more methods[0m; [93;1mI need to give the method a name, and put the name e.g., 'b' inside a list called _methods=['b'] inside class T[0m; [36;1mthen after writing a func e.g., _new_func, I can add it by T(b = _new_func)[0m; [36;1mif I want the func added to class to use self, I shall write @funcs_kwargs(as_method=True)[0m; 
                        old_init = cls.__init__===============================================================(1)       
                        def _init(self, *args, **kwargs):=====================================================(2) # [37;1mhow to define a method which can use self and accept any parameters[0m; 
                            for k in cls._methods:============================================================(3) # [35;1mhow to pop out the value of an item in a dict (with None as default), and if the item name is not found, pop out None instead[0m; [91;1m[0m; 
                                arg = kwargs.pop(k,None)======================================================(4)       
                                if arg is not None:===========================================================(5)       
                                    if as_method: arg = method(arg)===========================================(6) # [36;1mhow to turn a func into a method[0m; 
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)=======(7) # [93;1mhow to give a method a different instance, like self[0m; 
                                    setattr(self, k, arg)=====================================================(8) # [36;1mhow to add a method to a class as an attribute[0m; 
                            old_init(self, *args, **kwargs)===================================================(9)       
                        functools.update_wrapper(_init, old_init)=============================================(10) # [34;1mhow to wrap `_init` around `old_init`, so that `_init` can use `old_init` inside itself[0m; 
                        cls.__init__ = use_kwargs(cls._methods)(_init)========================================(11) # [34;1mhow to add a list of names with None as default value to function `_init` to repalce its kwargs param[0m; 
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__)) # [35;1mhow to make a class.`__init__` signature to be the signature of the class using `__signature__` and `_rm_self`[0m;  (12)
                        return cls============================================================================(13)      
                                                                                                                                                                            (14)
                
                
                
                ```
                
                ```
                
                
            
            
            
            [Open `0009_funcs_kwargs` in Jupyter Notebook](http://localhost:8888/tree/nbs/demos/0009_funcs_kwargs.ipynb)
            
            
            
        
        
        
        [Open `utils` in Jupyter Notebook](http://localhost:8888/tree/nbs/lib/utils.ipynb)
        
        
        
        
    
    
    
    [Open `utils` in Jupyter Notebook](http://localhost:8888/tree/nbs/lib/utils.ipynb)
    
    
    
    



[Open `utils` in Jupyter Notebook locally](http://localhost:8888/tree/nbs/lib/utils.ipynb)



###  <mark style="background-color: #ffff00">snoop:</mark>   <mark style="background-color: #ffff00">from</mark>   <mark style="background-color: #ffff00">_ <mark style="background-color: #FFFF00">funcs_kwargs</mark> </mark>   <mark style="background-color: #ffff00">to</mark>   <mark style="background-color: #FFFF00">funcs_kwargs</mark> 



    
    
    
        
        
        
            
            
            
                
                how to snoop on two functions one wrap around another: `funcs_kwargs` is a wrapper around `_funcs_kwargs`, so I can first snoop on `_funcs_kwargs` and assign its snoop dbsrc to \
                `fm._funcs_kwargs` so that when I snoop on `funcs_kwargs`, it can use the snoop dbsrc of `_funcs_kwargs` and no example codes need to change.
                
                
                ```
                from fastcore.meta import _funcs_kwargs
                ```
                
                
                ```
                fdb_ = Fastdb(_funcs_kwargs)
                fdb_.eg = """
                @funcs_kwargs
                class T:
                    _methods=['b'] # allows you to add method b upon instantiation
                    def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                    def a(self): return 1
                    def b(self): return 2
                    
                t = T()
                test_eq(t.a(), 1)
                test_eq(t.b(), 2)
                
                test_sig(T, '(f=1, *, b=None)')
                inspect.signature(T)
                
                def _new_func(): return 5
                
                t = T(b = _new_func)
                test_eq(t.b(), 5)
                
                t = T(a = lambda:3)
                test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                """
                ```
                
                
                ```
                #| column: screen
                # no snoop result, it is expected, because the example is not calling _funcs_kwargs, but funcs_kwargs
                fdb_.snoop(deco=True) # how to snoop decorator: _funcs_kwargs is a decorator, so set deco=True to see running codes in inner f
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    [0m     
                    
                
                
                
                ```
                import fastcore.meta as fm
                ```
                
                
                ```
                fm._funcs_kwargs = fdb_.dbsrc # how to snoop on two functions one wrap around another
                ```
                
                
                ```
                fdb = Fastdb(funcs_kwargs)
                fdb.eg = """
                @funcs_kwargs
                class T:
                    _methods=['b'] # allows you to add method b upon instantiation
                    def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                    def a(self): return 1
                    def b(self): return 2
                    
                t = T()
                test_eq(t.a(), 1)
                test_eq(t.b(), 2)
                
                test_sig(T, '(f=1, *, b=None)')
                inspect.signature(T)
                
                def _new_func(): return 5
                
                t = T(b = _new_func)
                test_eq(t.b(), 5)
                
                t = T(a = lambda:3)
                test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                
                def _f(self,a=1): return self.num + a # access the num attribute from the instance
                
                @funcs_kwargs(as_method=True)
                class T: 
                    _methods=['b']
                    num = 5
                    
                t = T(b = _f) # adds method b
                test_eq(t.b(5), 10) # self.num + 5 = 10
                
                def _f(self,a=1): return self.num * a #multiply instead of add 
                
                class T2(T):
                    def __init__(self,num):
                        super().__init__(b = _f) # add method b from the super class
                        self.num=num
                        
                t = T2(num=3)
                test_eq(t.b(a=5), 15) # 3 * 5 = 15
                test_sig(T2, '(num)')
                """
                ```
                
                
                ```
                #| column: screen
                fdb.print()
                ```
                
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    def funcs_kwargs(as_method=False):========================================================(0)       
                        "Replace methods in `cls._methods` with those from `kwargs`"==========================(1)       
                        if callable(as_method): return _funcs_kwargs(as_method, False)========================(2)       
                        return partial(_funcs_kwargs, as_method=as_method)====================================(3)       
                                                                                                                                                                            (4)
                
                
                
                ```
                #| column: screen
                fdb_.print()
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    def _funcs_kwargs(cls, as_method):========================================================(0)       
                        old_init = cls.__init__===============================================================(1)       
                        def _init(self, *args, **kwargs):=====================================================(2)       
                            for k in cls._methods:============================================================(3)       
                                arg = kwargs.pop(k,None)======================================================(4)       
                                if arg is not None:===========================================================(5)       
                                    if as_method: arg = method(arg)===========================================(6)       
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)=======(7)       
                                    setattr(self, k, arg)=====================================================(8)       
                            old_init(self, *args, **kwargs)===================================================(9)       
                        functools.update_wrapper(_init, old_init)=============================================(10)      
                        cls.__init__ = use_kwargs(cls._methods)(_init)========================================(11)      
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))                                                     (12)
                        return cls============================================================================(13)      
                                                                                                                                                                            (14)
                
                
                
                ```
                #| column: screen
                fdb.docsrc(1, "how funcs_kwargs works; it is a wrapper around _funcs_kwargs; it offers two ways of running _funcs_kwargs; \
                the first, default way, is to add a func to a class without using self; second way is to add func to class enabling self use;")
                fdb.docsrc(2, "how to check whether an object is callable; how to return a result of running a func; ")
                fdb.docsrc(3, "how to custom the params of `_funcs_kwargs` for a particular use with partial")
                ```
                
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m1[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                    def funcs_kwargs(as_method=False):                                                                                                                      (0)
                        "Replace methods in `cls._methods` with those from `kwargs`"========================================================================================(1)
                    [91;1mhow funcs_kwargs works; it is a wrapper around _funcs_kwargs; it offers two ways of running _funcs_kwargs; the first, default way, is to add a func to a class without using self; second way is to add func to class enabling self use;[0m
                        if callable(as_method): return _funcs_kwargs(as_method, False)                                                                                      (2)
                        return partial(_funcs_kwargs, as_method=as_method)                                                                                                  (3)
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m2[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                    def funcs_kwargs(as_method=False):                                                                                                                      (0)
                        "Replace methods in `cls._methods` with those from `kwargs`"                                                                                        (1)
                        if callable(as_method): return _funcs_kwargs(as_method, False)======================================================================================(2)
                                                                                           [91;1mhow to check whether an object is callable; how to return a result of running a func; [0m
                        return partial(_funcs_kwargs, as_method=as_method)                                                                                                  (3)
                                                                                                                                                                            (4)
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m3[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                        "Replace methods in `cls._methods` with those from `kwargs`"                                                                                        (1)
                        if callable(as_method): return _funcs_kwargs(as_method, False)                                                                                      (2)
                        return partial(_funcs_kwargs, as_method=as_method)==================================================================================================(3)
                                                                                                    [91;1mhow to custom the params of `_funcs_kwargs` for a particular use with partial[0m
                                                                                                                                                                            (4)
                
                
                
                ```
                #| column: screen
                fdb_.print()
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    def _funcs_kwargs(cls, as_method):========================================================(0)       
                        old_init = cls.__init__===============================================================(1)       
                        def _init(self, *args, **kwargs):=====================================================(2)       
                            for k in cls._methods:============================================================(3)       
                                arg = kwargs.pop(k,None)======================================================(4)       
                                if arg is not None:===========================================================(5)       
                                    if as_method: arg = method(arg)===========================================(6)       
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)=======(7)       
                                    setattr(self, k, arg)=====================================================(8)       
                            old_init(self, *args, **kwargs)===================================================(9)       
                        functools.update_wrapper(_init, old_init)=============================================(10)      
                        cls.__init__ = use_kwargs(cls._methods)(_init)========================================(11)      
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))                                                     (12)
                        return cls============================================================================(13)      
                                                                                                                                                                            (14)
                
                
                
                ```
                #| column: screen
                fdb_.docsrc(0, "how does _funcs_kwargs work: _funcs_kwargs is a decorator; it helps class e.g., T to add more methods; \
                I need to give the method a name, \
                and put the name e.g., 'b' inside a list called _methods=['b'] inside class T; \
                then after writing a func e.g., _new_func, I can add it by T(b = _new_func); if I want the func added to class to use self, \
                I shall write @funcs_kwargs(as_method=True)")
                fdb_.docsrc(2, "how to define a method which can use self and accept any parameters")
                fdb_.docsrc(3, "how to pop out the value of an item in a dict (with None as default), and if the item name is not found, pop out None instead; ")
                fdb_.docsrc(6, "how to turn a func into a method")
                fdb_.docsrc(7, "how to give a method a different instance, like self")
                fdb_.docsrc(8, "how to add a method to a class as an attribute")
                fdb_.docsrc(10, "how to wrap `_init` around `old_init`, so that `_init` can use `old_init` inside itself")
                fdb_.docsrc(11, "how to add a list of names with None as default value to function `_init` to repalce its kwargs param")
                fdb_.docsrc(12, "how to make a class.`__init__` signature to be the signature of the class using `__signature__` and `_rm_self`")
                
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m0[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                    def _funcs_kwargs(cls, as_method):======================================================================================================================(0)
                    [91;1mhow does _funcs_kwargs work: _funcs_kwargs is a decorator; it helps class e.g., T to add more methods; I need to give the method a name, and put the name e.g., 'b' inside a list called _methods=['b'] inside class T; then after writing a func e.g., _new_func, I can add it by T(b = _new_func); if I want the func added to class to use self, I shall write @funcs_kwargs(as_method=True)[0m
                        old_init = cls.__init__                                                                                                                             (1)
                        def _init(self, *args, **kwargs):                                                                                                                   (2)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m2[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                    def _funcs_kwargs(cls, as_method):                                                                                                                      (0)
                        old_init = cls.__init__                                                                                                                             (1)
                        def _init(self, *args, **kwargs):===================================================================================================================(2)
                                                                                                              [91;1mhow to define a method which can use self and accept any parameters[0m
                            for k in cls._methods:                                                                                                                          (3)
                                arg = kwargs.pop(k,None)                                                                                                                    (4)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m3[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                        old_init = cls.__init__                                                                                                                             (1)
                        def _init(self, *args, **kwargs):                                                                                                                   (2)
                            for k in cls._methods:==========================================================================================================================(3)
                                                  [91;1mhow to pop out the value of an item in a dict (with None as default), and if the item name is not found, pop out None instead; [0m
                                arg = kwargs.pop(k,None)                                                                                                                    (4)
                                if arg is not None:                                                                                                                         (5)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m6[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                                arg = kwargs.pop(k,None)                                                                                                                    (4)
                                if arg is not None:                                                                                                                         (5)
                                    if as_method: arg = method(arg)=========================================================================================================(6)
                                                                                                                                                 [91;1mhow to turn a func into a method[0m
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)                                                                     (7)
                                    setattr(self, k, arg)                                                                                                                   (8)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m7[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                                if arg is not None:                                                                                                                         (5)
                                    if as_method: arg = method(arg)                                                                                                         (6)
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)=====================================================================(7)
                                                                                                                             [91;1mhow to give a method a different instance, like self[0m
                                    setattr(self, k, arg)                                                                                                                   (8)
                            old_init(self, *args, **kwargs)                                                                                                                 (9)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m8[0m     ================================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                                    if as_method: arg = method(arg)                                                                                                         (6)
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)                                                                     (7)
                                    setattr(self, k, arg)===================================================================================================================(8)
                                                                                                                                   [91;1mhow to add a method to a class as an attribute[0m
                            old_init(self, *args, **kwargs)                                                                                                                 (9)
                        functools.update_wrapper(_init, old_init)                                                                                                           (10)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m10[0m     ===============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                                    setattr(self, k, arg)                                                                                                                   (8)
                            old_init(self, *args, **kwargs)                                                                                                                 (9)
                        functools.update_wrapper(_init, old_init)===========================================================================================================(10)
                                                                                          [91;1mhow to wrap `_init` around `old_init`, so that `_init` can use `old_init` inside itself[0m
                        cls.__init__ = use_kwargs(cls._methods)(_init)                                                                                                      (11)
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))                                                     (12)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m11[0m     ===============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                            old_init(self, *args, **kwargs)                                                                                                                 (9)
                        functools.update_wrapper(_init, old_init)                                                                                                           (10)
                        cls.__init__ = use_kwargs(cls._methods)(_init)======================================================================================================(11)
                                                                            [91;1mhow to add a list of names with None as default value to function `_init` to repalce its kwargs param[0m
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))                                                     (12)
                        return cls                                                                                                                                          (13)
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m12[0m     ===============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    [93;1mprint selected srcline with expands below[0m--------
                        functools.update_wrapper(_init, old_init)                                                                                                           (10)
                        cls.__init__ = use_kwargs(cls._methods)(_init)                                                                                                      (11)
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))=====================================================(12)
                                                                   [91;1mhow to make a class.`__init__` signature to be the signature of the class using `__signature__` and `_rm_self`[0m
                        return cls                                                                                                                                          (13)
                                                                                                                                                                            (14)
                
                
                
                ```
                #| column: screen
                fdb.snoop() # how to snoop together with docsrc: snoop first and docsrc above it
                ```
                
                    22:28:59.99 >>> Call to funcs_kwargs in File "/tmp/funcs_kwargs.py", line 3
                    22:28:59.99 ...... as_method = <class 'fastcore.meta.T'>
                    22:28:59.99    3 | def funcs_kwargs(as_method=False):
                    22:28:59.99    5 |     if callable(as_method): return _funcs_kwargs(as_method, False)
                        22:28:59.99 >>> Call to _funcs_kwargs in File "/tmp/_funcs_kwargs.py", line 3
                        22:28:59.99 ...... cls = <class 'fastcore.meta.T'>
                        22:28:59.99 ...... as_method = False
                        22:28:59.99    3 | def _funcs_kwargs(cls, as_method):
                        22:28:59.99    4 |     old_init = cls.__init__
                        22:28:59.99 .......... old_init = <function T.__init__>
                        22:28:59.99    5 |     import snoop
                        22:28:59.99 .......... snoop = <class 'snoop.configuration.Config.__init__.<locals>.ConfiguredTracer'>
                        22:28:59.99    6 |     @snoop
                        22:28:59.99    7 |     def _init(self, *args, **kwargs):
                        22:28:59.99 .......... _init = <function _funcs_kwargs.<locals>._init>
                        22:28:59.99   15 |     functools.update_wrapper(_init, old_init)
                        22:28:59.99 .......... _init = <function T.__init__>
                        22:28:59.99   16 |     cls.__init__ = use_kwargs(cls._methods)(_init)
                        22:28:59.99   17 |     if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))
                        22:28:59.99   18 |     return cls
                        22:28:59.99 <<< Return value from _funcs_kwargs: <class 'fastcore.meta.T'>
                    22:28:59.99    5 |     if callable(as_method): return _funcs_kwargs(as_method, False)
                    22:28:59.99 <<< Return value from funcs_kwargs: <class 'fastcore.meta.T'>
                    22:28:59.99 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:28:59.99 .......... self = <fastcore.meta.T object>
                    22:28:59.99 .......... args = ()
                    22:28:59.99 .......... kwargs = {}
                    22:28:59.99 .......... as_method = False
                    22:28:59.99 .......... cls = <class 'fastcore.meta.T'>
                    22:28:59.99 .......... old_init = <function T.__init__>
                    22:28:59.99    7 |     def _init(self, *args, **kwargs):
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00 .............. k = 'b'
                    22:29:00.00    9 |             arg = kwargs.pop(k,None)
                    22:29:00.00 .................. arg = None
                    22:29:00.00   10 |             if arg is not None:
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00   14 |         old_init(self, *args, **kwargs)
                    22:29:00.00 <<< Return value from _funcs_kwargs.<locals>._init: None
                    22:29:00.00 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:29:00.00 .......... self = <fastcore.meta.T object>
                    22:29:00.00 .......... args = ()
                    22:29:00.00 .......... kwargs = {'b': <function _new_func>}
                    22:29:00.00 .......... len(kwargs) = 1
                    22:29:00.00 .......... as_method = False
                    22:29:00.00 .......... cls = <class 'fastcore.meta.T'>
                    22:29:00.00 .......... old_init = <function T.__init__>
                    22:29:00.00    7 |     def _init(self, *args, **kwargs):
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00 .............. k = 'b'
                    22:29:00.00    9 |             arg = kwargs.pop(k,None)
                    22:29:00.00 .................. kwargs = {}
                    22:29:00.00 .................. arg = <function _new_func>
                    22:29:00.00   10 |             if arg is not None:
                    22:29:00.00   11 |                 if as_method: arg = method(arg)
                    22:29:00.00   12 |                 if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)
                    22:29:00.00   13 |                 setattr(self, k, arg)
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00   14 |         old_init(self, *args, **kwargs)
                    22:29:00.00 <<< Return value from _funcs_kwargs.<locals>._init: None
                    22:29:00.00 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:29:00.00 .......... self = <fastcore.meta.T object>
                    22:29:00.00 .......... args = ()
                    22:29:00.00 .......... kwargs = {'a': <function <lambda>>}
                    22:29:00.00 .......... len(kwargs) = 1
                    22:29:00.00 .......... as_method = False
                    22:29:00.00 .......... cls = <class 'fastcore.meta.T'>
                    22:29:00.00 .......... old_init = <function T.__init__>
                    22:29:00.00    7 |     def _init(self, *args, **kwargs):
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00 .............. k = 'b'
                    22:29:00.00    9 |             arg = kwargs.pop(k,None)
                    22:29:00.00 .................. arg = None
                    22:29:00.00   10 |             if arg is not None:
                    22:29:00.00    8 |         for k in cls._methods:
                    22:29:00.00   14 |         old_init(self, *args, **kwargs)
                    22:29:00.00 <<< Return value from _funcs_kwargs.<locals>._init: None
                    22:29:00.00 >>> Call to funcs_kwargs in File "/tmp/funcs_kwargs.py", line 3
                    22:29:00.00 ...... as_method = True
                    22:29:00.00    3 | def funcs_kwargs(as_method=False):
                    22:29:00.00    5 |     if callable(as_method): return _funcs_kwargs(as_method, False)
                    22:29:00.00    6 |     return partial(_funcs_kwargs, as_method=as_method)
                    22:29:00.00 <<< Return value from funcs_kwargs: functools.partial(<function _funcs_kwargs>, as_method=True)
                    22:29:00.00 >>> Call to _funcs_kwargs in File "/tmp/_funcs_kwargs.py", line 3
                    22:29:00.00 ...... cls = <class 'fastcore.meta.T'>
                    22:29:00.00 ...... as_method = True
                    22:29:00.00    3 | def _funcs_kwargs(cls, as_method):
                    22:29:00.00    4 |     old_init = cls.__init__
                    22:29:00.00 .......... old_init = <slot wrapper '__init__' of 'object' objects>
                    22:29:00.00    5 |     import snoop
                    22:29:00.00 .......... snoop = <class 'snoop.configuration.Config.__init__.<locals>.ConfiguredTracer'>
                    22:29:00.00    6 |     @snoop
                    22:29:00.00    7 |     def _init(self, *args, **kwargs):
                    22:29:00.00 .......... _init = <function _funcs_kwargs.<locals>._init>
                    22:29:00.00   15 |     functools.update_wrapper(_init, old_init)
                    22:29:00.00 .......... _init = <function object.__init__>
                    22:29:00.00   16 |     cls.__init__ = use_kwargs(cls._methods)(_init)
                    22:29:00.01   17 |     if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))
                    22:29:00.01   18 |     return cls
                    22:29:00.01 <<< Return value from _funcs_kwargs: <class 'fastcore.meta.T'>
                    22:29:00.01 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:29:00.01 .......... self = <fastcore.meta.T object>
                    22:29:00.01 .......... args = ()
                    22:29:00.01 .......... kwargs = {'b': <function _f>}
                    22:29:00.01 .......... len(kwargs) = 1
                    22:29:00.01 .......... as_method = True
                    22:29:00.01 .......... cls = <class 'fastcore.meta.T'>
                    22:29:00.01 .......... old_init = <slot wrapper '__init__' of 'object' objects>
                    22:29:00.01    7 |     def _init(self, *args, **kwargs):
                    22:29:00.01    8 |         for k in cls._methods:
                    22:29:00.01 .............. k = 'b'
                    22:29:00.01    9 |             arg = kwargs.pop(k,None)
                    22:29:00.01 .................. kwargs = {}
                    22:29:00.01 .................. arg = <function _f>
                    22:29:00.01   10 |             if arg is not None:
                    22:29:00.01   11 |                 if as_method: arg = method(arg)
                    22:29:00.01 ...... arg = <bound method int._f of 1>
                    22:29:00.01   12 |                 if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)
                    22:29:00.01 ...... arg = <bound method T._f of <fastcore.meta.T object>>
                    22:29:00.01   13 |                 setattr(self, k, arg)
                    22:29:00.01    8 |         for k in cls._methods:
                    22:29:00.01   14 |         old_init(self, *args, **kwargs)
                    22:29:00.01 <<< Return value from _funcs_kwargs.<locals>._init: None
                    22:29:00.01 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
                    22:29:00.01 .......... self = <fastcore.meta.T2 object>
                    22:29:00.01 .......... args = ()
                    22:29:00.01 .......... kwargs = {'b': <function _f>}
                    22:29:00.01 .......... len(kwargs) = 1
                    22:29:00.01 .......... as_method = True
                    22:29:00.01 .......... cls = <class 'fastcore.meta.T'>
                    22:29:00.01 .......... old_init = <slot wrapper '__init__' of 'object' objects>
                    22:29:00.01    7 |     def _init(self, *args, **kwargs):
                    22:29:00.01    8 |         for k in cls._methods:
                    22:29:00.01 .............. k = 'b'
                    22:29:00.01    9 |             arg = kwargs.pop(k,None)
                    22:29:00.01 .................. kwargs = {}
                    22:29:00.01 .................. arg = <function _f>
                    22:29:00.01   10 |             if arg is not None:
                    22:29:00.01   11 |                 if as_method: arg = method(arg)
                    22:29:00.01 ...... arg = <bound method int._f of 1>
                    22:29:00.01   12 |                 if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)
                    22:29:00.01 ...... arg = <bound method T2._f of <fastcore.meta.T2 object>>
                    22:29:00.01   13 |                 setattr(self, k, arg)
                    22:29:00.01    8 |         for k in cls._methods:
                    22:29:00.01   14 |         old_init(self, *args, **kwargs)
                    22:29:00.01 <<< Return value from _funcs_kwargs.<locals>._init: None
                
                
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                
                
                
                ```
                fdb_.debug()
                ```
                
                    _funcs_kwargs's dbsrc code: ==============
                    import snoop
                    @snoop
                    def _funcs_kwargs(cls, as_method):
                        old_init = cls.__init__
                        import snoop
                        @snoop
                        def _init(self, *args, **kwargs):
                            for k in cls._methods:
                                arg = kwargs.pop(k,None)
                                if arg is not None:
                                    if as_method: arg = method(arg)
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)
                                    setattr(self, k, arg)
                            old_init(self, *args, **kwargs)
                        functools.update_wrapper(_init, old_init)
                        cls.__init__ = use_kwargs(cls._methods)(_init)
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))
                        return cls
                    
                    
                    
                    _funcs_kwargs's example processed with dbsrc: ===============
                    
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    
                
                
                
                ```
                #| column: screen
                fdb.print()
                ```
                
                    =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
                    ==============================================================     on line [91;1mNone[0m     ==============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    def _f(self,a=1): return self.num + a # access the num attribute from the instance
                    
                    @funcs_kwargs(as_method=True)
                    class T: 
                        _methods=['b']
                        num = 5
                        
                    t = T(b = _f) # adds method b
                    test_eq(t.b(5), 10) # self.num + 5 = 10
                    
                    def _f(self,a=1): return self.num * a #multiply instead of add 
                    
                    class T2(T):
                        def __init__(self,num):
                            super().__init__(b = _f) # add method b from the super class
                            self.num=num
                            
                    t = T2(num=3)
                    test_eq(t.b(a=5), 15) # 3 * 5 = 15
                    test_sig(T2, '(num)')
                    [0m     
                    
                    def funcs_kwargs(as_method=False):========================================================(0)       
                        "Replace methods in `cls._methods` with those from `kwargs`"==========================(1) # [93;1mhow funcs_kwargs works[0m; [93;1mit is a wrapper around _funcs_kwargs[0m; [91;1mit offers two ways of running _funcs_kwargs[0m; [37;1mthe first, default way, is to add a func to a class without using self[0m; [91;1msecond way is to add func to class enabling self use;[0m; 
                        if callable(as_method): return _funcs_kwargs(as_method, False)========================(2) # [37;1mhow to check whether an object is callable[0m; [93;1mhow to return a result of running a func[0m; [37;1m[0m; 
                        return partial(_funcs_kwargs, as_method=as_method)====================================(3) # [92;1mhow to custom the params of `_funcs_kwargs` for a particular use with partial[0m; 
                                                                                                                                                                            (4)
                
                
                
                ```
                #| column: screen
                fdb_.print()
                ```
                
                    ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
                    ===============================================================     on line [91;1m12[0m     ===============================================================
                         with example [91;1m
                    @funcs_kwargs
                    class T:
                        _methods=['b'] # allows you to add method b upon instantiation
                        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
                        def a(self): return 1
                        def b(self): return 2
                        
                    t = T()
                    test_eq(t.a(), 1)
                    test_eq(t.b(), 2)
                    
                    test_sig(T, '(f=1, *, b=None)')
                    inspect.signature(T)
                    
                    def _new_func(): return 5
                    
                    t = T(b = _new_func)
                    test_eq(t.b(), 5)
                    
                    t = T(a = lambda:3)
                    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
                    
                    [0m     
                    
                    def _funcs_kwargs(cls, as_method):========================================================(0) # [93;1mhow does _funcs_kwargs work: _funcs_kwargs is a decorator[0m; [35;1mit helps class e.g., T to add more methods[0m; [93;1mI need to give the method a name, and put the name e.g., 'b' inside a list called _methods=['b'] inside class T[0m; [36;1mthen after writing a func e.g., _new_func, I can add it by T(b = _new_func)[0m; [36;1mif I want the func added to class to use self, I shall write @funcs_kwargs(as_method=True)[0m; 
                        old_init = cls.__init__===============================================================(1)       
                        def _init(self, *args, **kwargs):=====================================================(2) # [37;1mhow to define a method which can use self and accept any parameters[0m; 
                            for k in cls._methods:============================================================(3) # [35;1mhow to pop out the value of an item in a dict (with None as default), and if the item name is not found, pop out None instead[0m; [91;1m[0m; 
                                arg = kwargs.pop(k,None)======================================================(4)       
                                if arg is not None:===========================================================(5)       
                                    if as_method: arg = method(arg)===========================================(6) # [36;1mhow to turn a func into a method[0m; 
                                    if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)=======(7) # [93;1mhow to give a method a different instance, like self[0m; 
                                    setattr(self, k, arg)=====================================================(8) # [36;1mhow to add a method to a class as an attribute[0m; 
                            old_init(self, *args, **kwargs)===================================================(9)       
                        functools.update_wrapper(_init, old_init)=============================================(10) # [34;1mhow to wrap `_init` around `old_init`, so that `_init` can use `old_init` inside itself[0m; 
                        cls.__init__ = use_kwargs(cls._methods)(_init)========================================(11) # [34;1mhow to add a list of names with None as default value to function `_init` to repalce its kwargs param[0m; 
                        if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__)) # [35;1mhow to make a class.`__init__` signature to be the signature of the class using `__signature__` and `_rm_self`[0m;  (12)
                        return cls============================================================================(13)      
                                                                                                                                                                            (14)
                
                
                
                ```
                
                ```
                
                
            
            
            
            [Open `0009_funcs_kwargs` in Jupyter Notebook](http://localhost:8888/tree/nbs/demos/0009_funcs_kwargs.ipynb)
            
            
            
        
        
        
        [Open `utils` in Jupyter Notebook](http://localhost:8888/tree/nbs/lib/utils.ipynb)
        
        
        
        
    
    
    
    [Open `utils` in Jupyter Notebook](http://localhost:8888/tree/nbs/lib/utils.ipynb)
    
    
    
    



[Open `utils` in Jupyter Notebook locally](http://localhost:8888/tree/nbs/lib/utils.ipynb)



###  <mark style="background-color: #ffff00">snoop:</mark>   <mark style="background-color: #ffff00">from</mark>   <mark style="background-color: #ffff00">_ <mark style="background-color: #FFFF00">funcs_kwargs</mark> </mark>   <mark style="background-color: #ffff00">to</mark>   <mark style="background-color: #FFFF00">funcs_kwargs</mark> 



    
    how to snoop on two functions one wrap around another: `funcs_kwargs` is a wrapper around `_funcs_kwargs`, so I can first snoop on `_funcs_kwargs` and assign its snoop dbsrc to \
    `fm._funcs_kwargs` so that when I snoop on `funcs_kwargs`, it can use the snoop dbsrc of `_funcs_kwargs` and no example codes need to change.
    
    
    ```
    from fastcore.meta import _funcs_kwargs
    ```
    
    
    ```
    fdb_ = Fastdb(_funcs_kwargs)
    fdb_.eg = """
    @funcs_kwargs
    class T:
        _methods=['b'] # allows you to add method b upon instantiation
        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
        def a(self): return 1
        def b(self): return 2
        
    t = T()
    test_eq(t.a(), 1)
    test_eq(t.b(), 2)
    
    test_sig(T, '(f=1, *, b=None)')
    inspect.signature(T)
    
    def _new_func(): return 5
    
    t = T(b = _new_func)
    test_eq(t.b(), 5)
    
    t = T(a = lambda:3)
    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
    """
    ```
    
    
    ```
    #| column: screen
    # no snoop result, it is expected, because the example is not calling _funcs_kwargs, but funcs_kwargs
    fdb_.snoop(deco=True) # how to snoop decorator: _funcs_kwargs is a decorator, so set deco=True to see running codes in inner f
    ```
    
        ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
        ==============================================================     on line [91;1mNone[0m     ==============================================================
             with example [91;1m
        @funcs_kwargs
        class T:
            _methods=['b'] # allows you to add method b upon instantiation
            def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
            def a(self): return 1
            def b(self): return 2
            
        t = T()
        test_eq(t.a(), 1)
        test_eq(t.b(), 2)
        
        test_sig(T, '(f=1, *, b=None)')
        inspect.signature(T)
        
        def _new_func(): return 5
        
        t = T(b = _new_func)
        test_eq(t.b(), 5)
        
        t = T(a = lambda:3)
        test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
        [0m     
        
    
    
    
    ```
    import fastcore.meta as fm
    ```
    
    
    ```
    fm._funcs_kwargs = fdb_.dbsrc # how to snoop on two functions one wrap around another
    ```
    
    
    ```
    fdb = Fastdb(funcs_kwargs)
    fdb.eg = """
    @funcs_kwargs
    class T:
        _methods=['b'] # allows you to add method b upon instantiation
        def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
        def a(self): return 1
        def b(self): return 2
        
    t = T()
    test_eq(t.a(), 1)
    test_eq(t.b(), 2)
    
    test_sig(T, '(f=1, *, b=None)')
    inspect.signature(T)
    
    def _new_func(): return 5
    
    t = T(b = _new_func)
    test_eq(t.b(), 5)
    
    t = T(a = lambda:3)
    test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
    
    def _f(self,a=1): return self.num + a # access the num attribute from the instance
    
    @funcs_kwargs(as_method=True)
    class T: 
        _methods=['b']
        num = 5
        
    t = T(b = _f) # adds method b
    test_eq(t.b(5), 10) # self.num + 5 = 10
    
    def _f(self,a=1): return self.num * a #multiply instead of add 
    
    class T2(T):
        def __init__(self,num):
            super().__init__(b = _f) # add method b from the super class
            self.num=num
            
    t = T2(num=3)
    test_eq(t.b(a=5), 15) # 3 * 5 = 15
    test_sig(T2, '(num)')
    """
    ```
    
    
    ```
    #| column: screen
    fdb.print()
    ```
    
        =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
        ==============================================================     on line [91;1mNone[0m     ==============================================================
             with example [91;1m
        @funcs_kwargs
        class T:
            _methods=['b'] # allows you to add method b upon instantiation
            def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
            def a(self): return 1
            def b(self): return 2
            
        t = T()
        test_eq(t.a(), 1)
        test_eq(t.b(), 2)
        
        test_sig(T, '(f=1, *, b=None)')
        inspect.signature(T)
        
        def _new_func(): return 5
        
        t = T(b = _new_func)
        test_eq(t.b(), 5)
        
        t = T(a = lambda:3)
        test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
        
        def _f(self,a=1): return self.num + a # access the num attribute from the instance
        
        @funcs_kwargs(as_method=True)
        class T: 
            _methods=['b']
            num = 5
            
        t = T(b = _f) # adds method b
        test_eq(t.b(5), 10) # self.num + 5 = 10
        
        def _f(self,a=1): return self.num * a #multiply instead of add 
        
        class T2(T):
            def __init__(self,num):
                super().__init__(b = _f) # add method b from the super class
                self.num=num
                
        t = T2(num=3)
        test_eq(t.b(a=5), 15) # 3 * 5 = 15
        test_sig(T2, '(num)')
        [0m     
        
        def funcs_kwargs(as_method=False):========================================================(0)       
            "Replace methods in `cls._methods` with those from `kwargs`"==========================(1)       
            if callable(as_method): return _funcs_kwargs(as_method, False)========================(2)       
            return partial(_funcs_kwargs, as_method=as_method)====================================(3)       
                                                                                                                                                                (4)
    
    
    
    ```
    #| column: screen
    fdb_.print()
    ```
    
        ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
        ==============================================================     on line [91;1mNone[0m     ==============================================================
             with example [91;1m
        @funcs_kwargs
        class T:
            _methods=['b'] # allows you to add method b upon instantiation
            def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
            def a(self): return 1
            def b(self): return 2
            
        t = T()
        test_eq(t.a(), 1)
        test_eq(t.b(), 2)
        
        test_sig(T, '(f=1, *, b=None)')
        inspect.signature(T)
        
        def _new_func(): return 5
        
        t = T(b = _new_func)
        test_eq(t.b(), 5)
        
        t = T(a = lambda:3)
        test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
        
        [0m     
        
        def _funcs_kwargs(cls, as_method):========================================================(0)       
            old_init = cls.__init__===============================================================(1)       
            def _init(self, *args, **kwargs):=====================================================(2)       
                for k in cls._methods:============================================================(3)       
                    arg = kwargs.pop(k,None)======================================================(4)       
                    if arg is not None:===========================================================(5)       
                        if as_method: arg = method(arg)===========================================(6)       
                        if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)=======(7)       
                        setattr(self, k, arg)=====================================================(8)       
                old_init(self, *args, **kwargs)===================================================(9)       
            functools.update_wrapper(_init, old_init)=============================================(10)      
            cls.__init__ = use_kwargs(cls._methods)(_init)========================================(11)      
            if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))                                                     (12)
            return cls============================================================================(13)      
                                                                                                                                                                (14)
    
    
    
    ```
    #| column: screen
    fdb.docsrc(1, "how funcs_kwargs works; it is a wrapper around _funcs_kwargs; it offers two ways of running _funcs_kwargs; \
    the first, default way, is to add a func to a class without using self; second way is to add func to class enabling self use;")
    fdb.docsrc(2, "how to check whether an object is callable; how to return a result of running a func; ")
    fdb.docsrc(3, "how to custom the params of `_funcs_kwargs` for a particular use with partial")
    ```
    
        =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
        ===============================================================     on line [91;1m1[0m     ================================================================
             with example [91;1m
        @funcs_kwargs
        class T:
            _methods=['b'] # allows you to add method b upon instantiation
            def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
            def a(self): return 1
            def b(self): return 2
            
        t = T()
        test_eq(t.a(), 1)
        test_eq(t.b(), 2)
        
        test_sig(T, '(f=1, *, b=None)')
        inspect.signature(T)
        
        def _new_func(): return 5
        
        t = T(b = _new_func)
        test_eq(t.b(), 5)
        
        t = T(a = lambda:3)
        test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
        
        def _f(self,a=1): return self.num + a # access the num attribute from the instance
        
        @funcs_kwargs(as_method=True)
        class T: 
            _methods=['b']
            num = 5
            
        t = T(b = _f) # adds method b
        test_eq(t.b(5), 10) # self.num + 5 = 10
        
        def _f(self,a=1): return self.num * a #multiply instead of add 
        
        class T2(T):
            def __init__(self,num):
                super().__init__(b = _f) # add method b from the super class
                self.num=num
                
        t = T2(num=3)
        test_eq(t.b(a=5), 15) # 3 * 5 = 15
        test_sig(T2, '(num)')
        [0m     
        
        [93;1mprint selected srcline with expands below[0m--------
        def funcs_kwargs(as_method=False):                                                                                                                      (0)
            "Replace methods in `cls._methods` with those from `kwargs`"========================================================================================(1)
        [91;1mhow funcs_kwargs works; it is a wrapper around _funcs_kwargs; it offers two ways of running _funcs_kwargs; the first, default way, is to add a func to a class without using self; second way is to add func to class enabling self use;[0m
            if callable(as_method): return _funcs_kwargs(as_method, False)                                                                                      (2)
            return partial(_funcs_kwargs, as_method=as_method)                                                                                                  (3)
        =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
        ===============================================================     on line [91;1m2[0m     ================================================================
             with example [91;1m
        @funcs_kwargs
        class T:
            _methods=['b'] # allows you to add method b upon instantiation
            def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
            def a(self): return 1
            def b(self): return 2
            
        t = T()
        test_eq(t.a(), 1)
        test_eq(t.b(), 2)
        
        test_sig(T, '(f=1, *, b=None)')
        inspect.signature(T)
        
        def _new_func(): return 5
        
        t = T(b = _new_func)
        test_eq(t.b(), 5)
        
        t = T(a = lambda:3)
        test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
        
        def _f(self,a=1): return self.num + a # access the num attribute from the instance
        
        @funcs_kwargs(as_method=True)
        class T: 
            _methods=['b']
            num = 5
            
        t = T(b = _f) # adds method b
        test_eq(t.b(5), 10) # self.num + 5 = 10
        
        def _f(self,a=1): return self.num * a #multiply instead of add 
        
        class T2(T):
            def __init__(self,num):
                super().__init__(b = _f) # add method b from the super class
                self.num=num
                
        t = T2(num=3)
        test_eq(t.b(a=5), 15) # 3 * 5 = 15
        test_sig(T2, '(num)')
        [0m     
        
        [93;1mprint selected srcline with expands below[0m--------
        def funcs_kwargs(as_method=False):                                                                                                                      (0)
            "Replace methods in `cls._methods` with those from `kwargs`"                                                                                        (1)
            if callable(as_method): return _funcs_kwargs(as_method, False)======================================================================================(2)
                                                                               [91;1mhow to check whether an object is callable; how to return a result of running a func; [0m
            return partial(_funcs_kwargs, as_method=as_method)                                                                                                  (3)
                                                                                                                                                                (4)
        =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
        ===============================================================     on line [91;1m3[0m     ================================================================
             with example [91;1m
        @funcs_kwargs
        class T:
            _methods=['b'] # allows you to add method b upon instantiation
            def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
            def a(self): return 1
            def b(self): return 2
            
        t = T()
        test_eq(t.a(), 1)
        test_eq(t.b(), 2)
        
        test_sig(T, '(f=1, *, b=None)')
        inspect.signature(T)
        
        def _new_func(): return 5
        
        t = T(b = _new_func)
        test_eq(t.b(), 5)
        
        t = T(a = lambda:3)
        test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
        
        def _f(self,a=1): return self.num + a # access the num attribute from the instance
        
        @funcs_kwargs(as_method=True)
        class T: 
            _methods=['b']
            num = 5
            
        t = T(b = _f) # adds method b
        test_eq(t.b(5), 10) # self.num + 5 = 10
        
        def _f(self,a=1): return self.num * a #multiply instead of add 
        
        class T2(T):
            def __init__(self,num):
                super().__init__(b = _f) # add method b from the super class
                self.num=num
                
        t = T2(num=3)
        test_eq(t.b(a=5), 15) # 3 * 5 = 15
        test_sig(T2, '(num)')
        [0m     
        
        [93;1mprint selected srcline with expands below[0m--------
            "Replace methods in `cls._methods` with those from `kwargs`"                                                                                        (1)
            if callable(as_method): return _funcs_kwargs(as_method, False)                                                                                      (2)
            return partial(_funcs_kwargs, as_method=as_method)==================================================================================================(3)
                                                                                        [91;1mhow to custom the params of `_funcs_kwargs` for a particular use with partial[0m
                                                                                                                                                                (4)
    
    
    
    ```
    #| column: screen
    fdb_.print()
    ```
    
        ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
        ==============================================================     on line [91;1mNone[0m     ==============================================================
             with example [91;1m
        @funcs_kwargs
        class T:
            _methods=['b'] # allows you to add method b upon instantiation
            def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
            def a(self): return 1
            def b(self): return 2
            
        t = T()
        test_eq(t.a(), 1)
        test_eq(t.b(), 2)
        
        test_sig(T, '(f=1, *, b=None)')
        inspect.signature(T)
        
        def _new_func(): return 5
        
        t = T(b = _new_func)
        test_eq(t.b(), 5)
        
        t = T(a = lambda:3)
        test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
        
        [0m     
        
        def _funcs_kwargs(cls, as_method):========================================================(0)       
            old_init = cls.__init__===============================================================(1)       
            def _init(self, *args, **kwargs):=====================================================(2)       
                for k in cls._methods:============================================================(3)       
                    arg = kwargs.pop(k,None)======================================================(4)       
                    if arg is not None:===========================================================(5)       
                        if as_method: arg = method(arg)===========================================(6)       
                        if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)=======(7)       
                        setattr(self, k, arg)=====================================================(8)       
                old_init(self, *args, **kwargs)===================================================(9)       
            functools.update_wrapper(_init, old_init)=============================================(10)      
            cls.__init__ = use_kwargs(cls._methods)(_init)========================================(11)      
            if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))                                                     (12)
            return cls============================================================================(13)      
                                                                                                                                                                (14)
    
    
    
    ```
    #| column: screen
    fdb_.docsrc(0, "how does _funcs_kwargs work: _funcs_kwargs is a decorator; it helps class e.g., T to add more methods; \
    I need to give the method a name, \
    and put the name e.g., 'b' inside a list called _methods=['b'] inside class T; \
    then after writing a func e.g., _new_func, I can add it by T(b = _new_func); if I want the func added to class to use self, \
    I shall write @funcs_kwargs(as_method=True)")
    fdb_.docsrc(2, "how to define a method which can use self and accept any parameters")
    fdb_.docsrc(3, "how to pop out the value of an item in a dict (with None as default), and if the item name is not found, pop out None instead; ")
    fdb_.docsrc(6, "how to turn a func into a method")
    fdb_.docsrc(7, "how to give a method a different instance, like self")
    fdb_.docsrc(8, "how to add a method to a class as an attribute")
    fdb_.docsrc(10, "how to wrap `_init` around `old_init`, so that `_init` can use `old_init` inside itself")
    fdb_.docsrc(11, "how to add a list of names with None as default value to function `_init` to repalce its kwargs param")
    fdb_.docsrc(12, "how to make a class.`__init__` signature to be the signature of the class using `__signature__` and `_rm_self`")
    
    ```
    
        ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
        ===============================================================     on line [91;1m0[0m     ================================================================
             with example [91;1m
        @funcs_kwargs
        class T:
            _methods=['b'] # allows you to add method b upon instantiation
            def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
            def a(self): return 1
            def b(self): return 2
            
        t = T()
        test_eq(t.a(), 1)
        test_eq(t.b(), 2)
        
        test_sig(T, '(f=1, *, b=None)')
        inspect.signature(T)
        
        def _new_func(): return 5
        
        t = T(b = _new_func)
        test_eq(t.b(), 5)
        
        t = T(a = lambda:3)
        test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
        
        [0m     
        
        [93;1mprint selected srcline with expands below[0m--------
        def _funcs_kwargs(cls, as_method):======================================================================================================================(0)
        [91;1mhow does _funcs_kwargs work: _funcs_kwargs is a decorator; it helps class e.g., T to add more methods; I need to give the method a name, and put the name e.g., 'b' inside a list called _methods=['b'] inside class T; then after writing a func e.g., _new_func, I can add it by T(b = _new_func); if I want the func added to class to use self, I shall write @funcs_kwargs(as_method=True)[0m
            old_init = cls.__init__                                                                                                                             (1)
            def _init(self, *args, **kwargs):                                                                                                                   (2)
        ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
        ===============================================================     on line [91;1m2[0m     ================================================================
             with example [91;1m
        @funcs_kwargs
        class T:
            _methods=['b'] # allows you to add method b upon instantiation
            def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
            def a(self): return 1
            def b(self): return 2
            
        t = T()
        test_eq(t.a(), 1)
        test_eq(t.b(), 2)
        
        test_sig(T, '(f=1, *, b=None)')
        inspect.signature(T)
        
        def _new_func(): return 5
        
        t = T(b = _new_func)
        test_eq(t.b(), 5)
        
        t = T(a = lambda:3)
        test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
        
        [0m     
        
        [93;1mprint selected srcline with expands below[0m--------
        def _funcs_kwargs(cls, as_method):                                                                                                                      (0)
            old_init = cls.__init__                                                                                                                             (1)
            def _init(self, *args, **kwargs):===================================================================================================================(2)
                                                                                                  [91;1mhow to define a method which can use self and accept any parameters[0m
                for k in cls._methods:                                                                                                                          (3)
                    arg = kwargs.pop(k,None)                                                                                                                    (4)
        ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
        ===============================================================     on line [91;1m3[0m     ================================================================
             with example [91;1m
        @funcs_kwargs
        class T:
            _methods=['b'] # allows you to add method b upon instantiation
            def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
            def a(self): return 1
            def b(self): return 2
            
        t = T()
        test_eq(t.a(), 1)
        test_eq(t.b(), 2)
        
        test_sig(T, '(f=1, *, b=None)')
        inspect.signature(T)
        
        def _new_func(): return 5
        
        t = T(b = _new_func)
        test_eq(t.b(), 5)
        
        t = T(a = lambda:3)
        test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
        
        [0m     
        
        [93;1mprint selected srcline with expands below[0m--------
            old_init = cls.__init__                                                                                                                             (1)
            def _init(self, *args, **kwargs):                                                                                                                   (2)
                for k in cls._methods:==========================================================================================================================(3)
                                      [91;1mhow to pop out the value of an item in a dict (with None as default), and if the item name is not found, pop out None instead; [0m
                    arg = kwargs.pop(k,None)                                                                                                                    (4)
                    if arg is not None:                                                                                                                         (5)
        ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
        ===============================================================     on line [91;1m6[0m     ================================================================
             with example [91;1m
        @funcs_kwargs
        class T:
            _methods=['b'] # allows you to add method b upon instantiation
            def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
            def a(self): return 1
            def b(self): return 2
            
        t = T()
        test_eq(t.a(), 1)
        test_eq(t.b(), 2)
        
        test_sig(T, '(f=1, *, b=None)')
        inspect.signature(T)
        
        def _new_func(): return 5
        
        t = T(b = _new_func)
        test_eq(t.b(), 5)
        
        t = T(a = lambda:3)
        test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
        
        [0m     
        
        [93;1mprint selected srcline with expands below[0m--------
                    arg = kwargs.pop(k,None)                                                                                                                    (4)
                    if arg is not None:                                                                                                                         (5)
                        if as_method: arg = method(arg)=========================================================================================================(6)
                                                                                                                                     [91;1mhow to turn a func into a method[0m
                        if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)                                                                     (7)
                        setattr(self, k, arg)                                                                                                                   (8)
        ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
        ===============================================================     on line [91;1m7[0m     ================================================================
             with example [91;1m
        @funcs_kwargs
        class T:
            _methods=['b'] # allows you to add method b upon instantiation
            def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
            def a(self): return 1
            def b(self): return 2
            
        t = T()
        test_eq(t.a(), 1)
        test_eq(t.b(), 2)
        
        test_sig(T, '(f=1, *, b=None)')
        inspect.signature(T)
        
        def _new_func(): return 5
        
        t = T(b = _new_func)
        test_eq(t.b(), 5)
        
        t = T(a = lambda:3)
        test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
        
        [0m     
        
        [93;1mprint selected srcline with expands below[0m--------
                    if arg is not None:                                                                                                                         (5)
                        if as_method: arg = method(arg)                                                                                                         (6)
                        if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)=====================================================================(7)
                                                                                                                 [91;1mhow to give a method a different instance, like self[0m
                        setattr(self, k, arg)                                                                                                                   (8)
                old_init(self, *args, **kwargs)                                                                                                                 (9)
        ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
        ===============================================================     on line [91;1m8[0m     ================================================================
             with example [91;1m
        @funcs_kwargs
        class T:
            _methods=['b'] # allows you to add method b upon instantiation
            def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
            def a(self): return 1
            def b(self): return 2
            
        t = T()
        test_eq(t.a(), 1)
        test_eq(t.b(), 2)
        
        test_sig(T, '(f=1, *, b=None)')
        inspect.signature(T)
        
        def _new_func(): return 5
        
        t = T(b = _new_func)
        test_eq(t.b(), 5)
        
        t = T(a = lambda:3)
        test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
        
        [0m     
        
        [93;1mprint selected srcline with expands below[0m--------
                        if as_method: arg = method(arg)                                                                                                         (6)
                        if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)                                                                     (7)
                        setattr(self, k, arg)===================================================================================================================(8)
                                                                                                                       [91;1mhow to add a method to a class as an attribute[0m
                old_init(self, *args, **kwargs)                                                                                                                 (9)
            functools.update_wrapper(_init, old_init)                                                                                                           (10)
        ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
        ===============================================================     on line [91;1m10[0m     ===============================================================
             with example [91;1m
        @funcs_kwargs
        class T:
            _methods=['b'] # allows you to add method b upon instantiation
            def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
            def a(self): return 1
            def b(self): return 2
            
        t = T()
        test_eq(t.a(), 1)
        test_eq(t.b(), 2)
        
        test_sig(T, '(f=1, *, b=None)')
        inspect.signature(T)
        
        def _new_func(): return 5
        
        t = T(b = _new_func)
        test_eq(t.b(), 5)
        
        t = T(a = lambda:3)
        test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
        
        [0m     
        
        [93;1mprint selected srcline with expands below[0m--------
                        setattr(self, k, arg)                                                                                                                   (8)
                old_init(self, *args, **kwargs)                                                                                                                 (9)
            functools.update_wrapper(_init, old_init)===========================================================================================================(10)
                                                                              [91;1mhow to wrap `_init` around `old_init`, so that `_init` can use `old_init` inside itself[0m
            cls.__init__ = use_kwargs(cls._methods)(_init)                                                                                                      (11)
            if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))                                                     (12)
        ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
        ===============================================================     on line [91;1m11[0m     ===============================================================
             with example [91;1m
        @funcs_kwargs
        class T:
            _methods=['b'] # allows you to add method b upon instantiation
            def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
            def a(self): return 1
            def b(self): return 2
            
        t = T()
        test_eq(t.a(), 1)
        test_eq(t.b(), 2)
        
        test_sig(T, '(f=1, *, b=None)')
        inspect.signature(T)
        
        def _new_func(): return 5
        
        t = T(b = _new_func)
        test_eq(t.b(), 5)
        
        t = T(a = lambda:3)
        test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
        
        [0m     
        
        [93;1mprint selected srcline with expands below[0m--------
                old_init(self, *args, **kwargs)                                                                                                                 (9)
            functools.update_wrapper(_init, old_init)                                                                                                           (10)
            cls.__init__ = use_kwargs(cls._methods)(_init)======================================================================================================(11)
                                                                [91;1mhow to add a list of names with None as default value to function `_init` to repalce its kwargs param[0m
            if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))                                                     (12)
            return cls                                                                                                                                          (13)
        ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
        ===============================================================     on line [91;1m12[0m     ===============================================================
             with example [91;1m
        @funcs_kwargs
        class T:
            _methods=['b'] # allows you to add method b upon instantiation
            def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
            def a(self): return 1
            def b(self): return 2
            
        t = T()
        test_eq(t.a(), 1)
        test_eq(t.b(), 2)
        
        test_sig(T, '(f=1, *, b=None)')
        inspect.signature(T)
        
        def _new_func(): return 5
        
        t = T(b = _new_func)
        test_eq(t.b(), 5)
        
        t = T(a = lambda:3)
        test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
        
        [0m     
        
        [93;1mprint selected srcline with expands below[0m--------
            functools.update_wrapper(_init, old_init)                                                                                                           (10)
            cls.__init__ = use_kwargs(cls._methods)(_init)                                                                                                      (11)
            if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))=====================================================(12)
                                                       [91;1mhow to make a class.`__init__` signature to be the signature of the class using `__signature__` and `_rm_self`[0m
            return cls                                                                                                                                          (13)
                                                                                                                                                                (14)
    
    
    
    ```
    #| column: screen
    fdb.snoop() # how to snoop together with docsrc: snoop first and docsrc above it
    ```
    
        22:28:59.99 >>> Call to funcs_kwargs in File "/tmp/funcs_kwargs.py", line 3
        22:28:59.99 ...... as_method = <class 'fastcore.meta.T'>
        22:28:59.99    3 | def funcs_kwargs(as_method=False):
        22:28:59.99    5 |     if callable(as_method): return _funcs_kwargs(as_method, False)
            22:28:59.99 >>> Call to _funcs_kwargs in File "/tmp/_funcs_kwargs.py", line 3
            22:28:59.99 ...... cls = <class 'fastcore.meta.T'>
            22:28:59.99 ...... as_method = False
            22:28:59.99    3 | def _funcs_kwargs(cls, as_method):
            22:28:59.99    4 |     old_init = cls.__init__
            22:28:59.99 .......... old_init = <function T.__init__>
            22:28:59.99    5 |     import snoop
            22:28:59.99 .......... snoop = <class 'snoop.configuration.Config.__init__.<locals>.ConfiguredTracer'>
            22:28:59.99    6 |     @snoop
            22:28:59.99    7 |     def _init(self, *args, **kwargs):
            22:28:59.99 .......... _init = <function _funcs_kwargs.<locals>._init>
            22:28:59.99   15 |     functools.update_wrapper(_init, old_init)
            22:28:59.99 .......... _init = <function T.__init__>
            22:28:59.99   16 |     cls.__init__ = use_kwargs(cls._methods)(_init)
            22:28:59.99   17 |     if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))
            22:28:59.99   18 |     return cls
            22:28:59.99 <<< Return value from _funcs_kwargs: <class 'fastcore.meta.T'>
        22:28:59.99    5 |     if callable(as_method): return _funcs_kwargs(as_method, False)
        22:28:59.99 <<< Return value from funcs_kwargs: <class 'fastcore.meta.T'>
        22:28:59.99 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
        22:28:59.99 .......... self = <fastcore.meta.T object>
        22:28:59.99 .......... args = ()
        22:28:59.99 .......... kwargs = {}
        22:28:59.99 .......... as_method = False
        22:28:59.99 .......... cls = <class 'fastcore.meta.T'>
        22:28:59.99 .......... old_init = <function T.__init__>
        22:28:59.99    7 |     def _init(self, *args, **kwargs):
        22:29:00.00    8 |         for k in cls._methods:
        22:29:00.00 .............. k = 'b'
        22:29:00.00    9 |             arg = kwargs.pop(k,None)
        22:29:00.00 .................. arg = None
        22:29:00.00   10 |             if arg is not None:
        22:29:00.00    8 |         for k in cls._methods:
        22:29:00.00   14 |         old_init(self, *args, **kwargs)
        22:29:00.00 <<< Return value from _funcs_kwargs.<locals>._init: None
        22:29:00.00 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
        22:29:00.00 .......... self = <fastcore.meta.T object>
        22:29:00.00 .......... args = ()
        22:29:00.00 .......... kwargs = {'b': <function _new_func>}
        22:29:00.00 .......... len(kwargs) = 1
        22:29:00.00 .......... as_method = False
        22:29:00.00 .......... cls = <class 'fastcore.meta.T'>
        22:29:00.00 .......... old_init = <function T.__init__>
        22:29:00.00    7 |     def _init(self, *args, **kwargs):
        22:29:00.00    8 |         for k in cls._methods:
        22:29:00.00 .............. k = 'b'
        22:29:00.00    9 |             arg = kwargs.pop(k,None)
        22:29:00.00 .................. kwargs = {}
        22:29:00.00 .................. arg = <function _new_func>
        22:29:00.00   10 |             if arg is not None:
        22:29:00.00   11 |                 if as_method: arg = method(arg)
        22:29:00.00   12 |                 if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)
        22:29:00.00   13 |                 setattr(self, k, arg)
        22:29:00.00    8 |         for k in cls._methods:
        22:29:00.00   14 |         old_init(self, *args, **kwargs)
        22:29:00.00 <<< Return value from _funcs_kwargs.<locals>._init: None
        22:29:00.00 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
        22:29:00.00 .......... self = <fastcore.meta.T object>
        22:29:00.00 .......... args = ()
        22:29:00.00 .......... kwargs = {'a': <function <lambda>>}
        22:29:00.00 .......... len(kwargs) = 1
        22:29:00.00 .......... as_method = False
        22:29:00.00 .......... cls = <class 'fastcore.meta.T'>
        22:29:00.00 .......... old_init = <function T.__init__>
        22:29:00.00    7 |     def _init(self, *args, **kwargs):
        22:29:00.00    8 |         for k in cls._methods:
        22:29:00.00 .............. k = 'b'
        22:29:00.00    9 |             arg = kwargs.pop(k,None)
        22:29:00.00 .................. arg = None
        22:29:00.00   10 |             if arg is not None:
        22:29:00.00    8 |         for k in cls._methods:
        22:29:00.00   14 |         old_init(self, *args, **kwargs)
        22:29:00.00 <<< Return value from _funcs_kwargs.<locals>._init: None
        22:29:00.00 >>> Call to funcs_kwargs in File "/tmp/funcs_kwargs.py", line 3
        22:29:00.00 ...... as_method = True
        22:29:00.00    3 | def funcs_kwargs(as_method=False):
        22:29:00.00    5 |     if callable(as_method): return _funcs_kwargs(as_method, False)
        22:29:00.00    6 |     return partial(_funcs_kwargs, as_method=as_method)
        22:29:00.00 <<< Return value from funcs_kwargs: functools.partial(<function _funcs_kwargs>, as_method=True)
        22:29:00.00 >>> Call to _funcs_kwargs in File "/tmp/_funcs_kwargs.py", line 3
        22:29:00.00 ...... cls = <class 'fastcore.meta.T'>
        22:29:00.00 ...... as_method = True
        22:29:00.00    3 | def _funcs_kwargs(cls, as_method):
        22:29:00.00    4 |     old_init = cls.__init__
        22:29:00.00 .......... old_init = <slot wrapper '__init__' of 'object' objects>
        22:29:00.00    5 |     import snoop
        22:29:00.00 .......... snoop = <class 'snoop.configuration.Config.__init__.<locals>.ConfiguredTracer'>
        22:29:00.00    6 |     @snoop
        22:29:00.00    7 |     def _init(self, *args, **kwargs):
        22:29:00.00 .......... _init = <function _funcs_kwargs.<locals>._init>
        22:29:00.00   15 |     functools.update_wrapper(_init, old_init)
        22:29:00.00 .......... _init = <function object.__init__>
        22:29:00.00   16 |     cls.__init__ = use_kwargs(cls._methods)(_init)
        22:29:00.01   17 |     if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))
        22:29:00.01   18 |     return cls
        22:29:00.01 <<< Return value from _funcs_kwargs: <class 'fastcore.meta.T'>
        22:29:00.01 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
        22:29:00.01 .......... self = <fastcore.meta.T object>
        22:29:00.01 .......... args = ()
        22:29:00.01 .......... kwargs = {'b': <function _f>}
        22:29:00.01 .......... len(kwargs) = 1
        22:29:00.01 .......... as_method = True
        22:29:00.01 .......... cls = <class 'fastcore.meta.T'>
        22:29:00.01 .......... old_init = <slot wrapper '__init__' of 'object' objects>
        22:29:00.01    7 |     def _init(self, *args, **kwargs):
        22:29:00.01    8 |         for k in cls._methods:
        22:29:00.01 .............. k = 'b'
        22:29:00.01    9 |             arg = kwargs.pop(k,None)
        22:29:00.01 .................. kwargs = {}
        22:29:00.01 .................. arg = <function _f>
        22:29:00.01   10 |             if arg is not None:
        22:29:00.01   11 |                 if as_method: arg = method(arg)
        22:29:00.01 ...... arg = <bound method int._f of 1>
        22:29:00.01   12 |                 if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)
        22:29:00.01 ...... arg = <bound method T._f of <fastcore.meta.T object>>
        22:29:00.01   13 |                 setattr(self, k, arg)
        22:29:00.01    8 |         for k in cls._methods:
        22:29:00.01   14 |         old_init(self, *args, **kwargs)
        22:29:00.01 <<< Return value from _funcs_kwargs.<locals>._init: None
        22:29:00.01 >>> Call to _funcs_kwargs.<locals>._init in File "/tmp/_funcs_kwargs.py", line 7
        22:29:00.01 .......... self = <fastcore.meta.T2 object>
        22:29:00.01 .......... args = ()
        22:29:00.01 .......... kwargs = {'b': <function _f>}
        22:29:00.01 .......... len(kwargs) = 1
        22:29:00.01 .......... as_method = True
        22:29:00.01 .......... cls = <class 'fastcore.meta.T'>
        22:29:00.01 .......... old_init = <slot wrapper '__init__' of 'object' objects>
        22:29:00.01    7 |     def _init(self, *args, **kwargs):
        22:29:00.01    8 |         for k in cls._methods:
        22:29:00.01 .............. k = 'b'
        22:29:00.01    9 |             arg = kwargs.pop(k,None)
        22:29:00.01 .................. kwargs = {}
        22:29:00.01 .................. arg = <function _f>
        22:29:00.01   10 |             if arg is not None:
        22:29:00.01   11 |                 if as_method: arg = method(arg)
        22:29:00.01 ...... arg = <bound method int._f of 1>
        22:29:00.01   12 |                 if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)
        22:29:00.01 ...... arg = <bound method T2._f of <fastcore.meta.T2 object>>
        22:29:00.01   13 |                 setattr(self, k, arg)
        22:29:00.01    8 |         for k in cls._methods:
        22:29:00.01   14 |         old_init(self, *args, **kwargs)
        22:29:00.01 <<< Return value from _funcs_kwargs.<locals>._init: None
    
    
        =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
        ==============================================================     on line [91;1mNone[0m     ==============================================================
             with example [91;1m
        @funcs_kwargs
        class T:
            _methods=['b'] # allows you to add method b upon instantiation
            def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
            def a(self): return 1
            def b(self): return 2
            
        t = T()
        test_eq(t.a(), 1)
        test_eq(t.b(), 2)
        
        test_sig(T, '(f=1, *, b=None)')
        inspect.signature(T)
        
        def _new_func(): return 5
        
        t = T(b = _new_func)
        test_eq(t.b(), 5)
        
        t = T(a = lambda:3)
        test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
        
        def _f(self,a=1): return self.num + a # access the num attribute from the instance
        
        @funcs_kwargs(as_method=True)
        class T: 
            _methods=['b']
            num = 5
            
        t = T(b = _f) # adds method b
        test_eq(t.b(5), 10) # self.num + 5 = 10
        
        def _f(self,a=1): return self.num * a #multiply instead of add 
        
        class T2(T):
            def __init__(self,num):
                super().__init__(b = _f) # add method b from the super class
                self.num=num
                
        t = T2(num=3)
        test_eq(t.b(a=5), 15) # 3 * 5 = 15
        test_sig(T2, '(num)')
        [0m     
        
    
    
    
    ```
    fdb_.debug()
    ```
    
        _funcs_kwargs's dbsrc code: ==============
        import snoop
        @snoop
        def _funcs_kwargs(cls, as_method):
            old_init = cls.__init__
            import snoop
            @snoop
            def _init(self, *args, **kwargs):
                for k in cls._methods:
                    arg = kwargs.pop(k,None)
                    if arg is not None:
                        if as_method: arg = method(arg)
                        if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)
                        setattr(self, k, arg)
                old_init(self, *args, **kwargs)
            functools.update_wrapper(_init, old_init)
            cls.__init__ = use_kwargs(cls._methods)(_init)
            if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__))
            return cls
        
        
        
        _funcs_kwargs's example processed with dbsrc: ===============
        
        @funcs_kwargs
        class T:
            _methods=['b'] # allows you to add method b upon instantiation
            def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
            def a(self): return 1
            def b(self): return 2
            
        t = T()
        test_eq(t.a(), 1)
        test_eq(t.b(), 2)
        
        test_sig(T, '(f=1, *, b=None)')
        inspect.signature(T)
        
        def _new_func(): return 5
        
        t = T(b = _new_func)
        test_eq(t.b(), 5)
        
        t = T(a = lambda:3)
        test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
        
        
    
    
    
    ```
    #| column: screen
    fdb.print()
    ```
    
        =======================================================     Investigating [91;1mfuncs_kwargs[0m     =======================================================
        ==============================================================     on line [91;1mNone[0m     ==============================================================
             with example [91;1m
        @funcs_kwargs
        class T:
            _methods=['b'] # allows you to add method b upon instantiation
            def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
            def a(self): return 1
            def b(self): return 2
            
        t = T()
        test_eq(t.a(), 1)
        test_eq(t.b(), 2)
        
        test_sig(T, '(f=1, *, b=None)')
        inspect.signature(T)
        
        def _new_func(): return 5
        
        t = T(b = _new_func)
        test_eq(t.b(), 5)
        
        t = T(a = lambda:3)
        test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
        
        def _f(self,a=1): return self.num + a # access the num attribute from the instance
        
        @funcs_kwargs(as_method=True)
        class T: 
            _methods=['b']
            num = 5
            
        t = T(b = _f) # adds method b
        test_eq(t.b(5), 10) # self.num + 5 = 10
        
        def _f(self,a=1): return self.num * a #multiply instead of add 
        
        class T2(T):
            def __init__(self,num):
                super().__init__(b = _f) # add method b from the super class
                self.num=num
                
        t = T2(num=3)
        test_eq(t.b(a=5), 15) # 3 * 5 = 15
        test_sig(T2, '(num)')
        [0m     
        
        def funcs_kwargs(as_method=False):========================================================(0)       
            "Replace methods in `cls._methods` with those from `kwargs`"==========================(1) # [93;1mhow funcs_kwargs works[0m; [93;1mit is a wrapper around _funcs_kwargs[0m; [91;1mit offers two ways of running _funcs_kwargs[0m; [37;1mthe first, default way, is to add a func to a class without using self[0m; [91;1msecond way is to add func to class enabling self use;[0m; 
            if callable(as_method): return _funcs_kwargs(as_method, False)========================(2) # [37;1mhow to check whether an object is callable[0m; [93;1mhow to return a result of running a func[0m; [37;1m[0m; 
            return partial(_funcs_kwargs, as_method=as_method)====================================(3) # [92;1mhow to custom the params of `_funcs_kwargs` for a particular use with partial[0m; 
                                                                                                                                                                (4)
    
    
    
    ```
    #| column: screen
    fdb_.print()
    ```
    
        ======================================================     Investigating [91;1m_funcs_kwargs[0m     =======================================================
        ===============================================================     on line [91;1m12[0m     ===============================================================
             with example [91;1m
        @funcs_kwargs
        class T:
            _methods=['b'] # allows you to add method b upon instantiation
            def __init__(self, f=1, **kwargs): pass # don't forget to include **kwargs in __init__
            def a(self): return 1
            def b(self): return 2
            
        t = T()
        test_eq(t.a(), 1)
        test_eq(t.b(), 2)
        
        test_sig(T, '(f=1, *, b=None)')
        inspect.signature(T)
        
        def _new_func(): return 5
        
        t = T(b = _new_func)
        test_eq(t.b(), 5)
        
        t = T(a = lambda:3)
        test_eq(t.a(), 1) # the attempt to add a is ignored and uses the original method instead.
        
        [0m     
        
        def _funcs_kwargs(cls, as_method):========================================================(0) # [93;1mhow does _funcs_kwargs work: _funcs_kwargs is a decorator[0m; [35;1mit helps class e.g., T to add more methods[0m; [93;1mI need to give the method a name, and put the name e.g., 'b' inside a list called _methods=['b'] inside class T[0m; [36;1mthen after writing a func e.g., _new_func, I can add it by T(b = _new_func)[0m; [36;1mif I want the func added to class to use self, I shall write @funcs_kwargs(as_method=True)[0m; 
            old_init = cls.__init__===============================================================(1)       
            def _init(self, *args, **kwargs):=====================================================(2) # [37;1mhow to define a method which can use self and accept any parameters[0m; 
                for k in cls._methods:============================================================(3) # [35;1mhow to pop out the value of an item in a dict (with None as default), and if the item name is not found, pop out None instead[0m; [91;1m[0m; 
                    arg = kwargs.pop(k,None)======================================================(4)       
                    if arg is not None:===========================================================(5)       
                        if as_method: arg = method(arg)===========================================(6) # [36;1mhow to turn a func into a method[0m; 
                        if isinstance(arg,MethodType): arg = MethodType(arg.__func__, self)=======(7) # [93;1mhow to give a method a different instance, like self[0m; 
                        setattr(self, k, arg)=====================================================(8) # [36;1mhow to add a method to a class as an attribute[0m; 
                old_init(self, *args, **kwargs)===================================================(9)       
            functools.update_wrapper(_init, old_init)=============================================(10) # [34;1mhow to wrap `_init` around `old_init`, so that `_init` can use `old_init` inside itself[0m; 
            cls.__init__ = use_kwargs(cls._methods)(_init)========================================(11) # [34;1mhow to add a list of names with None as default value to function `_init` to repalce its kwargs param[0m; 
            if hasattr(cls, '__signature__'): cls.__signature__ = _rm_self(inspect.signature(cls.__init__)) # [35;1mhow to make a class.`__init__` signature to be the signature of the class using `__signature__` and `_rm_self`[0m;  (12)
            return cls============================================================================(13)      
                                                                                                                                                                (14)
    
    
    
    ```
    
    ```
    
    



[Open `0009_funcs_kwargs` in Jupyter Notebook locally](http://localhost:8888/tree/nbs/demos/0009_funcs_kwargs.ipynb)



```
fastlistnbs()
```

    
    /Users/Natsume/Documents/fastdebug/mds/2022part1/0004_fastai_how_neuralnet_work.md
    ## Fitting a function with *gradient descent*
    ### Is neuralnet just a math function? what does the function look like?
    ### why neuralnet is random at first and how to make neuralnet useful
    ### `plot_function`: how to plot a function with plt; how to create x input with torch.linspace; how to plot x, y, color and title with plt;
    ### how to create a particular quadratic function
    ### how to write a function `quad` to create any quadratic function
    ### how does `partial` and `quad` work to modify `quad` to a slightly different func?
    ### how to add noise to both mult and add of the neuralnet/function; how to create noise using `np.random.normal`
    ### how to create a random seed to ensure x and y are the same each run
    ## A numpy book recommended by Jeremy; what is a tensor
    ### how to scatterplot with plt
    ### how to plot a scatterplot and a line and slides for 3 params of the line func
    ### why need a loss function? how to write a mean absolute error function with torch.abs and mean
    ### how display and change loss by changing values of params with sliders of interactive plot
    ### A 15-min calculus video series recommended by Jeremy to watch first
    ## Automating gradient descent
    ### how derivatives automatically guide params to change for a lower loss
    ### how to create a mean absolute error function on any quadratic model
    ### how to create an random tensor with 3 values as initialized params
    ### how to calc gradients of params? 1. tell PyTorch to get ready for calculating gradients for these params; 2. calc loss; 3. calc the gradients with `loss.backward()`; 4. how to access params' gradients; 
    ### how to change params with gradients properly to lower loss¶
    ### why `with torch.no_grad():` when updating params with gradients
    ### how to do 10 iterations of updating params with gradients
    ## How a neural network approximates any given function
    ## how to combine a linear func with max(x, 0) into a rectified linear function; how to use torch.clip(y, 0.) to perform max(y, 0.)
    ## how to use partial to wrap rectified_linear to create a specific rectified_linear func
    ## how to use `F.relu` to replace `torch.clip` to create a rectified linear func; 
    ### create double and quaduple relu func/neuralnet
    ## How to recognise an owl
    ### deep learning basically is drawing squiggly lines infinitely given computation and time
    
    /Users/Natsume/Documents/fastdebug/mds/2022part1/0001_fastai_is_it_a_bird.md
    ## Useful Course sites
    ## How to use autoreload
    ## How to install and update libraries
    ## Know a little about the libraries
    ### what is fastai
    ### what is duckduckgo
    ## How to use fastdebug with fastai notebooks
    ### how to use fastdebug
    ### Did I document it in a notebook before?
    ### Did I document it in a src before?
    ## how to search and get a url of an image; how to download with an url; how to view an image;
    ### how to create folders using path; how to search and download images in folders; how to resize images 
    ## Train my model
    ### How to find and unlink images not properly downloaded
    ### How to create a DataLoaders with DataBlock; how to view data with it
    ### How to build my model with dataloaders and pretrained model; how to train my model
    ### How to predict with my model; how to avoid running cells in nbdev_prepare
    
    /Users/Natsume/Documents/fastdebug/mds/2022part1/0006_fastai_why_should_use_framework.md
    ## Introduction and set up
    ### what are the benefits of using fastai and PyTorch frameworks
    ### which fastai module is for tabular data; how to set float format display for pandas; how to set random seed;
    ## Prep the data
    ### no worry of dummy variables, normalization, missing values and so on if using fastai; interesting feature ideas from a nice Titanic feature notebook;
    ### how to create a tabular dataloaders with `TabularPandas` which handles all messing processing; how to set the parameters of `TabularPandas`
    ## Train the model
    ### how to create a tabular learner using tabular dataloader, metrics and layers
    ### how to find the learning rate automatically in fastai
    ### how to pick the best learning rate from the learning rate curve; how to train model 16 epochs using `learn.fit`
    ## Submit to Kaggle
    ### how to prepare test data including added new features
    ### how to apply all the processing steps of training data to test data with `learn.dls.test_dl`
    ### how to calc all predictions for test set using `learn.get_preds`
    ### how to prepare the results of test set into a csv file for kaggle submission; how to save into csv file without idx number
    ## Ensembling
    ### what is ensembling and why it is more robust than any single model
    ## Final thoughts
    
    /Users/Natsume/Documents/fastdebug/mds/2022part1/0002_fastai_saving_a_basic_fastai_model.md
    ## what to import to handle vision problems in fastai
    ## how to download and decompress datasets prepared by fastai
    ## how to tell it is a cat by reading filename
    ## how to create dataloaders with `from_name_func`
    ## how to create a pretrained model with resnet18 and error_rate; how to fine tune it 3 epochs
    ## how to export model to a pickle file and download it from Kaggle
    ## how to convert ipynb to md
    
    /Users/Natsume/Documents/fastdebug/mds/2022part1/0005_fastai_linear_neuralnet_scratch.md
    ## how to not execute the entire notebook
    ## Introduction
    ## How to download kaggle dataset to your local machine or colab? how to ues kaggle api and zipfile to download data into specified folder; how to use `pathlib.Path` to create a path;
    ## how to set the print display option for numpy, torch and pandas
    ## Cleaning the data
    ### how to read csv file with pandas and `path/'subfolder_name'`
    ### why missing value is a problem? how to find out the num of missing values of each column with pandas?
    ### which value is most used to replace missing value? how to get mode for each column with pandas using `iloc[0]`
    ### how to use pandas `iloc` function
    ### how to fill missing values with mode without making a new copy with `pandas.fillna`
    ### how to get a quick summary of all the numeric columns with pandas and numpy
    ### what is long-tailed data in histogram and why it is a problem for neuralnet
    ### how to plot histogram with pandas on a single column
    ### how to fix long-tailed data with logarithm; why should logarithm work; how to handle zero values when applying logarithm
    ### how to get a quick summary of all the non-numeric columns with pandas
    ### when do we need dummy variables and how to create dummy variables with pandas
    ### how to check the first few rows of selected columns with pandas
    ### how to create dependent/target variable and independent/predictor variables in PyTorch tensors; how to create variables in tensor from pandas dataframe
    ### how to check the size (rows and columns) of independent variables in tensor
    ## Setting up a linear model
    ### how to create coefficients for each (column) of our independent variables; how to get random seed in torch; how to get the num of columns; how to create random number between -0.5 and 0.5;
    ### why no bias or a constant is needed for this Titanic dataset?
    ### why a column `Age` having higher values than other columns can cause problem for our model; how to solve this problem by making them the same scale; how to get the max value of each column with pandas dataframe max func
    ### what is maxtrix by vector operation (multiply or divide)
    ### How to calculate the prediction of a linear model
    ### how to look at the first 10 values of predictions
    ### how to calc mean absolute error
    ### how to calc predictions with a func `calc_preds`; how to calc loss with a func `calc_loss`
    ## Doing a gradient descent step
    ### How to cacl gradients for coefficients
    ### why set gradients to zero after each gradient descent step; how to set gradient to zero; how to do one iteration of training
    ### what does _ mean for `coeffs.sub_()` and `grad.zero_()`
    ## Training the linear model
    ### how to split the dataset by using train and valid idx produced by `fastai.data.transforms.RandomSplitter`
    ### how to udpate coefficients in a function `update_coeffs`
    ### how to do one epoch training in a function `one_epoch`
    ### how to initializing coefficients in a function `init_coeffs`
    ### how to integrate funcs above to form a function `train_model` on multiple epochs
    ### how to display coefficients of the model with func `show_coeffs`
    ## Measuring accuracy
    ### There are many possible loss options such as accuracy other than mean absolute error
    ### how to calc accuracy for the binary dependent variable
    ### how to wrap the process of calc accuracy using coeffs into a func `acc(coeffs)`
    ## Using sigmoid
    ### when will we be needing something like sigmoid
    ### how to write and plot a func like `sigmoid` using sympy
    ### how to update `calc_preds` by wrapping `torch.sigmoid` around prediction
    ## Submitting to Kaggle
    ### read test data using `pandas.read_csv`
    ### why and how to fill the missing value in Fare column with 0 instead of mode
    ### how to handle missing values, long-tailed distribution and dummies together for test data
    ### how to turn independent variable values into tensor
    ### how to make sure independent variable in test data share the same value scare with those in training data
    ### how to turn true or false into 1 or 0 and save them into a column
    ### how to select two columns of a dataframe and save them into a csv file using `to_csv`
    ### how to check the first few lines of the csv file using `!head`
    ## Using matrix product
    ### how to do matrix product `@` between a matrix and a vector with PyTorch; how to use `@` instead of doing multiplication and then addition together
    ### update `calc_preds` func using matrix multiplication `@`
    ### how to initialize coeffs and turn it into a matrix with a single column; question: but why make coeffs between 0 and 0.1 instead of -0.5 and 0.5
    ### how to turn a single column of dependent variable into a single column matrix or a column vector
    ### question: why set learning rate to be 100 for this Titanic model
    ## A neural network
    ### how to initialize coeffs for a neuralnet with two layers (including a hidden layer of n neurons) and the final output layer is a single neuron with a single coeff; question: how do `-0.5` and `-0.3` come from?
    ### how to update `calc_preds` for this 2 layer neuralnet using `F.relu`, matrix product `@`, and `torch.sigmoid`
    ### how to update coeffs layer by layer with `layer.sub_` and `layer.grad.zero_`
    ### question: how the learning rate is chosen (1.4 or 20) when training
    ## Deep learning
    ### how to move from neuralnet with one hidden layer to a deep learning
    ### why so many messy constants and how they block the progress of deep learning in the early days
    ### how to use `enumerate` to loop both idx and item
    ## Final thoughts
    ### How much similar or different between practical models and the models from scratch above
    
    /Users/Natsume/Documents/fastdebug/mds/2022part1/0003_fastai_which_image_model_best.md
    ## timm
    ## how to git clone TIMM analysis data; how to enter a directory with %cd
    ## how to read a csv file with pandas
    ## how to merge data with pandas; how to create new column with pandas; how to string extract with regex expression; how to select columns up to a particular column with pandas; how to do loc in pandas; how to select a group of columns using str.contains and regex
    ## Inference results
    ### how to scatterplot with plotly.express; how to set the plot's width, height, size, title, x, y, log_x, color, hover_name, hover_data; 
    ### how to scatterplot on a subgroup of data using regex and plotly
    ## Training results
    ### convert ipynb to md
    
    /Users/Natsume/Documents/fastdebug/mds/lib/utils.md
    ## setup for exporting to a module
    ## how to get current notebook's name, path and url
    ## how to convert ipynb to md automatically; how to run commands in python
    ## Autoreload for every notebook
    ## Expand cells
    ## Import fastcore env
    ## to inspect a class
    ### get the docs for each function of a class
    ## is it a metaclass?
    ## is it a decorator
    ### handle all kinds of exceptions for evaluating retn 
    ## whatinside a module of a library
    ### show the type of objects inside `__all__`
    ### working for fastdebug.core
    ### to show Fastdb methods
    ## whichversion of a library
    ## fastview
    ## fastscrs
    ## getrootport
    ## jn_link
    ## get_all_nbs
    ### get all nbs path for both md and ipynb
    ### add index.ipynb
    ## openNB
    ## openNBKaggle
    ## highlight
    ## display_md
    ## display_block
    ### handle both file path and file content at the same time
    ## fastnbs
    ## fastcodes
    ## fastnotes
    ### multiple folders
    ## fastlistnbs
    ## fastlistsrcs
    ## Best practice of fastdebug.core
    ## Best practice of fastdebug.utils
    ## Export
    
    /Users/Natsume/Documents/fastdebug/mds/lib/00_core.md
    ## make life easier with defaults  
    ## globals() and locals()
    ## Execute strings
    ### new variable or updated variable by exec will only be accessible from locals()
    ### eval can override its own globals() and locals()
    ### when exec update existing functions
    ### when the func to be udpated involve other libraries
    ### inside a function, exec() allow won't give you necessary env from function namespace
    ### magic of `exec(b, globals().update(locals()))`
    ### Bring variables from a func namespace to the sideout world
    ### globals() in a cell vs globals() in a func
    ## make a colorful string
    ## align text to the most right
    ## printsrcwithidx
    ### print the entire source code with idx from 0
    ### print the whole src with idx or print them in parts
    ### use cmts from dbprint to print out src with comments
    ### no more update for printsrcwithidx, for the latest see Fastdb.print
    ## print out src code
    ### basic version
    ### print src with specific number of lines
    ### make the naming more sensible
    ### Allow a dbline occur more than once
    ### adding idx to the selected srclines
    #### printsrclinewithidx
    ### dblines can be string of code or idx number
    ### avoid multi-occurrance of the same srcline
    ## dbprint on expression
    ### basic version
    ### insert dbcode and make a new dbfunc
    ### Bring outside namespace variables into exec()
    ### Bring what inside the func namespace variables to the outside world
    ### Adding g = locals() to dbprintinsert to avoid adding env individually
    ### enable srclines to be either string or int 
    ### enable = to be used as assignment in codes
    ### avoid adding "env=g" for dbprintinsert
    ### collect cmt for later printsrcwithidx to print comments together
    ### make sure only one line with correct idx is debugged
    ### avoid typing "" when there is no codes
    ### no more update for dbprint, for the latest see Fastdb.dbprint
    ### use dbprint to override the original official code without changing its own pyfile
    ## dbprintinsert
    ### Run and display the inserted dbcodes 
    ### use locals() inside the dbsrc code to avoid adding env individually
    ### enable dbprintinsert to do exec on a block of code
    ## printrunsrclines() 
    ### Examples
    #### simple example
    #### complex example
    ### insert a line after each srcline to add idx
    ### add correct indentation to each inserted line
    #### count the indentation for each srcline
    ### indentation special case: if, else, for, def
    ### remove pure comments or docs from dbsrc
    ### print out the srclines which get run
    ### Make sure all if, else, for get printed
    ### Put all together into the function printrunsrclines()
    #### no more renaming of foo
    #### add example as a param into the function
    #### improve on search for `if`, else, for, def to avoid errors for more examples
    #### remove an empty line with indentation
    ### make it work
    ### more difficult examples to test printrunsrc()
    ## Make fastdebug a class
    ### improve on the line idx readability
    ### collect cmt from dbprint and print
    ### make sure only the line with correct idx is debugged
    ### having "" or "   " inside codes without causing error
    ### replace Fastdb.printsrcwithdix with Fastdb.print
    ### add idx to dbsrc when showdbsrc=True
    ### not load the inner locals() to outenv can prevent mysterious printing of previous db messages
    ### using @patch to enable docs for instance methods like `dbprint` and `print`
    ### move param env into `__init__`
    ### Add example to the obj
    ### Take not only function but also class
    ### To remove the necessity of self.takExample()
    ### Try to remove g = locals()
    ### Make sure `showdbsrc=True` give us the line starting with 'dbprintinsert'
    ### Make sure `showdbsrc=True` give us info on changes in g or outenv
    ### exit and print a warning message: idx has to be int
    ### handle errors by codes with trailing spaces 
    ### showdbsrc=True, check whether Fastdb.dbprint and fdb.dbprint are same object using `is`
    ### remove unnecessary db printout when showdbsrc=True and add printout to display sections
    ### raise TypeError when decode are not integer and showdbsrc=true working on both method and function
    ### when debugging dbprint, make sure dbsrc is printed with the same idx as original
    ### update dbsrc to the global env
    ### go back to normal before running dbprint again
    ### auto print src with cmt and idx as the ending part of dbprint
    ### to mark my explorations (expressions to evaluate) to stand out
    ### Add the print of src with idx and comments at the end of dbsrc
    ### embed example and autoprint to shorten the code to type
    ### Make title for dbprint
    ### Adding self.eg info and color group into dbprint and print
    #### todo: make the comments with same self.eg have the same color
    ### make dbsrc print idx right
    ### add self.eg to a dict with keys are idxsrc
    ### handle both function and class as src
    ### documenting on Fastdb.dbprint itself
    ## mk_dbsrc
    ## Turn mk_dbsrc into docsrc 
    ### handle when no codes are given
    ## create_dbsrc_from_string
    ## replaceWithDbsrc
    ### handle class and metaclass
    ### improve on handling function as decorator
    ### Handling `inspect._signature_from_callable` to become `self.dbsrc`
    ### handling usage of `@delegates`
    ### handling `@delegates` with indentation before it
    ### handling classes by inspect.isclass() rather than == type and add more class situations
    ### handling `class _T(_TestA, metaclass=BypassNewMeta): `
    ## run_example
    ### `exec(self.eg, globals().update(self.egEnv), locals())` works better than `...update(locals()), self.egEnv)
    ### no more env cells run before `fdb.eg` to make `fdb.run_example` work
    ## Autoprint
    ## Take an example and its env into Fastdb obj
    ## print src with idx and cmt in whole or parts
    ### print self.eg after each comment and colorize comments
    ### color examples and cmts separately and make the func simpler
    ### split each cmt and colorize parts randomly
    ### printcmts1 while saving into a file
    ## goback
    ## Fastdb.explore
    ### adding one breakpoint with comment
    ### Adding multiple breakpoints by multiple set_trace()
    ### Go back to normal before running explore again
    ### enable fdb.takExample("whatinside(fu), ...) without using `fu.whatinside`
    ### refactory explore
    ## snoop
    ### snoop on both function and class
    ### snoop on class and method and all???
    ### snoop
    ### simplify adding @snoop for both normal function and decorator
    ### handling classes
    ### add watch
    ## Snoop
    ### add watch
    ### use guide on Fastdb.dbprint
    ## reliveonce
    ## Fastdb.debug
    ## Export
    ## Send to Obsidian
    
    /Users/Natsume/Documents/fastdebug/mds/demos/0001_fastcore_meta_delegates.md
    ## Import
    ## Initiate Fastdb and example in str
    ## Example
    ## docsrc
    ## Snoop
    
    /Users/Natsume/Documents/fastdebug/mds/demos/0003_Explore_document_FixSigMeta_PrePostInitMeta_AutoInit.md
    ## Initialize fastdebug objects
    ## class FixSigMeta(type) vs class Foo(type)
    ## class Foo()
    ## class PrePostInitMeta(FixSigMeta)
    ## class Foo(metaclass=FixSigMeta)
    ## class AutoInit(metaclass=PrePostInitMeta)
    ## Prepare examples for FixSigMeta, PrePostInitMeta, AutoInit 
    ## Snoop them together in one go
    ### embed the dbsrc of FixSigMeta into PrePostInitMeta
    ### embed dbsrc of PrePostInitMeta into AutoInit
    ## Explore and Document on them together 
    
    /Users/Natsume/Documents/fastdebug/mds/demos/0004_fastcore.meta._rm_self.md
    ## imports
    ## set up
    ## document
    ## snoop
    
    /Users/Natsume/Documents/fastdebug/mds/demos/0005_fastcore.meta.test_sig.md
    ## imports
    ## setups
    ## documents
    ## snoop
    
    /Users/Natsume/Documents/fastdebug/mds/demos/0007_fastcore.meta.BypassNewMeta.md
    ## Reading official docs
    ## Inspecting class
    ## Initiating with examples
    ## Snoop
    ## Document
    
    /Users/Natsume/Documents/fastdebug/mds/demos/0002_signature_from_callable.md
    ## Expand cell
    ## Imports and initiate
    ## Examples
    
    /Users/Natsume/Documents/fastdebug/mds/demos/0008_use_kwargs_dict.md
    ## Imports
    ## Reading official docs
    ## empty2none
    ## `_mk_param`
    ## use_kwargs_dict
    ### Reading docs
    ## use_kwargs
    ### Reading docs
    
    /Users/Natsume/Documents/fastdebug/mds/demos/0006_fastcore.meta.NewChkMeta.md
    ## Import and Initalization
    ## Official docs
    ## Prepare Example
    ## Inspect classes
    ## Snoop
    ## Document
    
    /Users/Natsume/Documents/fastdebug/mds/demos/0000_tour.md
    ### Documentation
    ### Testing
    ### Foundations
    ### L
    ### Transforms
    
    /Users/Natsume/Documents/fastdebug/mds/demos/0012_fastcore_foundation_L.md
    ## Document `L` with fastdebug
    
    /Users/Natsume/Documents/fastdebug/mds/demos/0011_Fastdb.md
    
    /Users/Natsume/Documents/fastdebug/mds/demos/0009_funcs_kwargs.md
    ## fastcore.meta.method
    ### Reading Docs
    ### Running codes
    ### Document
    ### snoop
    ## funcs_kwargs
    ### Official docs
    ### snoop: from _funcs_kwargs to funcs_kwargs
    ### snoop only '_funcs_kwargs' by breaking up 'funcs_kwargs'
    
    /Users/Natsume/Documents/fastdebug/mds/demos/0010_fastcore_meta_summary.md
    ## import
    ## fastcore and fastcore.meta
    ### What's inside fastcore.meta
    ## Review individual funcs and classes
    ### What is fastcore.meta all about? 
    ### What can these metaclasses do for me?
    #### FixSigMeta
    #### PrePostInitMeta
    #### AutoInit
    #### NewChkMeta
    #### BypassNewMeta
    ### What can those decorators do for me?
    #### use_kwargs_dict
    #### use_kwargs
    #### delegates
    #### funcs_kwargs
    ### The remaining functions
    ## What is fastcore.meta all about
    
    /Users/Natsume/Documents/fastdebug/mds/questions/00_question_anno_dict.md
    ## `anno_dict` docs
    ## Dive in
    ## `anno_dict` seems not add anything new to `__annotations__`
    ## use fastdebug to double check
    ## Does fastcore want anno_dict to include params with no annos?
    ## Jeremy's response


**When I just want to have a quick look of the commented source code**

Run `fastsrcs()` first to have the list of all commented srcodes files

Run `fastview(srcname)` on the cell above `fastsrcs()` to view the actual commented srcs with an example

Run `fastcodes(query)` to search src comments for learning points


```
fastcodes("how to turn a sig into string", accu=1)
```


keyword match is  <mark style="background-color: #ffff00">1.0</mark> , found a line: in  <mark style="background-color: #FFFF00">test_sig.py</mark> 


        test_eq(str(inspect.signature(f)), b)=================================================(2) # [34;1mtest_sig is to test two strings with test_eq[0m; [37;1mhow to turn a signature into a string;[0m; 
    



the entire source code in  <mark style="background-color: #FFFF00">test_sig.py</mark> 


    
    def func_2(h,i=3, j=[5,6]): pass
    test_sig(func_2, '(h, i=3, j=[5, 6])')
    
    def test_sig(f, b):=======================================================================(0)       
        "Test the signature of an object"=====================================================(1) # [91;1mtest_sig(f:FunctionType or ClassType, b:str)[0m; [34;1mtest_sig will get f's signature as a string[0m; [37;1mb is a signature in string provided by the user[0m; [92;1min fact, test_sig is to compare two strings[0m; 
        test_eq(str(inspect.signature(f)), b)=================================================(2) # [34;1mtest_sig is to test two strings with test_eq[0m; [37;1mhow to turn a signature into a string;[0m; 
                                                                                                                                                            (3)
    



```
fastview("test_sig")
```

    
    def func_2(h,i=3, j=[5,6]): pass
    test_sig(func_2, '(h, i=3, j=[5, 6])')
    
    def test_sig(f, b):=======================================================================(0)       
        "Test the signature of an object"=====================================================(1) # [91;1mtest_sig(f:FunctionType or ClassType, b:str)[0m; [34;1mtest_sig will get f's signature as a string[0m; [37;1mb is a signature in string provided by the user[0m; [92;1min fact, test_sig is to compare two strings[0m; 
        test_eq(str(inspect.signature(f)), b)=================================================(2) # [34;1mtest_sig is to test two strings with test_eq[0m; [37;1mhow to turn a signature into a string;[0m; 
                                                                                                                                                            (3)



```
fastsrcs()
```

    anno_dict.py
    test_sig.py
    BypassNewMeta.py
    snoop.py
    FixSigMeta.py
    fastnbs.py
    funcs_kwargs.py
    NewChkMeta.py
    printtitle.py
    AutoInit.py
    method.py
    _rm_self.py
    delegates.py
    create_explore_str.py
    PrePostInitMeta.py
    _funcs_kwargs.py
    whatinside.py


#|hide
## Export


```
#| hide
from nbdev import nbdev_export
nbdev_export()
```


```

```
